{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NjYzODg5", "number": 62, "title": "Add Package Model, Package Recipe schema model and Semver based versi\u2026", "bodyText": "This presents a part of the work so far on package manager, all of these components will get moved to a library package. For the entire working codebase, please see this  branch. The remaining components will be added in a separate pull request here.\nThis is a fairly long pull request due to data files and exception classes. The main source files are under src/main/java/com/aws/iot/evergreen/packagemanager/models\nAs discussed, the range based dependency resolution style is based on npm's semver implementation.\nDescription of changes:\n\nModel for Evergreen package\nModel for Recipe schema, allows versioning\n(Lib: Semver4j) Semver based versioning along with various comparison/range operations\nException hierarchy for packaging\nBase interface for Artifact and Package Providers\n\nFuture planned work:\n\nGeneral cleanup, add final to input params, fix some of the exception handling TODOs, Move strings to Constants.java\nFurther unit testing coverage improvements", "createdAt": "2020-02-13T04:32:21Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62", "merged": true, "mergeCommit": {"oid": "96dd1d9555c138cfe13d09323876698c8a2feef8"}, "closed": true, "closedAt": "2020-02-23T23:28:51Z", "author": {"login": "chaurah"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcD-LcSAFqTM1ODM5MjY0Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHRHfNgFqTM2MzEyOTcyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4MzkyNjQz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-358392643", "createdAt": "2020-02-13T17:02:11Z", "commit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzowMjoxMlrOFpb9Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzoxMzo1N1rOFpcZmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5Mzk3OA==", "bodyText": "For ease of use by customers, we probably want to treat the keys case-insensitive.\nOBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378993978", "createdAt": "2020-02-13T17:02:12Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NTMwMQ==", "bodyText": "Lombok should be able to help with these getters/setters and constructors.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378995301", "createdAt": "2020-02-13T17:03:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final IPackageConfig recipe;\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NjU2NA==", "bodyText": "Any reason not to just put @getter onto the entire class so you don't have to repeat it all the time here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378996564", "createdAt": "2020-02-13T17:05:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NzYwMg==", "bodyText": "This is probably fine, but you could also just use a stream and filter it instead of using removeIf, then return the filtered list. Then you wouldn't need this note at all.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378997602", "createdAt": "2020-02-13T17:07:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    @Getter\n+    private final String version;\n+\n+    @Getter\n+    private final int major;\n+\n+    @Getter\n+    private final int minor;\n+\n+    @Getter\n+    private final int patch;\n+\n+    // Unused at the moment\n+    @Getter\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    @Getter\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare\n+    }\n+\n+    /**\n+     * Check if given version is in range\n+     */\n+    public static boolean isVersionInRange(String testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        return isVersionInRange(new EvergreenPackageVersion(testVersion), range);\n+    }\n+\n+    /**\n+     * Check if given version is in range\n+     * NOTE: Quick fix, Probably can be simplfied, the List is redundant\n+     */\n+    public static boolean isVersionInRange(EvergreenPackageVersion testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        List<EvergreenPackageVersion> versions = new ArrayList<>();\n+        versions.add(testVersion);\n+\n+        applyRangeToInput(versions, range);\n+        return !versions.isEmpty();\n+    }\n+\n+    /**\n+     * Apply provided range to a list of versions.\n+     * NOTE: The input list WILL BE mutated and contain the result of applying the provided range conditions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5ODY3MQ==", "bodyText": "Not sure if we have guidelines yet, but looking at the code so far, the interface should just be PackageConfig and the implementation PackageConfigImpl. Something to discuss briefly post-scrum.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378998671", "createdAt": "2020-02-13T17:09:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/IPackageConfig.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+public interface IPackageConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTcyMQ==", "bodyText": "I know this is WIP, so that's fine, but we have a bigger list of OSes in the Kernel currently if you look at the method pickByOS.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r378999721", "createdAt": "2020-02-13T17:11:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackage;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.IPackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.IArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements IPackageConfig {\n+    private final Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    private static final String DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT\n+            = \"Default platform config was not found when parsing recipe for package\";\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<IArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifacts();\n+    }\n+\n+    @Override\n+    public HashMap<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<IArtifactProvider> artifacts;\n+\n+        private final HashMap<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle Map of all lifecycle configurations\n+         * @param artifactUrls Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") Map<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifactUrls,\n+                                             @JsonProperty(\"dependencies\") List<EvergreenPackageDependency>\n+                                                             dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: Migrate to deserializing artifact providers directly\n+            if (artifactUrls == null) {\n+                this.artifacts = Collections.emptySet();\n+            } else {\n+                HashSet<IArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifactUrls) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }\n+                this.artifacts = providerSet;\n+            }\n+            this.dependencies = new HashMap<>();\n+            if (dependencies != null && !dependencies.isEmpty()) {\n+                for (EvergreenPackageDependency entry : dependencies) {\n+                    // TODO: This is an ugly hack, figure out how to get Jackson to parse an array of key value pairs\n+                    //  as map\n+                    this.dependencies.put(entry.getPackageName(), entry.getPackageVersion());\n+                }\n+            }\n+        }\n+\n+        public Map<String, Object> getLifecycle() {\n+            return lifecycle;\n+        }\n+\n+        public Set<IArtifactProvider> getArtifacts() {\n+            return artifacts;\n+        }\n+\n+        public HashMap<String, String> getDependencies() {\n+            return dependencies;\n+        }\n+\n+    }\n+\n+    public enum SupportedPlatforms {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwMDQ0Mg==", "bodyText": "We're going with the outputstream way of doing it? I commented on Jason's PR earlier and he seemed to like the idea that the caller would pass a File that they want the artifact to be written to. That way the artifact stays out of Java's memory as much as possible.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379000442", "createdAt": "2020-02-13T17:12:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/IArtifactProvider.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Path;\n+\n+public interface IArtifactProvider {\n+\n+    ByteArrayOutputStream loadArtifact(String artifactUrl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwMTI0MA==", "bodyText": "Unused?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r379001240", "createdAt": "2020-02-13T17:13:57Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/TestHelper.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class TestHelper {\n+    public static final String MONITORING_SERVICE_PACKAGE_NAME = \"MonitoringService\";\n+    public static final String CONVEYOR_BELT_PACKAGE_NAME = \"ConveyorBelt\";\n+\n+    public static final String TEST_RECIPE_FMT = \"RecipeTemplateVersion: '2020-01-25'\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e986b0edfc94850f69483e53357e0b4654d1c8cc"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a252b66ce1a3b66086b7552f35092f90b66ed55", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2a252b66ce1a3b66086b7552f35092f90b66ed55", "committedDate": "2020-02-14T23:14:19Z", "message": "Improve code quality, add full list of supported platforms, improve unit test coverage"}, "afterCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "committedDate": "2020-02-14T23:22:24Z", "message": "Improve code quality, add full list of supported platforms, improve unit test coverage"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjI5MTY1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-360629165", "createdAt": "2020-02-18T19:55:09Z", "commit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxOTo1NTowOVrOFrQUTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxOTo1NTowOVrOFrQUTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMDQzMA==", "bodyText": "I don't think this is needed at all. If you just have @AllArgsConstructor from lombok then Jackson should be abel to serialize/deserialize.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380900430", "createdAt": "2020-02-18T19:55:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjI5NTU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-360629554", "createdAt": "2020-02-18T19:55:44Z", "commit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxOTo1NTo0NFrOFrQVnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxOTo1NTo0NFrOFrQVnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMDc2NA==", "bodyText": "[nit]\nLombok for getters and constructor. @Getter and @AllArgsConstructor.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380900764", "createdAt": "2020-02-18T19:55:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageDependency.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+public class EvergreenPackageDependency {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjMwNzM3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-360630737", "createdAt": "2020-02-18T19:57:35Z", "commit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxOTo1NzozNVrOFrQZQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxOTo1NzozNVrOFrQZQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwMTY5OQ==", "bodyText": "Very likely this may want to throw something.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380901699", "createdAt": "2020-02-18T19:57:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/ArtifactProvider.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.file.Path;\n+\n+public interface ArtifactProvider {\n+\n+    void downloadArtifactToPath(Path outPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjk5NDQ1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-360699445", "createdAt": "2020-02-18T21:51:05Z", "commit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMTo1MTowNVrOFrTwCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNDo0NTo1NVrOFra_JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NjY4Mg==", "bodyText": "What's this for? It's not being used.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380956682", "createdAt": "2020-02-18T21:51:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageLifecycle.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+public interface PackageLifecycle {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Njg1NQ==", "bodyText": "What's this for? It's not being used.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380956855", "createdAt": "2020-02-18T21:51:30Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackagePlatformConfig.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+public interface PackagePlatformConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1OTc4NA==", "bodyText": "Why is this needed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380959784", "createdAt": "2020-02-18T21:57:30Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/exceptions/PackagingException.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package com.aws.iot.evergreen.packagemanager.exceptions;\n+\n+public class PackagingException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MTUzNQ==", "bodyText": "Not sure if this is desired. Why do you want to make the package name case-insensitive?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380961535", "createdAt": "2020-02-18T22:01:09Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        this.packageVersion = packageVersion;\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.recipe =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifacts() {\n+        return recipe.getArtifactProviders();\n+    }\n+\n+    public HashMap<String, String> getDependencies() {\n+        return recipe.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static EvergreenPackage getPackageObject(String recipe) {\n+        EvergreenPackage pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, EvergreenPackage.class);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to parse recipe\", e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof EvergreenPackage)) {\n+            return false;\n+        }\n+\n+        EvergreenPackage pkg = (EvergreenPackage) obj;\n+        boolean ret = true;\n+        if (!pkg.getPackageName().equalsIgnoreCase(getPackageName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzM3NQ==", "bodyText": "Why do we need to override this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r380963375", "createdAt": "2020-02-18T22:05:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        this.packageVersion = packageVersion;\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.recipe =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifacts() {\n+        return recipe.getArtifactProviders();\n+    }\n+\n+    public HashMap<String, String> getDependencies() {\n+        return recipe.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static EvergreenPackage getPackageObject(String recipe) {\n+        EvergreenPackage pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, EvergreenPackage.class);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to parse recipe\", e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof EvergreenPackage)) {\n+            return false;\n+        }\n+\n+        EvergreenPackage pkg = (EvergreenPackage) obj;\n+        boolean ret = true;\n+        if (!pkg.getPackageName().equalsIgnoreCase(getPackageName())) {\n+            ret = false;\n+        } else if (!pkg.getPackageVersion().equals((getPackageVersion()))) {\n+            ret = false;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MDQxMQ==", "bodyText": "Why does PackageConfig need to be an interface? Also why not just name it PackageRecipe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381070411", "createdAt": "2020-02-19T04:23:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageConfig.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+public interface PackageConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTIyNQ==", "bodyText": "Let's use a consistent way to name unit test. Some of the codebase uses the behavior driven development pattern: \"GIVEN...WHEN...THEN\".", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381071225", "createdAt": "2020-02-19T04:27:34Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageTests.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.PackageManager;\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class EvergreenPackageTests {\n+\n+    @Test\n+    public void testPackageCreateSuccess() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTg3OQ==", "bodyText": "This doesn't help when someone needs to update the code. Can you add a readme describing how the versioning works with concrete examples?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381071879", "createdAt": "2020-02-19T04:30:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTk3OQ==", "bodyText": "unused, then remove them.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381071979", "createdAt": "2020-02-19T04:31:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MjczMw==", "bodyText": "These two the same. I see a lot of redundant input in this list. We only need one valid input for each category. We should try to be precise when writing unit tests. It makes the code easier to maintain.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381072733", "createdAt": "2020-02-19T04:34:35Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MjgzMA==", "bodyText": "Same here. Please remove the redundant invalid versions.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381072830", "createdAt": "2020-02-19T04:35:12Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MzYwOQ==", "bodyText": "This doesn't seem to be conventional. By convention, you use @before annotation to perform the common step in a test.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381073609", "createdAt": "2020-02-19T04:38:32Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3Mzc5Mw==", "bodyText": "These are different test cases. Please break them into separate test cases.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381073793", "createdAt": "2020-02-19T04:39:13Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {\n+        testInputList = new ArrayList<>();\n+        testInputList.add(new EvergreenPackageVersion(\"1.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.4.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.8.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.9.9\"));\n+        testInputList.add(new EvergreenPackageVersion(\"3.3.0\"));\n+    }\n+\n+    @Test\n+    public void testVersioning() {\n+        try {\n+            for(String sValid : validVersionList) {\n+                assertTrue(EvergreenPackageVersion.isValidVersion(sValid));\n+            }\n+            for(String sInvalid : invalidVersionsList) {\n+                assertFalse(EvergreenPackageVersion.isValidVersion(sInvalid));\n+            }\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeHyphens() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NDc4Mw==", "bodyText": "You don't need this! The test will fail if an exception is thrown.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381074783", "createdAt": "2020-02-19T04:43:38Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {\n+        testInputList = new ArrayList<>();\n+        testInputList.add(new EvergreenPackageVersion(\"1.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.4.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.8.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.9.9\"));\n+        testInputList.add(new EvergreenPackageVersion(\"3.3.0\"));\n+    }\n+\n+    @Test\n+    public void testVersioning() {\n+        try {\n+            for(String sValid : validVersionList) {\n+                assertTrue(EvergreenPackageVersion.isValidVersion(sValid));\n+            }\n+            for(String sInvalid : invalidVersionsList) {\n+                assertFalse(EvergreenPackageVersion.isValidVersion(sInvalid));\n+            }\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeHyphens() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.5 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"2 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2.9\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(\"1.5.0\", \"1.4.0 - 2\"));\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"1.5.0\"),\n+                                                                \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(\"2.5.0\", \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"2.5.0\"),\n+                                                                 \"1.4.0 - 2\"));\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NDg2NQ==", "bodyText": "Same here. break them into multiple tests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381074865", "createdAt": "2020-02-19T04:44:03Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersionTests.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class EvergreenPackageVersionTests {\n+    private final String [] validVersionList = { \"0.0.4\",\n+                                                 \"1.2.3\",\n+                                                 \"10.20.30\",\n+                                                 \"1.1.2-prerelease+meta\",\n+                                                 \"1.1.2+meta\",\n+                                                 \"1.1.2+meta-valid\",\n+                                                 \"1.0.0-alpha\",\n+                                                 \"1.0.0-beta\",\n+                                                 \"1.0.0-alpha.beta\",\n+                                                 \"1.0.0-alpha.beta.1\",\n+                                                 \"1.0.0-alpha.1\",\n+                                                 \"1.0.0-alpha0.valid\",\n+                                                 \"1.0.0-alpha.0valid\",\n+                                                 \"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\",\n+                                                 \"1.0.0-rc.1+build.1\",\n+                                                 \"2.0.0-rc.1+build.123\",\n+                                                 \"1.2.3-beta\",\n+                                                 \"10.2.3-DEV-SNAPSHOT\",\n+                                                 \"1.2.3-SNAPSHOT-123\",\n+                                                 \"1.0.0\",\n+                                                 \"2.0.0\",\n+                                                 \"1.1.7\",\n+                                                 \"2.0.0+build.1848\",\n+                                                 \"2.0.1-alpha.1227\",\n+                                                 \"1.0.0-alpha+beta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\",\n+                                                 \"1.2.3----R-S.12.9.1--.12+meta\",\n+                                                 \"1.2.3----RC-SNAPSHOT.12.9.1--.12\",\n+                                                 \"1.0.0+0.build.1-rc.10000aaa-kk-0.1\",\n+                                                 \"99999999999999999999999.999999999999999999.99999999999999999\",\n+                                                 \"1.0.0-0A.is.legal\" };\n+    private final String [] invalidVersionsList = { \"1\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3-0123\",\n+                                                    \"1.2.3-0123.0123\",\n+                                                    \"1.1.2+.123\",\n+                                                    \"+invalid\",\n+                                                    \"-invalid\",\n+                                                    \"-invalid+invalid\",\n+                                                    \"-invalid.01\",\n+                                                    \"alpha\",\n+                                                    \"alpha.beta\",\n+                                                    \"alpha.beta.1\",\n+                                                    \"alpha.1\",\n+                                                    \"alpha+beta\",\n+                                                    \"alpha_beta\",\n+                                                    \"alpha.\",\n+                                                    \"alpha..\",\n+                                                    \"beta\",\n+                                                    \"1.0.0-alpha_beta\",\n+                                                    \"-alpha.\",\n+                                                    \"1.0.0-alpha..\",\n+                                                    \"1.0.0-alpha..1\",\n+                                                    \"1.0.0-alpha...1\",\n+                                                    \"1.0.0-alpha....1\",\n+                                                    \"1.0.0-alpha.....1\",\n+                                                    \"1.0.0-alpha......1\",\n+                                                    \"1.0.0-alpha.......1\",\n+                                                    \"01.1.1\",\n+                                                    \"1.01.1\",\n+                                                    \"1.1.01\",\n+                                                    \"1.2\",\n+                                                    \"1.2.3.DEV\",\n+                                                    \"1.2-SNAPSHOT\",\n+                                                    \"1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788\",\n+                                                    \"1.2-RC-SNAPSHOT\",\n+                                                    \"-1.0.3-gamma+b7718\",\n+                                                    \"+justmeta\",\n+                                                    \"9.8.7+meta+meta\",\n+                                                    \"9.8.7-whatever+meta+meta\",\n+                                                    \"99999999999999999999999.999999999999999999.99999999999999999-\"\n+                                                        + \"---RC-SNAPSHOT.12.09.1-----------------\"\n+                                                        + \"---------------..12\" };\n+\n+    private final List<EvergreenPackageVersion> testInputList;\n+\n+    public EvergreenPackageVersionTests() throws InvalidPackageVersionFormatException {\n+        testInputList = new ArrayList<>();\n+        testInputList.add(new EvergreenPackageVersion(\"1.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.4.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"1.8.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.3.0\"));\n+        testInputList.add(new EvergreenPackageVersion(\"2.9.9\"));\n+        testInputList.add(new EvergreenPackageVersion(\"3.3.0\"));\n+    }\n+\n+    @Test\n+    public void testVersioning() {\n+        try {\n+            for(String sValid : validVersionList) {\n+                assertTrue(EvergreenPackageVersion.isValidVersion(sValid));\n+            }\n+            for(String sInvalid : invalidVersionsList) {\n+                assertFalse(EvergreenPackageVersion.isValidVersion(sInvalid));\n+            }\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeHyphens() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.5 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"2 - 3.0.0\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 3.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2.9\");\n+            assertTrue(testInputCopyList.size() == 3);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \"1.4.0 - 2\");\n+            assertTrue(testInputCopyList.size() == 2);\n+\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(\"1.5.0\", \"1.4.0 - 2\"));\n+            assertTrue(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"1.5.0\"),\n+                                                                \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(\"2.5.0\", \"1.4.0 - 2\"));\n+            assertFalse(EvergreenPackageVersion.isVersionInRange(new EvergreenPackageVersion(\"2.5.0\"),\n+                                                                 \"1.4.0 - 2\"));\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void testApplyRangeComparators() {\n+        try {\n+            List<EvergreenPackageVersion> testInputCopyList = new ArrayList<>();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \">1.4.0\");\n+            assertTrue(testInputCopyList.size() == 4);\n+\n+            testInputCopyList.clear();\n+            testInputCopyList.addAll(testInputList);\n+            EvergreenPackageVersion.applyRangeToInput(testInputCopyList, \">1.4\");\n+            assertTrue(testInputCopyList.size() == 4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3NTIzNg==", "bodyText": "Probably don't want to throw RuntimeException here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381075236", "createdAt": "2020-02-19T04:45:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        this.packageVersion = packageVersion;\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.recipe =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifacts() {\n+        return recipe.getArtifactProviders();\n+    }\n+\n+    public HashMap<String, String> getDependencies() {\n+        return recipe.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static EvergreenPackage getPackageObject(String recipe) {\n+        EvergreenPackage pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, EvergreenPackage.class);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to parse recipe\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMzQwODIy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-361340822", "createdAt": "2020-02-19T18:41:11Z", "commit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODo0MToxMlrOFrzCcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDowMjozNVrOFr1t1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2OTI5OQ==", "bodyText": "This looks unused, if you do need it it probably shouldn't be public?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381469299", "createdAt": "2020-02-19T18:41:12Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3MTUxNA==", "bodyText": "Will be better if we used one term for this, if it's recipe maybe this class should be called recipe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381471514", "createdAt": "2020-02-19T18:45:05Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackage.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import lombok.Getter;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+// not thread safe yet\n+// should be used in single thread\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Getter\n+public class EvergreenPackage {\n+\n+    public static final String UNSUPPORTED_TEMPLATE_EXCEPTION_MSG_FMT\n+            = \"Found template version %s which is not supported by this version of Evergreen.\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    @JsonProperty(\"RecipeTemplateVersion\")\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @JsonProperty(\"PackageName\")\n+    private final String packageName;\n+\n+    @JsonProperty(\"Version\")\n+    private EvergreenPackageVersion packageVersion;\n+\n+    @JsonProperty(\"Description\")\n+    private final String description;\n+\n+    @JsonProperty(\"Publisher\")\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfig recipe;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public EvergreenPackage(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                            @JsonProperty(\"PackageName\") String packageName,\n+                            @JsonProperty(\"Version\") EvergreenPackageVersion packageVersion,\n+                            @JsonProperty(\"Description\") String description,\n+                            @JsonProperty(\"Publisher\") String publisher,\n+                            @JsonProperty(\"Config\") PackageConfig config) throws InvalidPackageVersionFormatException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5ODY3MQ==", "bodyText": "Should this be called getArtifactProviders? 'getArtifacts' kind of suggests that you are downloading/fetching the actual artifacts but it looks like after this method call you'll still need to call the download method on each artifact provider", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381498671", "createdAt": "2020-02-19T19:35:01Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfig {\n+    private final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    private static final String DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT\n+            = \"Default platform config was not found when parsing recipe for package\";\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException       Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms25Jan2020.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifacts();\n+    }\n+\n+    @Override\n+    public HashMap<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<ArtifactProvider> artifacts;\n+\n+        private final HashMap<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle    Map of all lifecycle configurations\n+         * @param artifactUrls Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires     Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") Map<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifactUrls,\n+                                             @JsonProperty(\"dependencies\") List<EvergreenPackageDependency>\n+                                                     dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: Migrate to deserializing artifact providers directly\n+            if (artifactUrls == null) {\n+                this.artifacts = Collections.emptySet();\n+            } else {\n+                HashSet<ArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifactUrls) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }\n+                this.artifacts = providerSet;\n+            }\n+            this.dependencies = new HashMap<>();\n+            if (dependencies != null && !dependencies.isEmpty()) {\n+                for (EvergreenPackageDependency entry : dependencies) {\n+                    // TODO: This is an ugly hack, figure out how to get Jackson to parse an array of key value pairs\n+                    //  as map\n+                    this.dependencies.put(entry.getPackageName(), entry.getPackageVersion());\n+                }\n+            }\n+        }\n+\n+        public Map<String, Object> getLifecycle() {\n+            return lifecycle;\n+        }\n+\n+        public Set<ArtifactProvider> getArtifacts() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMDcxOQ==", "bodyText": "Should this list be managed by Kernel and reused by package manager if it needs to?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381500719", "createdAt": "2020-02-19T19:38:55Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfig {\n+    private final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    private static final String DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT\n+            = \"Default platform config was not found when parsing recipe for package\";\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException       Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms25Jan2020.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(DEFAULT_CONFIG_NOT_FOUND_ERROR_MSG_FMT);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifacts();\n+    }\n+\n+    @Override\n+    public HashMap<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<ArtifactProvider> artifacts;\n+\n+        private final HashMap<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle    Map of all lifecycle configurations\n+         * @param artifactUrls Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires     Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") Map<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifactUrls,\n+                                             @JsonProperty(\"dependencies\") List<EvergreenPackageDependency>\n+                                                     dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: Migrate to deserializing artifact providers directly\n+            if (artifactUrls == null) {\n+                this.artifacts = Collections.emptySet();\n+            } else {\n+                HashSet<ArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifactUrls) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }\n+                this.artifacts = providerSet;\n+            }\n+            this.dependencies = new HashMap<>();\n+            if (dependencies != null && !dependencies.isEmpty()) {\n+                for (EvergreenPackageDependency entry : dependencies) {\n+                    // TODO: This is an ugly hack, figure out how to get Jackson to parse an array of key value pairs\n+                    //  as map\n+                    this.dependencies.put(entry.getPackageName(), entry.getPackageVersion());\n+                }\n+            }\n+        }\n+\n+        public Map<String, Object> getLifecycle() {\n+            return lifecycle;\n+        }\n+\n+        public Set<ArtifactProvider> getArtifacts() {\n+            return artifacts;\n+        }\n+\n+        public HashMap<String, String> getDependencies() {\n+            return dependencies;\n+        }\n+\n+    }\n+\n+    public enum SupportedPlatforms25Jan2020 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwMzE2Mg==", "bodyText": "Don't see how this is used, suppose it will be in the following PR? Will it talk to the cloud service? If it doesn't then maybe call it LocalPackageStore or something", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381503162", "createdAt": "2020-02-19T19:43:27Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackage;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageVersion;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNjEwOA==", "bodyText": "Maybe we've already discussed and decided this but do they have a library(of acceptable size) we can depend on instead of maintaining this? Or do they only have guidelines for specs?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381506108", "createdAt": "2020-02-19T19:48:56Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA3MTg3OQ=="}, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzUxNQ==", "bodyText": "Nit - the code here is self explanatory, probably don't need this documentation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381507515", "createdAt": "2020-02-19T19:51:29Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwNzk3NQ==", "bodyText": "Nit - is this a TODO? maybe we should mark all TODOs as TODOs so it's easier to find them for IDEs", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381507975", "createdAt": "2020-02-19T19:52:18Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTQ1NA==", "bodyText": "Remove this now?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381509454", "createdAt": "2020-02-19T19:55:06Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     */\n+    public static boolean isVersionInRange(String testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        return isVersionInRange(new EvergreenPackageVersion(testVersion), range);\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     * NOTE: Quick fix, Probably can be simplfied, the List is redundant\n+     */\n+    public static boolean isVersionInRange(EvergreenPackageVersion testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        List<EvergreenPackageVersion> versions = new ArrayList<>();\n+        versions.add(testVersion);\n+\n+        applyRangeToInput(versions, range);\n+        return !versions.isEmpty();\n+    }\n+\n+    /**\n+     * Apply provided range to a list of versions.\n+     * NOTE: The input list WILL BE mutated and contain the result of applying the provided range conditions.\n+     *\n+     */\n+    public static void applyRangeToInput(List<EvergreenPackageVersion> versions, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        // NOTE: Only supports major.minor.patch for the moment\n+        // NOTE: This is only for ONE SINGLE comparator set, we may not support multiple sets, TBD\n+        // Multiple comparator sets are range conditions separated by either whitespace or ||\n+        // https://www.npmjs.com/package/semver#ranges\n+\n+        // Apply Hyphen Ranges X.Y.Z - A.B.C\n+        final Matcher hyphenRangeMatcher = HYPHEN_RANGE_PATTERN.matcher(range);\n+        if (hyphenRangeMatcher.matches()) {\n+            // matched hyphen range pattern\n+            // Construct lower bound\n+            /*System.out.println(\"Full match: \" + hyphenRangeMatcher.group(0));\n+            for (int i = 1; i <= hyphenRangeMatcher.groupCount(); i++) {\n+                System.out.println(\"Group \" + i + \": \" + hyphenRangeMatcher.group(i));\n+            }\n+            System.out.println(\"\\n\\n\");*/\n+\n+            String lowerBoundStr = String.format(VERSION_FMT, hyphenRangeMatcher.group(1),\n+                                         (hyphenRangeMatcher.group(2) != null) ? hyphenRangeMatcher.group(2) : \"0\",\n+                                         (hyphenRangeMatcher.group(3) != null) ? hyphenRangeMatcher.group(3) : \"0\");\n+            EvergreenPackageVersion lowerBound = new EvergreenPackageVersion(lowerBoundStr);\n+            String upperBoundStr = String.format(VERSION_FMT, hyphenRangeMatcher.group(6),\n+                                         (hyphenRangeMatcher.group(7) != null) ? hyphenRangeMatcher.group(7) : \"0\",\n+                                         (hyphenRangeMatcher.group(8) != null) ? hyphenRangeMatcher.group(8) : \"0\");\n+            EvergreenPackageVersion upperBound = new EvergreenPackageVersion(upperBoundStr);\n+\n+            versions.removeIf(\n+                    ver -> (ver.compareTo(lowerBound) < 0 || ver.compareTo(upperBound) >= 0));\n+\n+            // Range was a complete match, no need to proceed further\n+            return;\n+        }\n+\n+        String processedRange = range;\n+        // Convert X-Ranges 1.2.x 1.X 1.2.* * to < or >\n+        // Convert Tilde Ranges ~1.2.3 ~1.2 ~1 to < or >\n+        // Convert Caret Ranges ^1.2.3 ^0.2.5 ^0.0.4 to < or >\n+\n+        final Matcher comparisionRangeMatcher = COMPARISION_RANGE_PATTERN.matcher(processedRange);\n+        if (comparisionRangeMatcher.matches()) {\n+            /*System.out.println(\"Full match: \" + comparisionRangeMatcher.group(0));\n+            for (int i = 1; i <= comparisionRangeMatcher.groupCount(); i++) {\n+                System.out.println(\"Group \" + i + \": \" + comparisionRangeMatcher.group(i));\n+            }*/\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTkwNQ==", "bodyText": "Was this for debugging, want to remove it now?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381509905", "createdAt": "2020-02-19T19:55:59Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/EvergreenPackageVersion.java", "diffHunk": "@@ -0,0 +1,255 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.InvalidPackageVersionFormatException;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.Getter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+@Getter\n+public class EvergreenPackageVersion implements Comparable<EvergreenPackageVersion> {\n+\n+    // This was taken directly from semver.org\n+    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\n+    // Tags are non capturing at the moment\n+    private static final String SEMVER_REGEX = \"(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/160\n+    private static final String HYPHEN_RANGE_REGEX = \"(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-((?:0|[1-\"\n+            + \"9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?\\\\ \\\\-\\\\ (0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?(0|[1-9]\\\\d*)?(?:-(\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+\"\n+            + \"([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    // Generated using https://regex101.com/r/vkijKf/161\n+    private static final String COMPARISION_RANGE_REGEX = \"(>|<)(=)?(0|[1-9]\\\\d*)\\\\.?(0|[1-9]\\\\d*)?\\\\.?\"\n+            + \"(0|[1-9]\\\\d*)?(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.\"\n+            + \"(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\";\n+\n+    private static final Pattern SEMVER_PATTERN = Pattern.compile(SEMVER_REGEX, Pattern.MULTILINE);\n+    private static final Pattern HYPHEN_RANGE_PATTERN = Pattern.compile(HYPHEN_RANGE_REGEX, Pattern.MULTILINE);\n+    private static final Pattern COMPARISION_RANGE_PATTERN = Pattern.compile(COMPARISION_RANGE_REGEX,\n+                                                                             Pattern.MULTILINE);\n+    // Only major.minor.patch for the moment\n+    private static final String VERSION_FMT = \"%s.%s.%s\";\n+\n+    private final String version;\n+\n+    private final int major;\n+\n+    private final int minor;\n+\n+    private final int patch;\n+\n+    // Unused at the moment\n+    private final String preReleaseTag;\n+\n+    // Unused at the moment\n+    private final String buildMetaTag;\n+\n+    /**\n+     * Constructor with one String as input.\n+     *\n+     * @param versionString String to use to construct object\n+     */\n+    @JsonCreator\n+    public EvergreenPackageVersion(final String versionString)\n+            throws InvalidPackageVersionFormatException {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+        if (! matcher.matches()) {\n+            throw new InvalidPackageVersionFormatException(\"Package Version is not in correct format\");\n+        }\n+\n+        this.version = matcher.group(0);\n+\n+        // Major, minor, patch MUST be present\n+        this.major = Integer.parseInt(matcher.group(1));\n+        this.minor = Integer.parseInt(matcher.group(2));\n+        this.patch = Integer.parseInt(matcher.group(3));\n+\n+        // Tags may be present\n+        if (matcher.group(4) != null) {\n+            this.preReleaseTag = matcher.group(4);\n+        } else {\n+            this.preReleaseTag = null;\n+        }\n+\n+        if (matcher.group(5) != null) {\n+            this.buildMetaTag = matcher.group(5);\n+        } else {\n+            this.buildMetaTag = null;\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given string contains a valid version string.\n+     *\n+     * @param versionString String to test\n+     * @return boolean value indicating whether the String defines a valid version\n+     */\n+    public static boolean isValidVersion(final String versionString) {\n+        final Matcher matcher = SEMVER_PATTERN.matcher(versionString);\n+\n+        // Must match regex exactly (don't succeed on substrings)\n+        return matcher.matches();\n+    }\n+\n+    /**\n+     * Override toString method.\n+     *\n+     * @return String\n+     */\n+    @Override\n+    public String toString() {\n+        return version;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     *\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof EvergreenPackageVersion)) {\n+            return false;\n+        }\n+\n+        EvergreenPackageVersion pkgVer = (EvergreenPackageVersion) obj;\n+        return (pkgVer.getVersion().equalsIgnoreCase(version));\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     *\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        // Use the hashCode from the full version string\n+        return version.hashCode();\n+    }\n+\n+    /**\n+     * Override compareTo method.\n+     *\n+     * @return int with comparison answer\n+     */\n+    @Override\n+    public int compareTo(EvergreenPackageVersion evergreenPackageVersion) {\n+        int compareRes = Integer.compare(major, evergreenPackageVersion.getMajor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        compareRes = Integer.compare(minor, evergreenPackageVersion.getMinor());\n+        if (compareRes != 0) {\n+            return compareRes;\n+        }\n+        return Integer.compare(patch, evergreenPackageVersion.getPatch());\n+\n+        // Add tag compare\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     */\n+    public static boolean isVersionInRange(String testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        return isVersionInRange(new EvergreenPackageVersion(testVersion), range);\n+    }\n+\n+    /**\n+     * Check if given version is in range.\n+     * NOTE: Quick fix, Probably can be simplfied, the List is redundant\n+     */\n+    public static boolean isVersionInRange(EvergreenPackageVersion testVersion, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        List<EvergreenPackageVersion> versions = new ArrayList<>();\n+        versions.add(testVersion);\n+\n+        applyRangeToInput(versions, range);\n+        return !versions.isEmpty();\n+    }\n+\n+    /**\n+     * Apply provided range to a list of versions.\n+     * NOTE: The input list WILL BE mutated and contain the result of applying the provided range conditions.\n+     *\n+     */\n+    public static void applyRangeToInput(List<EvergreenPackageVersion> versions, final String range)\n+            throws InvalidPackageVersionFormatException {\n+        // NOTE: Only supports major.minor.patch for the moment\n+        // NOTE: This is only for ONE SINGLE comparator set, we may not support multiple sets, TBD\n+        // Multiple comparator sets are range conditions separated by either whitespace or ||\n+        // https://www.npmjs.com/package/semver#ranges\n+\n+        // Apply Hyphen Ranges X.Y.Z - A.B.C\n+        final Matcher hyphenRangeMatcher = HYPHEN_RANGE_PATTERN.matcher(range);\n+        if (hyphenRangeMatcher.matches()) {\n+            // matched hyphen range pattern\n+            // Construct lower bound\n+            /*System.out.println(\"Full match: \" + hyphenRangeMatcher.group(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxMjEwMA==", "bodyText": "I'm not sure it's necessary to have an interface or a class for that matter for lifecycle, if it's deserialized as Map<String, Object> from the recipe, we can work with that directly.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381512100", "createdAt": "2020-02-19T20:00:27Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageLifecycle.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+public interface PackageLifecycle {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1NjY4Mg=="}, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxMzE3Mw==", "bodyText": "Is this a way to implement recipe schema versions or is it temporary until we finalize the format? It looks like there will be a bunch of changes whenever the format changes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r381513173", "createdAt": "2020-02-19T20:02:35Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.EvergreenPackageDependency;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfig;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.impl.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa", "committedDate": "2020-02-14T23:22:24Z", "message": "Improve code quality, add full list of supported platforms, improve unit test coverage"}, "afterCommit": {"oid": "c22347dd0d7e1634f38c667bc85ba9ee62f7ca39", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c22347dd0d7e1634f38c667bc85ba9ee62f7ca39", "committedDate": "2020-02-20T22:31:33Z", "message": "Add Package Model, Package Recipe schema model and Semver based versioning"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c22347dd0d7e1634f38c667bc85ba9ee62f7ca39", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c22347dd0d7e1634f38c667bc85ba9ee62f7ca39", "committedDate": "2020-02-20T22:31:33Z", "message": "Add Package Model, Package Recipe schema model and Semver based versioning"}, "afterCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b2d27eb73613a06f19ca3916d0878006ef4435c6", "committedDate": "2020-02-21T02:13:36Z", "message": "Add Package Model, Package Recipe schema model and Semver based versioning"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzYzMjA1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-362363205", "createdAt": "2020-02-21T02:19:21Z", "commit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoxOToyMVrOFspq9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoxOToyMVrOFspq9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDQwNQ==", "bodyText": "What's the point of the math? Isn't the hashcode of that string good enough?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382364405", "createdAt": "2020-02-21T02:19:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public PackageRecipe(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                         @JsonProperty(\"PackageName\") String packageName,\n+                         @JsonProperty(\"Version\") Semver packageVersion,\n+                         @JsonProperty(\"Description\") String description,\n+                         @JsonProperty(\"Publisher\") String publisher,\n+                         @JsonProperty(\"Config\") PackageConfigFormat config) throws SemverException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        //TODO: Figure out how to do this in deserialize (only option so far seems to be custom deserializer)\n+        this.packageVersion = new Semver(packageVersion.toString(), Semver.SemverType.NPM);\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.config =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return config.getArtifactProviders();\n+    }\n+\n+    public Map<String, String> getDependencies() {\n+        return config.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static PackageRecipe getPackageObject(String recipe)\n+            throws UnsupportedRecipeFormatException {\n+        PackageRecipe pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, PackageRecipe.class);\n+        } catch (IOException e) {\n+            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof PackageRecipe)) {\n+            return false;\n+        }\n+\n+        PackageRecipe pkg = (PackageRecipe) obj;\n+        boolean ret = true;\n+        if (!pkg.getPackageName().equals(getPackageName())) {\n+            ret = false;\n+        } else if (!pkg.getPackageVersion().equals((getPackageVersion()))) {\n+            ret = false;\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Override hashCode method.\n+     * @return int containing hashcode\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        // TODO: Check against INT_MAX, maybe extend to include other fields and change to lombok?\n+        // TODO: See if this can be used for local override config as well\n+        String packageId = packageName + \"-\" + packageVersion.toString();\n+        result = prime * result", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzYzNjEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-362363613", "createdAt": "2020-02-21T02:20:58Z", "commit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoyMDo1OVrOFspsbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoyMDo1OVrOFspsbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDc4Mw==", "bodyText": "Probably also needs method to perform cleanup or at least list all cached packages so you can determine what can be deleted.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382364783", "createdAt": "2020-02-21T02:20:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzYzODMz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-362363833", "createdAt": "2020-02-21T02:21:55Z", "commit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoyMTo1NlrOFsptKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoyMzozNFrOFspulQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NDk2OQ==", "bodyText": "The order should be (expected value, actual value). So I believe you need to flip this one and some others.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382364969", "createdAt": "2020-02-21T02:21:56Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipeTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PackageRecipeTests {\n+\n+    @Test\n+    public void GIVEN_valid_package_recipe_WHEN_attempt_package_recipe_create_THEN_valid_package_recipe_created() {\n+        try {\n+            String recipeContents\n+                    = TestHelper.getPackageRecipeForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME,\n+                                                                \"1.0.0\");\n+            PackageRecipe testPkg = PackageRecipe.getPackageObject(recipeContents);\n+            assertEquals(testPkg.getPackageName(), TestHelper.MONITORING_SERVICE_PACKAGE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTA1NQ==", "bodyText": "Remove this, just throw from the test case. Here and everywhere else too.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382365055", "createdAt": "2020-02-21T02:22:18Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipeTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PackageRecipeTests {\n+\n+    @Test\n+    public void GIVEN_valid_package_recipe_WHEN_attempt_package_recipe_create_THEN_valid_package_recipe_created() {\n+        try {\n+            String recipeContents\n+                    = TestHelper.getPackageRecipeForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME,\n+                                                                \"1.0.0\");\n+            PackageRecipe testPkg = PackageRecipe.getPackageObject(recipeContents);\n+            assertEquals(testPkg.getPackageName(), TestHelper.MONITORING_SERVICE_PACKAGE_NAME);\n+            assertTrue(testPkg.getPackageVersion().isEqualTo(\"1.0.0\"));\n+            assertEquals(\"Me\", testPkg.getPublisher());\n+            assertEquals(testPkg.getRecipeTemplateVersion(), RecipeTemplateVersion.JAN_25_2020);\n+            assertEquals(testPkg.getRecipeTemplateVersion().getRecipeTemplateVersion(),\n+                         \"2020-01-25\");\n+            assertNotNull(testPkg.getConfig());\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTE0NA==", "bodyText": "Use assertThrows here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382365144", "createdAt": "2020-02-21T02:22:47Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipeTests.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+\n+import com.aws.iot.evergreen.packagemanager.TestHelper;\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PackageRecipeTests {\n+\n+    @Test\n+    public void GIVEN_valid_package_recipe_WHEN_attempt_package_recipe_create_THEN_valid_package_recipe_created() {\n+        try {\n+            String recipeContents\n+                    = TestHelper.getPackageRecipeForTestPackage(TestHelper.MONITORING_SERVICE_PACKAGE_NAME,\n+                                                                \"1.0.0\");\n+            PackageRecipe testPkg = PackageRecipe.getPackageObject(recipeContents);\n+            assertEquals(testPkg.getPackageName(), TestHelper.MONITORING_SERVICE_PACKAGE_NAME);\n+            assertTrue(testPkg.getPackageVersion().isEqualTo(\"1.0.0\"));\n+            assertEquals(\"Me\", testPkg.getPublisher());\n+            assertEquals(testPkg.getRecipeTemplateVersion(), RecipeTemplateVersion.JAN_25_2020);\n+            assertEquals(testPkg.getRecipeTemplateVersion().getRecipeTemplateVersion(),\n+                         \"2020-01-25\");\n+            assertNotNull(testPkg.getConfig());\n+        } catch (Throwable ex) {\n+            ex.printStackTrace(System.out);\n+            fail();\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_empty_package_recipe_WHEN_attempt_package_recipe_create_THEN_create_throws_exception() {\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTMzMw==", "bodyText": "What is this %s here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382365333", "createdAt": "2020-02-21T02:23:34Z", "author": {"login": "MikeDombo"}, "path": "src/test/resources/com/aws/iot/evergreen/packagemanager/test_packages/ConveyorBelt-1.0.0/recipe.yaml", "diffHunk": "@@ -0,0 +1,30 @@\n+---\n+RecipeTemplateVersion: '2020-01-25'\n+PackageName: ConveyorBelt\n+Description: Test recipe for Evergreen packages\n+Publisher: Me\n+Version: '1.0.0'\n+Config:\n+  Platform:\n+    Default:\n+      lifecycle:\n+        install:\n+          skipif: onpath git\n+          script: sudo apt-get install git\n+      artifacts:\n+        - %s/ConveyorBelt-1.0.0/conveyor_artifact.txt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzk3MzM5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-362397339", "createdAt": "2020-02-21T04:47:08Z", "commit": {"oid": "bc5b3fe4bbbabaed1785ec01b78e7ee1c54229fa"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTowODoyNlrOFsr1hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNTozOTowOFrOFssM9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5OTg3Ng==", "bodyText": "Is it data model? If it's data model, why does it mix with control logic? For example, PackageConfigFormat interface. The data model shouldn't decide artifact provider. The controlling logic decides what artifact provider to use in term of data model artifact type.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382399876", "createdAt": "2020-02-21T05:08:26Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDMxNQ==", "bodyText": "Again, data model shouldn't control deserializing itself. We should separate control and data flows.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382400315", "createdAt": "2020-02-21T05:10:52Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDU1Mg==", "bodyText": "Can you try to use lombok to generate equals and hashcode? why do we need to write ourselves?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382400552", "createdAt": "2020-02-21T05:12:04Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public PackageRecipe(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                         @JsonProperty(\"PackageName\") String packageName,\n+                         @JsonProperty(\"Version\") Semver packageVersion,\n+                         @JsonProperty(\"Description\") String description,\n+                         @JsonProperty(\"Publisher\") String publisher,\n+                         @JsonProperty(\"Config\") PackageConfigFormat config) throws SemverException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        //TODO: Figure out how to do this in deserialize (only option so far seems to be custom deserializer)\n+        this.packageVersion = new Semver(packageVersion.toString(), Semver.SemverType.NPM);\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.config =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return config.getArtifactProviders();\n+    }\n+\n+    public Map<String, String> getDependencies() {\n+        return config.getDependencies();\n+    }\n+\n+    /**\n+     * Build package object from Recipe file and register it to the package database.\n+     *\n+     * @param recipe Recipe contents\n+     * @return Package described by the input recipe file\n+     */\n+    public static PackageRecipe getPackageObject(String recipe)\n+            throws UnsupportedRecipeFormatException {\n+        PackageRecipe pkg = null;\n+        try {\n+            pkg = OBJECT_MAPPER.readValue(recipe, PackageRecipe.class);\n+        } catch (IOException e) {\n+            throw new UnsupportedRecipeFormatException(Constants.UNABLE_TO_PARSE_RECIPE_EXCEPTION_MSG, e);\n+        }\n+\n+        return pkg;\n+    }\n+\n+    /**\n+     * Override equals method.\n+     * @param obj Package to compare this one to\n+     * @return boolean value indicating whether the two packages have same name and version\n+     */\n+    @Override\n+    public boolean equals(Object obj) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjAzNw==", "bodyText": "I understand the reasons behind versioned template. But my arguments are if name and version are fixed, why not artifacts and dependencies? Oppositely, are the package name and version ever fixed? for example, won't we decide to alter the name in the future? Also this creates another level indentation in recipe file.\nHave you thought different approach for this purpose? For example, use different recipe/package model to map to different template version completely?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382402037", "createdAt": "2020-02-21T05:19:48Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjQwNw==", "bodyText": "Why is it an interface? Isn't cache internal to package manager? Will we have different implementation of package cache? What's this store's relationship with package registry/database? Is it playing both roles of registry and cache?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382402407", "createdAt": "2020-02-21T05:21:40Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNTg3Nw==", "bodyText": "Do we have to decide how we support recipe template version now? Can we add the support when we need to? I don't think it's one-way door.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382405877", "createdAt": "2020-02-21T05:39:08Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMjAzNw=="}, "originalCommit": {"oid": "b2d27eb73613a06f19ca3916d0878006ef4435c6"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyOTAzODI2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-362903826", "createdAt": "2020-02-21T20:41:26Z", "commit": {"oid": "2d974c001e110bc0d2f311d2fcac0d2400b81344"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMDo0MToyNlrOFtD_gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQyMDo0MToyNlrOFtD_gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NTY1MQ==", "bodyText": "We will need parameters section from the recipe in here as well, maybe an inner class of this with parameter name, default value and type. But if you are merging this soon, I can add that in my pull request", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382795651", "createdAt": "2020-02-21T20:41:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+public class PackageRecipe {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(new YAMLFactory());\n+\n+    static {\n+        OBJECT_MAPPER.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+    }\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    private final String packageName;\n+\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d974c001e110bc0d2f311d2fcac0d2400b81344"}, "originalPosition": 43}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9635ce77807cbfd684e47233bc2f820134f98b15", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9635ce77807cbfd684e47233bc2f820134f98b15", "committedDate": "2020-02-22T01:47:15Z", "message": "Add LocalArtifactProvider impl to avoid Covertura issues"}, "afterCommit": {"oid": "b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "committedDate": "2020-02-22T02:06:06Z", "message": "Add LocalArtifactProvider impl to avoid Covertura issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDAxOTU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-363001955", "createdAt": "2020-02-22T02:08:46Z", "commit": {"oid": "9635ce77807cbfd684e47233bc2f820134f98b15"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMjoxOTozMlrOFtI_nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMlQwMjoyMTowNlrOFtJAIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NzU5Ng==", "bodyText": "Get package/recipe implementation would be different based on the source, but I'm thinking cache and the copy location and hence the implementation should be the same for all package stores?  Should this be an abstract class instead of an interface so you could move these methods to a common place?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382877596", "createdAt": "2020-02-22T02:19:32Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/plugins/PackageStore.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.aws.iot.evergreen.packagemanager.plugins;\n+\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageRecipe;\n+import com.vdurmont.semver4j.Semver;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface PackageStore {\n+    Optional<String> getPackageRecipeIfExists(final String packageName,\n+                                                     final Semver packageVersion);\n+\n+    void cachePackageArtifacts(PackageRecipe evgPackage) throws PackagingException;\n+\n+    void cachePackageRecipeAndArtifacts(PackageRecipe evgPackage, final String recipeContents)\n+            throws PackagingException;\n+\n+    void copyPackageArtifactsToPath(PackageRecipe curPackage, Path destPath) throws PackagingException;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1d27e309968c5eeca8f9ef899b52f0f13dffa0f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NzcyOA==", "bodyText": "Is this temporary since we only have local artifact provider right now?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r382877728", "createdAt": "2020-02-22T02:21:06Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/impl/ConfigFormat25Jan2020.java", "diffHunk": "@@ -0,0 +1,155 @@\n+package com.aws.iot.evergreen.packagemanager.models.impl;\n+\n+import com.aws.iot.evergreen.packagemanager.config.Constants;\n+import com.aws.iot.evergreen.packagemanager.exceptions.DefaultPlatformConfigNotFoundException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnsupportedRecipeFormatException;\n+import com.aws.iot.evergreen.packagemanager.models.PackageConfigFormat;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.aws.iot.evergreen.packagemanager.plugins.LocalArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.Getter;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ConfigFormat25Jan2020 implements PackageConfigFormat {\n+    private final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig;\n+    private final PlatformConfigFormat25Jan2020 mergedPlatformConfig;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param platformConfig Platform config object that was deserialized from Recipe\n+     * @throws UnsupportedRecipeFormatException       Thrown when parsing fails or config is empty\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default platform config in the Recipe\n+     */\n+    @JsonCreator\n+    public ConfigFormat25Jan2020(\n+            @JsonProperty(\"Platform\") Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws UnsupportedRecipeFormatException, DefaultPlatformConfigNotFoundException {\n+        if (platformConfig == null) {\n+            throw new UnsupportedRecipeFormatException(\"Platform Config is empty!\");\n+        }\n+        this.platformConfig = platformConfig;\n+        this.mergedPlatformConfig = mergeConfigs(platformConfig);\n+    }\n+\n+    /**\n+     * Resolve final config for this device using Default and platform specific configs.\n+     *\n+     * @param platformConfig Map of all platform configurations that were present in the Recipe\n+     * @return Resolved Platform config\n+     * @throws DefaultPlatformConfigNotFoundException Thrown when there's no default config available\n+     */\n+    private static PlatformConfigFormat25Jan2020 mergeConfigs(\n+            final Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> platformConfig)\n+            throws DefaultPlatformConfigNotFoundException {\n+        PlatformConfigFormat25Jan2020 resolvedConfig = platformConfig.get(SupportedPlatforms25Jan2020.DEFAULT);\n+        if (resolvedConfig == null) {\n+            // TODO: Do we want to use this as a mechanism to restrict some packages to specific platforms?\n+            throw new DefaultPlatformConfigNotFoundException(Constants.DEFAULT_CONFIG_NOT_FOUND_EXCEPTION_MSG);\n+        }\n+\n+        // TODO: Merge platform specific overrides\n+\n+        return resolvedConfig;\n+    }\n+\n+    @Override\n+    public Set<ArtifactProvider> getArtifactProviders() {\n+        return mergedPlatformConfig.getArtifactProviders();\n+    }\n+\n+    @Override\n+    public Map<String, String> getDependencies() {\n+        return mergedPlatformConfig.getDependencies();\n+    }\n+\n+    // TODO: Probably not needed?\n+    public Map<SupportedPlatforms25Jan2020, PlatformConfigFormat25Jan2020> getFullPlatformConfig() {\n+        return platformConfig;\n+    }\n+\n+    /**\n+     * Platform config specific to this version of the template.\n+     */\n+    @Getter\n+    public static class PlatformConfigFormat25Jan2020 {\n+        private final Map<String, Object> lifecycle;\n+\n+        // TODO: Migrate to deserializing artifact providers\n+        private final Set<ArtifactProvider> artifactProviders;\n+\n+        private final Map<String, String> dependencies;\n+\n+        /**\n+         * Constructer for Deserialize.\n+         *\n+         * @param lifecycle    Map of all lifecycle configurations\n+         * @param artifacts Artifact URLs (TODO: This will change to artifact providers)\n+         * @param dependencies Set of all dependencies (name and version range)\n+         * @param requires     Set of all Required services names\n+         */\n+        @JsonCreator\n+        public PlatformConfigFormat25Jan2020(@JsonProperty(\"lifecycle\") HashMap<String, Object> lifecycle,\n+                                             @JsonProperty(\"artifacts\") Set<String> artifacts,\n+                                             @JsonProperty(\"dependencies\") HashMap<String, String> dependencies,\n+                                             @JsonProperty(\"requires\") List<String> requires) {\n+            this.lifecycle = lifecycle == null ? Collections.emptyMap() : Collections.unmodifiableMap(lifecycle);\n+            // TODO: This is temporary, Migrate to deserializing artifact providers directly\n+            if (artifacts == null) {\n+                this.artifactProviders = Collections.emptySet();\n+            } else {\n+                HashSet<ArtifactProvider> providerSet = new HashSet<>();\n+                for (String url : artifacts) {\n+                    providerSet.add(new LocalArtifactProvider(url));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1d27e309968c5eeca8f9ef899b52f0f13dffa0f"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0526e84183a351199ecc1d79f8b5070fe2deaa8b", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0526e84183a351199ecc1d79f8b5070fe2deaa8b", "committedDate": "2020-02-23T18:59:19Z", "message": "Add Package Model, Package Recipe schema model and Semver based versioning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bde7133f31ef31550061f7a161c92a05042160a3", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bde7133f31ef31550061f7a161c92a05042160a3", "committedDate": "2020-02-23T18:59:19Z", "message": "Upload coverage report first to debug failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d37088b1a518fb49f55e31e745617bb60000676", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9d37088b1a518fb49f55e31e745617bb60000676", "committedDate": "2020-02-23T18:59:19Z", "message": "Add a test for Constants to get around cobertura issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/68119a3357d78e294bdbfedc3783deb63615324e", "committedDate": "2020-02-23T18:59:19Z", "message": "Add LocalArtifactProvider impl to avoid Covertura issues"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b1d27e309968c5eeca8f9ef899b52f0f13dffa0f", "committedDate": "2020-02-22T02:06:06Z", "message": "Add LocalArtifactProvider impl to avoid Covertura issues"}, "afterCommit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e", "author": {"user": {"login": "chaurah", "name": "Rahul Singh Chauhan"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/68119a3357d78e294bdbfedc3783deb63615324e", "committedDate": "2020-02-23T18:59:19Z", "message": "Add LocalArtifactProvider impl to avoid Covertura issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTIyNDg0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-363122484", "createdAt": "2020-02-23T21:09:15Z", "commit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QyMTowOToxNVrOFtS06A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QyMTowOToxNVrOFtS06A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzODY5Ng==", "bodyText": "I think there are no strong reason to have another level of indentation now. The template versioning problem can be solved by the other way. Adding this config tab is especially not necessary when thinking from customer point of view.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r383038696", "createdAt": "2020-02-23T21:09:15Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+@EqualsAndHashCode(onlyExplicitlyIncluded = true)\n+public class PackageRecipe {\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @EqualsAndHashCode.Include\n+    private final String packageName;\n+\n+    @EqualsAndHashCode.Include\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTIyNjEw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-363122610", "createdAt": "2020-02-23T21:11:27Z", "commit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QyMToxMToyN1rOFtS1eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yM1QyMToxMToyN1rOFtS1eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzODg0MQ==", "bodyText": "Like we have discussed, model shouldn't decide handlers. Using applicable artifact provider to process artifact is controlling logic. Can we return artifacts instead of artifact provider?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#discussion_r383038841", "createdAt": "2020-02-23T21:11:27Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/models/PackageRecipe.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.aws.iot.evergreen.packagemanager.models;\n+\n+import com.aws.iot.evergreen.packagemanager.models.impl.ConfigFormat25Jan2020;\n+import com.aws.iot.evergreen.packagemanager.plugins.ArtifactProvider;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.vdurmont.semver4j.Semver;\n+import com.vdurmont.semver4j.SemverException;\n+import lombok.AccessLevel;\n+import lombok.EqualsAndHashCode;\n+import lombok.NoArgsConstructor;\n+import lombok.Value;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+@Value\n+@NoArgsConstructor(force = true, access = AccessLevel.PRIVATE)\n+@EqualsAndHashCode(onlyExplicitlyIncluded = true)\n+public class PackageRecipe {\n+\n+    private final RecipeTemplateVersion recipeTemplateVersion;\n+\n+    @EqualsAndHashCode.Include\n+    private final String packageName;\n+\n+    @EqualsAndHashCode.Include\n+    private Semver packageVersion;\n+\n+    private final String description;\n+\n+    private final String publisher;\n+\n+    // TODO: May be more maintainable as a custom deserializer?? This was way faster to get started with\n+    @JsonTypeInfo(\n+            use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+            property = \"RecipeTemplateVersion\",\n+            visible = true)\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = ConfigFormat25Jan2020.class, name = \"2020-01-25\")\n+    })\n+    @JsonProperty(\"Config\")\n+    private final PackageConfigFormat config;\n+\n+    /**\n+     * Constructor for Deserialize.\n+     *\n+     * @param recipeTemplateVersion Template version found in the Recipe file\n+     * @param packageName Name of the package\n+     * @param packageVersion Version of the package\n+     * @param description Description metadata\n+     * @param publisher Name of the publisher\n+     * @param config Configuration for this package\n+     */\n+    @JsonCreator\n+    public PackageRecipe(@JsonProperty(\"RecipeTemplateVersion\") RecipeTemplateVersion recipeTemplateVersion,\n+                         @JsonProperty(\"PackageName\") String packageName,\n+                         @JsonProperty(\"Version\") Semver packageVersion,\n+                         @JsonProperty(\"Description\") String description,\n+                         @JsonProperty(\"Publisher\") String publisher,\n+                         @JsonProperty(\"Config\") PackageConfigFormat config) throws SemverException {\n+        this.recipeTemplateVersion = recipeTemplateVersion;\n+        this.packageName = packageName;\n+        //TODO: Figure out how to do this in deserialize (only option so far seems to be custom deserializer)\n+        this.packageVersion = new Semver(packageVersion.toString(), Semver.SemverType.NPM);\n+        this.description = description;\n+        this.publisher = publisher;\n+        this.config =  config;\n+    }\n+\n+    public Set<ArtifactProvider> getArtifactProviders() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTIyNjQz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-363122643", "createdAt": "2020-02-23T21:12:12Z", "commit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTI0MzAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-363124303", "createdAt": "2020-02-23T21:40:21Z", "commit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTI5NzI2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/62#pullrequestreview-363129726", "createdAt": "2020-02-23T23:00:07Z", "commit": {"oid": "68119a3357d78e294bdbfedc3783deb63615324e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2484, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}