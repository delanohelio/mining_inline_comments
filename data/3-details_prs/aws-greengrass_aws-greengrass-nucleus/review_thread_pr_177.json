{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyNzcwNDgz", "number": 177, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMToyNjoyNVrODxZQBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo1MTozMFrODxcEmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTIwNTE4OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMToyNjoyNVrOGE18EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMjo0MTo0OVrOGE3yPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTIxNg==", "bodyText": "Why do we need this change? Waiting for IPCService to be ready is not sufficient?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/177#discussion_r407731216", "createdAt": "2020-04-13T21:26:25Z", "author": {"login": "hui-yang"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -60,7 +60,7 @@ static void startKernel() throws Exception {\n         // ensure awaitIpcServiceLatch starts\n         CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n         kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(\"IPCService\") && newState.equals(State.RUNNING)) {\n+            if (service.getName().equals(\"ServiceName\") && newState.equals(State.FINISHED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87b54cf0bd99f3ad24201f5358bdd33a066c2442"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc2MTQ2OA==", "bodyText": "I want to have a well known state, so I start with the service under test which is \"ServiceName\", is running.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/177#discussion_r407761468", "createdAt": "2020-04-13T22:41:49Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -60,7 +60,7 @@ static void startKernel() throws Exception {\n         // ensure awaitIpcServiceLatch starts\n         CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n         kernel.context.addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(\"IPCService\") && newState.equals(State.RUNNING)) {\n+            if (service.getName().equals(\"ServiceName\") && newState.equals(State.FINISHED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTIxNg=="}, "originalCommit": {"oid": "87b54cf0bd99f3ad24201f5358bdd33a066c2442"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY2NzQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo1MTozMFrOGE6Qtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo1Mjo1MlrOGE6SKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMjAzOQ==", "bodyText": "Can there be other exception?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/177#discussion_r407802039", "createdAt": "2020-04-14T00:51:30Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -106,35 +107,45 @@ public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest life\n         return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n+    @SuppressWarnings(\"PMD.AvoidGettingFutureWithoutTimeout\")\n     private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n                                                                ConnectionContext context) {\n         return (oldState, newState) -> {\n-            executor.execute(() -> {\n-                // Synchronize on context so that we only try to send 1 update at a time to a given client\n-                synchronized (context) {\n-                    StateTransitionEvent stateTransitionEvent =\n-                            StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                                    .service(listenRequest.getServiceName()).build();\n-\n-                    log.info(\"Pushing state change notification to {} from {} to {}\",\n-                            listenRequest.getServiceName(), oldState, newState);\n-                    try {\n-                        ApplicationMessage applicationMessage =\n-                                ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                        // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+            StateTransitionEvent stateTransitionEvent =\n+                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n+                            .service(listenRequest.getServiceName()).build();\n+\n+            log.info(\"Pushing state change notification to {} from {} to {}\",\n+                    listenRequest.getServiceName(), oldState, newState);\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n+                                .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n+                                .payload(IPCUtil.encode(stateTransitionEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n                         context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray())).get();\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get();\n                         // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (IOException | InterruptedException | ExecutionException e) {\n+                    } catch (InterruptedException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e303af677675494c4f4cc111786ebbb153aa1811"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMjQwOA==", "bodyText": "No, any exception would be caught within the execution exception", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/177#discussion_r407802408", "createdAt": "2020-04-14T00:52:52Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -106,35 +107,45 @@ public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest life\n         return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n+    @SuppressWarnings(\"PMD.AvoidGettingFutureWithoutTimeout\")\n     private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n                                                                ConnectionContext context) {\n         return (oldState, newState) -> {\n-            executor.execute(() -> {\n-                // Synchronize on context so that we only try to send 1 update at a time to a given client\n-                synchronized (context) {\n-                    StateTransitionEvent stateTransitionEvent =\n-                            StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                                    .service(listenRequest.getServiceName()).build();\n-\n-                    log.info(\"Pushing state change notification to {} from {} to {}\",\n-                            listenRequest.getServiceName(), oldState, newState);\n-                    try {\n-                        ApplicationMessage applicationMessage =\n-                                ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                        // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+            StateTransitionEvent stateTransitionEvent =\n+                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n+                            .service(listenRequest.getServiceName()).build();\n+\n+            log.info(\"Pushing state change notification to {} from {} to {}\",\n+                    listenRequest.getServiceName(), oldState, newState);\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n+                                .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n+                                .payload(IPCUtil.encode(stateTransitionEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n                         context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray())).get();\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get();\n                         // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (IOException | InterruptedException | ExecutionException e) {\n+                    } catch (InterruptedException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMjAzOQ=="}, "originalCommit": {"oid": "e303af677675494c4f4cc111786ebbb153aa1811"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4573, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}