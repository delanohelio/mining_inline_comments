{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNjE5MjA2", "number": 54, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDoyNjowMVrODdhxug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMTozOToyM1rODdiguQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjg4Njk4OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/ipc/IPCRouterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDoyNjowMVrOFmLw3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDoyNjowMVrOFmLw3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4Mjk0Mg==", "bodyText": "Super clear! Helped a lot for reading tests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375582942", "createdAt": "2020-02-06T00:26:01Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/IPCRouterTest.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.ipc;\n+\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class IPCRouterTest {\n+    @Mock\n+    Log log;\n+\n+    @Test\n+    public void GIVEN_function_WHEN_register_callback_THEN_callback_can_be_called() throws Throwable {\n+        IPCRouter router = new IPCRouter(log);\n+\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        router.registerServiceCallback(\"dest\", (a, b) -> {\n+            cdl.countDown();\n+            return null;\n+        });\n+\n+        router.getCallbackForDestination(\"dest\").onMessage(null, null);\n+        assertTrue(cdl.await(100, TimeUnit.MILLISECONDS));\n+    }\n+\n+    @Test\n+    public void GIVEN_already_registered_function_WHEN_register_callback_THEN_exception_is_thrown() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0487faf174865d66ed37a559e017c7545ba50652"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjg5Njc5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDozMTo1OVrOFmL3Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDo0OTo0N1rOFmMJMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw==", "bodyText": "I like AuthRequestType.Auth better. (plural -> singular)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375584523", "createdAt": "2020-02-06T00:31:59Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import org.junit.jupiter.api.Test;\n+\n+import static com.aws.iot.evergreen.ipc.handler.AuthHandler.AUTH_TOKEN_LOOKUP_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AuthHandlerTest {\n+    private static final String SERVICE_NAME = \"ServiceName\";\n+\n+    @Test\n+    public void GIVEN_service_WHEN_register_auth_token_THEN_client_can_be_authenticated_with_token() throws Exception {\n+        Configuration config = new Configuration(new Context());\n+        AuthHandler.registerAuthToken(new EvergreenService(config.lookupTopics(SERVICE_NAME)));\n+        Object authToken = config.find(SERVICE_NAME, \"_UID\").getOnce();\n+\n+        assertNotNull(authToken);\n+        assertEquals(SERVICE_NAME, config.find(AUTH_TOKEN_LOOKUP_KEY, (String) authToken).getOnce());\n+\n+        AuthHandler auth = new AuthHandler(config);\n+        RequestContext authContext = auth.doAuth(new FrameReader.Message(IPCUtil\n+                .encode(GeneralRequest.builder().type(AuthRequestTypes.Auth).request(authToken).build())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4Nzc3Nw==", "bodyText": "There is only 1 type, yes, but it is an enum which could technically have differing types.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375587777", "createdAt": "2020-02-06T00:44:23Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import org.junit.jupiter.api.Test;\n+\n+import static com.aws.iot.evergreen.ipc.handler.AuthHandler.AUTH_TOKEN_LOOKUP_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AuthHandlerTest {\n+    private static final String SERVICE_NAME = \"ServiceName\";\n+\n+    @Test\n+    public void GIVEN_service_WHEN_register_auth_token_THEN_client_can_be_authenticated_with_token() throws Exception {\n+        Configuration config = new Configuration(new Context());\n+        AuthHandler.registerAuthToken(new EvergreenService(config.lookupTopics(SERVICE_NAME)));\n+        Object authToken = config.find(SERVICE_NAME, \"_UID\").getOnce();\n+\n+        assertNotNull(authToken);\n+        assertEquals(SERVICE_NAME, config.find(AUTH_TOKEN_LOOKUP_KEY, (String) authToken).getOnce());\n+\n+        AuthHandler auth = new AuthHandler(config);\n+        RequestContext authContext = auth.doAuth(new FrameReader.Message(IPCUtil\n+                .encode(GeneralRequest.builder().type(AuthRequestTypes.Auth).request(authToken).build())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw=="}, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4ODY1OA==", "bodyText": "Not because it just have 1 type for now... Since each enum is a Type so we use a singular name for most Enum types.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375588658", "createdAt": "2020-02-06T00:47:47Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import org.junit.jupiter.api.Test;\n+\n+import static com.aws.iot.evergreen.ipc.handler.AuthHandler.AUTH_TOKEN_LOOKUP_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AuthHandlerTest {\n+    private static final String SERVICE_NAME = \"ServiceName\";\n+\n+    @Test\n+    public void GIVEN_service_WHEN_register_auth_token_THEN_client_can_be_authenticated_with_token() throws Exception {\n+        Configuration config = new Configuration(new Context());\n+        AuthHandler.registerAuthToken(new EvergreenService(config.lookupTopics(SERVICE_NAME)));\n+        Object authToken = config.find(SERVICE_NAME, \"_UID\").getOnce();\n+\n+        assertNotNull(authToken);\n+        assertEquals(SERVICE_NAME, config.find(AUTH_TOKEN_LOOKUP_KEY, (String) authToken).getOnce());\n+\n+        AuthHandler auth = new AuthHandler(config);\n+        RequestContext authContext = auth.doAuth(new FrameReader.Message(IPCUtil\n+                .encode(GeneralRequest.builder().type(AuthRequestTypes.Auth).request(authToken).build())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw=="}, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4OTE2OA==", "bodyText": "The enum is describing the different types of requests that can happen.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375589168", "createdAt": "2020-02-06T00:49:47Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/AuthHandlerTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import org.junit.jupiter.api.Test;\n+\n+import static com.aws.iot.evergreen.ipc.handler.AuthHandler.AUTH_TOKEN_LOOKUP_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AuthHandlerTest {\n+    private static final String SERVICE_NAME = \"ServiceName\";\n+\n+    @Test\n+    public void GIVEN_service_WHEN_register_auth_token_THEN_client_can_be_authenticated_with_token() throws Exception {\n+        Configuration config = new Configuration(new Context());\n+        AuthHandler.registerAuthToken(new EvergreenService(config.lookupTopics(SERVICE_NAME)));\n+        Object authToken = config.find(SERVICE_NAME, \"_UID\").getOnce();\n+\n+        assertNotNull(authToken);\n+        assertEquals(SERVICE_NAME, config.find(AUTH_TOKEN_LOOKUP_KEY, (String) authToken).getOnce());\n+\n+        AuthHandler auth = new AuthHandler(config);\n+        RequestContext authContext = auth.doAuth(new FrameReader.Message(IPCUtil\n+                .encode(GeneralRequest.builder().type(AuthRequestTypes.Auth).request(authToken).build())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDUyMw=="}, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjkwMzE2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDozNTo1OFrOFmL7FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDozNTo1OFrOFmL7FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NTU1Ng==", "bodyText": "For long tests, maybe adding //GIVEN //WHEN //THEN will be helpful", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375585556", "createdAt": "2020-02-06T00:35:58Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjkwNzM5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDozODoyNFrOFmL9mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDozODoyNFrOFmL9mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NjIwMA==", "bodyText": "times(1) can be removed. save as several occurrences below", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375586200", "createdAt": "2020-02-06T00:38:24Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        RequestContext requestCtx = new RequestContext();\n+        requestCtx.serviceName = \"ABC\";\n+        when(mockAuth.doAuth(any())).thenReturn(requestCtx);\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Success\"));\n+        assertEquals(requestCtx, mockAttrValue);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_bad_auth_request_THEN_server_validates_token_and_rejects_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        when(mockAuth.doAuth(any())).thenThrow(new IPCClientNotAuthorizedException(\"No Auth!\"));\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjkxMzM4OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDo0MTozNVrOFmMBIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMDo0MTozNVrOFmMBIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NzEwNA==", "bodyText": "Seems this could be moved to beforeEach. ArgumentCaptor could be an @Captor class field", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375587104", "createdAt": "2020-02-06T00:41:35Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/ipc/handler/MessageRouterTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ */\n+\n+package com.aws.iot.evergreen.ipc.handler;\n+\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.util.Log;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.util.Attribute;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class MessageRouterTest {\n+    public static final String ERROR_MESSAGE = \"AAAAAAH!\";\n+    @Mock\n+    AuthHandler mockAuth;\n+    @Mock\n+    IPCRouter ipcRouter;\n+    @Mock\n+    ChannelHandlerContext mockCtx;\n+    @Mock\n+    Channel mockChannel;\n+    @Mock\n+    Attribute<RequestContext> mockAttr;\n+    RequestContext mockAttrValue = null;\n+\n+    private MessageRouter router;\n+\n+    @BeforeEach\n+    public void setupMocks() throws Exception {\n+        router = new MessageRouter(mock(Log.class), mockAuth, ipcRouter);\n+\n+        when(mockCtx.channel()).thenReturn(mockChannel);\n+        when(mockChannel.attr(any())).thenReturn((Attribute) mockAttr);\n+        doAnswer((invocation) -> mockAttrValue = invocation.getArgument(0)).when(mockAttr).set(any());\n+        lenient().when(mockChannel.remoteAddress()).thenReturn(LocalAddress.ANY);\n+\n+        router.channelRegistered(mockCtx);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_auth_request_THEN_server_validates_token_and_authenticates_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        RequestContext requestCtx = new RequestContext();\n+        requestCtx.serviceName = \"ABC\";\n+        when(mockAuth.doAuth(any())).thenReturn(requestCtx);\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Success\"));\n+        assertEquals(requestCtx, mockAttrValue);\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_bad_auth_request_THEN_server_validates_token_and_rejects_client() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(AUTH_SERVICE, new FrameReader.Message(\"MyAuthToken\"\n+                .getBytes(StandardCharsets.UTF_8)), FrameReader.FrameType.REQUEST);\n+\n+        when(mockAuth.doAuth(any())).thenThrow(new IPCClientNotAuthorizedException(\"No Auth!\"));\n+\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(AUTH_SERVICE, responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Unauthorized\"));\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Error while authenticating client\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_unauthenticated_client_WHEN_send_any_request_THEN_server_forces_them_to_authenticate_first() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(1)).addListener(eq(ChannelFutureListener.CLOSE));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Error while authenticating client\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_unregistered_destination_THEN_respond_with_error() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        // Pretend that we are authenticated\n+        when(mockAttr.get()).thenReturn(new RequestContext());\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+        verify(ipcRouter, times(1)).getCallbackForDestination(eq(\"Destination\"));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertThat(new String(responseFrame.message.getPayload()), containsString(\"Destination handler not found\"));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_normal_return_THEN_respond_with_message() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);\n+\n+        // Pretend that we are authenticated\n+        when(mockAttr.get()).thenReturn(new RequestContext());\n+        // Setup handler for destination\n+        when(ipcRouter.getCallbackForDestination(anyString())).thenReturn((message, ctx) -> {\n+            CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+            fut.complete(new FrameReader.Message(\"Success\".getBytes()));\n+            return fut;\n+        });\n+\n+        FrameReader.MessageFrame requestFrame = new FrameReader.MessageFrame(\"Destination\", new FrameReader.Message(new byte[0]), FrameReader.FrameType.REQUEST);\n+        router.channelRead(mockCtx, requestFrame);\n+\n+        verify(mockChannelFuture, times(0)).addListener(any());\n+        verify(ipcRouter, times(1)).getCallbackForDestination(eq(\"Destination\"));\n+\n+        FrameReader.MessageFrame responseFrame = frameCaptor.getValue();\n+        assertEquals(\"Destination\", responseFrame.destination);\n+        assertEquals(requestFrame.sequenceNumber, responseFrame.sequenceNumber);\n+        assertEquals(\"Success\", new String(responseFrame.message.getPayload()));\n+    }\n+\n+    @Test\n+    public void GIVEN_authenticated_client_WHEN_request_with_exceptional_return_THEN_respond_with_error() throws Exception {\n+        ArgumentCaptor<FrameReader.MessageFrame> frameCaptor = ArgumentCaptor.forClass(FrameReader.MessageFrame.class);\n+        ChannelFuture mockChannelFuture = mock(ChannelFuture.class);\n+        when(mockCtx.writeAndFlush(frameCaptor.capture())).thenReturn(mockChannelFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "316542c6089da88a4b8a5107dae97e5dba39dfbf"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjk0OTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMTowMjoyNlrOFmMWjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMjowNjowOFrOFmNR9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ==", "bodyText": "Not related to this pull request, but can you change this to not use hardcoded string \"_UID\".", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375592591", "createdAt": "2020-02-06T01:02:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n         Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMzEyOA==", "bodyText": "Also at line 33, what if the random generated authToken collides with an existing one? Right now it seems it would overwrite the existing one. Isn't that wrong?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375603128", "createdAt": "2020-02-06T01:44:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n         Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ=="}, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwNTA5OA==", "bodyText": "There shouldn't be a collision since there should be enough entropy, but yeah, it would just overwrite if that was the case.\nI'll pull out _UID to a const.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375605098", "createdAt": "2020-02-06T01:53:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n         Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ=="}, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwNzc5OQ==", "bodyText": "Changed it to check if it was previously set, and if so, it will retry registering an auth token, thus generating a new one.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375607799", "createdAt": "2020-02-06T02:06:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {\n         Topic uid = s.config.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MjU5MQ=="}, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjk4MzU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMToyMzoxM1rOFmMryw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMToyMzoxM1rOFmMryw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5ODAyNw==", "bodyText": "Not related to this pull request, but I think it's cleaner to move this method into the GenericExternalService class. Not block this pull request though.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375598027", "createdAt": "2020-02-06T01:23:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,26 +1,30 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n+import com.aws.iot.evergreen.config.Configuration;\n import com.aws.iot.evergreen.config.Topic;\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.ipc.common.FrameReader;\n import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n import com.aws.iot.evergreen.ipc.services.common.AuthRequestTypes;\n import com.aws.iot.evergreen.ipc.services.common.GeneralRequest;\n-import com.aws.iot.evergreen.ipc.services.common.SendAndReceiveIPCUtil;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.util.Utils;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n \n import java.io.IOException;\n import javax.inject.Inject;\n \n+@AllArgsConstructor\n+@NoArgsConstructor\n public class AuthHandler implements InjectionActions {\n     public static final String AUTH_TOKEN_LOOKUP_KEY = \"_AUTH_TOKENS\";\n \n     @Inject\n-    private Kernel kernel;\n+    private Configuration config;\n \n     public static void registerAuthToken(EvergreenService s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzAwNzI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMTozOToyM1rOFmM60w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwMTo1NDo1M1rOFmNIUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ==", "bodyText": "getOnce() is marked as deprecated. Is this a misuse?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375601875", "createdAt": "2020-02-06T01:39:23Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -46,7 +50,7 @@ public RequestContext doAuth(FrameReader.Message request) throws IPCClientNotAut\n         String authToken = decodedRequest.getRequest();\n \n         // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) kernel.getRoot().lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = (String) config.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMzU0MQ==", "bodyText": "line 59-60, can you change serviceName to be private and use constructor?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375603541", "createdAt": "2020-02-06T01:46:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -46,7 +50,7 @@ public RequestContext doAuth(FrameReader.Message request) throws IPCClientNotAut\n         String authToken = decodedRequest.getRequest();\n \n         // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) kernel.getRoot().lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = (String) config.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ=="}, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwNTMyOA==", "bodyText": "getOnce shouldn't be deprecated. The \"deprecation\" is that we should be subscribing for updates and not using getOnce, but in this case we're just doing a static lookup and there's no need to be notified of a change.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/54#discussion_r375605328", "createdAt": "2020-02-06T01:54:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -46,7 +50,7 @@ public RequestContext doAuth(FrameReader.Message request) throws IPCClientNotAut\n         String authToken = decodedRequest.getRequest();\n \n         // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) kernel.getRoot().lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = (String) config.lookup(AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYwMTg3NQ=="}, "originalCommit": {"oid": "4da926e04a410557c7a06f6b7dcc68315dc7304f"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 68, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}