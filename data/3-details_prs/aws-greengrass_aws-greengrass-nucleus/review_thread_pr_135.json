{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzc2NTE5", "number": 135, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzozMDoyMFrODrwUug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzowMDo0NlrODsQCKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjA3MDk4OnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzozMDoyMFrOF8SRjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1MzozMVrOF8Vwig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1ODI4Ng==", "bodyText": "NIT: make 'failed_tests' a const", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398758286", "createdAt": "2020-03-26T17:30:20Z", "author": {"login": "ShirleyZheng92"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+        if existing_issues[0] == 200:\n+            existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+        else:\n+            existing_issues = []\n+\n+        body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+               f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+        for test_class, v in results.items():\n+            for test_case, failures in v.items():\n+                body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+                unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+                body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+        if existing_issues:\n+            issue_number = existing_issues[0][\"number\"]\n+            updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                      \"title\": title})\n+            print(updated_issue, flush=True)\n+        else:\n+            issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                               \"title\": title})\n+            print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):\n+            failure = None\n+            # Find failures and errors (there's no important difference between these for us)\n+            if testcase.find(\"failure\") is not None:\n+                failure = testcase.find(\"failure\").text\n+            elif testcase.find(\"error\") is not None:\n+                failure = testcase.find(\"error\").text\n+            if failure is not None:\n+                previous_results[testcase.get(\"classname\")][testcase.get(\"name\")] \\\n+                    .append({\"iteration\": iteration, \"failure\": failure})\n+                if not os.path.exists('failed_tests'):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNTM3MA==", "bodyText": "sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398815370", "createdAt": "2020-03-26T18:53:31Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+        if existing_issues[0] == 200:\n+            existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+        else:\n+            existing_issues = []\n+\n+        body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+               f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+        for test_class, v in results.items():\n+            for test_case, failures in v.items():\n+                body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+                unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+                body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+        if existing_issues:\n+            issue_number = existing_issues[0][\"number\"]\n+            updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                      \"title\": title})\n+            print(updated_issue, flush=True)\n+        else:\n+            issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                               \"title\": title})\n+            print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):\n+            failure = None\n+            # Find failures and errors (there's no important difference between these for us)\n+            if testcase.find(\"failure\") is not None:\n+                failure = testcase.find(\"failure\").text\n+            elif testcase.find(\"error\") is not None:\n+                failure = testcase.find(\"error\").text\n+            if failure is not None:\n+                previous_results[testcase.get(\"classname\")][testcase.get(\"name\")] \\\n+                    .append({\"iteration\": iteration, \"failure\": failure})\n+                if not os.path.exists('failed_tests'):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1ODI4Ng=="}, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjA3OTg0OnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzozMTo1MFrOF8SW2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1Mzo0MFrOF8VxRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1OTY0MQ==", "bodyText": "I think in Python3.2+ you can do os.makedirs(\"path/to/directory\", exist_ok=True)\nhttps://docs.python.org/3/library/os.html", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398759641", "createdAt": "2020-03-26T17:31:50Z", "author": {"login": "ShirleyZheng92"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+        if existing_issues[0] == 200:\n+            existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+        else:\n+            existing_issues = []\n+\n+        body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+               f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+        for test_class, v in results.items():\n+            for test_case, failures in v.items():\n+                body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+                unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+                body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+        if existing_issues:\n+            issue_number = existing_issues[0][\"number\"]\n+            updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                      \"title\": title})\n+            print(updated_issue, flush=True)\n+        else:\n+            issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                               \"title\": title})\n+            print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):\n+            failure = None\n+            # Find failures and errors (there's no important difference between these for us)\n+            if testcase.find(\"failure\") is not None:\n+                failure = testcase.find(\"failure\").text\n+            elif testcase.find(\"error\") is not None:\n+                failure = testcase.find(\"error\").text\n+            if failure is not None:\n+                previous_results[testcase.get(\"classname\")][testcase.get(\"name\")] \\\n+                    .append({\"iteration\": iteration, \"failure\": failure})\n+                if not os.path.exists('failed_tests'):\n+                    os.mkdir('failed_tests')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNTU1Ng==", "bodyText": "Sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398815556", "createdAt": "2020-03-26T18:53:40Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+        if existing_issues[0] == 200:\n+            existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+        else:\n+            existing_issues = []\n+\n+        body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+               f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+        for test_class, v in results.items():\n+            for test_case, failures in v.items():\n+                body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+                unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+                body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+        if existing_issues:\n+            issue_number = existing_issues[0][\"number\"]\n+            updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                      \"title\": title})\n+            print(updated_issue, flush=True)\n+        else:\n+            issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                               \"title\": title})\n+            print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):\n+            failure = None\n+            # Find failures and errors (there's no important difference between these for us)\n+            if testcase.find(\"failure\") is not None:\n+                failure = testcase.find(\"failure\").text\n+            elif testcase.find(\"error\") is not None:\n+                failure = testcase.find(\"error\").text\n+            if failure is not None:\n+                previous_results[testcase.get(\"classname\")][testcase.get(\"name\")] \\\n+                    .append({\"iteration\": iteration, \"failure\": failure})\n+                if not os.path.exists('failed_tests'):\n+                    os.mkdir('failed_tests')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1OTY0MQ=="}, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjA4ODQxOnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzozMzo0OVrOF8Sccw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1Mzo0NFrOF8VxnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MTA3NQ==", "bodyText": "NIT: make f'failed_tests/{iteration}-{testcase.get(\"classname\")}.' a variable", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398761075", "createdAt": "2020-03-26T17:33:49Z", "author": {"login": "ShirleyZheng92"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+        if existing_issues[0] == 200:\n+            existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+        else:\n+            existing_issues = []\n+\n+        body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+               f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+        for test_class, v in results.items():\n+            for test_case, failures in v.items():\n+                body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+                unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+                body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+        if existing_issues:\n+            issue_number = existing_issues[0][\"number\"]\n+            updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                      \"title\": title})\n+            print(updated_issue, flush=True)\n+        else:\n+            issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                               \"title\": title})\n+            print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):\n+            failure = None\n+            # Find failures and errors (there's no important difference between these for us)\n+            if testcase.find(\"failure\") is not None:\n+                failure = testcase.find(\"failure\").text\n+            elif testcase.find(\"error\") is not None:\n+                failure = testcase.find(\"error\").text\n+            if failure is not None:\n+                previous_results[testcase.get(\"classname\")][testcase.get(\"name\")] \\\n+                    .append({\"iteration\": iteration, \"failure\": failure})\n+                if not os.path.exists('failed_tests'):\n+                    os.mkdir('failed_tests')\n+                # Save test stdout and stderr\n+                if testcase.find(\"system-out\") is not None:\n+                    with open(f'failed_tests/{iteration}-{testcase.get(\"classname\")}.'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNTY0NQ==", "bodyText": "Sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398815645", "createdAt": "2020-03-26T18:53:44Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+        if existing_issues[0] == 200:\n+            existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+        else:\n+            existing_issues = []\n+\n+        body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+               f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+        for test_class, v in results.items():\n+            for test_case, failures in v.items():\n+                body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+                unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+                body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+        if existing_issues:\n+            issue_number = existing_issues[0][\"number\"]\n+            updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                      \"title\": title})\n+            print(updated_issue, flush=True)\n+        else:\n+            issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                               \"title\": title})\n+            print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):\n+            failure = None\n+            # Find failures and errors (there's no important difference between these for us)\n+            if testcase.find(\"failure\") is not None:\n+                failure = testcase.find(\"failure\").text\n+            elif testcase.find(\"error\") is not None:\n+                failure = testcase.find(\"error\").text\n+            if failure is not None:\n+                previous_results[testcase.get(\"classname\")][testcase.get(\"name\")] \\\n+                    .append({\"iteration\": iteration, \"failure\": failure})\n+                if not os.path.exists('failed_tests'):\n+                    os.mkdir('failed_tests')\n+                # Save test stdout and stderr\n+                if testcase.find(\"system-out\") is not None:\n+                    with open(f'failed_tests/{iteration}-{testcase.get(\"classname\")}.'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MTA3NQ=="}, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjA5NzUyOnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzozNTo1NVrOF8Siew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzozNTo1NVrOF8Siew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MjYxOQ==", "bodyText": "Or you can do if (len(results) == 0) { return;}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398762619", "createdAt": "2020-03-26T17:35:55Z", "author": {"login": "ShirleyZheng92"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjEzMTUwOnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzo0NDowNVrOF8S4xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1Mzo1MlrOF8Vx5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2ODMyNw==", "bodyText": "can you add a comment of the format here? It took me a while to figure out results is a dict of [className][testCaseName] - List of Failed Iteration Details", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398768327", "createdAt": "2020-03-26T17:44:05Z", "author": {"login": "ShirleyZheng92"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNTcxOQ==", "bodyText": "Yep sure.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398815719", "createdAt": "2020-03-26T18:53:52Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2ODMyNw=="}, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjE0MTQ4OnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzo0NjoyOFrOF8S_MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1NDoyMVrOF8VzBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2OTk2OQ==", "bodyText": "Is there a way to query an issue given the title? Or you can only list and search?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398769969", "createdAt": "2020-03-26T17:46:28Z", "author": {"login": "ShirleyZheng92"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNjAwNw==", "bodyText": "No, according to their API docs there doesn't seem to be a way to search by title or other keyword.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398816007", "createdAt": "2020-03-26T18:54:21Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2OTk2OQ=="}, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjE0NjUyOnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzo0NzozOFrOF8TCWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzo0NzozOFrOF8TCWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc3MDc3OA==", "bodyText": "Same here: if failure is None: return\nwe can save one level of indentation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r398770778", "createdAt": "2020-03-26T17:47:38Z", "author": {"login": "ShirleyZheng92"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,106 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) > 0:\n+        print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+        print(json.dumps(results), flush=True)\n+\n+        gh = GitHub(token=token)\n+        title = \"[Bot] Flaky Test(s) Identified\"\n+        existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+        if existing_issues[0] == 200:\n+            existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+        else:\n+            existing_issues = []\n+\n+        body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+               f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+        for test_class, v in results.items():\n+            for test_case, failures in v.items():\n+                body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+                unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+                body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+        if existing_issues:\n+            issue_number = existing_issues[0][\"number\"]\n+            updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                      \"title\": title})\n+            print(updated_issue, flush=True)\n+        else:\n+            issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                               \"title\": title})\n+            print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):\n+            failure = None\n+            # Find failures and errors (there's no important difference between these for us)\n+            if testcase.find(\"failure\") is not None:\n+                failure = testcase.find(\"failure\").text\n+            elif testcase.find(\"error\") is not None:\n+                failure = testcase.find(\"error\").text\n+            if failure is not None:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cce179fe9c36b4ef4040f04b96a64d3ce597bff4"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzIyOTAwOnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjozOToyMFrOF9Dybg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzowNDozNFrOF9EMSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTUxOA==", "bodyText": "Why \"./testcase\"? Should it be just \"testcase\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r399569518", "createdAt": "2020-03-27T22:39:20Z", "author": {"login": "abanthiy"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,111 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+\n+    # Dict for results as a dict of classname -> method name -> [failure details]\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) == 0:\n+        return\n+\n+    print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+    print(json.dumps(results), flush=True)\n+\n+    gh = GitHub(token=token)\n+    title = \"[Bot] Flaky Test(s) Identified\"\n+    existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+    if existing_issues[0] == 200:\n+        existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+    else:\n+        existing_issues = []\n+\n+    body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+           f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+    for test_class, v in results.items():\n+        for test_case, failures in v.items():\n+            body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+            unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+            body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+    if existing_issues:\n+        issue_number = existing_issues[0][\"number\"]\n+        updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                  \"title\": title})\n+        print(updated_issue, flush=True)\n+    else:\n+        issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                           \"title\": title})\n+        print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    failed_test_dir = \"failed_tests/\"\n+\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a096c42d6f926b1918067217aaa805c8d51c4e2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NjEzOA==", "bodyText": "Needs to be that. We're parsing XML and that is the XPATH. Or at least I know that this works.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r399576138", "createdAt": "2020-03-27T23:04:34Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,111 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+\n+    # Dict for results as a dict of classname -> method name -> [failure details]\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) == 0:\n+        return\n+\n+    print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+    print(json.dumps(results), flush=True)\n+\n+    gh = GitHub(token=token)\n+    title = \"[Bot] Flaky Test(s) Identified\"\n+    existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+    if existing_issues[0] == 200:\n+        existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+    else:\n+        existing_issues = []\n+\n+    body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+           f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+    for test_class, v in results.items():\n+        for test_case, failures in v.items():\n+            body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+            unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+            body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+    if existing_issues:\n+        issue_number = existing_issues[0][\"number\"]\n+        updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                  \"title\": title})\n+        print(updated_issue, flush=True)\n+    else:\n+        issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                           \"title\": title})\n+        print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    failed_test_dir = \"failed_tests/\"\n+\n+    if not os.path.exists(report_dir):\n+        return\n+    reports = list(filter(lambda f: f.startswith(\"TEST-\") and f.endswith(\".xml\"), os.listdir(report_dir)))\n+    for r in reports:\n+        tree = ET.parse(report_dir + r)\n+        for testcase in tree.getroot().findall(\"./testcase\"):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTUxOA=="}, "originalCommit": {"oid": "3a096c42d6f926b1918067217aaa805c8d51c4e2"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzI0MTIzOnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjo0NjozNlrOF9D55w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjo0NjozNlrOF9D55w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTQzMQ==", "bodyText": "May take this as argument since caller workflow is uploading the same directory", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r399571431", "createdAt": "2020-03-27T22:46:36Z", "author": {"login": "abanthiy"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,111 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+\n+    # Dict for results as a dict of classname -> method name -> [failure details]\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) == 0:\n+        return\n+\n+    print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+    print(json.dumps(results), flush=True)\n+\n+    gh = GitHub(token=token)\n+    title = \"[Bot] Flaky Test(s) Identified\"\n+    existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+    if existing_issues[0] == 200:\n+        existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+    else:\n+        existing_issues = []\n+\n+    body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+           f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+    for test_class, v in results.items():\n+        for test_case, failures in v.items():\n+            body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+            unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+            body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+    if existing_issues:\n+        issue_number = existing_issues[0][\"number\"]\n+        updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                  \"title\": title})\n+        print(updated_issue, flush=True)\n+    else:\n+        issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.post(body={\"body\": body,\n+                                                                           \"title\": title})\n+        print(issue, flush=True)\n+\n+\n+def parse_test_results(iteration, previous_results):\n+    report_dir = \"target/surefire-reports/\"\n+    failed_test_dir = \"failed_tests/\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a096c42d6f926b1918067217aaa805c8d51c4e2"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NzI2NjMyOnYy", "diffSide": "RIGHT", "path": ".github/scripts/flake.py", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzowMDo0NlrOF9EIiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzowODowMFrOF9EPdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NTE3Nw==", "bodyText": "Are we going to override the issue. If the failures in previous run were different that in the latest run then will the previous run be oerridden?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r399575177", "createdAt": "2020-03-27T23:00:46Z", "author": {"login": "abanthiy"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,111 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+\n+    # Dict for results as a dict of classname -> method name -> [failure details]\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) == 0:\n+        return\n+\n+    print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+    print(json.dumps(results), flush=True)\n+\n+    gh = GitHub(token=token)\n+    title = \"[Bot] Flaky Test(s) Identified\"\n+    existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+    if existing_issues[0] == 200:\n+        existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+    else:\n+        existing_issues = []\n+\n+    body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+           f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+    for test_class, v in results.items():\n+        for test_case, failures in v.items():\n+            body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+            unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+            body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+    if existing_issues:\n+        issue_number = existing_issues[0][\"number\"]\n+        updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                  \"title\": title})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a096c42d6f926b1918067217aaa805c8d51c4e2"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NjU0NQ==", "bodyText": "Consider making separate issues for different classname/classmethod which failed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r399576545", "createdAt": "2020-03-27T23:06:22Z", "author": {"login": "abanthiy"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,111 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+\n+    # Dict for results as a dict of classname -> method name -> [failure details]\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) == 0:\n+        return\n+\n+    print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+    print(json.dumps(results), flush=True)\n+\n+    gh = GitHub(token=token)\n+    title = \"[Bot] Flaky Test(s) Identified\"\n+    existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+    if existing_issues[0] == 200:\n+        existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+    else:\n+        existing_issues = []\n+\n+    body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+           f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+    for test_class, v in results.items():\n+        for test_case, failures in v.items():\n+            body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+            unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+            body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+    if existing_issues:\n+        issue_number = existing_issues[0][\"number\"]\n+        updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                  \"title\": title})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NTE3Nw=="}, "originalCommit": {"oid": "3a096c42d6f926b1918067217aaa805c8d51c4e2"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NjU3NA==", "bodyText": "Yes. I don't think this is an issue, and in fact I do want it to overwrite so that as we fix the issues, they will be removed from the issue. If we \"miss\" a flaky test, then it may not actually be flaky. In future, I'd expect that we increase the number of rounds from 10 to be higher, and then there's even less chance of missing flakiness.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r399576574", "createdAt": "2020-03-27T23:06:28Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,111 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+\n+    # Dict for results as a dict of classname -> method name -> [failure details]\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) == 0:\n+        return\n+\n+    print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+    print(json.dumps(results), flush=True)\n+\n+    gh = GitHub(token=token)\n+    title = \"[Bot] Flaky Test(s) Identified\"\n+    existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+    if existing_issues[0] == 200:\n+        existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+    else:\n+        existing_issues = []\n+\n+    body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+           f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+    for test_class, v in results.items():\n+        for test_case, failures in v.items():\n+            body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+            unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+            body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+    if existing_issues:\n+        issue_number = existing_issues[0][\"number\"]\n+        updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                  \"title\": title})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NTE3Nw=="}, "originalCommit": {"oid": "3a096c42d6f926b1918067217aaa805c8d51c4e2"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3Njk1MA==", "bodyText": "Also, the full edit history is still available on the issue if we really wanted.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/135#discussion_r399576950", "createdAt": "2020-03-27T23:08:00Z", "author": {"login": "MikeDombo"}, "path": ".github/scripts/flake.py", "diffHunk": "@@ -0,0 +1,111 @@\n+#  Copyright Amazon.com Inc. or its affiliates.\n+#  SPDX-License-Identifier: Apache-2.0\n+\n+import argparse\n+import json\n+import os\n+import subprocess\n+import xml.etree.ElementTree as ET\n+from collections import defaultdict\n+\n+from agithub.GitHub import GitHub\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument('--cmd', type=str, help='Command to run')\n+    parser.add_argument('-i', type=int, help='Iterations')\n+    parser.add_argument('--token', type=str, help='GitHub token')\n+    parser.add_argument('-ff', action=\"store_true\", help='Fail fast. If enabled, quit '\n+                                                         'after the first failure')\n+    args = parser.parse_args()\n+\n+    command = args.cmd\n+    iterations = args.i\n+    token = args.token\n+\n+    # Dict for results as a dict of classname -> method name -> [failure details]\n+    results = defaultdict(lambda: defaultdict(list))\n+\n+    for i in range(0, iterations):\n+        print(f\"Running iteration {i + 1} of {iterations}\", flush=True)\n+        process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True)\n+        # If the tests failed, then we should check which test(s) failed in order to report it\n+        if process.returncode != 0:\n+            print(f\"Iteration {i + 1} failed, saving and parsing results now\", flush=True)\n+            parse_test_results(i, results)\n+            if args.ff:\n+                break\n+        else:\n+            print(\"Succeeded with no failure\", flush=True)\n+\n+    if len(results) == 0:\n+        return\n+\n+    print(\"Found some flakiness. Creating/updating GitHub issue.\", flush=True)\n+    print(json.dumps(results), flush=True)\n+\n+    gh = GitHub(token=token)\n+    title = \"[Bot] Flaky Test(s) Identified\"\n+    existing_issues = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues.get(creator=\"app/github-actions\")\n+    if existing_issues[0] == 200:\n+        existing_issues = list(filter(lambda i: title in i[\"title\"], existing_issues[1]))\n+    else:\n+        existing_issues = []\n+\n+    body = f\"Flaky test(s) found for commit {os.getenv('GITHUB_SHA')}.\\n\" \\\n+           f\" See the uploaded artifacts from the action for details.\\n\\n\"\n+    for test_class, v in results.items():\n+        for test_case, failures in v.items():\n+            body += f\"- {test_class}.{test_case} failed {len(failures)} times over {iterations} iterations \"\n+            unique_failure_reasons = set(map(lambda f: f[\"failure\"], failures))\n+            body += f\"with {len(unique_failure_reasons)} unique failures.\\n\"\n+\n+    if existing_issues:\n+        issue_number = existing_issues[0][\"number\"]\n+        updated_issue = gh.repos[os.getenv(\"GITHUB_REPOSITORY\")].issues[issue_number].patch(body={\"body\": body,\n+                                                                                                  \"title\": title})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NTE3Nw=="}, "originalCommit": {"oid": "3a096c42d6f926b1918067217aaa805c8d51c4e2"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4952, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}