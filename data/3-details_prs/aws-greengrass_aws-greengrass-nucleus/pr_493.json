{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NzQ1NzQw", "number": 493, "title": "Merge new dependency resolution process", "bodyText": "Issue #, if available:\nDescription of changes:\nswitch to use simplified dependency resolution process\nWhy is this change necessary:\nSimplifying dependency resolution process is a greengrass v2 launch blocker\nHow was this change tested:\nFixed integ and e2e tests.\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-09-30T19:44:43Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493", "merged": true, "mergeCommit": {"oid": "cc6ba7eecc7da50721bec39ff1ac037b5234cc64"}, "closed": true, "closedAt": "2020-10-02T18:33:04Z", "author": {"login": "wikimonkey"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNbK-4gH2gAyNDk1NzQ1NzQwOmYwZGQyYWIxNTY3MTIwNzM3MDA4MWNkMjVlZjc3YjRkNDMwODIyZjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOqF0ygFqTUwMTM0OTI3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f0dd2ab15671207370081cd25ef77b4d430822f7", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f0dd2ab15671207370081cd25ef77b4d430822f7", "committedDate": "2020-09-28T22:17:41Z", "message": "switch to use simplified dependency resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af39520e8b38dea44159d526b56e7cd24a091602", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af39520e8b38dea44159d526b56e7cd24a091602", "committedDate": "2020-09-29T04:18:53Z", "message": "use local version if cloud service is not available"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "845024881e06ba4e5e463461583449e27c83eedd", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/845024881e06ba4e5e463461583449e27c83eedd", "committedDate": "2020-09-29T04:48:31Z", "message": "fix integ tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2234309489c810c45d53f4c69d524286d69ab555", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2234309489c810c45d53f4c69d524286d69ab555", "committedDate": "2020-09-29T05:23:40Z", "message": "pass deploymentConfigurationId to service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61d22f0c674c391422cea615583bb6dad8a8e5e2", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/61d22f0c674c391422cea615583bb6dad8a8e5e2", "committedDate": "2020-09-29T05:47:09Z", "message": "support global component dependencies in backward compatible way"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bca9493745cbb5330f8feff44042a9afa413f264", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bca9493745cbb5330f8feff44042a9afa413f264", "committedDate": "2020-09-29T06:07:17Z", "message": "fix format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "795d58ccceb20a8a20c60c48539260179be9a977", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/795d58ccceb20a8a20c60c48539260179be9a977", "committedDate": "2020-09-30T17:21:45Z", "message": "fix e2e tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "057cc77343109aa64f8c34f002d0e9e5ead97a4e", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/057cc77343109aa64f8c34f002d0e9e5ead97a4e", "committedDate": "2020-09-30T17:22:13Z", "message": "switch to use simplified dependency resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e1c5ceca1062630a915ecc0c20083143ce812f9", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7e1c5ceca1062630a915ecc0c20083143ce812f9", "committedDate": "2020-09-30T17:22:13Z", "message": "use local version if cloud service is not available"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab79c72d10b676bd65892f2f1693024ead180ded", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab79c72d10b676bd65892f2f1693024ead180ded", "committedDate": "2020-09-30T17:22:13Z", "message": "fix integ tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e18d46ea87e26809a0c2f94a7bad2c055356035", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4e18d46ea87e26809a0c2f94a7bad2c055356035", "committedDate": "2020-09-30T17:22:13Z", "message": "pass deploymentConfigurationId to service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c2198758668a64837564ca5bf06296eb6ccbd24", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1c2198758668a64837564ca5bf06296eb6ccbd24", "committedDate": "2020-09-30T17:22:13Z", "message": "support global component dependencies in backward compatible way"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94a7b1c6899cfd4e4730f93931c494d6049e58b4", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/94a7b1c6899cfd4e4730f93931c494d6049e58b4", "committedDate": "2020-09-30T17:22:13Z", "message": "fix format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d2a31a6f012e2483618313a795511d094ec5821", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6d2a31a6f012e2483618313a795511d094ec5821", "committedDate": "2020-09-30T17:22:13Z", "message": "fix e2e tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4daf93a17dc36ad046f1ed3c28e57b516f24aafd", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4daf93a17dc36ad046f1ed3c28e57b516f24aafd", "committedDate": "2020-09-30T17:22:44Z", "message": "Merge branch 'merge_new_DR_process' of https://github.com/aws/aws-greengrass-kernel into merge_new_DR_process"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98d87eb99a0c331016c32e1f36850edb7b0bf942", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/98d87eb99a0c331016c32e1f36850edb7b0bf942", "committedDate": "2020-09-30T17:55:16Z", "message": "cosmetic changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77b112cd9623681aa8c9dbcb663f62d8dfe3c225", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/77b112cd9623681aa8c9dbcb663f62d8dfe3c225", "committedDate": "2020-09-30T19:46:26Z", "message": "Merge branch 'master' into merge_new_DR_process"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a2342710b715bdac24c6fcd98e282ee03fd775", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b8a2342710b715bdac24c6fcd98e282ee03fd775", "committedDate": "2020-10-01T00:57:05Z", "message": "workaround with UUID as deploymentConfigurationId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3b0c45d5ce8c2bb8e6b3ff7489a36930cad9e18", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f3b0c45d5ce8c2bb8e6b3ff7489a36930cad9e18", "committedDate": "2020-10-01T04:41:41Z", "message": "Merge branch 'master' into merge_new_DR_process"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/420616f13da4a4e4534224864bf1cf91cb675035", "committedDate": "2020-10-01T16:42:02Z", "message": "Merge branch 'master' into merge_new_DR_process"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzYzNTI1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#pullrequestreview-500763525", "createdAt": "2020-10-01T22:37:01Z", "commit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjozNzowMVrOHbcz9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzowNjo1OFrOHbdUFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTY1NA==", "bodyText": "What is an example where we are doing version checking of a built-in component? I'm suspecting this should simplify with the idea of describing installed updatable components with a Recipe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498545654", "createdAt": "2020-10-01T22:37:01Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -231,6 +230,21 @@ private Requirement mergeVersionRequirements(Map<String, Requirement> versionReq\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTg0MQ==", "bodyText": "In current implementation, are we only negotiating one component at a time?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498545841", "createdAt": "2020-10-01T22:37:44Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n             // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n+            resolvedComponentId = localCandidateOptional.orElseThrow(() -> new NoAvailableComponentVersionException(\n+                    String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                            componentName, versionRequirements)));\n         } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+            // otherwise try to negotiate with cloud\n+            resolvedComponentId =\n+                    negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null),\n+                            deploymentConfigurationId);\n         }\n+\n+        return getComponentMetadata(resolvedComponentId);\n     }\n \n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+    private ComponentIdentifier negotiateVersionWithCloud(String componentName,\n+                                                          Map<String, Requirement> versionRequirements,\n+                                                          ComponentIdentifier localCandidate,\n+                                                          String deploymentConfigurationId) throws PackagingException {\n         ComponentContent componentContent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTk0MA==", "bodyText": "How did we land on a design that uses a Package requirement called \"LOCAL\" to indicate this is a local override? This is very fragile (are we expecting to document this as a reserved package name?) Also as this string is so important, pulling it from an enum that happens to have that string text, will cause the reserved-ness of this name to change if there is a code refactor. Let's fix this by at least defining an Enum to denote local overrides, and pass that enum as a parameter.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498545940", "createdAt": "2020-10-01T22:38:06Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjE4NQ==", "bodyText": "We had established coding standards that included comments, let's use them", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498546185", "createdAt": "2020-10-01T22:38:52Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n             // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n+            resolvedComponentId = localCandidateOptional.orElseThrow(() -> new NoAvailableComponentVersionException(\n+                    String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                            componentName, versionRequirements)));\n         } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+            // otherwise try to negotiate with cloud\n+            resolvedComponentId =\n+                    negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null),\n+                            deploymentConfigurationId);\n         }\n+\n+        return getComponentMetadata(resolvedComponentId);\n     }\n \n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+    private ComponentIdentifier negotiateVersionWithCloud(String componentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjY4OQ==", "bodyText": "When reviewing code, let's try and review comments too - Better comments (this isn't useful), capitalization, etc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498546689", "createdAt": "2020-10-01T22:40:43Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -405,23 +419,13 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n             return Optional.empty();\n         }\n \n-        // If the component is builtin, then we won't be able to get the metadata from the filesystem,\n-        // so in that case we will try getting it from builtin. If that fails too, then we just rethrow.\n-        try {\n-            return Optional\n-                    .of(componentStore.getPackageMetadata(new ComponentIdentifier(componentName, activeVersion)));\n-        } catch (PackagingException e) {\n-            ComponentMetadata md = getBuiltinComponentMetadata(componentName, activeVersion);\n-            if (md != null) {\n-                return Optional.of(md);\n-            }\n-            throw e;\n-        }\n+        return Optional.of(getComponentMetadata(new ComponentIdentifier(componentName, activeVersion)));\n     }\n \n-    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n+    /**\n+     * Get active component version and dependencies, the component version satisfies dependent version requirements.\n      *\n-     * @param componentName component name\n+     * @param componentName  component name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NzE4OQ==", "bodyText": "This comment needs improving. Use JavaDoc to describe the interface as a black box (/** ...*/) and implementation details as \"//\" comments inside the function.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498547189", "createdAt": "2020-10-01T22:42:24Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -104,7 +105,8 @@ public ComponentServiceHelper(GreengrassComponentServiceClientFactory clientFact\n     // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0OTc4OQ==", "bodyText": "In code below, downloadPackageRecipeAsString -- why don't we know the scope with the new changes? This seems very fragile if we resolved the PUBLIC version but then try to download PRIVATE version.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498549789", "createdAt": "2020-10-01T22:51:32Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -116,25 +118,30 @@ ComponentContent resolveComponentVersion(String componentName, Semver localCandi\n                 .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n                 .withVersionRequirements(versionRequirementsInString);\n         ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n+                .withComponentCandidates(Collections.singletonList(candidate))\n+                // TODO switch back deploymentConfigurationId once it's removed from URL path\n+                // use UUID to avoid ARN complication in URL, deploymentConfigurationId is used for logging purpose\n+                // in server, so could have this hack now\n+                .withDeploymentConfigurationId(UUID.randomUUID().toString());\n \n         ResolveComponentVersionsResult result;\n         try {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n+                            componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(\n+                    String.format(\"Component service error when resolving %s\", componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n+                \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MDM0MA==", "bodyText": "I like this, why is this not applied consistently?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498550340", "createdAt": "2020-10-01T22:53:28Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/DependencyResolver.java", "diffHunk": "@@ -5,296 +5,174 @@\n \n package com.aws.greengrass.componentmanager;\n \n-import com.aws.greengrass.componentmanager.exceptions.ComponentVersionConflictException;\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n import com.aws.greengrass.config.Topics;\n import com.aws.greengrass.deployment.model.DeploymentDocument;\n import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n-import com.aws.greengrass.lifecyclemanager.Kernel;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.vdurmont.semver4j.Requirement;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.AllArgsConstructor;\n import lombok.NoArgsConstructor;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n+import java.util.Queue;\n import java.util.Set;\n-import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n \n-@AllArgsConstructor\n @NoArgsConstructor\n public class DependencyResolver {\n     private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n     private static final String VERSION_KEY = \"version\";\n     private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n \n     @Inject\n     private ComponentManager componentManager;\n \n-    @Inject\n-    private Kernel kernel;\n-\n     /**\n-     * Create the full list of packages to be run on the device from a deployment document.\n-     * It also resolves the conflicts between the packages specified in the deployment document and the existing\n-     * running packages on the device.\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n      *\n-     * @param document                   deployment document\n-     * @param groupToRootPackagesDetails {@link Topics} providing package details for each group\n-     * @return a list of packages to be run on the device\n-     * @throws ComponentVersionConflictException when a package version conflict cannot be resolved\n-     * @throws PackagingException              for other package errors\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n      */\n-    public List<ComponentIdentifier> resolveDependencies(final DeploymentDocument document,\n-                                                         Topics groupToRootPackagesDetails)\n-            throws ComponentVersionConflictException, PackagingException {\n-\n-        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n-        // maintained and updated. This information needs to be tracked because: 1. One package can have multiple\n-        // depending packages posing different version constraints. 2. When the version of a depending package changes,\n-        // the version constraints will also change accordingly. 3. The information also shows the complete dependency\n-        // tree.\n-        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n-        Set<String> rootPackagesToResolve = new LinkedHashSet<>();\n-\n-        // Get a list of all package configurations with version constraints in the deployment document\n-        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n-            logger.atDebug().addKeyValue(COMPONENT_NAME_KEY, dpc.getPackageName())\n-                    .addKeyValue(VERSION_KEY, dpc.getResolvedVersion()).log(\"Found package configuration\");\n-            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n-\n-            // Only the group to package mapping before this deployment is guaranteed to be available, since config\n-            // updates happen in a separate thread.\n-            if (document.getRootPackages().contains(dpc.getPackageName())) {\n-                rootPackagesToResolve.add(dpc.getPackageName());\n-            }\n-            packageNameToVersionConstraints.get(dpc.getPackageName())\n-                    .put(document.getGroupName(), dpc.getResolvedVersion());\n-        }\n-\n-        //Get package version constraints for root packages corresponding to other groups\n-        updatePackageConstraintsFromOtherGroups(groupToRootPackagesDetails, document.getGroupName(),\n-                rootPackagesToResolve, packageNameToVersionConstraints);\n-\n-        logger.atInfo().setEventType(\"resolve-dependencies-start\")\n-                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints)\n-                .kv(\"RootPackagesToResolve\", rootPackagesToResolve).kv(\"DeploymentGroup\", document.getGroupName())\n-                .log(\"The root packages for deployment\");\n-\n-        // Map of package name and resolved version\n-        Map<String, ComponentIdentifier> resolvedPackageNameToVersion = new HashMap<>();\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MTk0Mw==", "bodyText": "findBestMatchAvailableComponent will potentially downgrade component version?\nI want an explicit test that will verify that given a local version 1.3 that does not satisfy dependencies, a local version 1.1 that does satisfy dependencies, and an active version 1.2 that does not satisfy dependencies (due to conflict), that we DO_NOT try to downgrade to 1.1, that would be bad (unless rollback, in which case we want to roll back to version last used, but I suspect we're not handling that correctly?).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498551943", "createdAt": "2020-10-01T22:59:09Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -208,7 +207,7 @@ private ComponentMetadata negotiateVersionWithCloud(String componentName,\n             componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n         }\n \n-        return componentStore.getPackageMetadata(resolvedComponentId);\n+        return resolvedComponentId;\n     }\n \n     private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MzQzMQ==", "bodyText": "Also lets have an action item to find and address ALL equalsIgnoreCase in the Kernel.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498553431", "createdAt": "2020-10-01T23:05:09Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -116,25 +118,30 @@ ComponentContent resolveComponentVersion(String componentName, Semver localCandi\n                 .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n                 .withVersionRequirements(versionRequirementsInString);\n         ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n+                .withComponentCandidates(Collections.singletonList(candidate))\n+                // TODO switch back deploymentConfigurationId once it's removed from URL path\n+                // use UUID to avoid ARN complication in URL, deploymentConfigurationId is used for logging purpose\n+                // in server, so could have this hack now\n+                .withDeploymentConfigurationId(UUID.randomUUID().toString());\n \n         ResolveComponentVersionsResult result;\n         try {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n+                            componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(\n+                    String.format(\"Component service error when resolving %s\", componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n+                \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0OTc4OQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1Mzg3Ng==", "bodyText": "be careful about using any() in tests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498553876", "createdAt": "2020-10-01T23:06:58Z", "author": {"login": "JamieHunter"}, "path": "src/test/java/com/aws/greengrass/componentmanager/DependencyResolverTest.java", "diffHunk": "@@ -19,431 +18,379 @@\n import com.aws.greengrass.testcommons.testutilities.GGExtension;\n import com.vdurmont.semver4j.Requirement;\n import com.vdurmont.semver4j.Semver;\n+import org.hamcrest.collection.IsMapContaining;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n import org.mockito.InjectMocks;\n import org.mockito.Mock;\n-import org.mockito.Mockito;\n import org.mockito.junit.jupiter.MockitoExtension;\n import software.amazon.awssdk.utils.ImmutableMap;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n-import static org.hamcrest.Matchers.containsString;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.hamcrest.core.Is.is;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, GGExtension.class})\n class DependencyResolverTest {\n+\n+    private static final Semver v2_0_0 = new Semver(\"2.0.0\");\n+    private static final Semver v1_5_0 = new Semver(\"1.5.0\");\n+    private static final Semver v1_2_0 = new Semver(\"1.2.0\");\n+    private static final Semver v1_1_0 = new Semver(\"1.1.0\");\n+    private static final Semver v1_0_0 = new Semver(\"1.0.0\");\n+    private static final String componentA = \"A\";\n+    private static final String componentB1 = \"B1\";\n+    private static final String componentB2 = \"B2\";\n+    private static final String componentC1 = \"C1\";\n+    private static final String componentX = \"X\";\n+\n     @InjectMocks\n-    private DependencyResolver resolver;\n+    private DependencyResolver dependencyResolver;\n \n     @Mock\n-    private ComponentManager mockComponentManager;\n+    private ComponentManager componentManager;\n \n-    private Topics groupToRootPackagesTopics;\n+    private Topics groupToTargetComponentsTopics;\n     private Context context;\n     private final ComponentUpdatePolicy componentUpdatePolicy =\n             new ComponentUpdatePolicy(60, ComponentUpdatePolicyAction.NOTIFY_COMPONENTS);\n \n     @BeforeEach\n     void setupTopics() {\n         context = new Context();\n-        groupToRootPackagesTopics = Topics.of(context, GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+        groupToTargetComponentsTopics = Topics.of(context, GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n     }\n \n     @AfterEach\n-    void cleanupTopics() throws IOException {\n+    void cleanTopics() throws IOException {\n         context.close();\n     }\n \n-    @Nested\n-    class MergeSemverRequirementsTest {\n-\n-        @Test\n-        void GIVEN_list_of_version_ranges_WHEN_get_union_THEN_get_version_range() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\"<3.0\");\n-            constraints.add(\">1.0\");\n-            constraints.add(\">2.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\"<3.0 >1.0 >2.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n-            assertTrue(r.isSatisfiedBy(\"2.0.1\"));\n-        }\n-\n-        @Test\n-        void GIVEN_list_of_version_range_and_pinned_version_WHEN_get_union_THEN_get_pinned_version() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\"<3.0\");\n-            constraints.add(\"1.0.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\"<3.0 =1.0.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n-            assertTrue(r.isSatisfiedBy(\"1.0.0\"));\n-        }\n-\n-        @Test\n-        void GIVEN_list_of_version_range_with_conflicts_WHEN_get_union_THEN_get_no_version_match() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\">4.0\");\n-            constraints.add(\"<3.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\">4.0 <3.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"4.0.1\"));\n-            assertFalse(r.isSatisfiedBy(\"2.0.0\"));\n-        }\n+    @Test\n+    void GIVEN_component_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_versions() throws Exception {\n+        /*\n+         *      group1\n+         *         \\(1.0.0)\n+         *          A\n+         * (1.0.0)/   \\(>1.0)\n+         *      B1     B2\n+         *       \\(1.0.0)\n+         *        C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+        dependenciesA_1_x.put(componentB2, \">1.0\");\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \"1.0.0\");\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        ComponentMetadata componentB2_1_2_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_2_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_2_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_0_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1), any(), anyString()))\n+                .thenReturn(componentC1_1_0_0);\n+\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(componentA), Collections\n+                .singletonList(\n+                        new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+\n+        List<ComponentIdentifier> result = dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics);\n+\n+        assertThat(result.size(), is(4));\n+        assertThat(result, containsInAnyOrder(new ComponentIdentifier(componentA, v1_0_0),\n+                new ComponentIdentifier(componentB1, v1_0_0), new ComponentIdentifier(componentB2, v1_2_0),\n+                new ComponentIdentifier(componentC1, v1_0_0)));\n+    }\n+\n+    @Test\n+    void GIVEN_component_A_B2_WHEN_dependencies_overlap_THEN_satisfy_both() throws Exception {\n+        /*\n+         *             group1\n+         *    (1.0.0)/      \\(1.1.0)\n+         *          A       B2\n+         *  (1.0.0)/       /\n+         *        B1      /\n+         * (>1.0.0)\\     /(<=1.1.0)\n+         *           C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \">1.0.0\");\n+\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        Map<String, String> dependenciesB2_1_x = new HashMap<>();\n+        dependenciesB2_1_x.put(componentC1, \"<=1.1.0\");\n+\n+        ComponentMetadata componentB2_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_1_0), dependenciesB2_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_1_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC_1_5_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_5_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1),\n+                eq(Collections.singletonMap(componentB1, Requirement.buildNPM(\">1.0.0\"))), anyString()))\n+                .thenReturn(componentC_1_5_0);\n+        ComponentMetadata componentC_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_1_0), Collections.emptyMap());\n+        Map<String, Requirement> versionRequirementMap = new HashMap<>();\n+        versionRequirementMap.put(componentB1, Requirement.buildNPM(\">1.0.0\"));\n+        versionRequirementMap.put(componentB2, Requirement.buildNPM(\"<=1.1.0\"));\n+        when(componentManager.resolveComponentVersion(eq(componentC1), eq(versionRequirementMap), anyString()))\n+                .thenReturn(componentC_1_1_0);\n+\n+        // top-level package order: A, B2\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(componentA, componentB2),\n+                Arrays.asList(new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>()),\n+                        new DeploymentPackageConfiguration(componentB2, true, v1_1_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentB2)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+        List<ComponentIdentifier> result = dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics);\n+\n+        assertThat(result.size(), is(4));\n+        assertThat(result, containsInAnyOrder(new ComponentIdentifier(componentA, v1_0_0),\n+                new ComponentIdentifier(componentB1, v1_0_0), new ComponentIdentifier(componentB2, v1_1_0),\n+                new ComponentIdentifier(componentC1, v1_1_0)));\n+        ArgumentCaptor<String> componentNameCaptor = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<Map<String, Requirement>> versionRequirementsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(componentManager, times(5))\n+                .resolveComponentVersion(componentNameCaptor.capture(), versionRequirementsCaptor.capture(),\n+                        eq(\"mockJob1\"));\n+        List<String> componentNameList = componentNameCaptor.getAllValues();\n+        assertThat(componentNameList, contains(\"A\", \"B1\", \"C1\", \"B2\", \"C1\"));\n+        List<Map<String, Requirement>> versionRequirementsList = versionRequirementsCaptor.getAllValues();\n+        assertThat(versionRequirementsList.size(), is(5));\n+        Map<String, Requirement> versionRequirements = versionRequirementsList.get(2);\n+        assertThat(versionRequirements.size(), is(1));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B1\", Requirement.buildNPM(\">1.0.0\")));\n+        versionRequirements = versionRequirementsList.get(4);\n+        assertThat(versionRequirements.size(), is(2));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B1\", Requirement.buildNPM(\">1.0.0\")));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B2\", Requirement.buildNPM(\"<=1.1.0\")));\n+    }\n+\n+    @Test\n+    void GIVEN_component_A_B2_WHEN_dependencies_conflict_THEN_throws_no_available_version_error() throws Exception {\n+        /*\n+         *             group1\n+         *    (1.0.0)/      \\(1.1.0)\n+         *          A       B2\n+         *  (1.0.0)/       /\n+         *        B1      /\n+         * (<=1.1.0)\\    /(>=1.2.0)\n+         *           C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \"<=1.1.0\");\n+\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        Map<String, String> dependenciesB2_1_x = new HashMap<>();\n+        dependenciesB2_1_x.put(componentC1, \">=1.2.0\");\n+\n+        ComponentMetadata componentB2_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_1_0), dependenciesB2_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_1_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_1_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1),\n+                eq(Collections.singletonMap(componentB1, Requirement.buildNPM(\"<=1.1.0\"))), anyString()))\n+                .thenReturn(componentC_1_1_0);\n+        Map<String, Requirement> versionRequirements = new HashMap<>();\n+        versionRequirements.put(componentB1, Requirement.buildNPM(\"<=1.1.0\"));\n+        versionRequirements.put(componentB2, Requirement.buildNPM(\">=1.2.0\"));\n+        when(componentManager.resolveComponentVersion(eq(componentC1), eq(versionRequirements), anyString()))\n+                .thenThrow(NoAvailableComponentVersionException.class);\n+\n+        // top-level package order: A, B2\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(componentA, componentB2),\n+                Arrays.asList(new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>()),\n+                        new DeploymentPackageConfiguration(componentB2, true, v1_1_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentB2)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+        assertThrows(NoAvailableComponentVersionException.class,\n+                () -> dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics));\n     }\n \n-    @Nested\n-    class ResolveDependenciesTest {\n-        private final Semver v1_2_0 = new Semver(\"1.2.0\");\n-        private final Semver v1_1_0 = new Semver(\"1.1.0\");\n-        private final Semver v1_0_0 = new Semver(\"1.0.0\");\n-        private static final String pkgA = \"A\";\n-        private static final String pkgB1 = \"B1\";\n-        private static final String pkgB2 = \"B2\";\n-        private static final String pkgC1 = \"C1\";\n-\n-        @Test\n-        void GIVEN_package_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_versions()\n-                throws ComponentVersionConflictException, IOException, PackagingException {\n-\n-            /*\n-             *      main\n-             *         \\(1.0.0)\n-             *          A\n-             * (1.0.0)/   \\(>1.0)\n-             *      B1     B2\n-             *       \\(1.0.0)\n-             *        C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-            dependenciesA_1_x.put(pkgB2, \">1.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            // B2 has both 1.1.0 and 1.2.0 satisfying >1.0\n-            // expected to pick 1.1.0\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), Collections.emptyMap());\n-            ComponentMetadata packageB2_1_2_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_2_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Arrays.asList(packageB2_1_1_0, packageB2_1_2_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_0_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(pkgA), Collections\n-                    .singletonList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-        }\n-\n-        @Test\n-        void GIVEN_package_A_B2_WHEN_dependencies_overlap_THEN_satisfy_both()\n-                throws ComponentVersionConflictException, IOException, PackagingException {\n-\n-            /*\n-             *             main\n-             *    (1.0.0)/      \\(1.0.0)\n-             *          A       B2\n-             *  (1.0.0)/       /\n-             *        B1      /\n-             * (<1.1.0)\\     /(>=1.0.0)\n-             *           C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"<1.1.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_0_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            // top-level package order: A, B2\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB2),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-            verify(mockComponentManager).listAvailablePackageMetadata(pkgC1, Requirement.buildNPM(\">=1.0.0 <1.1.0\"));\n-\n-            // top-level package order: B2, A\n-            // refresh iterator\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            doc = new DeploymentDocument(\"mockJob2\", Arrays.asList(pkgB2, pkgA),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-            verify(mockComponentManager).listAvailablePackageMetadata(pkgC1, Requirement.buildNPM(\">=1.0.0 <1.1.0\"));\n-\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-        }\n-\n-\n-        @Test\n-        void GIVEN_package_A_B2_WHEN_dependencies_conflict_THEN_throws_conflict_error()\n-                throws IOException, PackagingException {\n-\n-            /*\n-             *             main\n-             *    (1.0.0)/      \\(1.0.0)\n-             *          A       B2\n-             *  (1.0.0)/       /\n-             *        B1      /\n-             * (<1.0.0)\\     /(>1.1.0)\n-             *           C1\n-             */\n-\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"<1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">1.1.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            lenient().when(mockComponentManager\n-                    .listAvailablePackageMetadata(eq(pkgC1), eq(Requirement.buildNPM(\">1.1.0 <1.0.0\"))))\n-                    .thenReturn(Collections.emptyIterator());\n-\n-            // top-level package order: A, B2\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB2),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            Exception thrown = assertThrows(ComponentVersionConflictException.class,\n-                    () -> resolver.resolveDependencies(doc, groupToRootPackagesTopics));\n-            assertThat(thrown.getMessage(), containsString(\"C1\"));\n-            assertThat(thrown.getMessage(), containsString(\"{B2-v1.1.0=>1.1.0, B1-v1.0.0=<1.0.0}\"));\n-\n-\n-            // top-level package order: B2, A\n-            // refresh iterator for A B1 and B2\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_2_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_2_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), eq(Requirement.buildNPM(\">1.1.0\"))))\n-                    .thenReturn(Collections.singletonList(packageC_1_2_0).iterator());\n-\n-            DeploymentDocument doc2 = new DeploymentDocument(\"mockJob2\", Arrays.asList(pkgB2, pkgA),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-            thrown = assertThrows(ComponentVersionConflictException.class,\n-                    () -> resolver.resolveDependencies(doc2, groupToRootPackagesTopics));\n-            assertEquals(\"Package version C1-v1.2.0 does not satisfy requirements of B1-v1.0.0, which is: <1.0.0\",\n-                    thrown.getMessage());\n-        }\n-\n-\n-        @Test\n-        void GIVEN_active_packages_WHEN_merge_in_packages_THEN_add_or_update_or_keep_or_delete_accordingly()\n-                throws IOException, PackagingException, ComponentVersionConflictException {\n-\n-            /*\n-             * (add) A    (update) B1   (keep) B2   (delete) D\n-             *         \\        |        |         /\n-             *                  (update) C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgC1, \">=1.0.0\");\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_0 = new HashMap<>();\n-            dependenciesB1_1_0.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_1_0), dependenciesB1_1_0);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_0_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_1_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_1_0).iterator());\n-\n-            // New deployment: A, B1\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB1),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB1, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgB1)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup2\" ,pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-\n-            // DA gives A, B1, B2 as root packages, meaning B2 is a root package for another group\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_1_0),\n-                            new ComponentIdentifier(pkgB2, v1_0_0), new ComponentIdentifier(pkgC1, v1_1_0)));\n-        }\n+    @Test\n+    void GIVEN_other_group_have_same_dependency_WHEN_deploy_current_group_THEN_resolve_dependency_version()\n+            throws Exception {\n+        /*\n+         *             group1            group2\n+         *    (1.0.0)/      \\(1.1.0)      / (2.0.0)\n+         *          A       B2           X\n+         *  (1.0.0)/        /           /\n+         *        B1       /(<=1.2.0) / (>=1.0.0)\n+         * (>=1.1.0)\\     /         /\n+         *                C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 690}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13cb54fccbcd1f61ee24c2cd2c0b6840c6cb26d5", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/13cb54fccbcd1f61ee24c2cd2c0b6840c6cb26d5", "committedDate": "2020-10-02T01:03:59Z", "message": "swallow no component in cloud exception to keep backward compatible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17e572f1f0e6524a39ee4f6f23d27d49204f14b2", "author": {"user": {"login": "wikimonkey", "name": "Jason Wang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/17e572f1f0e6524a39ee4f6f23d27d49204f14b2", "committedDate": "2020-10-02T05:09:43Z", "message": "fix some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzE3Njc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#pullrequestreview-501317675", "createdAt": "2020-10-02T17:26:44Z", "commit": {"oid": "17e572f1f0e6524a39ee4f6f23d27d49204f14b2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMzQ5Mjc4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#pullrequestreview-501349278", "createdAt": "2020-10-02T18:14:33Z", "commit": {"oid": "17e572f1f0e6524a39ee4f6f23d27d49204f14b2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3068, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}