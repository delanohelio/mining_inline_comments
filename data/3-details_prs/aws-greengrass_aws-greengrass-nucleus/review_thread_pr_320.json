{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxNTAxMDcy", "number": 320, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjozOTowNFrOEQSISg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTo1ODo1MVrOETAyiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTA5NzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjozOTowNFrOG0WZmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjozOTowNFrOG0WZmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU0NjEzNw==", "bodyText": "May be we should not convert it to string, as it could be used by other clients which might just want to deal with bytes.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r457546137", "createdAt": "2020-07-20T16:39:04Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "diffHunk": "@@ -95,34 +96,37 @@ public void onResponseHeaders(HttpStream httpStream, int i, int i1, HttpHeader[]\n             @Override\n             public int onResponseBody(HttpStream stream, byte[] bodyBytes) {\n                 responseBody.append(new String(bodyBytes, StandardCharsets.UTF_8));\n+                response.setResponseBody(responseBody.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b160fe64572b1f67b23886a4d31abba7a7c6da3"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTEwNDk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/iot/model/IotCloudResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjo0MTowM1rOG0WeZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjo0MTowM1rOG0WeZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU0NzM2Ng==", "bodyText": "Do you want to use @Data here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r457547366", "createdAt": "2020-07-20T16:41:03Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/iot/model/IotCloudResponse.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.aws.iot.evergreen.iot.model;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.Setter;\n+\n+@Getter\n+@NoArgsConstructor\n+@AllArgsConstructor\n+@Setter\n+public class IotCloudResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b160fe64572b1f67b23886a4d31abba7a7c6da3"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTc3MDg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzozOTo1NlrOG1C2xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzozOTo1NlrOG1C2xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3NDUwMw==", "bodyText": "I think this method might get called multiple times, you cannot assume that its only called once.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r458274503", "createdAt": "2020-07-21T17:39:56Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "diffHunk": "@@ -95,8 +95,7 @@ public void onResponseHeaders(HttpStream httpStream, int i, int i1, HttpHeader[]\n \n             @Override\n             public int onResponseBody(HttpStream stream, byte[] bodyBytes) {\n-                responseBody.append(new String(bodyBytes, StandardCharsets.UTF_8));\n-                response.setResponseBody(responseBody.toString());\n+                response.setResponseBody(bodyBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7e970c1838b3bdccb8e35d3f94c054b9fd0012d"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTc3MjY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0MDoyNVrOG1C35w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNzo0MDoyNVrOG1C35w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3NDc5MQ==", "bodyText": "Great. Thanks for adding this.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r458274791", "createdAt": "2020-07-21T17:40:25Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "diffHunk": "@@ -55,16 +59,12 @@ public IotCloudResponse sendHttpRequest(final IotConnectionManager connManager,\n         final HttpRequestBodyStream httpRequestBodyStream = body == null ? null : createHttpRequestBodyStream(body);\n         final HttpRequest request = new HttpRequest(verb, path, headers, httpRequestBodyStream);\n \n-        IotCloudResponse response;\n         try (HttpClientConnection conn = connManager.getConnection()) {\n-            // TODO: Make it exponential backoff, create backoff util for common use.\n-            int numAttempts = 0;\n-            do {\n-                numAttempts++;\n-                response = getHttpResponse(conn, request);\n-            } while (numAttempts < 1);\n+            BaseRetryableAccessor accessor = new BaseRetryableAccessor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7e970c1838b3bdccb8e35d3f94c054b9fd0012d"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzA0OTUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMzo1NDoxOFrOG3AjTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwMToyNDoxMVrOG35NvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzMzkwMQ==", "bodyText": "Is there a reason to introduce byte array separately and not part of IotCloudResponse ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r460333901", "createdAt": "2020-07-24T23:54:18Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "diffHunk": "@@ -83,7 +86,8 @@ public boolean resetPosition() {\n \n     private HttpStreamResponseHandler createResponseHandler(CompletableFuture<Integer> reqCompleted,\n                                                             Map<String, String> responseHeaders,\n-                                                            StringBuilder responseBody) {\n+                                                            ByteArrayOutputStream responseByteArray,\n+                                                            IotCloudResponse response) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI2MjI2OQ==", "bodyText": "I was using the ByteArrayOurputStream in the same way as StringBuilder to build the response byte array. I can remove the argument and do the concatenation inside onResponseBody()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r461262269", "createdAt": "2020-07-28T01:24:11Z", "author": {"login": "youtuyy"}, "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "diffHunk": "@@ -83,7 +86,8 @@ public boolean resetPosition() {\n \n     private HttpStreamResponseHandler createResponseHandler(CompletableFuture<Integer> reqCompleted,\n                                                             Map<String, String> responseHeaders,\n-                                                            StringBuilder responseBody) {\n+                                                            ByteArrayOutputStream responseByteArray,\n+                                                            IotCloudResponse response) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzMzkwMQ=="}, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzA2Njg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMDowNzozMlrOG3Aspg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODowNjoxN1rOG4Ya6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzNjI5NA==", "bodyText": "We also need to cover the case when lets say role alias is invalid, then we will receive a response with 200, but response will be error from cloud like \"role alias is invalid\"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r460336294", "createdAt": "2020-07-25T00:07:32Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -92,45 +97,61 @@ public void handle(final HttpExchange exchange) throws IOException {\n             response = tesCache.get(iotCredentialsPath).credentials;\n             return response;\n         }\n-        \n+\n+        // Get new credentials from cloud\n+        LOGGER.info(\"IAM credentials not found in cache or already expired. Fetching new ones from TES\");\n         Instant newExpiry = tesCache.get(iotCredentialsPath).expiry;\n \n         try {\n-            final String credentials = iotCloudHelper.sendHttpRequest(iotConnectionManager,\n-                    iotCredentialsPath,\n-                    IOT_CREDENTIALS_HTTP_VERB, null);\n-\n-            try {\n-                response = translateToAwsSdkFormat(credentials);\n-                String expiryString = parseExpiryFromResponse(credentials);\n-                Instant expiry = Instant.parse(expiryString);\n-\n-                if (expiry.isBefore(Instant.now(clock))) {\n-                    String responseString = \"TES responded with expired credentials: \" + credentials;\n-                    response = responseString.getBytes(StandardCharsets.UTF_8);\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n-                    LOGGER.error(\"Unable to cache expired credentials which expired at {}\", expiry.toString());\n-                } else {\n-                    newExpiry = expiry.minus(Duration.ofMinutes(TIME_BEFORE_CACHE_EXPIRE_IN_MIN));\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_OK;\n-\n-                    if (newExpiry.isBefore(Instant.now(clock))) {\n-                        LOGGER.warn(\"Can't cache credentials as new credentials {} will expire in less than {} minutes\",\n-                                expiry.toString(),\n-                                TIME_BEFORE_CACHE_EXPIRE_IN_MIN);\n+            final IotCloudResponse cloudResponse = iotCloudHelper\n+                    .sendHttpRequest(iotConnectionManager, iotCredentialsPath, IOT_CREDENTIALS_HTTP_VERB, null);\n+            final String credentials = cloudResponse.toString();\n+            final int cloudResponseCode = cloudResponse.getStatusCode();\n+\n+            if (cloudResponseCode == 0) {\n+                // Client errors should expire immediately\n+                String responseString = \"Failed to get credentials from TES\";\n+                response = responseString.getBytes(StandardCharsets.UTF_8);\n+                newExpiry = Instant.now(clock);\n+                tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+            } else if (cloudResponseCode == HttpURLConnection.HTTP_OK) {\n+                // Get response successfully, cache credentials according to expiry in response\n+                try {\n+                    response = translateToAwsSdkFormat(credentials);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI2MjI0OQ==", "bodyText": "In which case will we receive 200 and error from the cloud? I'm getting \"access denied (403)\" when using a wrong role-alias in the request url", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r461262249", "createdAt": "2020-07-28T01:24:07Z", "author": {"login": "youtuyy"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -92,45 +97,61 @@ public void handle(final HttpExchange exchange) throws IOException {\n             response = tesCache.get(iotCredentialsPath).credentials;\n             return response;\n         }\n-        \n+\n+        // Get new credentials from cloud\n+        LOGGER.info(\"IAM credentials not found in cache or already expired. Fetching new ones from TES\");\n         Instant newExpiry = tesCache.get(iotCredentialsPath).expiry;\n \n         try {\n-            final String credentials = iotCloudHelper.sendHttpRequest(iotConnectionManager,\n-                    iotCredentialsPath,\n-                    IOT_CREDENTIALS_HTTP_VERB, null);\n-\n-            try {\n-                response = translateToAwsSdkFormat(credentials);\n-                String expiryString = parseExpiryFromResponse(credentials);\n-                Instant expiry = Instant.parse(expiryString);\n-\n-                if (expiry.isBefore(Instant.now(clock))) {\n-                    String responseString = \"TES responded with expired credentials: \" + credentials;\n-                    response = responseString.getBytes(StandardCharsets.UTF_8);\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n-                    LOGGER.error(\"Unable to cache expired credentials which expired at {}\", expiry.toString());\n-                } else {\n-                    newExpiry = expiry.minus(Duration.ofMinutes(TIME_BEFORE_CACHE_EXPIRE_IN_MIN));\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_OK;\n-\n-                    if (newExpiry.isBefore(Instant.now(clock))) {\n-                        LOGGER.warn(\"Can't cache credentials as new credentials {} will expire in less than {} minutes\",\n-                                expiry.toString(),\n-                                TIME_BEFORE_CACHE_EXPIRE_IN_MIN);\n+            final IotCloudResponse cloudResponse = iotCloudHelper\n+                    .sendHttpRequest(iotConnectionManager, iotCredentialsPath, IOT_CREDENTIALS_HTTP_VERB, null);\n+            final String credentials = cloudResponse.toString();\n+            final int cloudResponseCode = cloudResponse.getStatusCode();\n+\n+            if (cloudResponseCode == 0) {\n+                // Client errors should expire immediately\n+                String responseString = \"Failed to get credentials from TES\";\n+                response = responseString.getBytes(StandardCharsets.UTF_8);\n+                newExpiry = Instant.now(clock);\n+                tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+            } else if (cloudResponseCode == HttpURLConnection.HTTP_OK) {\n+                // Get response successfully, cache credentials according to expiry in response\n+                try {\n+                    response = translateToAwsSdkFormat(credentials);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzNjI5NA=="}, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3MzU0Nw==", "bodyText": "My bad. I was trying to give an example. But you are right, status code will let us catch any errors.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r461773547", "createdAt": "2020-07-28T18:06:17Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -92,45 +97,61 @@ public void handle(final HttpExchange exchange) throws IOException {\n             response = tesCache.get(iotCredentialsPath).credentials;\n             return response;\n         }\n-        \n+\n+        // Get new credentials from cloud\n+        LOGGER.info(\"IAM credentials not found in cache or already expired. Fetching new ones from TES\");\n         Instant newExpiry = tesCache.get(iotCredentialsPath).expiry;\n \n         try {\n-            final String credentials = iotCloudHelper.sendHttpRequest(iotConnectionManager,\n-                    iotCredentialsPath,\n-                    IOT_CREDENTIALS_HTTP_VERB, null);\n-\n-            try {\n-                response = translateToAwsSdkFormat(credentials);\n-                String expiryString = parseExpiryFromResponse(credentials);\n-                Instant expiry = Instant.parse(expiryString);\n-\n-                if (expiry.isBefore(Instant.now(clock))) {\n-                    String responseString = \"TES responded with expired credentials: \" + credentials;\n-                    response = responseString.getBytes(StandardCharsets.UTF_8);\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n-                    LOGGER.error(\"Unable to cache expired credentials which expired at {}\", expiry.toString());\n-                } else {\n-                    newExpiry = expiry.minus(Duration.ofMinutes(TIME_BEFORE_CACHE_EXPIRE_IN_MIN));\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_OK;\n-\n-                    if (newExpiry.isBefore(Instant.now(clock))) {\n-                        LOGGER.warn(\"Can't cache credentials as new credentials {} will expire in less than {} minutes\",\n-                                expiry.toString(),\n-                                TIME_BEFORE_CACHE_EXPIRE_IN_MIN);\n+            final IotCloudResponse cloudResponse = iotCloudHelper\n+                    .sendHttpRequest(iotConnectionManager, iotCredentialsPath, IOT_CREDENTIALS_HTTP_VERB, null);\n+            final String credentials = cloudResponse.toString();\n+            final int cloudResponseCode = cloudResponse.getStatusCode();\n+\n+            if (cloudResponseCode == 0) {\n+                // Client errors should expire immediately\n+                String responseString = \"Failed to get credentials from TES\";\n+                response = responseString.getBytes(StandardCharsets.UTF_8);\n+                newExpiry = Instant.now(clock);\n+                tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+            } else if (cloudResponseCode == HttpURLConnection.HTTP_OK) {\n+                // Get response successfully, cache credentials according to expiry in response\n+                try {\n+                    response = translateToAwsSdkFormat(credentials);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzNjI5NA=="}, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzA2OTQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMDowOTozMlrOG3AuCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMDowOTozMlrOG3AuCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzNjY1MQ==", "bodyText": "nit:\nexpiryTime = UNKNOWN_ERROR_CACHE_IN_MIN;\nif (statusCode >= 400 && statusCode < 500) {\n    expiryTime = CLOUD_4XX_ERROR_CACHE_IN_MIN;\n} else if (statusCode >= 500 && statusCode < 600) {\n   expiryTime = CLOUD_5XX_ERROR_CACHE_IN_MIN;\n}\nreturn Instant.now(clock).plus(Duration.ofMinutes(expiryTime);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r460336651", "createdAt": "2020-07-25T00:09:32Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -166,7 +187,28 @@ private String parseExpiryFromResponse(final String credentials) throws AWSIotEx\n         }\n     }\n \n-    private boolean areCredentialsValid() {\n+    private Instant getExpiryPolicyForErr(int statusCode) {\n+        Instant t;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzA3NDUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMDoxMzozNVrOG3Awpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwMToyNDowMlrOG35NmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzNzMxOA==", "bodyText": "Lets increase the backoff time to may be 200ms? Does the retryer backs off exponentially? Then overall if it takes around 1-2 seconds to retry under no network conditions, thats ideal. We dont want to give up too early.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r460337318", "createdAt": "2020-07-25T00:13:35Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "diffHunk": "@@ -36,6 +41,8 @@\n     // TODO: revisit all timeout values\n     // Max wait time for device to receive HTTP response from IOT CLOUD\n     private static final long TIMEOUT_FOR_RESPONSE_FROM_IOT_CLOUD_SECONDS = (long) Duration.ofSeconds(30).getSeconds();\n+    private static final int RETRY_COUNT = 3;\n+    private static final int BACKOFF_MILLIS = 100;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI2MjIzMg==", "bodyText": "There is no exponential back off. 200 sounds good", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r461262232", "createdAt": "2020-07-28T01:24:02Z", "author": {"login": "youtuyy"}, "path": "src/main/java/com/aws/iot/evergreen/iot/IotCloudHelper.java", "diffHunk": "@@ -36,6 +41,8 @@\n     // TODO: revisit all timeout values\n     // Max wait time for device to receive HTTP response from IOT CLOUD\n     private static final long TIMEOUT_FOR_RESPONSE_FROM_IOT_CLOUD_SECONDS = (long) Duration.ofSeconds(30).getSeconds();\n+    private static final int RETRY_COUNT = 3;\n+    private static final int BACKOFF_MILLIS = 100;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzNzMxOA=="}, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzA3NjI0OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/tes/CredentialRequestHandlerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMDoxNTowNVrOG3Axlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMDoxNTowNVrOG3Axlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzNzU1OQ==", "bodyText": "Lets add a test case, when Iot cloud returns a response like \"role not found\" with a 200.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r460337559", "createdAt": "2020-07-25T00:15:05Z", "author": {"login": "prateek-y"}, "path": "src/test/java/com/aws/iot/evergreen/tes/CredentialRequestHandlerTest.java", "diffHunk": "@@ -171,4 +175,100 @@ public void GIVEN_unparsable_response_WHEN_called_handle_THEN_returns_error(\n         verify(mockStream, times(1)).write(expectedReponse);\n         mockStream.close();\n     }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void GIVEN_no_response_code_WHEN_called_handle_THEN_expire_immediately() throws Exception {\n+        String responseStr = \"\";\n+        IotCloudResponse mockResponse = new IotCloudResponse(responseStr.getBytes(StandardCharsets.UTF_8), 0);\n+        when(mockCloudHelper.sendHttpRequest(any(), any(), any(), any())).thenReturn(mockResponse);\n+        CredentialRequestHandler handler =\n+                new CredentialRequestHandler(ROLE_ALIAS, mockCloudHelper, mockConnectionManager);\n+        HttpExchange mockExchange = mock(HttpExchange.class);\n+        OutputStream mockStream = mock(OutputStream.class);\n+        when(mockExchange.getResponseBody()).thenReturn(mockStream);\n+        handler.handle(mockExchange);\n+        byte[] expectedResponse = \"Failed to get credentials from TES\".getBytes();\n+        int expectedStatus = 500;\n+        // expire immediately\n+        assertFalse(handler.areCredentialsValid());\n+        verify(mockExchange, times(1)).sendResponseHeaders(expectedStatus, expectedResponse.length);\n+        verify(mockStream, times(1)).write(expectedResponse);\n+        mockStream.close();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"PMD.CloseResource\")\n+    public void GIVEN_4xx_response_code_WHEN_called_handle_THEN_expire_in_2_minutes() throws Exception {\n+        byte[] response = {};\n+        IotCloudResponse mockResponse = new IotCloudResponse(response, 400);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b27d0b7053ad7fc3b17ca2448920c6080a683c49"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MzcxMzM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTo1ODo1MVrOG4gy3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMzozODowOFrOG4jbAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkxMDc0OA==", "bodyText": "Could you add a test for this case too?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r461910748", "createdAt": "2020-07-28T21:58:51Z", "author": {"login": "popanmol"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -82,55 +86,77 @@ public void handle(final HttpExchange exchange) throws IOException {\n \n     /**\n      * API for kernel to directly fetch credentials from TES instead of using HTTP server.\n+     *\n      * @return AWS credentials from cloud.\n      */\n     public byte[] getCredentials() {\n-        byte[] response = {};\n+        byte[] response;\n         LOGGER.debug(\"Got request for credentials\");\n \n         if (areCredentialsValid()) {\n             response = tesCache.get(iotCredentialsPath).credentials;\n             return response;\n         }\n-        \n+\n+        // Get new credentials from cloud\n+        LOGGER.info(\"IAM credentials not found in cache or already expired. Fetching new ones from TES\");\n         Instant newExpiry = tesCache.get(iotCredentialsPath).expiry;\n \n         try {\n-            final String credentials = iotCloudHelper.sendHttpRequest(iotConnectionManager,\n-                    iotCredentialsPath,\n-                    IOT_CREDENTIALS_HTTP_VERB, null);\n-\n-            try {\n-                response = translateToAwsSdkFormat(credentials);\n-                String expiryString = parseExpiryFromResponse(credentials);\n-                Instant expiry = Instant.parse(expiryString);\n-\n-                if (expiry.isBefore(Instant.now(clock))) {\n-                    String responseString = \"TES responded with expired credentials: \" + credentials;\n-                    response = responseString.getBytes(StandardCharsets.UTF_8);\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n-                    LOGGER.error(\"Unable to cache expired credentials which expired at {}\", expiry.toString());\n-                } else {\n-                    newExpiry = expiry.minus(Duration.ofMinutes(TIME_BEFORE_CACHE_EXPIRE_IN_MIN));\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_OK;\n-\n-                    if (newExpiry.isBefore(Instant.now(clock))) {\n-                        LOGGER.warn(\"Can't cache credentials as new credentials {} will expire in less than {} minutes\",\n-                                expiry.toString(),\n-                                TIME_BEFORE_CACHE_EXPIRE_IN_MIN);\n+            final IotCloudResponse cloudResponse = iotCloudHelper\n+                    .sendHttpRequest(iotConnectionManager, iotCredentialsPath, IOT_CREDENTIALS_HTTP_VERB, null);\n+            final String credentials = cloudResponse.toString();\n+            final int cloudResponseCode = cloudResponse.getStatusCode();\n+\n+            if (cloudResponseCode == 0) {\n+                // Client errors should expire immediately\n+                String responseString = \"Failed to get credentials from TES\";\n+                response = responseString.getBytes(StandardCharsets.UTF_8);\n+                newExpiry = Instant.now(clock);\n+                tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+            } else if (cloudResponseCode == HttpURLConnection.HTTP_OK) {\n+                // Get response successfully, cache credentials according to expiry in response\n+                try {\n+                    response = translateToAwsSdkFormat(credentials);\n+                    String expiryString = parseExpiryFromResponse(credentials);\n+                    Instant expiry = Instant.parse(expiryString);\n+\n+                    if (expiry.isBefore(Instant.now(clock))) {\n+                        String responseString = \"TES responded with expired credentials: \" + credentials;\n+                        response = responseString.getBytes(StandardCharsets.UTF_8);\n+                        tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+                        LOGGER.error(\"Unable to cache expired credentials which expired at {}\", expiry.toString());\n                     } else {\n-                        LOGGER.info(\"Received IAM credentials that will be cached until {}\", newExpiry.toString());\n+                        newExpiry = expiry.minus(Duration.ofMinutes(TIME_BEFORE_CACHE_EXPIRE_IN_MIN));\n+                        tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_OK;\n+\n+                        if (newExpiry.isBefore(Instant.now(clock))) {\n+                            LOGGER.warn(\n+                                    \"Can't cache credentials as new credentials {} will expire in less than {} minutes\",\n+                                    expiry.toString(), TIME_BEFORE_CACHE_EXPIRE_IN_MIN);\n+                        } else {\n+                            LOGGER.info(\"Received IAM credentials that will be cached until {}\", newExpiry.toString());\n+                        }\n                     }\n+                } catch (AWSIotException e) {\n+                    String responseString = \"Bad TES response: \" + credentials;\n+                    response = responseString.getBytes(StandardCharsets.UTF_8);\n+                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+                    LOGGER.error(\"Unable to parse response body\", e);\n                 }\n-            } catch (AWSIotException e) {\n-                String responseString = \"Bad TES response: \" + credentials;\n+            } else {\n+                // Cloud errors should be cached\n+                String responseString =\n+                        String.format(\"TES responded with status code: %d\", cloudResponseCode, credentials);\n                 response = responseString.getBytes(StandardCharsets.UTF_8);\n-                tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n-                LOGGER.error(\"Unable to parse response body\", e);\n+                newExpiry = getExpiryPolicyForErr(cloudResponseCode);\n+                tesCache.get(iotCredentialsPath).responseCode = cloudResponseCode;\n             }\n-\n         } catch (AWSIotException e) {\n-            // TODO: Generate 4xx, 5xx responses for all error scenarios\n+            // Http connection error", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557aab3dd39069ff36d49199499901112bc0395"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1Mzc5Mw==", "bodyText": "added", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/320#discussion_r461953793", "createdAt": "2020-07-28T23:38:08Z", "author": {"login": "youtuyy"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -82,55 +86,77 @@ public void handle(final HttpExchange exchange) throws IOException {\n \n     /**\n      * API for kernel to directly fetch credentials from TES instead of using HTTP server.\n+     *\n      * @return AWS credentials from cloud.\n      */\n     public byte[] getCredentials() {\n-        byte[] response = {};\n+        byte[] response;\n         LOGGER.debug(\"Got request for credentials\");\n \n         if (areCredentialsValid()) {\n             response = tesCache.get(iotCredentialsPath).credentials;\n             return response;\n         }\n-        \n+\n+        // Get new credentials from cloud\n+        LOGGER.info(\"IAM credentials not found in cache or already expired. Fetching new ones from TES\");\n         Instant newExpiry = tesCache.get(iotCredentialsPath).expiry;\n \n         try {\n-            final String credentials = iotCloudHelper.sendHttpRequest(iotConnectionManager,\n-                    iotCredentialsPath,\n-                    IOT_CREDENTIALS_HTTP_VERB, null);\n-\n-            try {\n-                response = translateToAwsSdkFormat(credentials);\n-                String expiryString = parseExpiryFromResponse(credentials);\n-                Instant expiry = Instant.parse(expiryString);\n-\n-                if (expiry.isBefore(Instant.now(clock))) {\n-                    String responseString = \"TES responded with expired credentials: \" + credentials;\n-                    response = responseString.getBytes(StandardCharsets.UTF_8);\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n-                    LOGGER.error(\"Unable to cache expired credentials which expired at {}\", expiry.toString());\n-                } else {\n-                    newExpiry = expiry.minus(Duration.ofMinutes(TIME_BEFORE_CACHE_EXPIRE_IN_MIN));\n-                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_OK;\n-\n-                    if (newExpiry.isBefore(Instant.now(clock))) {\n-                        LOGGER.warn(\"Can't cache credentials as new credentials {} will expire in less than {} minutes\",\n-                                expiry.toString(),\n-                                TIME_BEFORE_CACHE_EXPIRE_IN_MIN);\n+            final IotCloudResponse cloudResponse = iotCloudHelper\n+                    .sendHttpRequest(iotConnectionManager, iotCredentialsPath, IOT_CREDENTIALS_HTTP_VERB, null);\n+            final String credentials = cloudResponse.toString();\n+            final int cloudResponseCode = cloudResponse.getStatusCode();\n+\n+            if (cloudResponseCode == 0) {\n+                // Client errors should expire immediately\n+                String responseString = \"Failed to get credentials from TES\";\n+                response = responseString.getBytes(StandardCharsets.UTF_8);\n+                newExpiry = Instant.now(clock);\n+                tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+            } else if (cloudResponseCode == HttpURLConnection.HTTP_OK) {\n+                // Get response successfully, cache credentials according to expiry in response\n+                try {\n+                    response = translateToAwsSdkFormat(credentials);\n+                    String expiryString = parseExpiryFromResponse(credentials);\n+                    Instant expiry = Instant.parse(expiryString);\n+\n+                    if (expiry.isBefore(Instant.now(clock))) {\n+                        String responseString = \"TES responded with expired credentials: \" + credentials;\n+                        response = responseString.getBytes(StandardCharsets.UTF_8);\n+                        tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+                        LOGGER.error(\"Unable to cache expired credentials which expired at {}\", expiry.toString());\n                     } else {\n-                        LOGGER.info(\"Received IAM credentials that will be cached until {}\", newExpiry.toString());\n+                        newExpiry = expiry.minus(Duration.ofMinutes(TIME_BEFORE_CACHE_EXPIRE_IN_MIN));\n+                        tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_OK;\n+\n+                        if (newExpiry.isBefore(Instant.now(clock))) {\n+                            LOGGER.warn(\n+                                    \"Can't cache credentials as new credentials {} will expire in less than {} minutes\",\n+                                    expiry.toString(), TIME_BEFORE_CACHE_EXPIRE_IN_MIN);\n+                        } else {\n+                            LOGGER.info(\"Received IAM credentials that will be cached until {}\", newExpiry.toString());\n+                        }\n                     }\n+                } catch (AWSIotException e) {\n+                    String responseString = \"Bad TES response: \" + credentials;\n+                    response = responseString.getBytes(StandardCharsets.UTF_8);\n+                    tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n+                    LOGGER.error(\"Unable to parse response body\", e);\n                 }\n-            } catch (AWSIotException e) {\n-                String responseString = \"Bad TES response: \" + credentials;\n+            } else {\n+                // Cloud errors should be cached\n+                String responseString =\n+                        String.format(\"TES responded with status code: %d\", cloudResponseCode, credentials);\n                 response = responseString.getBytes(StandardCharsets.UTF_8);\n-                tesCache.get(iotCredentialsPath).responseCode = HttpURLConnection.HTTP_INTERNAL_ERROR;\n-                LOGGER.error(\"Unable to parse response body\", e);\n+                newExpiry = getExpiryPolicyForErr(cloudResponseCode);\n+                tesCache.get(iotCredentialsPath).responseCode = cloudResponseCode;\n             }\n-\n         } catch (AWSIotException e) {\n-            // TODO: Generate 4xx, 5xx responses for all error scenarios\n+            // Http connection error", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkxMDc0OA=="}, "originalCommit": {"oid": "3557aab3dd39069ff36d49199499901112bc0395"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4421, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}