{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTUyMDA3", "number": 302, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzozMjowM1rOENWyZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODo0MTowNFrOENYCPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDQwMjkyOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzozMjowM1rOGv_oXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDowMTo1MlrOGwEH4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3ODc4Mg==", "bodyText": "Is this toRollback() method needed? Can't the caller manage this on their own?\nBut still if we have to keep this method then toRollback is confusing name for the method. Maybe change this to getNewInstanceWithCurrentConfig(). We may be using this for rollback but as far as this class is concerned it is just getting an instance with current configuration values.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/302#discussion_r452978782", "createdAt": "2020-07-10T17:32:03Z", "author": {"login": "abanthiy"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentConfigMergerTest {\n+\n+    private final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @Test\n+    public void GIVEN_AggregateServicesChangeManager_WHEN_initialized_THEN_compute_service_to_add_or_remove() {\n+        Kernel kernel = mock(Kernel.class);\n+        Collection<EvergreenService> orderedDependencies = Arrays.asList(\n+                createMockEvergreenService(\"oldService\"),\n+                createMockEvergreenService(\"existingService\")\n+        );\n+        when(kernel.orderedDependencies()).thenReturn(orderedDependencies);\n+\n+        Map<String, Object> newConfig = new HashMap<>();\n+        newConfig.put(\"newService\", new Object());\n+        newConfig.put(\"existingService\", new Object());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager manager =\n+                new DeploymentConfigMerger.AggregateServicesChangeManager(kernel, newConfig);\n+\n+        assertEquals(newHashSet(\"newService\"), manager.getServicesToAdd());\n+        assertEquals(newHashSet(\"oldService\"), manager.getServicesToRemove());\n+        assertEquals(newHashSet(\"existingService\"), manager.getServicesToUpdate());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager toRollback = manager.toRollback();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf2188fff0669302f04d8df49e9d4408dd92e426"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1MjM4Nw==", "bodyText": "I rename it to createRollbackManager()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/302#discussion_r453052387", "createdAt": "2020-07-10T20:01:52Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentConfigMergerTest {\n+\n+    private final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @Test\n+    public void GIVEN_AggregateServicesChangeManager_WHEN_initialized_THEN_compute_service_to_add_or_remove() {\n+        Kernel kernel = mock(Kernel.class);\n+        Collection<EvergreenService> orderedDependencies = Arrays.asList(\n+                createMockEvergreenService(\"oldService\"),\n+                createMockEvergreenService(\"existingService\")\n+        );\n+        when(kernel.orderedDependencies()).thenReturn(orderedDependencies);\n+\n+        Map<String, Object> newConfig = new HashMap<>();\n+        newConfig.put(\"newService\", new Object());\n+        newConfig.put(\"existingService\", new Object());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager manager =\n+                new DeploymentConfigMerger.AggregateServicesChangeManager(kernel, newConfig);\n+\n+        assertEquals(newHashSet(\"newService\"), manager.getServicesToAdd());\n+        assertEquals(newHashSet(\"oldService\"), manager.getServicesToRemove());\n+        assertEquals(newHashSet(\"existingService\"), manager.getServicesToUpdate());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager toRollback = manager.toRollback();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3ODc4Mg=="}, "originalCommit": {"oid": "cf2188fff0669302f04d8df49e9d4408dd92e426"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDU5MTU3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODozNzoxNVrOGwBgMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNzowOTozNVrOGyHX2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwOTQ1Nw==", "bodyText": "You will be adding more tests for other methods in this class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/302#discussion_r453009457", "createdAt": "2020-07-10T18:37:15Z", "author": {"login": "abanthiy"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentConfigMergerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf2188fff0669302f04d8df49e9d4408dd92e426"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzMDI1Mg==", "bodyText": "Probably not. To test the rest of DeploymentConfigMerger need a lot of mock, while writing integ test will be much easier.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/302#discussion_r454630252", "createdAt": "2020-07-14T20:38:41Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentConfigMergerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwOTQ1Nw=="}, "originalCommit": {"oid": "cf2188fff0669302f04d8df49e9d4408dd92e426"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIwMjc3OQ==", "bodyText": "Integ tests and unit tests serve different purposes so ideally we should add unit tests for as much code as possible, but for this PR this is okay", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/302#discussion_r455202779", "createdAt": "2020-07-15T17:09:35Z", "author": {"login": "shaguptashaikh"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentConfigMergerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAwOTQ1Nw=="}, "originalCommit": {"oid": "cf2188fff0669302f04d8df49e9d4408dd92e426"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDYwNzM0OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxODo0MTowNFrOGwBqBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDowMToyNlrOGwEHFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxMTk3NA==", "bodyText": "Might be better to make wait time as a constant if we plan to use it in other tests as well.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/302#discussion_r453011974", "createdAt": "2020-07-10T18:41:04Z", "author": {"login": "abanthiy"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentConfigMergerTest {\n+\n+    private final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @Test\n+    public void GIVEN_AggregateServicesChangeManager_WHEN_initialized_THEN_compute_service_to_add_or_remove() {\n+        Kernel kernel = mock(Kernel.class);\n+        Collection<EvergreenService> orderedDependencies = Arrays.asList(\n+                createMockEvergreenService(\"oldService\"),\n+                createMockEvergreenService(\"existingService\")\n+        );\n+        when(kernel.orderedDependencies()).thenReturn(orderedDependencies);\n+\n+        Map<String, Object> newConfig = new HashMap<>();\n+        newConfig.put(\"newService\", new Object());\n+        newConfig.put(\"existingService\", new Object());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager manager =\n+                new DeploymentConfigMerger.AggregateServicesChangeManager(kernel, newConfig);\n+\n+        assertEquals(newHashSet(\"newService\"), manager.getServicesToAdd());\n+        assertEquals(newHashSet(\"oldService\"), manager.getServicesToRemove());\n+        assertEquals(newHashSet(\"existingService\"), manager.getServicesToUpdate());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager toRollback = manager.toRollback();\n+\n+        assertEquals(newHashSet(\"newService\"), toRollback.getServicesToRemove());\n+        assertEquals(newHashSet(\"oldService\"), toRollback.getServicesToAdd());\n+        assertEquals(newHashSet(\"existingService\"), toRollback.getServicesToUpdate());\n+    }\n+\n+    @Test\n+    public void GIVEN_waitForServicesToStart_WHEN_service_reached_desired_state_THEN_return_successfully() throws Exception {\n+        // GIVEN\n+        EvergreenService mockService = mock(EvergreenService.class);\n+        // service is in BROKEN state before merge\n+        when(mockService.getState()).thenReturn(State.BROKEN);\n+        when(mockService.getStateModTime()).thenReturn((long) 1);\n+        when(mockService.reachedDesiredState()).thenReturn(false);\n+        CountDownLatch serviceStarted = new CountDownLatch(1);\n+        new Thread(() -> {\n+            try {\n+                DeploymentConfigMerger.waitForServicesToStart(newHashSet(mockService), System.currentTimeMillis());\n+                serviceStarted.countDown();\n+            } catch (ServiceUpdateException | InterruptedException e) {\n+                logger.error(\"Fail in waitForServicesToStart\", e);\n+            }\n+        }).start();\n+\n+        Thread.sleep(2000);\n+        // assert waitForServicesToStart didn't finish\n+        assertEquals(1, serviceStarted.getCount());\n+\n+        // WHEN\n+        when(mockService.getState()).thenReturn(State.RUNNING);\n+        when(mockService.reachedDesiredState()).thenReturn(true);\n+\n+        // THEN\n+        assertTrue(serviceStarted.await(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf2188fff0669302f04d8df49e9d4408dd92e426"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1MjE4Mw==", "bodyText": "Sure. I have 2 seconds because the hard-coded polling interval is 1 second", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/302#discussion_r453052183", "createdAt": "2020-07-10T20:01:26Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentConfigMergerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DeploymentConfigMergerTest {\n+\n+    private final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @Test\n+    public void GIVEN_AggregateServicesChangeManager_WHEN_initialized_THEN_compute_service_to_add_or_remove() {\n+        Kernel kernel = mock(Kernel.class);\n+        Collection<EvergreenService> orderedDependencies = Arrays.asList(\n+                createMockEvergreenService(\"oldService\"),\n+                createMockEvergreenService(\"existingService\")\n+        );\n+        when(kernel.orderedDependencies()).thenReturn(orderedDependencies);\n+\n+        Map<String, Object> newConfig = new HashMap<>();\n+        newConfig.put(\"newService\", new Object());\n+        newConfig.put(\"existingService\", new Object());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager manager =\n+                new DeploymentConfigMerger.AggregateServicesChangeManager(kernel, newConfig);\n+\n+        assertEquals(newHashSet(\"newService\"), manager.getServicesToAdd());\n+        assertEquals(newHashSet(\"oldService\"), manager.getServicesToRemove());\n+        assertEquals(newHashSet(\"existingService\"), manager.getServicesToUpdate());\n+\n+        DeploymentConfigMerger.AggregateServicesChangeManager toRollback = manager.toRollback();\n+\n+        assertEquals(newHashSet(\"newService\"), toRollback.getServicesToRemove());\n+        assertEquals(newHashSet(\"oldService\"), toRollback.getServicesToAdd());\n+        assertEquals(newHashSet(\"existingService\"), toRollback.getServicesToUpdate());\n+    }\n+\n+    @Test\n+    public void GIVEN_waitForServicesToStart_WHEN_service_reached_desired_state_THEN_return_successfully() throws Exception {\n+        // GIVEN\n+        EvergreenService mockService = mock(EvergreenService.class);\n+        // service is in BROKEN state before merge\n+        when(mockService.getState()).thenReturn(State.BROKEN);\n+        when(mockService.getStateModTime()).thenReturn((long) 1);\n+        when(mockService.reachedDesiredState()).thenReturn(false);\n+        CountDownLatch serviceStarted = new CountDownLatch(1);\n+        new Thread(() -> {\n+            try {\n+                DeploymentConfigMerger.waitForServicesToStart(newHashSet(mockService), System.currentTimeMillis());\n+                serviceStarted.countDown();\n+            } catch (ServiceUpdateException | InterruptedException e) {\n+                logger.error(\"Fail in waitForServicesToStart\", e);\n+            }\n+        }).start();\n+\n+        Thread.sleep(2000);\n+        // assert waitForServicesToStart didn't finish\n+        assertEquals(1, serviceStarted.getCount());\n+\n+        // WHEN\n+        when(mockService.getState()).thenReturn(State.RUNNING);\n+        when(mockService.reachedDesiredState()).thenReturn(true);\n+\n+        // THEN\n+        assertTrue(serviceStarted.await(2, TimeUnit.SECONDS));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxMTk3NA=="}, "originalCommit": {"oid": "cf2188fff0669302f04d8df49e9d4408dd92e426"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4389, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}