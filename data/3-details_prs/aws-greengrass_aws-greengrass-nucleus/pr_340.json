{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5NTIzNTUy", "number": 340, "title": "Add initial AuthZ pub/sub integration", "bodyText": "Issue #, if available:\nDescription of changes:\nAdded a util to parse and create a List of AuthorizationPolicies from an AccessControl portion of the EG .yaml file.\nAdded UT for that method.\nAlso added changes to the PubSubService to register it with the AuthorizationHandler. The PubSubService now also loads the auth config during post-injection, and subscribes to further updates.\nWhy is this change necessary:\nThis is the first step towards having the PubSub service authorize pub/sub requests between EG components, building off of the initial AuthZ changes.\nHow was this change tested:\nAdded a handful of unit tests; will be adding more UT soon after initial feedback and then integration tests after.\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-07-30T19:21:52Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340", "merged": true, "mergeCommit": {"oid": "94a159152db184d2b70ed635056dbb0ded81bc60"}, "closed": true, "closedAt": "2020-08-11T04:43:09Z", "author": {"login": "avipinku"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6Exw-AFqTQ1ODY5MjcwMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9tXN6gH2gAyNDU5NTIzNTUyOmI2Zjc5Y2EzNzI0ZGRhOWJkZTA3MjE5NzQ3MmRlZThkMzg2NTE0MGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NjkyNzAy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458692702", "createdAt": "2020-07-30T19:27:40Z", "commit": {"oid": "f0ee2bf1b709f14d23d1a48ee24df3084ba83018"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxOToyNzo0MFrOG5wy1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxOToyNzo0MFrOG5wy1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyMTQ2Mw==", "bodyText": "you don't use this method. Get rid of it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463221463", "createdAt": "2020-07-30T19:27:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -17,4 +17,27 @@\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");\n+\n+        private final String name;\n+\n+        PolicyComponentTypes(String s) {\n+            name = s;\n+        }\n+\n+        public boolean equalsName(String otherName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0ee2bf1b709f14d23d1a48ee24df3084ba83018"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4NzE0OTEw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458714910", "createdAt": "2020-07-30T20:01:15Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "DISMISSED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDowMToxNVrOG5x23A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMDowMjoxN1rOG5x4yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzODg3Ng==", "bodyText": "pretty sure @Value has this already.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463238876", "createdAt": "2020-07-30T20:01:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "diffHunk": "@@ -4,11 +4,13 @@\n package com.aws.iot.evergreen.auth;\n \n import lombok.Builder;\n+import lombok.EqualsAndHashCode;\n import lombok.NonNull;\n import lombok.Value;\n \n @Builder\n @Value\n+@EqualsAndHashCode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTM2OQ==", "bodyText": "no * imports. setup your IDE to not do this.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463239369", "createdAt": "2020-07-30T20:02:17Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODYyMDQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458862046", "createdAt": "2020-07-31T01:19:28Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMToxOToyOFrOG55A7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMToxOToyOFrOG55A7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NjE0MA==", "bodyText": "I am not sure if we follow pascal case or camel case for the config fields? mostly it should be accessControl", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463356140", "createdAt": "2020-07-31T01:19:28Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODY2MTc4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458866178", "createdAt": "2020-07-31T01:34:26Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozNDoyNlrOG55Pkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozNDoyNlrOG55Pkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1OTg5MA==", "bodyText": "we would need to handle cases when some of the fields are not set by the customer.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463359890", "createdAt": "2020-07-31T01:34:26Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"AccessControl\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+\n+    /**\n+     * Given a Topics config object, construct and return a list of AuthorizationPolicy objects that may exist.\n+     * @param config Topics\n+     * @return List AuthorizationPolicy\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicy(Topics config) throws AuthorizationException {\n+\n+        Topics accessControlMap = config.findTopics(ACCESS_CONTROL_KEY);\n+        if (accessControlMap == null) {\n+            return null;\n+        }\n+\n+        ArrayList<AuthorizationPolicy> authorizationPolicyList = new ArrayList<>();\n+\n+        //Iterate through all policies\n+        for (Node policyObject : accessControlMap) {\n+\n+            //Initialize these components to null\n+            String policyDescription = null;\n+            Set<String> principals = null;\n+            Set<String> operations = null;\n+            Set<String> resources = null;\n+\n+            for (Node policyComponentNode : (Topics) policyObject) {\n+                //Iterate through the components of this policy\n+                Topic policyComponent = (Topic) policyComponentNode;\n+                PolicyComponentTypes policyComponentKey = toEnum(\n+                        PolicyComponentTypes.class,\n+                        policyComponentNode.getName(),\n+                        PolicyComponentTypes.INVALID_ENUM);\n+                switch (policyComponentKey) {\n+                    case POLICY_DESCRIPTION:\n+                        policyDescription = Coerce.toString(policyComponent);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODY2NDAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458866403", "createdAt": "2020-07-31T01:35:19Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozNToxOVrOG55Qtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozNToxOVrOG55Qtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDE4Mg==", "bodyText": "I am not sure if this should be Camel case or pascal case??", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360182", "createdAt": "2020-07-31T01:35:19Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -21,21 +26,29 @@\n import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n \n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.inject.Inject;\n \n //TODO: see if this needs to be a GGService\n-@ImplementsService(name = \"pubsubipc\", autostart = true)\n+@ImplementsService(name = \"pubsub\", autostart = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODY2NzYx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458866761", "createdAt": "2020-07-31T01:36:44Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozNjo0NVrOG55SDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozNjo0NVrOG55SDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MDUyNA==", "bodyText": "remove \"ipc\" from event type.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463360524", "createdAt": "2020-07-31T01:36:45Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -44,13 +57,47 @@ public PubSubIPCService(Topics c) {\n     public void postInject() {\n         BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.PUBSUB;\n         super.postInject();\n+\n+\n+        List<String> opCodes = Stream.of(PubSubClientOpCodes.values())\n+                .map(PubSubClientOpCodes::name)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+        try {\n+            authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n+            //Initialize auth config\n+            updateAuthConfig(this.config);\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"ipc-initialize-pubsub-authorization-error\").setCause(e)\n+                    .addKeyValue(DESTINATION_STRING, destination.name())\n+                    .log(\"Failed to initialize the Pub/Sub service with the Authorization module.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.config.subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    try {\n+                        //If there is a change in a node, reload the entire config\n+                        updateAuthConfig(this.config);\n+                    } catch (AuthorizationException e) {\n+                        logger.atError().setEventType(\"ipc-load-authorization-config-error\").setCause(e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODY3MzU2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458867356", "createdAt": "2020-07-31T01:39:00Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozOTowMFrOG55UCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozOTowMFrOG55UCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTAzMw==", "bodyText": "Any reason you just set the code and not create a PubSubGenericResponse object?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463361033", "createdAt": "2020-07-31T01:39:00Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -101,6 +151,9 @@ public void postInject() {\n             try {\n                 PubSubGenericResponse response =\n                         new PubSubGenericResponse(PubSubResponseStatus.InternalError, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODY3NTkz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458867593", "createdAt": "2020-07-31T01:39:53Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozOTo1M1rOG55U7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTozOTo1M1rOG55U7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTI2MA==", "bodyText": "We need to distinguish between the cases when policy is absent and its malformed, and atleast log informative error if its malformed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463361260", "createdAt": "2020-07-31T01:39:53Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -114,4 +167,23 @@ public void postInject() {\n         }\n         return fut;\n     }\n+\n+    private void updateAuthConfig(Topics config) throws AuthorizationException {\n+        List<AuthorizationPolicy> authorizationPolicyList = AuthorizationUtils\n+                .parseAuthorizationPolicy(config);\n+        if (authorizationPolicyList != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4ODY4MDE0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-458868014", "createdAt": "2020-07-31T01:41:23Z", "commit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTo0MToyNFrOG55WZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMTo0MToyNFrOG55WZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MTYzNg==", "bodyText": "lets also add tests when this config is malformed. We can create a task for that, and merge this if you want.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r463361636", "createdAt": "2020-07-31T01:41:24Z", "author": {"login": "prateek-y"}, "path": "src/test/resources/com/aws/iot/evergreen/auth/pubsub.yaml", "diffHunk": "@@ -0,0 +1,64 @@\n+---\n+services:\n+  main:\n+    dependencies:\n+      - IPCService\n+      - mqtt\n+      - ServiceName\n+    lifecycle:\n+\n+  mqtt:\n+    dependencies:\n+      - IPCService\n+    resources:\n+      - evergreen_1._mqtt._tcp.local\n+      - evergreen_1._http._tcp.local\n+    lifecycle:\n+\n+  ServiceName:\n+    dependencies:\n+      - IPCService\n+    resources:\n+      - http-resource\n+    lifecycle:\n+      run:\n+        windows:\n+          powershell -command sleep 100\n+        posix:\n+          sleep 100\n+\n+  pubsub:\n+    AccessControl:\n+      policyId1:\n+        policyDescription: \"access to pubsub topics\"\n+        principals:\n+          - \"ServiceName\"\n+          - \"mqtt\"\n+        operations:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88f8c5593f83f7ffb423bff360a0e453d301cb63"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bb67f81af6b9d0c98d18e5f1302b2b0a05f4cfa9", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bb67f81af6b9d0c98d18e5f1302b2b0a05f4cfa9", "committedDate": "2020-07-31T05:32:16Z", "message": "Tests for Pub/Sub Auth and YAML refactoring"}, "afterCommit": {"oid": "613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/613656cb0b51b06ac8ea8562b7e3ad4ef0804f81", "committedDate": "2020-08-04T03:30:46Z", "message": "Final iteration of authZ pub/sub"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDg1NDgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-461085480", "createdAt": "2020-08-04T19:00:14Z", "commit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMDoxNFrOG7tcYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMDoxNFrOG7tcYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2MzcxNQ==", "bodyText": "remove this.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465263715", "createdAt": "2020-08-04T19:00:14Z", "author": {"login": "MikeDombo"}, "path": "codestyle/pmd-eg-ruleset.xml", "diffHunk": "@@ -21,6 +21,7 @@\n         <exclude name=\"ArrayIsStoredDirectly\"/>\n         <exclude name=\"GuardLogStatement\"/>\n         <exclude name=\"AccessorMethodGeneration\"/>\n+        <exclude name=\"UnusedFormalParameter\"/><!--Temporary add -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDg2NjAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-461086600", "createdAt": "2020-08-04T19:01:54Z", "commit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMTo1NFrOG7tf8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMTo1NFrOG7tf8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDYyNg==", "bodyText": "This is commented out because the authhandler starts up before components become registered, which causes this to always fail. We're still discussing how to handle this case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465264626", "createdAt": "2020-08-04T19:01:54Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -185,19 +256,20 @@ private void validatePolicyId(List<AuthorizationPolicy> policies) throws Authori\n         }\n     }\n \n-    private void validateOperations(String componentName, AuthorizationPolicy policy) throws AuthorizationException {\n-        Set<String> operations = policy.getOperations();\n-        if (Utils.isEmpty(operations)) {\n-            throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n-                    + policy.getPolicyId());\n-        }\n-        Set<String> supportedOps = componentToOperationsMap.get(componentName);\n-        // check if operations are valid and registered.\n-        if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n-            throw new AuthorizationException(\n-                    String.format(\"Operation not registered with component %s\", componentName));\n+        private void validateOperations(String componentName, AuthorizationPolicy policy)\n+        throws AuthorizationException {\n+            Set<String> operations = policy.getOperations();\n+            if (Utils.isEmpty(operations)) {\n+                throw new AuthorizationException(\"Malformed policy with invalid/empty operations: \"\n+                        + policy.getPolicyId());\n+            }\n+            //Set<String> supportedOps = componentToOperationsMap.get(componentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDg2NjY1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-461086665", "createdAt": "2020-08-04T19:01:59Z", "commit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMjowMFrOG7tgHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMjowMFrOG7tgHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NDY3MA==", "bodyText": "This is commented out because the authhandler starts up before components become registered, which causes this to always fail. We're still discussing how to handle this case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465264670", "createdAt": "2020-08-04T19:02:00Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -155,13 +193,46 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies policies which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated policies would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }\n+        isComponentRegistered(componentName);\n+        validatePolicyId(policies);\n+        // First validate if all principals and operations are valid\n+        for (AuthorizationPolicy policy: policies) {\n+            validatePrincipals(policy);\n+            validateOperations(componentName, policy);\n+        }\n+\n+        authModule.clearComponentPermissions(componentName);\n+        // now start adding the policies as permissions\n+        for (AuthorizationPolicy policy: policies) {\n+            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        }\n+        this.componentToAuthZConfig.replace(componentName, policies);\n+    }\n+\n     private void isComponentRegistered(String componentName) throws AuthorizationException {\n         if (Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Component name is not specified: \" + componentName);\n         }\n-        if (!componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component not registered: \" + componentName);\n-        }\n+        //if (!componentToOperationsMap.containsKey(componentName)) {\n+        //throw new AuthorizationException(\"Component not registered: \" + componentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDkyMzU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-461092355", "createdAt": "2020-08-04T19:10:25Z", "commit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOToxMDoyNVrOG7txgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTozMDo1OVrOG7ujAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTEyMw==", "bodyText": "use https://github.com/aws/aws-greengrass-kernel/blob/1972ecb1e01f0ca1fc39b0228c9495b5a3381ccd/src/main/java/com/aws/iot/evergreen/kernel/Kernel.java#L140 instead", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269123", "createdAt": "2020-08-04T19:10:25Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(\"accessControl\")) {\n+                        return;\n+                    }\n+                    try {\n+                        Topic updatedTopic = (Topic) newv;\n+                        String componentName = updatedTopic.parent.parent.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTIxMQ==", "bodyText": "make a const for this string", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269211", "createdAt": "2020-08-04T19:10:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(\"accessControl\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30bf0cd8c636d624816f83064b7bdbfbd4a20377"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2OTY4NQ==", "bodyText": "reformat.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465269685", "createdAt": "2020-08-04T19:11:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -155,13 +193,48 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Update authZ policies for a single component. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * This method clears the existing policies for a component before refreshing with the updated list.\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies policies which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated policies would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }\n+        isComponentRegistered(componentName);\n+        validatePolicyId(policies);\n+        // First validate if all principals and operations are valid\n+        for (AuthorizationPolicy policy: policies) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MDgwOQ==", "bodyText": "don't make your own const. We already have these as consts", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465270809", "createdAt": "2020-08-04T19:13:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTMwNg==", "bodyText": "this isn't needed. Do for (Map.Entry policyEntry : allPoliciesMap.entrySet())", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271306", "createdAt": "2020-08-04T19:14:26Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTQyOA==", "bodyText": "again here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271428", "createdAt": "2020-08-04T19:14:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTc0Ng==", "bodyText": "this cast might fail, make sure that you are handling ClassCastException appropriately somewhere", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271746", "createdAt": "2020-08-04T19:15:18Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MTk4NQ==", "bodyText": "do a static import for Collections.singleton", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465271985", "createdAt": "2020-08-04T19:15:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Mjk0NQ==", "bodyText": "This log is completely wrong. All logging needs to end with .log() the message needs to go in the .log(). Putting a string in the atWarn is the event type and not the message. Do not use string.format, use .log(\"{}\", value)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465272945", "createdAt": "2020-08-04T19:17:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * @param config Topics\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);\n+        if (servicesConfig == null) {\n+            logger.atWarn(String.format(\"No services found in config.\"));\n+            return authorizationPolicyMap;\n+        }\n+\n+        //For each component\n+        for (Node componentConfigNode : servicesConfig) {\n+            Topics componentConfigTopics = (Topics) componentConfigNode;\n+            String componentName = componentConfigTopics.getName();\n+\n+            //Get the Access Control List for this component\n+            Topics accessControlTopics = componentConfigTopics.findTopics(ACCESS_CONTROL_KEY);\n+            if (accessControlTopics == null) {\n+                logger.atWarn(String.format(\"Component %s has no valid accessControl component field.\", componentName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjE1MA==", "bodyText": "I don't like this idea because it is dependent on the config layout. Use kernel.orderedDependencies() to get the list of all services, then use service.getConfig() to get their config.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465276150", "createdAt": "2020-08-04T19:24:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(Coerce.toString(policyEntry.getKey()))\n+                        .policyDescription(policyDescription)\n+                        .principals(new HashSet<String>(java.util.Collections.singleton(componentName)))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a Topics config object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * @param config Topics\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Topics config, Logger logger)\n+            throws AuthorizationException {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Topics servicesConfig = config.findTopics(SERVICES_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3NjgwMw==", "bodyText": "this log line can be shortened using our convenience overrides you can do atError(<event type>, <exception>).kv(key, value).log(<stuff>). kv == addKeyValue", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465276803", "createdAt": "2020-08-04T19:25:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -44,13 +55,28 @@ public PubSubIPCService(Topics c) {\n     public void postInject() {\n         BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.PUBSUB;\n         super.postInject();\n+\n+\n+        List<String> opCodes = Stream.of(PubSubClientOpCodes.values())\n+                .map(PubSubClientOpCodes::name)\n+                .map(String::toLowerCase)\n+                .collect(Collectors.toList());\n+        try {\n+            authorizationHandler.registerComponent(this.getName(), new HashSet<String>(opCodes));\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"initialize-pubsub-authorization-error\").setCause(e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3Nzc0MA==", "bodyText": "shutdown the context in the afterEach otherwise you're leaving a thread running forever.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465277740", "createdAt": "2020-08-04T19:26:11Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationHandlerTest.java", "diffHunk": "@@ -124,12 +127,18 @@ private AuthorizationPolicy getAuthZPolicyWithEmptyPolicyId() {\n                 .build();\n     }\n \n+    @BeforeEach\n+    void beforeEach() {\n+        when(mockKernel.getConfig()).thenReturn(new Configuration(new Context()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3OTkxNw==", "bodyText": "flip these assertions, the actual value should be first and the expected value second.\n\"Expected  to equal \"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465279917", "createdAt": "2020-08-04T19:28:51Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MDI1MQ==", "bodyText": "create a constant for the service name and use that here and in the annotation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465280251", "createdAt": "2020-08-04T19:29:14Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy.getPolicyDescription()));\n+                assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+                assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+                assertThat(policy.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\", \"*\"));\n+\n+                AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+                assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy2.getPolicyDescription()));\n+                assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+                assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+                assertThat(policy2.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\"));\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_without_description_or_resources_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid_optional.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+            Topics component = config.getRoot();\n+            Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+            assertEquals(1, authorizationPolicyMap.size());\n+            assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+            AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+            assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+            assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+            assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+            assertThat(policy.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy.getResources(), Matchers.nullValue());\n+\n+            AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MTc5Mg==", "bodyText": "We shouldn't be throwing nulls. Handle the exception properly when parsing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465281792", "createdAt": "2020-08-04T19:30:59Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthorizationUtilsTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.fasterxml.jackson.jr.ob.JSON;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthorizationUtilsTest {\n+\n+    private Configuration config;\n+\n+    protected final Logger logger = LogManager.getLogger(this.getClass());\n+\n+    @BeforeEach()\n+    void beforeEach() {\n+        config = new Configuration(new Context());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        config.context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+                assertEquals(1, authorizationPolicyMap.size());\n+                assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+                AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+                assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy.getPolicyDescription()));\n+                assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+                assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+                assertThat(policy.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\", \"*\"));\n+\n+                AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+                assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+                assertThat(\"access to pubsub topics\", equalTo(policy2.getPolicyDescription()));\n+                assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+                assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+                assertThat(policy2.getResources(), containsInAnyOrder(\"/topic/1/#\", \"/longer/topic/example/\"));\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_valid_pubsub_ACL_without_description_or_resources_WHEN_auth_parsing_THEN_return_auth_policies() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_valid_optional.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+            Topics component = config.getRoot();\n+            Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(component, logger);\n+            assertEquals(1, authorizationPolicyMap.size());\n+            assertEquals(2, authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").size());\n+\n+            AuthorizationPolicy policy = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(0);\n+            assertThat(\"policyId1\", equalTo(policy.getPolicyId()));\n+            assertThat(policy.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\", \"unsubscribe\"));\n+            assertThat(policy.getPrincipals(), containsInAnyOrder(\"ServiceName\"));\n+            assertThat(policy.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy.getResources(), Matchers.nullValue());\n+\n+            AuthorizationPolicy policy2 = authorizationPolicyMap.get(\"aws.greengrass.ipc.pubsub\").get(1);\n+            assertThat(\"policyId2\", equalTo(policy2.getPolicyId()));\n+            assertThat(policy2.getOperations(), containsInAnyOrder(\"publish\", \"subscribe\"));\n+            assertThat(policy2.getPrincipals(), containsInAnyOrder(\"mqtt\"));\n+            assertThat(policy2.getPolicyDescription(), Matchers.nullValue());\n+            assertThat(policy2.getResources(), Matchers.nullValue());\n+        }\n+    }\n+\n+    @Test\n+    public void GIVEN_invalid_pubsub_yaml_file_without_operations_WHEN_auth_parsing_THEN_fail() throws Throwable {\n+\n+        try (\n+                InputStream inputStream = getClass().getResourceAsStream(\"pubsub_invalid_no_operations.yaml\")) {\n+                assertNotNull(inputStream);\n+                config.mergeMap(0, (Map) JSON.std.with(new YAMLFactory()).anyFrom(inputStream));\n+\n+                Topics component = config.getRoot();\n+                assertThrows(NullPointerException.class, () -> AuthorizationUtils", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjIyMzM3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-461222337", "createdAt": "2020-08-04T22:34:34Z", "commit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjozNDozNVrOG7zzFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjozNzozMlrOG7z2-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NzgyOQ==", "bodyText": "These policies can be for any module other than pubsub as well. So we need to make it general. Currently it assumes policies are for pubsub right? This policy is for pubsub where is that captured?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465367829", "createdAt": "2020-08-04T22:34:35Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private static final String ACCESS_CONTROL_KEY = \"accessControl\";\n+    private static final String SERVICES_KEY = \"services\";\n+\n+    private AuthorizationUtils(){\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * @param componentName String\n+     * @param accessControlTopic Topic\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        List<Map> accessControlList = (List<Map>) accessControlTopic.getOnce();\n+\n+        //Iterate through each policy\n+        for (Map allPoliciesMap : accessControlList) {\n+            for (Object policyMapComponent : allPoliciesMap.entrySet()) {\n+                Map.Entry policyEntry = (Map.Entry) policyMapComponent;\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                //Retrieve the actual policy specifications\n+                Map policyMap = (Map) policyEntry.getValue();\n+\n+                for (Object policyComponentObject : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    Map.Entry policyComponent = (Map.Entry) policyComponentObject;\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2ODgyNg==", "bodyText": "This should be generic message than being specific to pubsub", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r465368826", "createdAt": "2020-08-04T22:37:32Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -46,6 +48,42 @@\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;\n+        try {\n+            mappedPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel.getConfig().getRoot(), logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : mappedPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Pub/Sub Authorization config.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02d6fd5499d4556da0502dffa27280ac5092042a"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMDE5NjMy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-462019632", "createdAt": "2020-08-05T21:00:10Z", "commit": {"oid": "1c88aad1e9b4accc516cb2cd4b2f2ca84ae60d9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTowMDoxMVrOG8abBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMTowMDoxMVrOG8abBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwMDY0Ng==", "bodyText": "Lets log all the variables so that its easy for customers to debug.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466000646", "createdAt": "2020-08-05T21:00:11Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+                HashSet<String> principals = new HashSet<>(java.util.Collections.singleton(componentName));\n+\n+                if (policyId == null || operations == null || principals.isEmpty()) {\n+                    String errorMessage = \"Policy component is missing or invalid\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c88aad1e9b4accc516cb2cd4b2f2ca84ae60d9a"}, "originalPosition": 100}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "224689b3cbb8b8ae27a1729e19e315bef85abdf8", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/224689b3cbb8b8ae27a1729e19e315bef85abdf8", "committedDate": "2020-08-05T17:19:10Z", "message": "Increase timeout for IPCPubSubTest"}, "afterCommit": {"oid": "5055bcbee2e9eb715770b7c9a1431c6809318746", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5055bcbee2e9eb715770b7c9a1431c6809318746", "committedDate": "2020-08-05T23:36:05Z", "message": "Initial AuthZ Pub/Sub Integration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMDg3MTYy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-462087162", "createdAt": "2020-08-05T23:20:18Z", "commit": {"oid": "224689b3cbb8b8ae27a1729e19e315bef85abdf8"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzoyMDoxOFrOG8d1Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowMjowOVrOG8fmaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjUxOQ==", "bodyText": "Change the name to indicate what the mapping is. componentNameToPolicies maybe", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466056519", "createdAt": "2020-08-05T23:20:18Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> mappedPolicies = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "224689b3cbb8b8ae27a1729e19e315bef85abdf8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODAyNA==", "bodyText": "Does this need to be exposed to customer/first party components (not running in same JVM as kernel) by Re:invent 2020? For example to Stream manager over IPC?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466078024", "createdAt": "2020-08-06T00:33:32Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,8 +149,9 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5055bcbee2e9eb715770b7c9a1431c6809318746"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTQ4MQ==", "bodyText": "Any reason to choose this path as name?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466085481", "createdAt": "2020-08-06T01:02:09Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/PubSubIPCService.java", "diffHunk": "@@ -21,21 +24,30 @@\n import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n \n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import javax.inject.Inject;\n \n //TODO: see if this needs to be a GGService\n-@ImplementsService(name = \"pubsubipc\", autostart = true)\n+@ImplementsService(name = PubSubIPCService.PUB_SUB_SERVICE_NAME, autostart = true)\n public class PubSubIPCService extends EvergreenService {\n     private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+    private static final String DESTINATION_STRING = \"destination\";\n+    public static final String PUB_SUB_SERVICE_NAME = \"aws.greengrass.ipc.pubsub\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5055bcbee2e9eb715770b7c9a1431c6809318746"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5055bcbee2e9eb715770b7c9a1431c6809318746", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5055bcbee2e9eb715770b7c9a1431c6809318746", "committedDate": "2020-08-05T23:36:05Z", "message": "Initial AuthZ Pub/Sub Integration"}, "afterCommit": {"oid": "39ee9af6b4fad604d39653cf8b3b8de019da9800", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/39ee9af6b4fad604d39653cf8b3b8de019da9800", "committedDate": "2020-08-06T17:46:20Z", "message": "Initial AuthZ Pub/Sub Integration"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "39ee9af6b4fad604d39653cf8b3b8de019da9800", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/39ee9af6b4fad604d39653cf8b3b8de019da9800", "committedDate": "2020-08-06T17:46:20Z", "message": "Initial AuthZ Pub/Sub Integration"}, "afterCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/97c1930a83fdcab29960d7c26689c5f0ce8e1033", "committedDate": "2020-08-06T18:06:41Z", "message": "Initial AuthZ Pub/Sub Integration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzU5MTY2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-462759166", "createdAt": "2020-08-06T18:07:20Z", "commit": {"oid": "39ee9af6b4fad604d39653cf8b3b8de019da9800"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODowNzoyMFrOG8-quw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxODo0OTozNVrOG9ADBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NDQ5MQ==", "bodyText": "What's ServiceName? Why is it a hardcoded string? It should be passed in as a parameter so this method can be used by other tests as well.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466594491", "createdAt": "2020-08-06T18:07:20Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();\n+    }\n+\n+    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+        Kernel kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());\n+\n+        // ensure awaitIpcServiceLatch starts\n+        CountDownLatch awaitIpcServiceLatch = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"ServiceName\") && newState.equals(State.RUNNING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39ee9af6b4fad604d39653cf8b3b8de019da9800"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NjMwNw==", "bodyText": "Use Coerce.toString()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466596307", "createdAt": "2020-08-06T18:10:38Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5NzEzOA==", "bodyText": "Instead of using IPCPubSubTest.class, can you make this a method parameter so it can be used by other tests as well?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466597138", "createdAt": "2020-08-06T18:12:11Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {\n+        return KernelIPCClientConfig.builder().hostAddress(address).port(port)\n+                .token((String) kernel.locate(serviceName).getPrivateConfig().findLeafChild(SERVICE_UNIQUE_ID_KEY)\n+                        .getOnce()).build();\n+    }\n+\n+    public static Kernel prepareKernelFromConfigFile(String configFile) throws InterruptedException {\n+        Kernel kernel = new Kernel();\n+        kernel.parseArgs(\"-i\", IPCPubSubTest.class.getResource(configFile).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU5OTYxNw==", "bodyText": "This is duplicated across multiple test cases, consider extracting them to a private method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466599617", "createdAt": "2020-08-06T18:16:45Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzg3Mg==", "bodyText": "Extract ServiceName to a constant.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466603872", "createdAt": "2020-08-06T18:24:40Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMTkyOA==", "bodyText": "Isn't this counter-intuitive? Why would we want to prevent unsubscribe? What would be the use case that a component is allowed to subscribe bu cannot unsubscribe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466611928", "createdAt": "2020-08-06T18:39:49Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCPubSubTest.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSub;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubException;\n+import com.aws.iot.evergreen.ipc.services.pubsub.PubSubImpl;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.util.Pair;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.prepareKernelFromConfigFile;\n+import static com.aws.iot.evergreen.ipc.IPCService.KERNEL_URI_ENV_VARIABLE_NAME;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SETENV_CONFIG_NAMESPACE;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionOfType;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionWithMessage;\n+import static com.aws.iot.evergreen.testcommons.testutilities.TestUtils.asyncAssertOnConsumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+@ExtendWith(EGExtension.class)\n+class IPCPubSubTest {\n+\n+    @TempDir\n+    static Path tempRootDir;\n+\n+    private static int port;\n+    private static String address;\n+    private static Kernel kernel;\n+    private IPCClient client;\n+\n+    @BeforeEach\n+    void beforeEach(ExtensionContext context) {\n+        ignoreExceptionWithMessage(context, \"Connection reset by peer\");\n+        // Ignore if IPC can't send us more lifecycle updates because the test is already done.\n+        ignoreExceptionUltimateCauseWithMessage(context, \"Channel not found for given connection context\");\n+    }\n+\n+    @BeforeAll\n+    static void startKernel() throws Exception {\n+        System.setProperty(\"root\", tempRootDir.toAbsolutePath().toString());\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws IOException {\n+        client.disconnect();\n+        kernel.shutdown();\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_and_publish_is_authorized_THEN_succeeds() throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_authorized.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+        IPCClientImpl client2 = new IPCClientImpl(config);\n+        try {\n+            PubSub c2 = new PubSubImpl(client2);\n+\n+            Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+                assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+            });\n+            c.subscribeToTopic(\"a\", cb.getRight());\n+            c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+            cb.getLeft().get(2, TimeUnit.SECONDS);\n+\n+            // Now unsubscribe and make sure that we only got the first message in the first client\n+            c.unsubscribeFromTopic(\"a\");\n+            Pair<CompletableFuture<Void>, Consumer<byte[]>> cb2 = asyncAssertOnConsumer((m) -> {\n+                assertEquals(\"second message\", new String(m, StandardCharsets.UTF_8));\n+            });\n+            c2.subscribeToTopic(\"a\", cb2.getRight());\n+            c2.publishToTopic(\"a\", \"second message\".getBytes(StandardCharsets.UTF_8));\n+            cb2.getLeft().get(2, TimeUnit.SECONDS);\n+            cb.getLeft().get(2, TimeUnit.SECONDS);\n+        } finally {\n+            client2.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_authorization_changes_THEN_succeeds(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_subscribe.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+        //Reload the kernel with the correct authorization policy\n+        kernel.getConfig().read(new URL(IPCPubSubTest.class.getResource(\"pubsub_authorized.yaml\").toString()), false);\n+        Thread.sleep(500);\n+        c.subscribeToTopic(\"a\", cb.getRight()); //now this should succeed\n+        c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n+    }\n+\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_subscribe_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_subscribe.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        Pair<CompletableFuture<Void>, Consumer<byte[]>> cb = asyncAssertOnConsumer((m) -> {\n+            assertEquals(\"some message\", new String(m, StandardCharsets.UTF_8));\n+        });\n+\n+        //TODO: change PubSubImpl L124 to handle PubSubExceptions better by switching on AuthorizationExceptions\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.subscribeToTopic(\"a\", cb.getRight()));\n+\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_publish_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {\n+\n+        kernel = prepareKernelFromConfigFile(\"pubsub_unauthorized_publish.yaml\");\n+        Topic kernelUri = kernel.getConfig().getRoot().lookup(SETENV_CONFIG_NAMESPACE, KERNEL_URI_ENV_VARIABLE_NAME);\n+        URI serverUri = new URI((String) kernelUri.getOnce());\n+        port = serverUri.getPort();\n+        address = serverUri.getHost();\n+\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", address, port, kernel);\n+        client = new IPCClientImpl(config);\n+        PubSub c = new PubSubImpl(client);\n+\n+        ignoreExceptionOfType(context, AuthorizationException.class);\n+        assertThrows(PubSubException.class, () -> c.publishToTopic(\"a\", \"some message\".getBytes(StandardCharsets.UTF_8)));\n+    }\n+\n+    @Test\n+    void GIVEN_pubsubclient_WHEN_unsubscribe_is_not_authorized_THEN_Fail(ExtensionContext context) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxMzE5MQ==", "bodyText": "Would it be simpler to change this method's parameters to take in only the service name and kernel object? Both the port and address are derived from the kernel object.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466613191", "createdAt": "2020-08-06T18:42:13Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCTestUtils.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.aws.iot.evergreen.integrationtests.ipc;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.ipc.AuthenticationHandler.SERVICE_UNIQUE_ID_KEY;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public final class IPCTestUtils {\n+\n+    private IPCTestUtils() {\n+\n+    }\n+\n+    public static KernelIPCClientConfig getIPCConfigForService(String serviceName, String address, int port, Kernel kernel) throws ServiceLoadException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng==", "bodyText": "Do you need a null check on the get method?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466614896", "createdAt": "2020-08-06T18:45:32Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java", "diffHunk": "@@ -38,6 +38,10 @@ public void addPermission(final String destination, Permission permission) throw\n         permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);\n     }\n \n+    public void clearComponentPermissions(String destination) {\n+        permissions.get(destination).clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNzA5Mg==", "bodyText": "Also the List<Permission> need to be thread-safe? It seems multiple threads can access it concurrently.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466617092", "createdAt": "2020-08-06T18:49:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java", "diffHunk": "@@ -38,6 +38,10 @@ public void addPermission(final String destination, Permission permission) throw\n         permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);\n     }\n \n+    public void clearComponentPermissions(String destination) {\n+        permissions.get(destination).clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzk1Nzgy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-462795782", "createdAt": "2020-08-06T19:00:29Z", "commit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTowMDoyOVrOG9AaNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTowNzoxOFrOG9An6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzAzMQ==", "bodyText": "Line66 in the isPresent method also requires a null check on the permissionForDest?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466623031", "createdAt": "2020-08-06T19:00:29Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationModule.java", "diffHunk": "@@ -38,6 +38,10 @@ public void addPermission(final String destination, Permission permission) throw\n         permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);\n     }\n \n+    public void clearComponentPermissions(String destination) {\n+        permissions.get(destination).clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYxNDg5Ng=="}, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMzQ1NQ==", "bodyText": "Just initialize it when you declare it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466623455", "createdAt": "2020-08-06T19:01:15Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNDMzNA==", "bodyText": "Why not just:\ntry {\n    Map<String, List<AuthorizationPolicy>> componentNameToPolicies = AuthorizationUtils.parseAllAuthorizationPolicies(kernel, logger);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466624334", "createdAt": "2020-08-06T19:02:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyNjUzNw==", "bodyText": "I would make this a class like AuthorizationPolicyParser and pass it in as a dependency of AuthorizationHandler. That way is more object-oriented. Utils is a bit too generic. Also don't mark the methods as static.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466626537", "createdAt": "2020-08-06T19:07:18Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyODg0MTE2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-462884116", "createdAt": "2020-08-06T21:18:56Z", "commit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMToxODo1NlrOG9EnTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjoxMTo1NlrOG9F8QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg==", "bodyText": "I saw this method both called here and in the TES. Shouldn't parseAllAuthorizationPolicies() already include TES policy?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466691916", "createdAt": "2020-08-06T21:18:56Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -128,13 +172,14 @@ public void registerComponent(String componentName, Set<String> operations)\n      * Loads authZ policies for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MzY3NA==", "bodyText": "Line 187, why not just return? Do you need to throw an exception? Is policies empty expected or unexpected? If it's expected, then the code can handle it gracefully by just return at that point. If it's not expected, then it's a programming error we should make sure it doesn't happen using testing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466693674", "createdAt": "2020-08-06T21:22:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -128,13 +172,14 @@ public void registerComponent(String componentName, Set<String> operations)\n      * Loads authZ policies for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5Nzc3MQ==", "bodyText": "I would revisit every line of the code that throws the AuthorizationException and think again whether that is the desired behavior. We don't want to just fail. For scenarios that we can recover (e.g. empty list), we should just handle it and move on.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466697771", "createdAt": "2020-08-06T21:32:11Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -128,13 +172,14 @@ public void registerComponent(String componentName, Set<String> operations)\n      * Loads authZ policies for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n      * @throws AuthorizationException if there is a problem loading the policies.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+    public void loadAllAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTkxNg=="}, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5ODI4Ng==", "bodyText": "This handling is interesting. So if some code throws AuthorizationException, we just stop loading the rest and move on? is that desirable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466698286", "createdAt": "2020-08-06T21:33:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Authorization config.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwNzU2Nw==", "bodyText": "Shouldn't you do null check on the componentName before parse the policy?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466707567", "createdAt": "2020-08-06T21:55:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -40,21 +45,59 @@\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n         authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies;\n+        try {\n+            componentNameToPolicies = AuthorizationUtils\n+                    .parseAllAuthorizationPolicies(kernel, logger);\n+\n+            for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+                this.loadAllAuthorizationPolicies(acl.getKey(), acl.getValue());\n+            }\n+        } catch (AuthorizationException e) {\n+            logger.atError().setEventType(\"load-authorization-config-error\").setCause(e)\n+                    .log(\"Failed to load the Authorization config.\");\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+                    try {\n+                        Topic updatedTopic = (Topic) newv;\n+                        String componentName = findServiceForNode(updatedTopic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcwODM2MA==", "bodyText": "Is this expected or not? If it's expected, the code can just return.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466708360", "createdAt": "2020-08-06T21:57:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -144,24 +189,60 @@ public void loadAuthorizationPolicy(String componentName, List<AuthorizationPoli\n         isComponentRegistered(componentName);\n         validatePolicyId(policies);\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             validatePrincipals(policy);\n             validateOperations(componentName, policy);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n+        for (AuthorizationPolicy policy : policies) {\n             addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n         }\n         this.componentToAuthZConfig.put(componentName, policies);\n     }\n \n+    /**\n+     * Update authZ policies for a single component. The policies should not have confidential\n+     * values. This method assumes that the component names for principal and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * This method clears the existing policies for a component before refreshing with the updated list.\n+     *\n+     * @param componentName Destination component which intents to supply auth policies\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public void updateComponentAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n+            throws AuthorizationException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(policies)) {\n+            throw new AuthorizationException(\"policies is null/empty\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMjMwOA==", "bodyText": "Can this ever happen?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466712308", "createdAt": "2020-08-06T22:08:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzAzOA==", "bodyText": "Why not just log and ignore? throw an exception up to the stack is very intrusive. How would the call handle it better?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466713038", "createdAt": "2020-08-06T22:10:08Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcxMzY2NQ==", "bodyText": "Same comment. Is throwing an exception up the best way to handle the error?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r466713665", "createdAt": "2020-08-06T22:11:56Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationUtils.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationUtils {\n+\n+    private AuthorizationUtils() {\n+    }\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public static List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger)\n+            throws AuthorizationException {\n+\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            throw new AuthorizationException(\"Unknown policy component key: \"\n+                                    + policyComponent.getKey());\n+                    }\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+\n+                if (policyId == null) {\n+                    String errorMessage = \"Policy ID is missing or invalid\";\n+                    logger.atError(\"missing-policy-component-policyId\")\n+                            .log(errorMessage);\n+                    throw new AuthorizationException(errorMessage);\n+                }\n+                if (operations == null || operations.isEmpty()) {\n+                    String errorMessage = \"Policy operations are missing or invalid\";\n+                    logger.atError(\"missing-policy-component-operations\")\n+                            .log(errorMessage);\n+                    throw new AuthorizationException(errorMessage);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97c1930a83fdcab29960d7c26689c5f0ce8e1033"}, "originalPosition": 109}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65852dac8654c9c68487a1dfacd87b2bac16e691", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65852dac8654c9c68487a1dfacd87b2bac16e691", "committedDate": "2020-08-07T05:49:25Z", "message": "Rename AuthorizationUtilsTest to AuthorizationPolicyParserTest"}, "afterCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0409dfb1f21c8c7c52a764b5860ed5f34d654fd4", "committedDate": "2020-08-07T17:17:07Z", "message": "Rename AuthorizationUtilsTest to AuthorizationPolicyParserTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjU4MTgx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-463658181", "createdAt": "2020-08-07T21:49:59Z", "commit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTo0OTo1OVrOG9pc1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTo1NzowOVrOG9pySg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NTQ0Ng==", "bodyText": "this cast is unsafe. Use instanceof to make sure it actually is a topic.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467295446", "createdAt": "2020-08-07T21:49:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +37,57 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+\n+                    Topic updatedTopic = (Topic) newv;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjUyNw==", "bodyText": "use compute otherwise this isn't threadsafe.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296527", "createdAt": "2020-08-07T21:51:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjcwNg==", "bodyText": "extra space in single component.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296706", "createdAt": "2020-08-07T21:51:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ==", "bodyText": "Why is this a warning, that's not a problem is it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467296991", "createdAt": "2020-08-07T21:51:56Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ==", "bodyText": "why does it need to be registered first? Why not just handle the registration here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467297639", "createdAt": "2020-08-07T21:52:47Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+        try {\n+            isComponentRegistered(componentName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5ODUyMQ==", "bodyText": "just use put.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467298521", "createdAt": "2020-08-07T21:53:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+        try {\n+            isComponentRegistered(componentName);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-unregistered-component\", e)\n+                    .log(\"Component {} is not registered with the AuthorizationHandler\", componentName);\n+            return;\n+        }\n+\n+        try {\n+            validatePolicyId(policies);\n+        } catch (AuthorizationException e) {\n+            logger.atError(\"load-authorization-config-invalid-policy\", e)\n+                    .log(\"Component {} contains an invalid policy\", componentName);\n+            return;\n+        }\n+\n         // First validate if all principals and operations are valid\n-        for (AuthorizationPolicy policy: policies) {\n-            validatePrincipals(policy);\n-            validateOperations(componentName, policy);\n+        for (AuthorizationPolicy policy : policies) {\n+            try {\n+                validatePrincipals(policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-principal\", e)\n+                        .log(\"Component {} contains an invalid principal in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+            try {\n+                validateOperations(componentName, policy);\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-invalid-operation\", e)\n+                        .log(\"Component {} contains an invalid operation in policy {}\", componentName,\n+                                policy.getPolicyId());\n+                continue;\n+            }\n+        }\n+        if (isUpdate) {\n+            authModule.clearComponentPermissions(componentName);\n         }\n         // now start adding the policies as permissions\n-        for (AuthorizationPolicy policy: policies) {\n-            addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+        for (AuthorizationPolicy policy : policies) {\n+            try {\n+                addPermission(componentName, policy.getPrincipals(), policy.getOperations(), policy.getResources());\n+            } catch (AuthorizationException e) {\n+                logger.atError(\"load-authorization-config-add-permission-error\", e)\n+                        .log(\"Error while loading policy {} for component {}\",  policy.getPolicyId(),\n+                                componentName);\n+                continue;\n+            }\n+        }\n+\n+        if (isUpdate) {\n+            this.componentToAuthZConfig.replace(componentName, policies);\n+        } else {\n+            this.componentToAuthZConfig.put(componentName, policies);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTQyOQ==", "bodyText": "why do you need this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467299429", "createdAt": "2020-08-07T21:55:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -11,10 +11,34 @@\n \n @Value\n @Builder\n-public class AuthorizationPolicy {\n+public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n     @NonNull String policyId;\n     String policyDescription;\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");\n+\n+        private final String name;\n+\n+        PolicyComponentTypes(String s) {\n+            name = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.name;\n+        }\n+    }\n+\n+    @Override\n+    public int compareTo(AuthorizationPolicy other) {\n+        return this.policyId.compareTo(other.policyId);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5OTc4NQ==", "bodyText": "instead of catching you can just use instanceof to make sure the cast is safe.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467299785", "createdAt": "2020-08-07T21:55:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDUxOQ==", "bodyText": "the key can't be null anyway, so I don't think this check is needed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467300519", "createdAt": "2020-08-07T21:56:38Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"load-authorization-access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwMDkzOA==", "bodyText": "replace \"service\" with \"component\" everywhere.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r467300938", "createdAt": "2020-08-07T21:57:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                         Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+        List<Map<String, Object>> accessControlList;\n+\n+        try {\n+            accessControlList = (List<Map<String, Object>>) accessControlTopic.getOnce();\n+        } catch (ClassCastException e) {\n+            logger.atError(\"load-authorization-access-control-list-retrieval-error\", e)\n+                    .log(\"Error while retrieving the Access Control List\");\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {\n+                    logger.atError(\"load-authorization-access-control-list-policy-retrieval-error\", e)\n+                            .log(\"Error while retrieving an Access Control List policy\");\n+                    continue;\n+                }\n+\n+                String policyId = Coerce.toString(policyEntry.getKey());\n+                if (policyId == null) {\n+                    logger.atError(\"load-authorization-missing-policy-component-policyId\")\n+                            .log(\"Policy ID is missing or invalid\");\n+                    continue;\n+                }\n+\n+                for (Map.Entry policyComponent : policyMap.entrySet()) {\n+                    //Iterate through the components of this policy\n+                    PolicyComponentTypes policyComponentKey = toEnum(\n+                            PolicyComponentTypes.class,\n+                            Coerce.toString(policyComponent.getKey()),\n+                            PolicyComponentTypes.INVALID_ENUM);\n+                    switch (policyComponentKey) {\n+                        case POLICY_DESCRIPTION:\n+                            policyDescription = Coerce.toString(policyComponent.getValue());\n+                            break;\n+                        case OPERATIONS:\n+                            operations = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        case RESOURCES:\n+                            resources = new HashSet<>(Coerce.toStringList(policyComponent.getValue()));\n+                            break;\n+                        default:\n+                            logger.atError(\"load-authorization-config-unknown policy key\")\n+                                    .log(\"Component {} has an invalid policy key in policy {}\", componentName,\n+                                            policyId);\n+                            continue;\n+                    }\n+                }\n+\n+                if (Utils.isEmpty(operations)) {\n+                    String errorMessage = \"Policy operations are missing or invalid\";\n+                    logger.atError(\"load-authorization-missing-policy-component-operations\")\n+                            .log(errorMessage);\n+                    continue;\n+                }\n+\n+                AuthorizationPolicy newPolicy = AuthorizationPolicy.builder()\n+                        .policyId(policyId)\n+                        .policyDescription(policyDescription)\n+                        .principals(java.util.Collections.singleton(componentName))\n+                        .operations(operations)\n+                        .resources(resources)\n+                        .build();\n+\n+                newAuthorizationPolicyList.add(newPolicy);\n+            }\n+        }\n+\n+        return newAuthorizationPolicyList;\n+    }\n+\n+    /**\n+     * Given a kernel object, construct and return a map of AuthorizationPolicy objects that may exist,\n+     * grouped into lists of the same policyType.\n+     * Never returns null.\n+     *\n+     * @param kernel Kernel\n+     * @param logger Logger\n+     * @return {@Map} of {@String} keys and {@List} of {@AuthorizationPolicy}'s as  values\"\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public Map<String, List<AuthorizationPolicy>> parseAllAuthorizationPolicies(Kernel kernel, Logger logger) {\n+\n+        Map<String, List<AuthorizationPolicy>> authorizationPolicyMap = new HashMap<>();\n+\n+        Collection<EvergreenService> allServices = kernel.orderedDependencies();\n+        for (EvergreenService service : allServices) {\n+            Topics serviceConfig = service.getConfig();\n+\n+            if (serviceConfig == null) {\n+                logger.atWarn(\"load-authorization-service-config-retrieval-error\")\n+                        .log(\"No config found for service {}.\", service.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 143}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2499cfc563b65ba240723e5577e2568989880b0e", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2499cfc563b65ba240723e5577e2568989880b0e", "committedDate": "2020-08-08T01:49:20Z", "message": "Revised according to feedback"}, "afterCommit": {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/68a368746998c94522d4c36d57bf7fa3507330cc", "committedDate": "2020-08-10T17:53:07Z", "message": "Revised according to feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDg5MjU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464489254", "createdAt": "2020-08-10T18:53:34Z", "commit": {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTEyMTgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464512180", "createdAt": "2020-08-10T19:23:19Z", "commit": {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOToyMzoxOVrOG-cIFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxOTozMjo0MVrOG-cp3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNTcxNw==", "bodyText": "[nit]\nInject these for easier testing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468125717", "createdAt": "2020-08-10T19:23:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +36,61 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyNjMxOA==", "bodyText": "[nit]\nAdd a k-v for the Node's full name", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468126318", "createdAt": "2020-08-10T19:24:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -32,29 +36,61 @@\n public class AuthorizationHandler {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n+    private final AuthorizationModule authModule = new AuthorizationModule();\n+    private final AuthorizationPolicyParser policyParser = new AuthorizationPolicyParser();\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n      */\n     @Inject\n     public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n         this.kernel = kernel;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Subscribe to future auth config updates\n+        this.kernel.getConfig().getRoot().subscribe(\n+                (why, newv) -> {\n+                    if (newv == null) {\n+                        return;\n+                    }\n+                    if (!newv.childOf(ACCESS_CONTROL_NAMESPACE_TOPIC)) {\n+                        return;\n+                    }\n+                    if (!(newv instanceof Topic)) {\n+                        logger.atError(\"update-authorization-formatting-error\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEyOTg0Mg==", "bodyText": "But why is that a problem for the acl list to be empty? That is definitely possible to happen, right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468129842", "createdAt": "2020-08-10T19:26:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5Njk5MQ=="}, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMjE0Ng==", "bodyText": "Not sure I follow this logic. Can you explain more? How does registration work, and why can't it be done on-demand instead of during startup? Also, it can't just be during startup because things need to be dynamic.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468132146", "createdAt": "2020-08-10T19:28:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -106,62 +139,114 @@ public boolean isAuthorized(String destination, Permission permission) throws Au\n      * in future, whose operations might not be known at bootstrap.\n      * Operations are identifiers which the components intend to match for incoming requests by calling\n      * {@link #isAuthorized(String, Permission)} isAuthorized} method.\n+     *\n      * @param componentName Name of the component to be registered.\n-     * @param operations Set of operations the component needs to register with AuthZ.\n+     * @param operations    Set of operations the component needs to register with AuthZ.\n      * @throws AuthorizationException If component is already registered.\n      */\n     public void registerComponent(String componentName, Set<String> operations)\n             throws AuthorizationException {\n         if (Utils.isEmpty(operations) || Utils.isEmpty(componentName)) {\n             throw new AuthorizationException(\"Invalid arguments for registerComponent()\");\n         }\n-        if (componentToOperationsMap.containsKey(componentName)) {\n-            throw new AuthorizationException(\"Component already registered: \" + componentName);\n-        }\n-\n         operations.add(ANY_REGEX);\n         Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n-        componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+\n+        //Check if the component was previously registered\n+        if (componentToOperationsMap.containsKey(componentName)) {\n+            Set<String> existingOperations = componentToOperationsMap.get(componentName);\n+            if (!Utils.isEmpty(existingOperations)) {\n+                existingOperations.addAll(operationsCopy);\n+            }\n+        } else {\n+            componentToOperationsMap.putIfAbsent(componentName, operationsCopy);\n+        }\n     }\n \n     /**\n-     * Loads authZ policies for future auth lookups. The policies should not have confidential\n+     * Loads authZ policies for a single  component for future auth lookups. The policies should not have confidential\n      * values. This method assumes that the component names for principal and destination,\n      * the operations and resources must not be secret and can be logged or shared if required.\n+     * If the isUpdate flag is specified, this method will clear the existing policies for a component before\n+     * refreshing with the updated list.\n+     *\n      * @param componentName Destination component which intents to supply auth policies\n-     * @param policies policies which has list of policies. All policies are treated as separate\n-     *               and no merging or joins happen. Duplicated policies would result in duplicated\n-     *               permissions but would not impact functionality.\n-     * @throws AuthorizationException if there is a problem loading the policies.\n+     * @param policies      policies which has list of policies. All policies are treated as separate\n+     *                      and no merging or joins happen. Duplicated policies would result in duplicated\n+     *                      permissions but would not impact functionality.\n+     * @param isUpdate      If this load request is to update existing policies for a component.\n      */\n-    public void loadAuthorizationPolicy(String componentName, List<AuthorizationPolicy> policies)\n-            throws AuthorizationException {\n-        // TODO: Make this method atomic operation or thread safe for manipulating\n-        // underlying permission store.\n+    public void loadAuthorizationPolicies(String componentName, List<AuthorizationPolicy> policies, boolean isUpdate) {\n         if (Utils.isEmpty(policies)) {\n-            throw new AuthorizationException(\"policies is null/empty\");\n+            logger.atWarn(\"load-authorization-config-empty-acl\")\n+                    .log(\"Component {} has an empty access control list\", componentName);\n+            return;\n         }\n-        isComponentRegistered(componentName);\n-        validatePolicyId(policies);\n+        try {\n+            isComponentRegistered(componentName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NzYzOQ=="}, "originalCommit": {"oid": "0409dfb1f21c8c7c52a764b5860ed5f34d654fd4"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzMzQ4Mg==", "bodyText": "the enum isn't invalid, the value is invalid. Change this to \"UNKNOWN\" or \"INVALID_VALUE\"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468133482", "createdAt": "2020-08-10T19:30:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicy.java", "diffHunk": "@@ -11,10 +11,34 @@\n \n @Value\n @Builder\n-public class AuthorizationPolicy {\n+public class AuthorizationPolicy implements Comparable<AuthorizationPolicy> {\n     @NonNull String policyId;\n     String policyDescription;\n     @NonNull Set<String> principals;\n     @NonNull Set<String> operations;\n     Set<String> resources;\n+\n+    enum PolicyComponentTypes {\n+        POLICY_DESCRIPTION(\"policyDescription\"),\n+        PRINCIPALS(\"principals\"),\n+        OPERATIONS(\"operations\"),\n+        RESOURCES(\"resources\"),\n+        INVALID_ENUM(\"invalid_enum\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEzNDM2Ng==", "bodyText": "are we making this not a list?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468134366", "createdAt": "2020-08-10T19:32:41Z", "author": {"login": "MikeDombo"}, "path": "src/test/resources/com/aws/iot/evergreen/auth/pubsub_invalid_fields.yaml", "diffHunk": "@@ -0,0 +1,41 @@\n+---\n+services:\n+  main:\n+    dependencies:\n+      - IPCService\n+      - mqtt\n+      - ServiceName\n+    lifecycle:\n+\n+  mqtt:\n+    dependencies:\n+      - IPCService\n+    resources:\n+      - evergreen_1._mqtt._tcp.local\n+      - evergreen_1._http._tcp.local\n+    accessControl:\n+      aws.greengrass.ipc.pubsub:\n+        - policyId2:\n+            operations11:\n+              - \"publish\"\n+              - \"subscribe\"\n+\n+  ServiceName:\n+    dependencies:\n+      - IPCService\n+    resources:\n+      - http-resource\n+    lifecycle:\n+      run:\n+        windows:\n+          powershell -command sleep 100\n+        posix:\n+          sleep 100\n+    accessControl:\n+      aws.greengrass.ipc.pubsub:\n+        - policyId1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68a368746998c94522d4c36d57bf7fa3507330cc"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjQ0ODAx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464644801", "createdAt": "2020-08-10T23:05:00Z", "commit": {"oid": "94ef07ebab1e8b1bc05374de9caadfa6575119ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzowNTowMFrOG-irog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzowNTowMFrOG-irog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzEyMg==", "bodyText": "If you're using constructor injection, move this into the constructor instead. Unless there's a reason not to.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468233122", "createdAt": "2020-08-10T23:05:00Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -29,32 +38,81 @@\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler implements InjectionActions {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+\n+    private final AuthorizationPolicyParser policyParser;\n+\n+    @Override\n+    public void postInject() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ef07ebab1e8b1bc05374de9caadfa6575119ca"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjQ2OTUz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464646953", "createdAt": "2020-08-10T23:10:58Z", "commit": {"oid": "94ef07ebab1e8b1bc05374de9caadfa6575119ca"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoxMDo1OFrOG-iyqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoxMDo1OFrOG-iyqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNDkyMw==", "bodyText": "again, you could use instanceof instead of catching the exception.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468234923", "createdAt": "2020-08-10T23:10:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationPolicyParser.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.AuthorizationPolicy.PolicyComponentTypes;\n+import com.aws.iot.evergreen.auth.exceptions.AuthorizationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.ACCESS_CONTROL_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.util.Coerce.toEnum;\n+\n+public final class AuthorizationPolicyParser {\n+\n+    /**\n+     * Given a Topics ACL object, construct and return a List of AuthorizationPolicy objects that may exist.\n+     * Never returns null.\n+     *\n+     * @param componentName      String\n+     * @param accessControlTopic Topic\n+     * @param logger             Logger\n+     * @return {@List} of {@AuthorizationPolicy}'s\n+     * @throws AuthorizationException if there is a problem loading the policies.\n+     */\n+    public List<AuthorizationPolicy> parseAuthorizationPolicyList(String componentName, Topic accessControlTopic,\n+                                                                  Logger logger) {\n+        List<AuthorizationPolicy> newAuthorizationPolicyList = new ArrayList<>();\n+\n+        Object accessControlTopicObject = accessControlTopic.getOnce();\n+\n+        if (!(accessControlTopicObject instanceof List)\n+                || Utils.isEmpty((List) accessControlTopicObject)\n+                || !(((List) accessControlTopicObject).get(0) instanceof Map)) {\n+            logger.atWarn(\"load-authorization-access-control-list-retrieval-error\")\n+                    .log(\"Access Control List is missing or invalid for component {}\", componentName);\n+            return newAuthorizationPolicyList;\n+        }\n+\n+        List<Map<String, Object>> accessControlList = (List<Map<String, Object>>) accessControlTopicObject;\n+\n+        //Iterate through each policy\n+        for (Map<String, Object> allPoliciesMap : accessControlList) {\n+            for (Map.Entry policyEntry : allPoliciesMap.entrySet()) {\n+\n+                //Initialize these components to null\n+                String policyDescription = null;\n+                Set<String> operations = null;\n+                Set<String> resources = null;\n+\n+                Map<String, Object> policyMap;\n+\n+                try {\n+                    //Retrieve the actual policy specifications\n+                    policyMap = (Map<String, Object>) policyEntry.getValue();\n+                } catch (ClassCastException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94ef07ebab1e8b1bc05374de9caadfa6575119ca"}, "originalPosition": 67}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94ef07ebab1e8b1bc05374de9caadfa6575119ca", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/94ef07ebab1e8b1bc05374de9caadfa6575119ca", "committedDate": "2020-08-10T23:00:08Z", "message": "Minor cleanup"}, "afterCommit": {"oid": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "committedDate": "2020-08-10T23:11:44Z", "message": "Initial AuthZ Pub/Sub Integration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d01e679683db12e548169c3380e42f1f1b57bc7", "committedDate": "2020-08-10T23:27:06Z", "message": " Initial AuthZ Pub/Sub Integration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjUyOTQ3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464652947", "createdAt": "2020-08-10T23:28:13Z", "commit": {"oid": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/363353e41bf65d4645f7db6b3e9bea0f2eb4a325", "committedDate": "2020-08-10T23:11:44Z", "message": "Initial AuthZ Pub/Sub Integration"}, "afterCommit": {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5d01e679683db12e548169c3380e42f1f1b57bc7", "committedDate": "2020-08-10T23:27:06Z", "message": " Initial AuthZ Pub/Sub Integration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjkwOTk3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464690997", "createdAt": "2020-08-11T01:32:23Z", "commit": {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMTozMjoyM1rOG-lSMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMTozMjoyM1rOG-lSMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI3NTc2MQ==", "bodyText": "Why are we loading tes here? Can tes load itself?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#discussion_r468275761", "createdAt": "2020-08-11T01:32:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthorizationHandler.java", "diffHunk": "@@ -29,32 +37,73 @@\n  * and not for storage.\n  */\n @Singleton\n-public class AuthorizationHandler {\n+public class AuthorizationHandler  {\n     private static final String ANY_REGEX = \"*\";\n     private static final Logger logger = LogManager.getLogger(AuthorizationHandler.class);\n-    private final AuthorizationModule authModule;\n     private final ConcurrentHashMap<String, Set<String>> componentToOperationsMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, List<AuthorizationPolicy>>\n             componentToAuthZConfig = new ConcurrentHashMap<>();\n     private final Kernel kernel;\n \n+    private final AuthorizationModule authModule;\n+    \n     /**\n      * Constructor for AuthZ.\n+     *\n      * @param kernel kernel module for getting component information\n+     * @param authModule authorization module to store the authorization state\n+     * @param policyParser for parsing a given policy ACL\n      */\n     @Inject\n-    public AuthorizationHandler(Kernel kernel) {\n-        authModule = new AuthorizationModule();\n+    public AuthorizationHandler(Kernel kernel,  AuthorizationModule authModule,\n+                                AuthorizationPolicyParser policyParser) {\n         this.kernel = kernel;\n+        this.authModule = authModule;\n+\n+        Map<String, List<AuthorizationPolicy>> componentNameToPolicies = policyParser.parseAllAuthorizationPolicies(\n+                kernel, logger);\n+        for (Map.Entry<String, List<AuthorizationPolicy>> acl : componentNameToPolicies.entrySet()) {\n+            this.loadAuthorizationPolicies(acl.getKey(), acl.getValue(), false);\n+        }\n+\n+        //Load default policy for TES\n+        this.loadAuthorizationPolicies(TOKEN_EXCHANGE_SERVICE_TOPICS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Njk5ODI0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464699824", "createdAt": "2020-08-11T02:03:25Z", "commit": {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzAwMjkw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/340#pullrequestreview-464700290", "createdAt": "2020-08-11T02:05:16Z", "commit": {"oid": "5d01e679683db12e548169c3380e42f1f1b57bc7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6f79ca3724dda9bde072197472dee8d3865140e", "author": {"user": {"login": "avipinku", "name": "Ashay Vipinkumar"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6f79ca3724dda9bde072197472dee8d3865140e", "committedDate": "2020-08-11T02:26:33Z", "message": "Merge branch 'master' into authZ_pubsub"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2966, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}