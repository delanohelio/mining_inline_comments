{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3ODgxNTM4", "number": 153, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMToxMTowNVrODuLE8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NzowMlrODvN0tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzQyNTc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMToxMTowNVrOGABy6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMzo1Mzo1MlrOGAEQSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjYwMg==", "bodyText": "I know why you did this, but I don't feel that this is appropriately fixing it. The reason why it failed is that the subscriber is called immediately during the subscribe. Which I think we do want, since that will immediately cause the service to restart and wait for the dependency to come up. With the change that you've made it will not do this; instead it would need the dependency to change state again before triggering this handling.\nI think one potential fix is to overload dependencyReady with an extra parameter for the startWhen state. Alternatively, just remove the start when state because I think we've been talking about getting rid of it for a while.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402682602", "createdAt": "2020-04-03T01:11:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -758,7 +758,8 @@ public synchronized void addOrUpdateDependency(\n     private Subscriber createDependencySubscriber(EvergreenService dependentEvergreenService) {\n         return (WhatHappened what, Topic t) -> {\n             if (this.getState() == State.INSTALLED || this.getState() == State.RUNNING) {\n-                if (!dependencyReady(dependentEvergreenService)) {\n+                if (dependencies.containsKey(dependentEvergreenService)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5MzI2Mg==", "bodyText": "We're not using startWhen? Do we allow specify dependency on different states?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402693262", "createdAt": "2020-04-03T01:51:56Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -758,7 +758,8 @@ public synchronized void addOrUpdateDependency(\n     private Subscriber createDependencySubscriber(EvergreenService dependentEvergreenService) {\n         return (WhatHappened what, Topic t) -> {\n             if (this.getState() == State.INSTALLED || this.getState() == State.RUNNING) {\n-                if (!dependencyReady(dependentEvergreenService)) {\n+                if (dependencies.containsKey(dependentEvergreenService)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjYwMg=="}, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDAzNw==", "bodyText": "It is allowed, but I know that Shirley has talked about removing it. We're not really using it at this time. All startWhen is just Running.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402694037", "createdAt": "2020-04-03T01:55:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -758,7 +758,8 @@ public synchronized void addOrUpdateDependency(\n     private Subscriber createDependencySubscriber(EvergreenService dependentEvergreenService) {\n         return (WhatHappened what, Topic t) -> {\n             if (this.getState() == State.INSTALLED || this.getState() == State.RUNNING) {\n-                if (!dependencyReady(dependentEvergreenService)) {\n+                if (dependencies.containsKey(dependentEvergreenService)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjYwMg=="}, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDg3OQ==", "bodyText": "Given that we'll want hot pluggability, maybe instead you should change the signature to take a DependencyInfo, that way you can pass it in directly instead of reading it from the dependency map since it doesn't exist at that point.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402694879", "createdAt": "2020-04-03T01:58:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -758,7 +758,8 @@ public synchronized void addOrUpdateDependency(\n     private Subscriber createDependencySubscriber(EvergreenService dependentEvergreenService) {\n         return (WhatHappened what, Topic t) -> {\n             if (this.getState() == State.INSTALLED || this.getState() == State.RUNNING) {\n-                if (!dependencyReady(dependentEvergreenService)) {\n+                if (dependencies.containsKey(dependentEvergreenService)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjYwMg=="}, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjg5MQ==", "bodyText": "I modified to pass in the startWhen.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402722891", "createdAt": "2020-04-03T03:53:52Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -758,7 +758,8 @@ public synchronized void addOrUpdateDependency(\n     private Subscriber createDependencySubscriber(EvergreenService dependentEvergreenService) {\n         return (WhatHappened what, Topic t) -> {\n             if (this.getState() == State.INSTALLED || this.getState() == State.RUNNING) {\n-                if (!dependencyReady(dependentEvergreenService)) {\n+                if (dependencies.containsKey(dependentEvergreenService)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjYwMg=="}, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzQyNzAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMToxMTo0M1rOGABzlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMToxMTo0M1rOGABzlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4Mjc3Mw==", "bodyText": "nit\ncreatePaths", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402682773", "createdAt": "2020-04-03T01:11:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -202,10 +209,7 @@ private void initPaths(String rootAbsolutePath) {\n         Exec.addFirstPath(clitoolPath);\n         workPath = Paths.get(deTilde(workPathName));\n         Exec.setDefaultEnv(\"HOME\", workPath.toString());\n-        ensureCreated(configPath);\n-        ensureCreated(clitoolPath);\n-        ensureCreated(rootPath);\n-        ensureCreated(workPath);\n+        createPath(rootPath, configPath, clitoolPath, workPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzQyOTMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMToxMzowNlrOGAB06Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMzo1Mjo1N1rOGAEPfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzExMw==", "bodyText": "Can this be scoped down from throwable? Maybe IOException?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402683113", "createdAt": "2020-04-03T01:13:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -247,37 +248,38 @@ public Kernel launch() {\n         }\n         Path transactionLogPath = configPath.resolve(\"config.tlog\"); //Paths.get(deTilde(\"~root/config/config.tlog\"));\n         Path configurationFile = configPath.resolve(\"config.yaml\"); //Paths.get(deTilde(\"~root/config/config.yaml\"));\n-        if (!broken) {\n-            try {\n-                if (haveRead) {\n-                    // new config file came in from the outside\n-                    writeEffectiveConfig(configurationFile);\n-                    Files.deleteIfExists(transactionLogPath);\n-                } else {\n-                    if (Files.exists(configurationFile)) {\n-                        read(configurationFile);\n-                    }\n-                    if (Files.exists(transactionLogPath)) {\n-                        read(transactionLogPath);\n-                    }\n+        try {\n+            mainService = EvergreenService.locate(context, mainServiceName);\n+        } catch (ServiceLoadException sle) {\n+            RuntimeException rte =\n+                    new RuntimeException(\"Cannot load main service\", sle);\n+            logger.atError().setEventType(\"system-boot-error\").setCause(rte);\n+            throw rte;\n+        }\n+        try {\n+            if (haveRead) {\n+                // new config file came in from the outside\n+                writeEffectiveConfig(configurationFile);\n+                Files.deleteIfExists(transactionLogPath);\n+            } else {\n+                if (Files.exists(configurationFile)) {\n+                    read(configurationFile);\n+                }\n+                if (Files.exists(transactionLogPath)) {\n+                    read(transactionLogPath);\n                 }\n-                tlog = ConfigurationWriter.logTransactionsTo(this, transactionLogPath);\n-                tlog.flushImmediately(true);\n-            } catch (Throwable ioe) {\n-                // Too early in the boot to log a message\n-                logger.atError().setEventType(\"system-config-error\").setCause(ioe).log();\n-                broken = true;\n-                return this;\n             }\n+            tlog = ConfigurationWriter.logTransactionsTo(this, transactionLogPath);\n+            tlog.flushImmediately(true);\n+        } catch (Throwable ioe) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyMjY4Ng==", "bodyText": "This will be revisited again. A lot of them haven't been cleaned up yet.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r402722686", "createdAt": "2020-04-03T03:52:57Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -247,37 +248,38 @@ public Kernel launch() {\n         }\n         Path transactionLogPath = configPath.resolve(\"config.tlog\"); //Paths.get(deTilde(\"~root/config/config.tlog\"));\n         Path configurationFile = configPath.resolve(\"config.yaml\"); //Paths.get(deTilde(\"~root/config/config.yaml\"));\n-        if (!broken) {\n-            try {\n-                if (haveRead) {\n-                    // new config file came in from the outside\n-                    writeEffectiveConfig(configurationFile);\n-                    Files.deleteIfExists(transactionLogPath);\n-                } else {\n-                    if (Files.exists(configurationFile)) {\n-                        read(configurationFile);\n-                    }\n-                    if (Files.exists(transactionLogPath)) {\n-                        read(transactionLogPath);\n-                    }\n+        try {\n+            mainService = EvergreenService.locate(context, mainServiceName);\n+        } catch (ServiceLoadException sle) {\n+            RuntimeException rte =\n+                    new RuntimeException(\"Cannot load main service\", sle);\n+            logger.atError().setEventType(\"system-boot-error\").setCause(rte);\n+            throw rte;\n+        }\n+        try {\n+            if (haveRead) {\n+                // new config file came in from the outside\n+                writeEffectiveConfig(configurationFile);\n+                Files.deleteIfExists(transactionLogPath);\n+            } else {\n+                if (Files.exists(configurationFile)) {\n+                    read(configurationFile);\n+                }\n+                if (Files.exists(transactionLogPath)) {\n+                    read(transactionLogPath);\n                 }\n-                tlog = ConfigurationWriter.logTransactionsTo(this, transactionLogPath);\n-                tlog.flushImmediately(true);\n-            } catch (Throwable ioe) {\n-                // Too early in the boot to log a message\n-                logger.atError().setEventType(\"system-config-error\").setCause(ioe).log();\n-                broken = true;\n-                return this;\n             }\n+            tlog = ConfigurationWriter.logTransactionsTo(this, transactionLogPath);\n+            tlog.flushImmediately(true);\n+        } catch (Throwable ioe) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzExMw=="}, "originalCommit": {"oid": "a67c291cd35575c664c6417f3d086757bbadebf0"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDA5MDQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNTozMToxMVrOGAak8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNTo1MzoxNFrOGAbcDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA4ODYyNA==", "bodyText": "This can be tricky. since this subscriber is created and added only once, if you update the same dependency with a different startWhen, it will not update the subscriber", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403088624", "createdAt": "2020-04-03T15:31:11Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -756,7 +756,7 @@ public synchronized void addOrUpdateDependency(\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n             if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n+                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService, startWhen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3b21c9b69007a4bea754be91dfbb34f06cccb8b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEwMjczNA==", "bodyText": "How about just removing the startWhen field?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403102734", "createdAt": "2020-04-03T15:53:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -756,7 +756,7 @@ public synchronized void addOrUpdateDependency(\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n             if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n+                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService, startWhen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA4ODYyNA=="}, "originalCommit": {"oid": "a3b21c9b69007a4bea754be91dfbb34f06cccb8b"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMTk2Njg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMTo1NzoyM1rOGAq5Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMjo0MjoyMFrOGArxHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM1NTk3OQ==", "bodyText": "Would it be crazy to just do this outside of the compute so that the value is in the map when dependencyRead() tries to look it up?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403355979", "createdAt": "2020-04-03T21:57:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -755,26 +755,17 @@ public synchronized void addOrUpdateDependency(\n         }\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n-            if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n-                dependentEvergreenService.getStateTopic().subscribe(subscriber);\n-                context.get(Kernel.class).clearODcache();\n-                return new DependencyInfo(startWhen, isDefault, subscriber);\n-            } else {\n-                dependencyInfo.startWhen = startWhen;\n-                // if a dependency is added as both a default and a non-default, treat it as default dependency\n-                if (!dependencyInfo.isDefaultDependency) {\n-                    dependencyInfo.isDefaultDependency = isDefault;\n-                }\n-                return dependencyInfo;\n-            }\n+            Subscriber subscriber = createDependencySubscriber(dependentEvergreenService, startWhen);\n+            dependentEvergreenService.getStateTopic().subscribe(subscriber);\n+            context.get(Kernel.class).clearODcache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d6f3d7cb143b91ee50bcefdf9ca1de8095a7ea7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2NTM4MA==", "bodyText": "Surely it will work, but is that much better than the current way? What's the benefit?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403365380", "createdAt": "2020-04-03T22:26:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -755,26 +755,17 @@ public synchronized void addOrUpdateDependency(\n         }\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n-            if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n-                dependentEvergreenService.getStateTopic().subscribe(subscriber);\n-                context.get(Kernel.class).clearODcache();\n-                return new DependencyInfo(startWhen, isDefault, subscriber);\n-            } else {\n-                dependencyInfo.startWhen = startWhen;\n-                // if a dependency is added as both a default and a non-default, treat it as default dependency\n-                if (!dependencyInfo.isDefaultDependency) {\n-                    dependencyInfo.isDefaultDependency = isDefault;\n-                }\n-                return dependencyInfo;\n-            }\n+            Subscriber subscriber = createDependencySubscriber(dependentEvergreenService, startWhen);\n+            dependentEvergreenService.getStateTopic().subscribe(subscriber);\n+            context.get(Kernel.class).clearODcache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM1NTk3OQ=="}, "originalCommit": {"oid": "9d6f3d7cb143b91ee50bcefdf9ca1de8095a7ea7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2NTkyMw==", "bodyText": "Just that passing everything through feels a bit ugly, especially when we need more than just the startWhen state.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403365923", "createdAt": "2020-04-03T22:27:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -755,26 +755,17 @@ public synchronized void addOrUpdateDependency(\n         }\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n-            if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n-                dependentEvergreenService.getStateTopic().subscribe(subscriber);\n-                context.get(Kernel.class).clearODcache();\n-                return new DependencyInfo(startWhen, isDefault, subscriber);\n-            } else {\n-                dependencyInfo.startWhen = startWhen;\n-                // if a dependency is added as both a default and a non-default, treat it as default dependency\n-                if (!dependencyInfo.isDefaultDependency) {\n-                    dependencyInfo.isDefaultDependency = isDefault;\n-                }\n-                return dependencyInfo;\n-            }\n+            Subscriber subscriber = createDependencySubscriber(dependentEvergreenService, startWhen);\n+            dependentEvergreenService.getStateTopic().subscribe(subscriber);\n+            context.get(Kernel.class).clearODcache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM1NTk3OQ=="}, "originalCommit": {"oid": "9d6f3d7cb143b91ee50bcefdf9ca1de8095a7ea7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM3MDI3MQ==", "bodyText": "I'm not sure if I completely get what you propose. If we try to construct the DependencyInfo outside and put it to dependencies, we can only construct it partially without the subscriber field and later we need to set the subscriber field. It's not ideal either.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403370271", "createdAt": "2020-04-03T22:42:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -755,26 +755,17 @@ public synchronized void addOrUpdateDependency(\n         }\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n-            if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n-                dependentEvergreenService.getStateTopic().subscribe(subscriber);\n-                context.get(Kernel.class).clearODcache();\n-                return new DependencyInfo(startWhen, isDefault, subscriber);\n-            } else {\n-                dependencyInfo.startWhen = startWhen;\n-                // if a dependency is added as both a default and a non-default, treat it as default dependency\n-                if (!dependencyInfo.isDefaultDependency) {\n-                    dependencyInfo.isDefaultDependency = isDefault;\n-                }\n-                return dependencyInfo;\n-            }\n+            Subscriber subscriber = createDependencySubscriber(dependentEvergreenService, startWhen);\n+            dependentEvergreenService.getStateTopic().subscribe(subscriber);\n+            context.get(Kernel.class).clearODcache();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM1NTk3OQ=="}, "originalCommit": {"oid": "9d6f3d7cb143b91ee50bcefdf9ca1de8095a7ea7"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjE0ODczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMzoyODoyN1rOGAshhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMzozNzoxNVrOGAspag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4MjY2MQ==", "bodyText": "Why do we want to resubscribe all the time? I believe we ought to be using computeIfAbsent and then just subscribing once.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403382661", "createdAt": "2020-04-03T23:28:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -755,26 +755,22 @@ public synchronized void addOrUpdateDependency(\n         }\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n-            if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n-                dependentEvergreenService.getStateTopic().subscribe(subscriber);\n-                context.get(Kernel.class).clearODcache();\n-                return new DependencyInfo(startWhen, isDefault, subscriber);\n-            } else {\n-                dependencyInfo.startWhen = startWhen;\n-                // if a dependency is added as both a default and a non-default, treat it as default dependency\n-                if (!dependencyInfo.isDefaultDependency) {\n-                    dependencyInfo.isDefaultDependency = isDefault;\n-                }\n-                return dependencyInfo;\n+            // If the dependency already exists, we should first remove the subscriber before creating the\n+            // new subscriber with updated input.\n+            if (dependencyInfo != null) {\n+                dependentEvergreenService.getStateTopic().remove(dependencyInfo.stateTopicSubscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f96a319bb54e7ddb2babb2a2e492e645da2c7d14"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NDMyNQ==", "bodyText": "If startWhenState is updated, don't we need to create a different subscriber?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403384325", "createdAt": "2020-04-03T23:35:28Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -755,26 +755,22 @@ public synchronized void addOrUpdateDependency(\n         }\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n-            if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n-                dependentEvergreenService.getStateTopic().subscribe(subscriber);\n-                context.get(Kernel.class).clearODcache();\n-                return new DependencyInfo(startWhen, isDefault, subscriber);\n-            } else {\n-                dependencyInfo.startWhen = startWhen;\n-                // if a dependency is added as both a default and a non-default, treat it as default dependency\n-                if (!dependencyInfo.isDefaultDependency) {\n-                    dependencyInfo.isDefaultDependency = isDefault;\n-                }\n-                return dependencyInfo;\n+            // If the dependency already exists, we should first remove the subscriber before creating the\n+            // new subscriber with updated input.\n+            if (dependencyInfo != null) {\n+                dependentEvergreenService.getStateTopic().remove(dependencyInfo.stateTopicSubscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4MjY2MQ=="}, "originalCommit": {"oid": "f96a319bb54e7ddb2babb2a2e492e645da2c7d14"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NDY4Mg==", "bodyText": "Oh, maybe. If the subscriber is pulling the startWhenState from the lambda's closure.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r403384682", "createdAt": "2020-04-03T23:37:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -755,26 +755,22 @@ public synchronized void addOrUpdateDependency(\n         }\n \n         dependencies.compute(dependentEvergreenService, (dependentService, dependencyInfo) -> {\n-            if (dependencyInfo == null) {\n-                Subscriber subscriber = createDependencySubscriber(dependentEvergreenService);\n-                dependentEvergreenService.getStateTopic().subscribe(subscriber);\n-                context.get(Kernel.class).clearODcache();\n-                return new DependencyInfo(startWhen, isDefault, subscriber);\n-            } else {\n-                dependencyInfo.startWhen = startWhen;\n-                // if a dependency is added as both a default and a non-default, treat it as default dependency\n-                if (!dependencyInfo.isDefaultDependency) {\n-                    dependencyInfo.isDefaultDependency = isDefault;\n-                }\n-                return dependencyInfo;\n+            // If the dependency already exists, we should first remove the subscriber before creating the\n+            // new subscriber with updated input.\n+            if (dependencyInfo != null) {\n+                dependentEvergreenService.getStateTopic().remove(dependencyInfo.stateTopicSubscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4MjY2MQ=="}, "originalCommit": {"oid": "f96a319bb54e7ddb2babb2a2e492e645da2c7d14"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODM1NzY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NjowM1rOGBgtBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzoyMToyNlrOGBiFPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzU3Mw==", "bodyText": "add \".log()\" in the end. Also is it good to log the error and throw it at the same time?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r404237573", "createdAt": "2020-04-06T16:46:03Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -141,8 +140,13 @@ public Kernel parseArgs(String... args) {\n                         read(deTilde(getArg()));\n                         haveRead = true;\n                     } catch (Throwable ex) {\n-                        broken = true;\n-                        logger.atError().log(\"Can't read config file {}\", arg, ex.getLocalizedMessage());\n+                        // Usually we don't want to log and throw at the same time because it can produce duplicate logs\n+                        // if the handler of the exception also logs. However since we use structured logging, I\n+                        // decide to log the error so that the future logging parser can parse the exceptions.\n+                        RuntimeException rte =\n+                                new RuntimeException(String.format(\"Can't read the config file %s\", getArg()), ex);\n+                        logger.atError().setEventType(\"parse-args-error\").setCause(rte);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a70d3730f9530e5bd20f25f772b367b20362dc1c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2MDE1OQ==", "bodyText": "As I explained in the comment, since we're doing structure logging, I think it's better to log the error too so that if we going to use a tool to parse the log, the error log won't be lost.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r404260159", "createdAt": "2020-04-06T17:21:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -141,8 +140,13 @@ public Kernel parseArgs(String... args) {\n                         read(deTilde(getArg()));\n                         haveRead = true;\n                     } catch (Throwable ex) {\n-                        broken = true;\n-                        logger.atError().log(\"Can't read config file {}\", arg, ex.getLocalizedMessage());\n+                        // Usually we don't want to log and throw at the same time because it can produce duplicate logs\n+                        // if the handler of the exception also logs. However since we use structured logging, I\n+                        // decide to log the error so that the future logging parser can parse the exceptions.\n+                        RuntimeException rte =\n+                                new RuntimeException(String.format(\"Can't read the config file %s\", getArg()), ex);\n+                        logger.atError().setEventType(\"parse-args-error\").setCause(rte);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzU3Mw=="}, "originalCommit": {"oid": "a70d3730f9530e5bd20f25f772b367b20362dc1c"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODM1ODM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NjoxNFrOGBgtfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NjoxNFrOGBgtfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzY5Mw==", "bodyText": "Ditto", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r404237693", "createdAt": "2020-04-06T16:46:14Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -160,19 +164,17 @@ public Kernel parseArgs(String... args) {\n                     rootAbsolutePath = getArg();\n                     break;\n                 default:\n-                    logger.atError().log(\"Undefined command line argument: {}\", arg);\n-                    broken = true;\n-                    break;\n+                    RuntimeException rte =\n+                            new RuntimeException(String.format(\"Undefined command line argument: %s\", arg));\n+                    logger.atError().setEventType(\"parse-args-error\").setCause(rte);\n+                    throw rte;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a70d3730f9530e5bd20f25f772b367b20362dc1c"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODM2MTUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NzowMlrOGBgvig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNjoxMFrOGBipXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzODIxOA==", "bodyText": "Curious, is it only available to Linux?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r404238218", "createdAt": "2020-04-06T16:47:02Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -297,48 +294,36 @@ public Kernel launch() {\n             });\n         } catch (Throwable ex) {\n             logger.atError().setEventType(\"system-boot-error\").setCause(ex)\n-                    .log(\"***BOOT FAILED, SWITCHING TO FALLBACKMAIN*** \");\n-            mainServiceName = \"fallbackMain\";\n-            try {\n-                mainService = getMain();\n-            } catch (Throwable t) {\n-                logger.atError().setEventType(\"system-boot-error\").setCause(t)\n-                        .log(\"***FALLBACK BOOT FAILED, ABANDON ALL HOPE*** \");\n-            }\n+                    .log(\"***BOOT FAILED, EXITING*** \");\n+            // The error is not recoverable, throw the exception up.\n+            throw ex;\n         }\n         writeEffectiveConfig();\n-        try {\n-            logger.atInfo().setEventType(\"system-start\").addKeyValue(\"main\", getMain()).log();\n-            startupAllServices();\n-        } catch (Throwable ex) {\n-            logger.atError().setEventType(\"service-start-error\").setCause(ex).log();\n-        }\n+        logger.atInfo().setEventType(\"system-start\").addKeyValue(\"main\", getMain()).log();\n+        startupAllServices();\n+\n         return this;\n     }\n \n-    private boolean ensureCreated(Path p) {\n-        try {\n-            Files.createDirectories(p,\n-                    PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\")));\n-            return true;\n-        } catch (IOException ex) {\n-            logger.atError().setEventType(\"file-path-create-error\").setCause(ex).addKeyValue(\"filePath\", p).log();\n-            return false;\n+    private void createPaths(Path... paths) {\n+        for (Path p: paths) {\n+            try {\n+                Files.createDirectories(p,\n+                        PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a70d3730f9530e5bd20f25f772b367b20362dc1c"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI2OTQwNQ==", "bodyText": "It is available in some of the Windows that are posix-compliant. We'll need to revisit this when we're testing on Windows.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/153#discussion_r404269405", "createdAt": "2020-04-06T17:36:10Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -297,48 +294,36 @@ public Kernel launch() {\n             });\n         } catch (Throwable ex) {\n             logger.atError().setEventType(\"system-boot-error\").setCause(ex)\n-                    .log(\"***BOOT FAILED, SWITCHING TO FALLBACKMAIN*** \");\n-            mainServiceName = \"fallbackMain\";\n-            try {\n-                mainService = getMain();\n-            } catch (Throwable t) {\n-                logger.atError().setEventType(\"system-boot-error\").setCause(t)\n-                        .log(\"***FALLBACK BOOT FAILED, ABANDON ALL HOPE*** \");\n-            }\n+                    .log(\"***BOOT FAILED, EXITING*** \");\n+            // The error is not recoverable, throw the exception up.\n+            throw ex;\n         }\n         writeEffectiveConfig();\n-        try {\n-            logger.atInfo().setEventType(\"system-start\").addKeyValue(\"main\", getMain()).log();\n-            startupAllServices();\n-        } catch (Throwable ex) {\n-            logger.atError().setEventType(\"service-start-error\").setCause(ex).log();\n-        }\n+        logger.atInfo().setEventType(\"system-start\").addKeyValue(\"main\", getMain()).log();\n+        startupAllServices();\n+\n         return this;\n     }\n \n-    private boolean ensureCreated(Path p) {\n-        try {\n-            Files.createDirectories(p,\n-                    PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\")));\n-            return true;\n-        } catch (IOException ex) {\n-            logger.atError().setEventType(\"file-path-create-error\").setCause(ex).addKeyValue(\"filePath\", p).log();\n-            return false;\n+    private void createPaths(Path... paths) {\n+        for (Path p: paths) {\n+            try {\n+                Files.createDirectories(p,\n+                        PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwx------\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzODIxOA=="}, "originalCommit": {"oid": "a70d3730f9530e5bd20f25f772b367b20362dc1c"}, "originalPosition": 182}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4986, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}