{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExOTkzMTgx", "number": 580, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToxNTozNFrOEzfFmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTo1NzoxNlrOEzf1Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDIyMTcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToxNTozNFrOHqvAOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToxNjo0NFrOHqvCYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3MjM0NQ==", "bodyText": "Configuration is labelled as Deprecated.  What the reason of adding this if block?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/580#discussion_r514572345", "createdAt": "2020-10-29T21:15:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -251,6 +251,12 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n             DeploymentPackageConfiguration packageConfiguration = optionalDeploymentPackageConfig.get();\n             optionalConfigUpdate = Optional.ofNullable(packageConfiguration.getConfigurationUpdateOperation());\n \n+            if (!optionalConfigUpdate.isPresent() && packageConfiguration.getConfiguration() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a24ba85932d0df49f07bbc9a4821436ec191a3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3Mjg5OA==", "bodyText": "It makes it work with the old-style CLI which uses --params instead of --update-config. We haven't switched over yet. This is required for compatibility.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/580#discussion_r514572898", "createdAt": "2020-10-29T21:16:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -251,6 +251,12 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n             DeploymentPackageConfiguration packageConfiguration = optionalDeploymentPackageConfig.get();\n             optionalConfigUpdate = Optional.ofNullable(packageConfiguration.getConfigurationUpdateOperation());\n \n+            if (!optionalConfigUpdate.isPresent() && packageConfiguration.getConfiguration() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3MjM0NQ=="}, "originalCommit": {"oid": "c4a24ba85932d0df49f07bbc9a4821436ec191a3"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDM0MzM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTo1NzoxNlrOHqwLAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTo1OTozMlrOHqwOuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MTQ4OQ==", "bodyText": "Is there any side effect of merge the configuration here? For example, can a subscriber to a config key be triggered here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/580#discussion_r514591489", "createdAt": "2020-10-29T21:57:16Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -275,140 +281,101 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n      *\n      * @param configurationUpdateOperation nullable component configuration update operation.\n      * @param componentRecipe              component recipe containing default configuration.\n+     * @param document                     deployment document\n      * @return resolved configuration for this component. non null.\n      */\n     private Map<String, Object> resolveConfigurationToApply(\n-            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe,\n+            DeploymentDocument document) {\n \n         // try read the running service config\n-        Map<String, Object> currentRunningConfig = null;\n-\n-        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n-        if (serviceTopics != null) {\n-            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n-            if (configuration != null) {\n-                currentRunningConfig = configuration.toPOJO();\n+        try (Context context = new Context()) {\n+            Configuration currentRunningConfig = new Configuration(context);\n+\n+            // Copy from running config (if any)\n+            Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+            if (serviceTopics != null) {\n+                Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+                if (configuration != null) {\n+                    currentRunningConfig.copyFrom(configuration);\n+                }\n             }\n-        }\n-\n-        // get default config\n-        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n-                .map(ComponentConfiguration::getDefaultConfiguration)\n-                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n \n-        // no update\n-        if (configurationUpdateOperation == null) {\n-            if (currentRunningConfig == null) {\n-                // no update nor running config, so it should return return the default config.\n-                return MAPPER.convertValue(defaultConfig, Map.class);\n-            } else {\n-                // no update but there is running config, so it should return running config as is.\n-                return currentRunningConfig;\n+            // Remove keys which want to be reset to their default value\n+            if (configurationUpdateOperation != null) {\n+                removeKeysFromConfigWhichAreReset(currentRunningConfig, configurationUpdateOperation.getPathsToReset());\n             }\n-        }\n-\n-        // perform RESET and then MERGE in order\n-        Map<String, Object> resolvedConfig;\n-\n-        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n \n-        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+            // Merge in the defaults with timestamp 1 so that they don't overwrite any pre-existing values\n+            JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                    .map(ComponentConfiguration::getDefaultConfiguration)\n+                    .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+            // Merge in the defaults from the recipe using timestamp 1 to denote a default\n+            currentRunningConfig.mergeMap(1, MAPPER.convertValue(defaultConfig, Map.class));\n+            currentRunningConfig.context.runOnPublishQueueAndWait(() -> {});\n+\n+            // Merge in the requested config updates\n+            if (configurationUpdateOperation != null && configurationUpdateOperation.getValueToMerge() != null) {\n+                currentRunningConfig.mergeMap(document.getTimestamp(), configurationUpdateOperation.getValueToMerge());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a24ba85932d0df49f07bbc9a4821436ec191a3"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MTg3NA==", "bodyText": "No, no subscribers because this is an entirely new config object", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/580#discussion_r514591874", "createdAt": "2020-10-29T21:58:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -275,140 +281,101 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n      *\n      * @param configurationUpdateOperation nullable component configuration update operation.\n      * @param componentRecipe              component recipe containing default configuration.\n+     * @param document                     deployment document\n      * @return resolved configuration for this component. non null.\n      */\n     private Map<String, Object> resolveConfigurationToApply(\n-            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe,\n+            DeploymentDocument document) {\n \n         // try read the running service config\n-        Map<String, Object> currentRunningConfig = null;\n-\n-        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n-        if (serviceTopics != null) {\n-            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n-            if (configuration != null) {\n-                currentRunningConfig = configuration.toPOJO();\n+        try (Context context = new Context()) {\n+            Configuration currentRunningConfig = new Configuration(context);\n+\n+            // Copy from running config (if any)\n+            Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+            if (serviceTopics != null) {\n+                Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+                if (configuration != null) {\n+                    currentRunningConfig.copyFrom(configuration);\n+                }\n             }\n-        }\n-\n-        // get default config\n-        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n-                .map(ComponentConfiguration::getDefaultConfiguration)\n-                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n \n-        // no update\n-        if (configurationUpdateOperation == null) {\n-            if (currentRunningConfig == null) {\n-                // no update nor running config, so it should return return the default config.\n-                return MAPPER.convertValue(defaultConfig, Map.class);\n-            } else {\n-                // no update but there is running config, so it should return running config as is.\n-                return currentRunningConfig;\n+            // Remove keys which want to be reset to their default value\n+            if (configurationUpdateOperation != null) {\n+                removeKeysFromConfigWhichAreReset(currentRunningConfig, configurationUpdateOperation.getPathsToReset());\n             }\n-        }\n-\n-        // perform RESET and then MERGE in order\n-        Map<String, Object> resolvedConfig;\n-\n-        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n \n-        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+            // Merge in the defaults with timestamp 1 so that they don't overwrite any pre-existing values\n+            JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                    .map(ComponentConfiguration::getDefaultConfiguration)\n+                    .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+            // Merge in the defaults from the recipe using timestamp 1 to denote a default\n+            currentRunningConfig.mergeMap(1, MAPPER.convertValue(defaultConfig, Map.class));\n+            currentRunningConfig.context.runOnPublishQueueAndWait(() -> {});\n+\n+            // Merge in the requested config updates\n+            if (configurationUpdateOperation != null && configurationUpdateOperation.getValueToMerge() != null) {\n+                currentRunningConfig.mergeMap(document.getTimestamp(), configurationUpdateOperation.getValueToMerge());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MTQ4OQ=="}, "originalCommit": {"oid": "c4a24ba85932d0df49f07bbc9a4821436ec191a3"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MjQ0Mw==", "bodyText": "And I create a new temporary Context so that the events which are triggered aren't on the main publish thread.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/580#discussion_r514592443", "createdAt": "2020-10-29T21:59:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/componentmanager/KernelConfigResolver.java", "diffHunk": "@@ -275,140 +281,101 @@ public KernelConfigResolver(ComponentStore componentStore, Kernel kernel, Nucleu\n      *\n      * @param configurationUpdateOperation nullable component configuration update operation.\n      * @param componentRecipe              component recipe containing default configuration.\n+     * @param document                     deployment document\n      * @return resolved configuration for this component. non null.\n      */\n     private Map<String, Object> resolveConfigurationToApply(\n-            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe) {\n+            @Nullable ConfigurationUpdateOperation configurationUpdateOperation, ComponentRecipe componentRecipe,\n+            DeploymentDocument document) {\n \n         // try read the running service config\n-        Map<String, Object> currentRunningConfig = null;\n-\n-        Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n-        if (serviceTopics != null) {\n-            Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n-            if (configuration != null) {\n-                currentRunningConfig = configuration.toPOJO();\n+        try (Context context = new Context()) {\n+            Configuration currentRunningConfig = new Configuration(context);\n+\n+            // Copy from running config (if any)\n+            Topics serviceTopics = kernel.findServiceTopic(componentRecipe.getComponentName());\n+            if (serviceTopics != null) {\n+                Topics configuration = serviceTopics.findTopics(CONFIGURATION_CONFIG_KEY);\n+                if (configuration != null) {\n+                    currentRunningConfig.copyFrom(configuration);\n+                }\n             }\n-        }\n-\n-        // get default config\n-        JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n-                .map(ComponentConfiguration::getDefaultConfiguration)\n-                .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n \n-        // no update\n-        if (configurationUpdateOperation == null) {\n-            if (currentRunningConfig == null) {\n-                // no update nor running config, so it should return return the default config.\n-                return MAPPER.convertValue(defaultConfig, Map.class);\n-            } else {\n-                // no update but there is running config, so it should return running config as is.\n-                return currentRunningConfig;\n+            // Remove keys which want to be reset to their default value\n+            if (configurationUpdateOperation != null) {\n+                removeKeysFromConfigWhichAreReset(currentRunningConfig, configurationUpdateOperation.getPathsToReset());\n             }\n-        }\n-\n-        // perform RESET and then MERGE in order\n-        Map<String, Object> resolvedConfig;\n-\n-        resolvedConfig = reset(currentRunningConfig, defaultConfig, configurationUpdateOperation.getPathsToReset());\n \n-        resolvedConfig = deepMerge(resolvedConfig, configurationUpdateOperation.getValueToMerge());\n+            // Merge in the defaults with timestamp 1 so that they don't overwrite any pre-existing values\n+            JsonNode defaultConfig = Optional.ofNullable(componentRecipe.getComponentConfiguration())\n+                    .map(ComponentConfiguration::getDefaultConfiguration)\n+                    .orElse(MAPPER.createObjectNode()); // init null to be empty default config\n+            // Merge in the defaults from the recipe using timestamp 1 to denote a default\n+            currentRunningConfig.mergeMap(1, MAPPER.convertValue(defaultConfig, Map.class));\n+            currentRunningConfig.context.runOnPublishQueueAndWait(() -> {});\n+\n+            // Merge in the requested config updates\n+            if (configurationUpdateOperation != null && configurationUpdateOperation.getValueToMerge() != null) {\n+                currentRunningConfig.mergeMap(document.getTimestamp(), configurationUpdateOperation.getValueToMerge());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MTQ4OQ=="}, "originalCommit": {"oid": "c4a24ba85932d0df49f07bbc9a4821436ec191a3"}, "originalPosition": 146}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 407, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}