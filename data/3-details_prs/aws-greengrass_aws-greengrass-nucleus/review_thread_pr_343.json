{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMzI3NTg0", "number": 343, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoxNzoyOVrOEUIacQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoyODo0MFrOEUJsCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTQ0ODE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/AuthenticationHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoxNzoyOVrOG6P_kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxNjo0OFrOG6Rs3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMjYyNw==", "bodyText": "rename to doAuthentication", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463732627", "createdAt": "2020-07-31T17:17:29Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/AuthenticationHandler.java", "diffHunk": "@@ -63,28 +63,39 @@ public static void registerAuthToken(EvergreenService s) {\n      * @param message       incoming message frame to be validated.\n      * @param remoteAddress remote address the client is connected from\n      * @return RequestContext containing the server name if validated.\n-     * @throws IPCClientNotAuthorizedException thrown if not authorized, or any other error happens.\n+     * @throws UnauthenticatedException thrown if not authorized, or any other error happens.\n      */\n     public ConnectionContext doAuth(FrameReader.Message message, SocketAddress remoteAddress)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2MDYwNA==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463760604", "createdAt": "2020-07-31T18:16:48Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/AuthenticationHandler.java", "diffHunk": "@@ -63,28 +63,39 @@ public static void registerAuthToken(EvergreenService s) {\n      * @param message       incoming message frame to be validated.\n      * @param remoteAddress remote address the client is connected from\n      * @return RequestContext containing the server name if validated.\n-     * @throws IPCClientNotAuthorizedException thrown if not authorized, or any other error happens.\n+     * @throws UnauthenticatedException thrown if not authorized, or any other error happens.\n      */\n     public ConnectionContext doAuth(FrameReader.Message message, SocketAddress remoteAddress)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMjYyNw=="}, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTQ0OTU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/AuthenticationHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoxODowMFrOG6QAhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxNjo1MlrOG6RtAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMjg2OA==", "bodyText": "use Coerce.toString(service)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463732868", "createdAt": "2020-07-31T17:18:00Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/AuthenticationHandler.java", "diffHunk": "@@ -63,28 +63,39 @@ public static void registerAuthToken(EvergreenService s) {\n      * @param message       incoming message frame to be validated.\n      * @param remoteAddress remote address the client is connected from\n      * @return RequestContext containing the server name if validated.\n-     * @throws IPCClientNotAuthorizedException thrown if not authorized, or any other error happens.\n+     * @throws UnauthenticatedException thrown if not authorized, or any other error happens.\n      */\n     public ConnectionContext doAuth(FrameReader.Message message, SocketAddress remoteAddress)\n-            throws IPCClientNotAuthorizedException {\n+            throws UnauthenticatedException {\n \n         ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n         AuthRequest authRequest;\n         try {\n             authRequest = IPCUtil.decode(applicationMessage.getPayload(), AuthRequest.class);\n         } catch (IOException e) {\n-            throw new IPCClientNotAuthorizedException(\"Fail to decode Auth message\", e);\n+            throw new UnauthenticatedException(\"Fail to decode Auth message\", e);\n         }\n \n-        String authToken = authRequest.getAuthToken();\n-        // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) config.lookup(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n-                AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = doAuthentication(authRequest.getAuthToken());\n+        return new ConnectionContext(serviceName, remoteAddress, router);\n+    }\n \n-        if (serviceName == null) {\n-            throw new IPCClientNotAuthorizedException(\"Auth token not found\");\n+    /**\n+     * Lookup the provided auth token to associate it with a service (or reject it).\n+     * @param authToken token to be looked up.\n+     * @return service name to which the token is associated.\n+     * @throws UnauthenticatedException if token is invalid or unassociated.\n+     */\n+    public String doAuthentication(String authToken) throws UnauthenticatedException {\n+        if (authToken == null) {\n+            throw new UnauthenticatedException(\"Invalid auth token\");\n         }\n-        return new ConnectionContext(serviceName, remoteAddress, router);\n+        Topic service = config.find(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                AUTH_TOKEN_LOOKUP_KEY, authToken);\n+        if (service == null) {\n+            throw new UnauthenticatedException(\"Auth token not found\");\n+        }\n+        return (String) service.getOnce();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2MDY0Mg==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463760642", "createdAt": "2020-07-31T18:16:52Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/AuthenticationHandler.java", "diffHunk": "@@ -63,28 +63,39 @@ public static void registerAuthToken(EvergreenService s) {\n      * @param message       incoming message frame to be validated.\n      * @param remoteAddress remote address the client is connected from\n      * @return RequestContext containing the server name if validated.\n-     * @throws IPCClientNotAuthorizedException thrown if not authorized, or any other error happens.\n+     * @throws UnauthenticatedException thrown if not authorized, or any other error happens.\n      */\n     public ConnectionContext doAuth(FrameReader.Message message, SocketAddress remoteAddress)\n-            throws IPCClientNotAuthorizedException {\n+            throws UnauthenticatedException {\n \n         ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n         AuthRequest authRequest;\n         try {\n             authRequest = IPCUtil.decode(applicationMessage.getPayload(), AuthRequest.class);\n         } catch (IOException e) {\n-            throw new IPCClientNotAuthorizedException(\"Fail to decode Auth message\", e);\n+            throw new UnauthenticatedException(\"Fail to decode Auth message\", e);\n         }\n \n-        String authToken = authRequest.getAuthToken();\n-        // Lookup the provided auth token to associate it with a service (or reject it)\n-        String serviceName = (String) config.lookup(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n-                AUTH_TOKEN_LOOKUP_KEY, authToken).getOnce();\n+        String serviceName = doAuthentication(authRequest.getAuthToken());\n+        return new ConnectionContext(serviceName, remoteAddress, router);\n+    }\n \n-        if (serviceName == null) {\n-            throw new IPCClientNotAuthorizedException(\"Auth token not found\");\n+    /**\n+     * Lookup the provided auth token to associate it with a service (or reject it).\n+     * @param authToken token to be looked up.\n+     * @return service name to which the token is associated.\n+     * @throws UnauthenticatedException if token is invalid or unassociated.\n+     */\n+    public String doAuthentication(String authToken) throws UnauthenticatedException {\n+        if (authToken == null) {\n+            throw new UnauthenticatedException(\"Invalid auth token\");\n         }\n-        return new ConnectionContext(serviceName, remoteAddress, router);\n+        Topic service = config.find(EvergreenService.SERVICES_NAMESPACE_TOPIC,\n+                AUTH_TOKEN_LOOKUP_KEY, authToken);\n+        if (service == null) {\n+            throw new UnauthenticatedException(\"Auth token not found\");\n+        }\n+        return (String) service.getOnce();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMjg2OA=="}, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTQ1Mzg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoxOTozNFrOG6QDTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxNjo1OVrOG6RtMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMzU4MQ==", "bodyText": "don't log just the message, log the whole exception by passing e instead of e.getMessage() (and remove the {})", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463733581", "createdAt": "2020-07-31T17:19:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -63,35 +74,67 @@\n     /**\n      * Constructor.\n      *\n-     * @param iotRoleAlias      Iot role alias configured by the customer in AWS account.\n      * @param cloudHelper       {@link IotCloudHelper} for making http requests to cloud.\n      * @param connectionManager {@link IotConnectionManager} underlying connection manager for cloud.\n+     * @param authenticationHandler {@link AuthenticationHandler} authN module for authenticating requests.\n+     * @param authZHandler {@link AuthorizationHandler} authZ module for authorizing requests.\n      */\n-    public CredentialRequestHandler(final String iotRoleAlias, final IotCloudHelper cloudHelper,\n-                                    final IotConnectionManager connectionManager) {\n-        this.iotCredentialsPath = \"/role-aliases/\" + iotRoleAlias + \"/credentials\";\n+    @Inject\n+    public CredentialRequestHandler(final IotCloudHelper cloudHelper,\n+                                    final IotConnectionManager connectionManager,\n+                                    final AuthenticationHandler authenticationHandler,\n+                                    final AuthorizationHandler authZHandler) {\n         this.iotCloudHelper = cloudHelper;\n         this.iotConnectionManager = connectionManager;\n+        this.authNHandler = authenticationHandler;\n+        this.authZHandler = authZHandler;\n+    }\n+\n+    /**\n+     * Set the role alias.\n+     * @param iotRoleAlias  Iot role alias configured by the customer in AWS account.\n+     */\n+    public void setIotCredentialsPath(String iotRoleAlias) {\n+        this.iotCredentialsPath = \"/role-aliases/\" + iotRoleAlias + \"/credentials\";\n         this.tesCache.put(this.iotCredentialsPath, new TESCache());\n         this.tesCache.get(iotCredentialsPath).expiry = Instant.now(clock);\n     }\n \n     @Override\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n     public void handle(final HttpExchange exchange) throws IOException {\n-        final byte[] credentials = getCredentials();\n-        exchange.sendResponseHeaders(tesCache.get(iotCredentialsPath).responseCode, credentials.length);\n-        exchange.getResponseBody().write(credentials);\n-        exchange.close();\n+        try {\n+            doAuth(exchange);\n+            final byte[] credentials = getCredentials();\n+            exchange.sendResponseHeaders(tesCache.get(iotCredentialsPath).responseCode, credentials.length);\n+            exchange.getResponseBody().write(credentials);\n+        } catch (AuthorizationException e) {\n+            LOGGER.atInfo().log(\"Request is not authorized\");\n+            generateError(exchange, HttpURLConnection.HTTP_FORBIDDEN);\n+        } catch (UnauthenticatedException e) {\n+            LOGGER.atInfo().log(\"Request denied due to invalid token\");\n+            generateError(exchange, HttpURLConnection.HTTP_FORBIDDEN);\n+        } catch (Throwable e) {\n+            // Dont let the server crash, swallow problems with a 5xx\n+            LOGGER.atInfo().log(\"Request failed due to {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2MDY5MQ==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463760691", "createdAt": "2020-07-31T18:16:59Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -63,35 +74,67 @@\n     /**\n      * Constructor.\n      *\n-     * @param iotRoleAlias      Iot role alias configured by the customer in AWS account.\n      * @param cloudHelper       {@link IotCloudHelper} for making http requests to cloud.\n      * @param connectionManager {@link IotConnectionManager} underlying connection manager for cloud.\n+     * @param authenticationHandler {@link AuthenticationHandler} authN module for authenticating requests.\n+     * @param authZHandler {@link AuthorizationHandler} authZ module for authorizing requests.\n      */\n-    public CredentialRequestHandler(final String iotRoleAlias, final IotCloudHelper cloudHelper,\n-                                    final IotConnectionManager connectionManager) {\n-        this.iotCredentialsPath = \"/role-aliases/\" + iotRoleAlias + \"/credentials\";\n+    @Inject\n+    public CredentialRequestHandler(final IotCloudHelper cloudHelper,\n+                                    final IotConnectionManager connectionManager,\n+                                    final AuthenticationHandler authenticationHandler,\n+                                    final AuthorizationHandler authZHandler) {\n         this.iotCloudHelper = cloudHelper;\n         this.iotConnectionManager = connectionManager;\n+        this.authNHandler = authenticationHandler;\n+        this.authZHandler = authZHandler;\n+    }\n+\n+    /**\n+     * Set the role alias.\n+     * @param iotRoleAlias  Iot role alias configured by the customer in AWS account.\n+     */\n+    public void setIotCredentialsPath(String iotRoleAlias) {\n+        this.iotCredentialsPath = \"/role-aliases/\" + iotRoleAlias + \"/credentials\";\n         this.tesCache.put(this.iotCredentialsPath, new TESCache());\n         this.tesCache.get(iotCredentialsPath).expiry = Instant.now(clock);\n     }\n \n     @Override\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n     public void handle(final HttpExchange exchange) throws IOException {\n-        final byte[] credentials = getCredentials();\n-        exchange.sendResponseHeaders(tesCache.get(iotCredentialsPath).responseCode, credentials.length);\n-        exchange.getResponseBody().write(credentials);\n-        exchange.close();\n+        try {\n+            doAuth(exchange);\n+            final byte[] credentials = getCredentials();\n+            exchange.sendResponseHeaders(tesCache.get(iotCredentialsPath).responseCode, credentials.length);\n+            exchange.getResponseBody().write(credentials);\n+        } catch (AuthorizationException e) {\n+            LOGGER.atInfo().log(\"Request is not authorized\");\n+            generateError(exchange, HttpURLConnection.HTTP_FORBIDDEN);\n+        } catch (UnauthenticatedException e) {\n+            LOGGER.atInfo().log(\"Request denied due to invalid token\");\n+            generateError(exchange, HttpURLConnection.HTTP_FORBIDDEN);\n+        } catch (Throwable e) {\n+            // Dont let the server crash, swallow problems with a 5xx\n+            LOGGER.atInfo().log(\"Request failed due to {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMzU4MQ=="}, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTQ1NjEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoyMDoxOFrOG6QExg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxODoxN1rOG6Rvbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMzk1OA==", "bodyText": "omit the resource in your build since it is null?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463733958", "createdAt": "2020-07-31T17:20:18Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -183,6 +225,19 @@ public void handle(final HttpExchange exchange) throws IOException {\n         }\n     }\n \n+    private void doAuth(final HttpExchange exchange) throws UnauthenticatedException, AuthorizationException {\n+        // if header is not present, then authToken would be null and authNhandler would throw\n+        String authNToken = exchange.getRequestHeaders().getFirst(AUTH_HEADER);\n+        String clientService = authNHandler.doAuthentication(authNToken);\n+        authZHandler.isAuthorized(\n+                TokenExchangeService.TOKEN_EXCHANGE_SERVICE_TOPICS,\n+                Permission.builder()\n+                        .principal(clientService)\n+                        .operation(TokenExchangeService.AUTHZ_TES_OPERATION)\n+                        .resource(null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2MTI2Mw==", "bodyText": "I like it this way. tells the reader explicitly that we want to set it to null.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463761263", "createdAt": "2020-07-31T18:18:17Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/tes/CredentialRequestHandler.java", "diffHunk": "@@ -183,6 +225,19 @@ public void handle(final HttpExchange exchange) throws IOException {\n         }\n     }\n \n+    private void doAuth(final HttpExchange exchange) throws UnauthenticatedException, AuthorizationException {\n+        // if header is not present, then authToken would be null and authNhandler would throw\n+        String authNToken = exchange.getRequestHeaders().getFirst(AUTH_HEADER);\n+        String clientService = authNHandler.doAuthentication(authNToken);\n+        authZHandler.isAuthorized(\n+                TokenExchangeService.TOKEN_EXCHANGE_SERVICE_TOPICS,\n+                Permission.builder()\n+                        .principal(clientService)\n+                        .operation(TokenExchangeService.AUTHZ_TES_OPERATION)\n+                        .resource(null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMzk1OA=="}, "originalCommit": {"oid": "845ed9a7cc3c578e48f32e3505d288bf582d9781"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTY1NzA1OnYy", "diffSide": "LEFT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/tes/TESTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoyODo0MFrOG6SBgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODozMjoxN1rOG6SHzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NTg4OA==", "bodyText": "status is used below. should change line 118 as well", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463765888", "createdAt": "2020-07-31T18:28:40Z", "author": {"login": "youtuyy"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/tes/TESTest.java", "diffHunk": "@@ -74,22 +88,16 @@ void tearDown() {\n \n     @Test\n     void GIVEN_iot_role_alias_WHEN_tes_is_queried_THEN_valid_credentials_are_returned() throws Exception {\n-        CountDownLatch tesRunning = new CountDownLatch(1);\n-        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(TOKEN_EXCHANGE_SERVICE_TOPICS) && newState.equals(State.RUNNING)) {\n-                tesRunning.countDown();\n-            }\n-        });\n-        kernel.launch();\n-        assertTrue(tesRunning.await(5, TimeUnit.SECONDS));\n-        Thread.sleep(5000);\n         String urlString = kernel.getConfig().find(SETENV_CONFIG_NAMESPACE, TES_URI_ENV_VARIABLE_NAME).getOnce().toString();\n         assertNotNull(urlString);\n         URL url = new URL(urlString);\n+        // Get the first token from the token map\n+        String token = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, AuthenticationHandler.AUTH_TOKEN_LOOKUP_KEY).iterator().next().getName();\n+        assertNotNull(token);\n         HttpURLConnection con = (HttpURLConnection) url.openConnection();\n         con.setRequestMethod(\"GET\");\n-        int status = con.getResponseCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad2c3494abfe48ea9b9797129dd680b95b0da995"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NzUwMw==", "bodyText": "yeah. updated now. thanks.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/343#discussion_r463767503", "createdAt": "2020-07-31T18:32:17Z", "author": {"login": "prateek-y"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/tes/TESTest.java", "diffHunk": "@@ -74,22 +88,16 @@ void tearDown() {\n \n     @Test\n     void GIVEN_iot_role_alias_WHEN_tes_is_queried_THEN_valid_credentials_are_returned() throws Exception {\n-        CountDownLatch tesRunning = new CountDownLatch(1);\n-        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n-            if (service.getName().equals(TOKEN_EXCHANGE_SERVICE_TOPICS) && newState.equals(State.RUNNING)) {\n-                tesRunning.countDown();\n-            }\n-        });\n-        kernel.launch();\n-        assertTrue(tesRunning.await(5, TimeUnit.SECONDS));\n-        Thread.sleep(5000);\n         String urlString = kernel.getConfig().find(SETENV_CONFIG_NAMESPACE, TES_URI_ENV_VARIABLE_NAME).getOnce().toString();\n         assertNotNull(urlString);\n         URL url = new URL(urlString);\n+        // Get the first token from the token map\n+        String token = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, AuthenticationHandler.AUTH_TOKEN_LOOKUP_KEY).iterator().next().getName();\n+        assertNotNull(token);\n         HttpURLConnection con = (HttpURLConnection) url.openConnection();\n         con.setRequestMethod(\"GET\");\n-        int status = con.getResponseCode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NTg4OA=="}, "originalCommit": {"oid": "ad2c3494abfe48ea9b9797129dd680b95b0da995"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4493, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}