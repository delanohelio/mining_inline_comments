{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5MTIwMTI4", "number": 369, "title": "Updated Lifecycle API's", "bodyText": "Description of changes:\nKernel side changes for supporting the below api updates:\n\nAdded API SubscribeToComponentUpdate\nAdded API DeferComponentUpdate\nRenamed reportState to updateState\nRemove listenToStateChanges\n\nCorresponding SDK changes : aws-greengrass/aws-greengrass-logging-java#50\nWhy is this change necessary:\nChanges based on API design : https://quip-amazon.com/mbN5ATEk6Db6/IPC-SDK-API-Design#GcZ9CAXofll\nHow was this change tested:\ninteg tests.\nChecklist:\n\n Updated the README if applicable\n[ X] Updated or added new unit tests\n[ X] Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-08-17T23:39:30Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369", "merged": true, "mergeCommit": {"oid": "46316bfa289f6c75a8b5b41b9b6e9b82de82c8a8"}, "closed": true, "closedAt": "2020-08-21T22:59:02Z", "author": {"login": "fahadmohammed01"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc_2Gi4AH2gAyNDY5MTIwMTI4OjNhOTcxZjAzZTM5NWZiZTE3ZDU2MWE0NTkzY2JhYWNlNzNlZDE1OTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBMDGCAFqTQ3MjgzODM0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3a971f03e395fbe17d561a4593cbaace73ed1593", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3a971f03e395fbe17d561a4593cbaace73ed1593", "committedDate": "2020-08-17T17:45:20Z", "message": "defer component update over ipc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "086caebfc3725009143261deecca00a4b0b0bf8d", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/086caebfc3725009143261deecca00a4b0b0bf8d", "committedDate": "2020-08-17T23:36:38Z", "message": "updated integ tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9f1067033a4841d7525a10aad96adb92c73735e0", "committedDate": "2020-08-17T23:44:33Z", "message": "Merge branch 'master' into safe-update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5ac90da363f3b1e2a3bf00c9f2838cdc45369096", "committedDate": "2020-08-17T23:48:13Z", "message": "resolved merge conflict"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTAxNTk4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-468901598", "createdAt": "2020-08-17T23:45:00Z", "commit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NTowMFrOHB-dDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo1NDoyOVrOHB-nNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzMzg2OA==", "bodyText": "[nit]\nDuration.ofSeconds(3).toMillis()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471833868", "createdAt": "2020-08-17T23:45:00Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzMzk5OA==", "bodyText": "shouldn't we fail the test on this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471833998", "createdAt": "2020-08-17T23:45:27Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){\n+                preComponentUpdateCount.getAndIncrement();\n+                //defer update the first time\n+                //no response the second time causes the kernel to move forward after default wait time\n+                if(deferCount.get() < 1){\n+                    try {\n+                        deferCount.getAndIncrement();\n+                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n+                    } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDIwNA==", "bodyText": "likewise", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834204", "createdAt": "2020-08-17T23:46:18Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -376,6 +382,20 @@ void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_pr\n                 DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n                 System.currentTimeMillis());\n         resultFuture.get(30, TimeUnit.SECONDS);\n+\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"NonDisruptableService\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+            if (event instanceof PreComponentUpdateEvent) {\n+                try {\n+                    lifecycle.deferComponentUpdate(\"NonDisruptableService\", TimeUnit.SECONDS.toMillis(60));\n+                    ipcClient.disconnect();\n+                } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDQzNQ==", "bodyText": "[nit]\nUse a set", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834435", "createdAt": "2020-08-17T23:47:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -3,74 +3,67 @@\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n-import com.aws.iot.evergreen.ipc.common.FrameReader;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleClientOpCodes;\n+import com.aws.iot.evergreen.ipc.common.ServiceEventHelper;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse.DeferComponentUpdateResponseBuilder;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleGenericResponse;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleImpl;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PostComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PreComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.SubscribeToComponentUpdatesResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.UpdateStateRequest;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n \n-import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.function.BiConsumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode.LIFECYCLE;\n+\n /**\n  * Class to handle business logic for all Lifecycle requests over IPC.\n  */\n public class LifecycleIPCAgent implements InjectionActions {\n-    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n-    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n-            new DefaultConcurrentHashMap<>(ConcurrentHashMap::new);\n-    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final List<ConnectionContext> componentUpdateListeners = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDUyOA==", "bodyText": "can you add a comment about how this is used?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834528", "createdAt": "2020-08-17T23:47:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -3,74 +3,67 @@\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n-import com.aws.iot.evergreen.ipc.common.FrameReader;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleClientOpCodes;\n+import com.aws.iot.evergreen.ipc.common.ServiceEventHelper;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse.DeferComponentUpdateResponseBuilder;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleGenericResponse;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleImpl;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PostComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PreComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.SubscribeToComponentUpdatesResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.UpdateStateRequest;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n \n-import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.function.BiConsumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode.LIFECYCLE;\n+\n /**\n  * Class to handle business logic for all Lifecycle requests over IPC.\n  */\n public class LifecycleIPCAgent implements InjectionActions {\n-    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n-    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n-            new DefaultConcurrentHashMap<>(ConcurrentHashMap::new);\n-    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final List<ConnectionContext> componentUpdateListeners = new CopyOnWriteArrayList<>();\n+\n+    private final Map<ConnectionContext, CompletableFuture<DeferComponentUpdateRequest>> deferUpdateFuturesMap =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDYxNA==", "bodyText": "debug", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834614", "createdAt": "2020-08-17T23:47:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDkwMA==", "bodyText": "use interpolation instead of concatenation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834900", "createdAt": "2020-08-17T23:48:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTMxMA==", "bodyText": "Does this need to be info?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471835310", "createdAt": "2020-08-17T23:50:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.info(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTU2NA==", "bodyText": "completing the future means that the update should be delayed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471835564", "createdAt": "2020-08-17T23:51:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.info(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferComponentUpdateRequest> deferComponentUpdateRequestFuture =\n+                deferUpdateFuturesMap.get(context);\n+        if (deferComponentUpdateRequestFuture == null) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Time limit to respond to PreComponentUpdateEvent exceeded\").build();\n+        }\n+\n+        deferComponentUpdateRequestFuture.complete(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTk0Mw==", "bodyText": "just remove them, why comment it out?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471835943", "createdAt": "2020-08-17T23:52:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -313,7 +304,7 @@ public long whenIsDisruptionOK() {\n         // By default, if anything goes wrong we will assume it is not safe to update right now\n         return Instant.now().plusSeconds(recheckSeconds).toEpochMilli();\n     }\n-\n+    /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNjMwMw==", "bodyText": "log?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471836303", "createdAt": "2020-08-17T23:53:49Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());\n+                            }\n+                        } catch (ExecutionException e) {\n+                            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNjQ2OQ==", "bodyText": "can it not be public if it is only for testing?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471836469", "createdAt": "2020-08-17T23:54:29Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -154,4 +185,10 @@ protected void startup() throws InterruptedException {\n             }\n         }\n     }\n+\n+    //only for testing\n+    public void setDefaultTimeOutInMs(long defaultTimeOutInMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 121}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85af4c6cf775ca43461dedc1b476a5af6a779e0c", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85af4c6cf775ca43461dedc1b476a5af6a779e0c", "committedDate": "2020-08-18T00:41:25Z", "message": "addressed pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e5f28332faa4684e18e29018b96011ffa65a739", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1e5f28332faa4684e18e29018b96011ffa65a739", "committedDate": "2020-08-18T20:17:33Z", "message": "Merge branch 'master' into safe-update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e13f3e3ca7aa9ebe7a1e52eb26c3a08ae375e0c5", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e13f3e3ca7aa9ebe7a1e52eb26c3a08ae375e0c5", "committedDate": "2020-08-18T20:17:48Z", "message": "updated e2e tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1ab26e8a7b8dd7c9a248c583f72cf2e07c463a4", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e1ab26e8a7b8dd7c9a248c583f72cf2e07c463a4", "committedDate": "2020-08-18T20:48:20Z", "message": "resolved merge conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f73213dd807f247296263c0116984028bfb4327", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9f73213dd807f247296263c0116984028bfb4327", "committedDate": "2020-08-18T21:11:05Z", "message": "updated comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODM2NzQz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-469836743", "createdAt": "2020-08-18T21:16:18Z", "commit": {"oid": "9f73213dd807f247296263c0116984028bfb4327"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbf3ac5a238c20ef20274cdb0f2d8844acd08e24", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bbf3ac5a238c20ef20274cdb0f2d8844acd08e24", "committedDate": "2020-08-18T21:18:45Z", "message": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e240d6c1d17f76591020b278e890c02cece8d357", "committedDate": "2020-08-19T06:23:05Z", "message": "Merge branch 'master' into safe-update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMDg4MjY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-470088267", "createdAt": "2020-08-19T02:49:32Z", "commit": {"oid": "bbf3ac5a238c20ef20274cdb0f2d8844acd08e24"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMjo0OTozMlrOHCuNVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMjozMVrOHDwIGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYxNjI3OQ==", "bodyText": "Nit - formatting here and a few places below", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r472616279", "createdAt": "2020-08-19T02:49:32Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf3ac5a238c20ef20274cdb0f2d8844acd08e24"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY3NjA1Mg==", "bodyText": "Why not add this to throws ? If I understand correctly this is a checked exception but it indicates a failure if the client does get this exception right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473676052", "createdAt": "2020-08-20T07:08:06Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){\n+                preComponentUpdateCount.getAndIncrement();\n+                //defer update the first time\n+                //no response the second time causes the kernel to move forward after default wait time\n+                if(deferCount.get() < 1){\n+                    try {\n+                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n+                        deferCount.getAndIncrement();\n+                    } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MjczMQ==", "bodyText": "This doesn't read very well I think - (System.currentTimeMillis() - now) Might want to change the name from now to something more appropriate", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473682731", "createdAt": "2020-08-20T07:16:14Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4NjQwNg==", "bodyText": "why is this needed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473686406", "createdAt": "2020-08-20T07:20:43Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());\n+                            }\n+                        } catch (ExecutionException e) {\n+                            logger.error(\"Failed to process component update request\", e);\n+                        }\n+                        iterator.remove();\n+                    }\n                 }\n+                Thread.sleep(TimeUnit.SECONDS.toMillis(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5MDMzNg==", "bodyText": "When one of the services defers update, this will cause a fresh set of PreComponentUpdateEvents to be sent to all services who have subscribed right? Do you not need to discard futures from previous batch in that case? Or alternately, manage that inside lifecycleIPCAgent.sendPreComponentUpdateEvent ? It doesn't seem to clear the set of futures on each sendPreComponentUpdateEvent call?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473690336", "createdAt": "2020-08-20T07:25:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NjI4Mw==", "bodyText": "There's no way for the component's process to report an error if it encounters one while evaluating the condition to defer update right? If there's a problem with that piece of code in customer's component, do we expect that customers should write it in a way that it always manages to make a defer update request? What happens if they can't make a defer request because of a bug/error and kernel takes that as it being okay with the update? What if that component happens to be performing critical tasks which are not safe to disrupt?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473696283", "createdAt": "2020-08-20T07:32:31Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 214}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzQwNDYz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-471340463", "createdAt": "2020-08-20T07:39:27Z", "commit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozOToyN1rOHDwqww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozOToyN1rOHDwqww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcwNTE1NQ==", "bodyText": "So all of the lifecycle APIs are being tested in the deployment workflow integ tests now? Do we need more tests? How is UpdateState API tested for instance?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473705155", "createdAt": "2020-08-20T07:39:27Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -155,25 +151,7 @@ void registerResourcePermissionTest() throws Exception {\n \n         assertThrows(ResourceNotOwnedException.class, () -> c.registerResource(req));\n     }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMzQ1MjIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-471345221", "createdAt": "2020-08-20T07:46:46Z", "commit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo0Njo0NlrOHDxPww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo0Njo0NlrOHDxPww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxNDYyNw==", "bodyText": "Following up on my comment on the sdk PR, there's componentname in the defer request https://github.com/aws/aws-greengrass-sdk-java/pull/50/files#r472616090, if it's only for logging which I see being the case in UpdateSystemSafelyService.java, should we validate that no components are making requests with some other component's name?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473714627", "createdAt": "2020-08-20T07:46:46Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferComponentUpdateRequest> deferComponentUpdateRequestFuture =\n+                deferUpdateFuturesMap.get(context);\n+        if (deferComponentUpdateRequestFuture == null) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Time limit to respond to PreComponentUpdateEvent exceeded\").build();\n+        }\n+\n+        deferComponentUpdateRequestFuture.complete(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 230}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13188c18d67b2553896c4b360518f9c3e019ace4", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/13188c18d67b2553896c4b360518f9c3e019ace4", "committedDate": "2020-08-20T23:30:45Z", "message": "addressed pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/70b8a604279cdd98a4b1599fa48cdff4a070c54e", "committedDate": "2020-08-21T01:08:49Z", "message": "minor refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjIzNDc5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-472623479", "createdAt": "2020-08-21T16:20:25Z", "commit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoyMDoyNVrOHEzYdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoyMDoyNVrOHEzYdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5ODE5Ng==", "bodyText": "If timeouts are to be made configurable, they will need to be added as service/system config that can change in deployment, when we do that this will not be needed since we should be able to use the config for testing as well, can you add a TODO for that here and have it say that this should be removed when that happens?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474798196", "createdAt": "2020-08-21T16:20:25Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -154,4 +188,10 @@ protected void startup() throws InterruptedException {\n             }\n         }\n     }\n+\n+    //only for testing\n+    public void setDefaultTimeOutInMs(long defaultTimeOutInMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjIzNjc2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-472623676", "createdAt": "2020-08-21T16:20:41Z", "commit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba1a59374bf6dfcfba39a114795dd829446e6b63", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ba1a59374bf6dfcfba39a114795dd829446e6b63", "committedDate": "2020-08-21T17:45:00Z", "message": "Merge branch 'master' into safe-update"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNTk1ODA1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-472595805", "createdAt": "2020-08-21T15:39:37Z", "commit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNTozOTozN1rOHEyFXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzozOTozNVrOHE1vpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjkyNQ==", "bodyText": "Can it be immutable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474776925", "createdAt": "2020-08-21T15:39:37Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class DeferUpdateRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNTU0OA==", "bodyText": "Is 'beforeComponentUpdate' more accurate on what this API is doing?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474815548", "createdAt": "2020-08-21T16:55:14Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNzMyMg==", "bodyText": "Why does it need to alter pass in parameter? Are we sure the list passed in is mutable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474817322", "createdAt": "2020-08-21T16:58:53Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyMzczNA==", "bodyText": "If we clear the map, are we giving up to update the previous futures? Are we expecting caller to abandon them as well?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474823734", "createdAt": "2020-08-21T17:12:24Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzNjkwMw==", "bodyText": "Do we have separate thread to monitor the expiration of future?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474836903", "createdAt": "2020-08-21T17:39:35Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 224}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjc3NjIx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-472677621", "createdAt": "2020-08-21T17:47:17Z", "commit": {"oid": "ba1a59374bf6dfcfba39a114795dd829446e6b63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzo0NzoxN1rOHE19zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzo0NzoxN1rOHE19zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0MDUyNg==", "bodyText": "Are we using enum indices as opCode? Is opCode visible to client?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474840526", "createdAt": "2020-08-21T17:47:17Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/LifecycleIPCService.java", "diffHunk": "@@ -68,36 +68,39 @@ public void postInject() {\n         ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n         try {\n             //TODO: add version compatibility check\n-            LifecycleServiceOpCodes lifecycleServiceOpCodes =\n-                    LifecycleServiceOpCodes.values()[applicationMessage.getOpCode()];\n-            LifecycleGenericResponse lifecycleGenericResponse = new LifecycleGenericResponse();\n-            switch (lifecycleServiceOpCodes) {\n-                case REGISTER_LISTENER:\n-                    LifecycleListenRequest listenRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), LifecycleListenRequest.class);\n-                    lifecycleGenericResponse = agent.listenToStateChanges(listenRequest, context);\n-                    break;\n-                case REPORT_STATE:\n-                    StateChangeRequest stateChangeRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), StateChangeRequest.class);\n-                    lifecycleGenericResponse = agent.reportState(stateChangeRequest, context);\n-                    break;\n-                default:\n-                    lifecycleGenericResponse.setStatus(LifecycleResponseStatus.InvalidRequest);\n-                    lifecycleGenericResponse\n-                            .setErrorMessage(\"Unknown request type \" + lifecycleServiceOpCodes.toString());\n-                    break;\n+            LifecycleGenericResponse lifecycleGenericResponse = new LifecycleGenericResponse(\n+                    LifecycleResponseStatus.InvalidRequest, \"Unknown request type\");\n+            if (LifecycleClientOpCodes.values().length > applicationMessage.getOpCode()) {\n+                LifecycleClientOpCodes lifecycleClientOpCodes =\n+                        LifecycleClientOpCodes.values()[applicationMessage.getOpCode()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1a59374bf6dfcfba39a114795dd829446e6b63"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d7104a0b7efbd3acfb58ce5c555295cab6896e6", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7d7104a0b7efbd3acfb58ce5c555295cab6896e6", "committedDate": "2020-08-21T20:56:51Z", "message": "addressed pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ea1867052e4e9dbcce0e7be12d7d87dba2d4208", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7ea1867052e4e9dbcce0e7be12d7d87dba2d4208", "committedDate": "2020-08-21T21:34:12Z", "message": "Merge branch 'master' into safe-update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9587d5e0038ea3493de7313276e72a3f2390f26", "author": {"user": {"login": "fahadmohammed01", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f9587d5e0038ea3493de7313276e72a3f2390f26", "committedDate": "2020-08-21T21:44:33Z", "message": "changed pom to point to the master branch of sdk"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODM2NzYz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-472836763", "createdAt": "2020-08-21T21:49:00Z", "commit": {"oid": "f9587d5e0038ea3493de7313276e72a3f2390f26"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODM4MzQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#pullrequestreview-472838346", "createdAt": "2020-08-21T21:53:24Z", "commit": {"oid": "f9587d5e0038ea3493de7313276e72a3f2390f26"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2090, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}