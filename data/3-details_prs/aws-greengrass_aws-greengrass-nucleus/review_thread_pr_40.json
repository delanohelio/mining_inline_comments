{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NTc3NTI1", "number": 40, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyNzo0M1rODaWDPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzozOTo0MFrODaj2Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTUwODQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyNzo0M1rOFhP8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjo1MDowN1rOFhVHHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA==", "bodyText": "Why do we need an atomic reference here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370408534", "createdAt": "2020-01-23T23:27:43Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,56 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public RequestContext doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n-        }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        AtomicReference<String> serviceName = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA5Ng==", "bodyText": "It is needed so that I can set the serviceName inside the lambda that I have in the deepForEach", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409096", "createdAt": "2020-01-23T23:29:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,56 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public RequestContext doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n-        }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        AtomicReference<String> serviceName = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA=="}, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4ODQ2Nw==", "bodyText": "There should be an inline comment explaining why having a atomic reference", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370488467", "createdAt": "2020-01-24T06:25:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,56 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public RequestContext doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n-        }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        AtomicReference<String> serviceName = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA=="}, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MzIxNQ==", "bodyText": "Alright, can do. I would expect to see this pattern a lot in our code going forward since so much of it is lambda/callback based.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370493215", "createdAt": "2020-01-24T06:50:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,56 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public RequestContext doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n-        }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        AtomicReference<String> serviceName = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA=="}, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTUxMTg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyOToyNFrOFhP-Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoxMDozN1rOFhUqyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA0Ng==", "bodyText": "Can we store the token in a different map so the lookup during auth is not a linear search", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409046", "createdAt": "2020-01-23T23:29:24Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -24,6 +24,10 @@ public GenericExternalService(Topics c) {\n                 setState(child.childOf(\"install\") ? State.Installing : State.AwaitingStartup);\n             }\n         });\n+\n+        // Set a unique ID used for IPC Auth\n+        Topic uid = c.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTMwNA==", "bodyText": "Potentially, but that means that we need to duplicate the value so we have both A->B and B->A.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409304", "createdAt": "2020-01-23T23:30:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -24,6 +24,10 @@ public GenericExternalService(Topics c) {\n                 setState(child.childOf(\"install\") ? State.Installing : State.AwaitingStartup);\n             }\n         });\n+\n+        // Set a unique ID used for IPC Auth\n+        Topic uid = c.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA0Ng=="}, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NTk2MQ==", "bodyText": "I'll see what I can do for this tomorrow.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370485961", "createdAt": "2020-01-24T06:10:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -24,6 +24,10 @@ public GenericExternalService(Topics c) {\n                 setState(child.childOf(\"install\") ? State.Installing : State.AwaitingStartup);\n             }\n         });\n+\n+        // Set a unique ID used for IPC Auth\n+        Topic uid = c.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA0Ng=="}, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTUxMjU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyOTo0MFrOFhP-tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzozMjo1MVrOFhQCEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTE0MA==", "bodyText": "add TODO: for synchronization between requests?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409140", "createdAt": "2020-01-23T23:29:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQxMDAwMw==", "bodyText": "It is synchronized", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370410003", "createdAt": "2020-01-23T23:32:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTE0MA=="}, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTkwNzg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDoyMjo0NVrOFhTn6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjo0Njo0M1rOFhVEow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2ODg0MQ==", "bodyText": "What's the reason of having SDAResource instead of directly using Resource class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370468841", "createdAt": "2020-01-24T04:22:45Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MjU3OQ==", "bodyText": "Just to store information not in the resource, but about the resource. Such as the owning service and if it is published to DNS-SD.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370492579", "createdAt": "2020-01-24T06:46:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2ODg0MQ=="}, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTkwOTI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDoyNDowM1rOFhTooA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzowODozM1rOFhkYcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA==", "bodyText": "I would add a comment explaining why this method is synchronized. Also, java doc?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469024", "createdAt": "2020-01-24T04:24:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MzM0MA==", "bodyText": "Sure thing", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370493340", "createdAt": "2020-01-24T06:50:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA=="}, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDczODIzOA==", "bodyText": "Do we need more finer level of synchronization?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370738238", "createdAt": "2020-01-24T16:57:21Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA=="}, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MzQwOQ==", "bodyText": "Added javadoc and switch from using synchronized to using a ReentrantReadWriteLock. I can't really go any finer because we're storing the data in the config store.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370743409", "createdAt": "2020-01-24T17:08:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA=="}, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTkxMDE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDoyNToxMlrOFhTpLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDoyNToxMlrOFhTpLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTE2Nw==", "bodyText": "Create a SIM and add a link to the SIM here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469167", "createdAt": "2020-01-24T04:25:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTkxMTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDoyNjowNVrOFhTpuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDoyNjowNVrOFhTpuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTMwNw==", "bodyText": "Unnecessary comment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469307", "createdAt": "2020-01-24T04:26:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+            response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+            return response;\n+        }\n+\n+        // Save resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MDAyNDk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoxMzo1OFrOFhUtJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjo0NzozM1rOFhVFKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjU2Ng==", "bodyText": "nonnull?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370486566", "createdAt": "2020-01-24T06:13:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {\n+    private Resource resource;\n+    private boolean publishedToDNSSD;\n+    private String owningService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5MjcxNQ==", "bodyText": "This isn't user input, so validations aren't really necessary. Though of course I could mark these all as nonnull.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370492715", "createdAt": "2020-01-24T06:47:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {\n+    private Resource resource;\n+    private boolean publishedToDNSSD;\n+    private String owningService;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjU2Ng=="}, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MDAyNTg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoxNDo0OFrOFhUtsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoxNDo0OFrOFhUtsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjcwNA==", "bodyText": "Unnecessary comment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370486704", "createdAt": "2020-01-24T06:14:48Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+            response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = SDAResource.builder()\n+                .resource(request.getResource())\n+                .publishedToDNSSD(request.isPublishToDNSSD())\n+                .owningService(serviceName).build();\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        response.setError(ServiceDiscoveryResponseStatus.Success);\n+        response.setResponse(request.getResource());\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public synchronized GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+            response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.getOwningService().equals(serviceName)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.getResource().setTxtRecords(request.getResource().getTxtRecords());\n+        resource.getResource().setUri(request.getResource().getUri());\n+        resource.setPublishedToDNSSD(request.isPublishToDNSSD());\n+\n+        response.setError(ServiceDiscoveryResponseStatus.Success);\n+        return response;\n+    }\n+\n+    public synchronized GeneralResponse<Void, ServiceDiscoveryResponseStatus> removeResource(RemoveResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+            response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.getOwningService().equals(serviceName)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to remove %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        // Remove from master list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MDAzMzk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/common/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoyMTo1MlrOFhUyaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoyMTo1MlrOFhUyaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NzkxMw==", "bodyText": "Extract the address to a constant?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370487913", "createdAt": "2020-01-24T06:21:52Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/common/Server.java", "diffHunk": "@@ -36,7 +36,7 @@ public void startup() throws IPCException {\n             serverSocket = new ServerSocket();\n             // specifying port 0 causes  the system to pick an ephemeral port and a valid local address to bind the socket\n             serverSocket.bind(new InetSocketAddress(0));\n-            String serverUri = \"tcp://\" + serverSocket.getInetAddress().getHostAddress() + \":\" + serverSocket.getLocalPort();\n+            String serverUri = \"tcp://127.0.0.1:\" + serverSocket.getLocalPort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTc2MzQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzozODowM1rOFhlKFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzo0MjoyM1rOFhlSLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NjExNw==", "bodyText": "The try...finally can be replaced by a LockScope object we used in stream manager: https://code.amazon.com/packages/AWSGreengrassGreenlake/blobs/mainline/--/src/com/amazonaws/iot/greengrass/streammanager/utils/LockScope.java", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370756117", "createdAt": "2020-01-24T17:38:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to handle the business logic for Service Discovery including CRUD operations.\n+ */\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    /**\n+     * Register a resource with Service Discovery. Will throw if the resource is already registered.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+                response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource sdaResource = SDAResource.builder()\n+                    .resource(request.getResource())\n+                    .publishedToDNSSD(request.isPublishToDNSSD())\n+                    .owningService(serviceName).build();\n+            config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            response.setResponse(request.getResource());\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Update an already existing resource. The update will only update the URI, TXT Records, and whether\n+     * it is published to DNS-SD or not.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (!isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+                response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+            if (!resource.getOwningService().equals(serviceName)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+                response.setErrorMessage(String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath));\n+                return response;\n+            }\n+\n+            // update resource (only some fields are updatable)\n+            resource.getResource().setTxtRecords(request.getResource().getTxtRecords());\n+            resource.getResource().setUri(request.getResource().getUri());\n+            resource.setPublishedToDNSSD(request.isPublishToDNSSD());\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7febfd634fa1666594b67ae2708c6cd195516168"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1ODE4OA==", "bodyText": "I know, I just didn't necessarily want to start copying utilities over from there. But I can if you think that's a good thing to do.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370758188", "createdAt": "2020-01-24T17:42:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to handle the business logic for Service Discovery including CRUD operations.\n+ */\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    /**\n+     * Register a resource with Service Discovery. Will throw if the resource is already registered.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+                response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource sdaResource = SDAResource.builder()\n+                    .resource(request.getResource())\n+                    .publishedToDNSSD(request.isPublishToDNSSD())\n+                    .owningService(serviceName).build();\n+            config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            response.setResponse(request.getResource());\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Update an already existing resource. The update will only update the URI, TXT Records, and whether\n+     * it is published to DNS-SD or not.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (!isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+                response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+            if (!resource.getOwningService().equals(serviceName)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+                response.setErrorMessage(String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath));\n+                return response;\n+            }\n+\n+            // update resource (only some fields are updatable)\n+            resource.getResource().setTxtRecords(request.getResource().getTxtRecords());\n+            resource.getResource().setUri(request.getResource().getUri());\n+            resource.setPublishedToDNSSD(request.isPublishToDNSSD());\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NjExNw=="}, "originalCommit": {"oid": "7febfd634fa1666594b67ae2708c6cd195516168"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTc2ODQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzozOTo0MFrOFhlM8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzozOTo0MFrOFhlM8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1Njg0OA==", "bodyText": "remove empty line", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370756848", "createdAt": "2020-01-24T17:39:40Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to handle the business logic for Service Discovery including CRUD operations.\n+ */\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    /**\n+     * Register a resource with Service Discovery. Will throw if the resource is already registered.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7febfd634fa1666594b67ae2708c6cd195516168"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 45, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}