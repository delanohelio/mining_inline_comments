{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MDM0MzQx", "number": 391, "title": "Component config validation before executing deployment change", "bodyText": "Issue #, if available:\nDescription of changes:\nServices that consume configuration changes on deployment dynamically i.e. without restarting, need a way to indicate if the configuration brought by the deployment is bad. We decided to solve this problem by asking them to preemptively validate the proposed configuration and fail deployment if they don't like it. More details in the design doc -\nhttps://quip-amazon.com/HVE9A5wmE4Ab/Customer-services-with-dynamic-configuration#SBM9CAtgrEM\nWhy is this change necessary:\nSee description\nHow was this change tested:\nTests\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-08-26T16:54:35Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391", "merged": true, "mergeCommit": {"oid": "ea72b04c1f99a0a41461c55c3456b138dd6c6656"}, "closed": true, "closedAt": "2020-09-03T21:05:45Z", "author": {"login": "shaguptashaikh"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCu1UGgBqjM2OTU3NjM1NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFV5smgH2gAyNDc0MDM0MzQxOmZmZDk5NzVhNWZiNzBmYTlhMjNjZjJkYzQwZmVkOTY3OWM4NGJjZGQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc6bc84dfaa0a7e3b19400c6429baebb94fcd8d3", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cc6bc84dfaa0a7e3b19400c6429baebb94fcd8d3", "committedDate": "2020-08-26T16:50:09Z", "message": "First pass at validation"}, "afterCommit": {"oid": "bc8ee7c7800e758eea4ca59e50ed486d0d0321a9", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bc8ee7c7800e758eea4ca59e50ed486d0d0321a9", "committedDate": "2020-08-26T16:58:45Z", "message": "First pass at validation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc8ee7c7800e758eea4ca59e50ed486d0d0321a9", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bc8ee7c7800e758eea4ca59e50ed486d0d0321a9", "committedDate": "2020-08-26T16:58:45Z", "message": "First pass at validation"}, "afterCommit": {"oid": "caff6fb3162fb940db85b523dde8f5c7fc3540e8", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/caff6fb3162fb940db85b523dde8f5c7fc3540e8", "committedDate": "2020-08-26T17:15:35Z", "message": "First pass at validation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "caff6fb3162fb940db85b523dde8f5c7fc3540e8", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/caff6fb3162fb940db85b523dde8f5c7fc3540e8", "committedDate": "2020-08-26T17:15:35Z", "message": "First pass at validation"}, "afterCommit": {"oid": "2d12e648c1f9ae23aaa7ce931fa3767b145af89a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2d12e648c1f9ae23aaa7ce931fa3767b145af89a", "committedDate": "2020-08-26T18:37:18Z", "message": "First pass at validation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NzgzOTc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-475783975", "createdAt": "2020-08-26T19:12:25Z", "commit": {"oid": "2d12e648c1f9ae23aaa7ce931fa3767b145af89a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOToxMjoyNVrOHHaH-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOToxMjoyNVrOHHaH-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUzMDEwNg==", "bodyText": "IMO this check is too complex for M2. Is it enough to just check if component version is changed? If version isn't changed can we assume that the validation logic hasn't changed? Even the service might restart due the lifecycle change (eg, envVar), the service can still validate config before restarting", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r477530106", "createdAt": "2020-08-26T19:12:25Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also has changes for it that\n+     * will cause restart, e.g. version change/lifecycle change etc. This helps prevent failures when the\n+     * configuration to be validated has new keys or schema that the running version of the component doesn't\n+     * understand and won't be able to validate. We rely on the fact that component startup logic will need to\n+     * handle any configuration usage since it would be needed for the 1st time startup anyway.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            if (!willServiceRestart(proposedServiceConfig, currentServiceConfig, proposedTimestamp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d12e648c1f9ae23aaa7ce931fa3767b145af89a"}, "originalPosition": 112}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d12e648c1f9ae23aaa7ce931fa3767b145af89a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2d12e648c1f9ae23aaa7ce931fa3767b145af89a", "committedDate": "2020-08-26T18:37:18Z", "message": "First pass at validation"}, "afterCommit": {"oid": "8ed0021b1552e97e0f694476d556d2ce54b55d88", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8ed0021b1552e97e0f694476d556d2ce54b55d88", "committedDate": "2020-08-28T16:32:37Z", "message": "Added tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ed0021b1552e97e0f694476d556d2ce54b55d88", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8ed0021b1552e97e0f694476d556d2ce54b55d88", "committedDate": "2020-08-28T16:32:37Z", "message": "Added tests"}, "afterCommit": {"oid": "1f2ea16c28eb4684e7bae9197c5c335e41a68e20", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1f2ea16c28eb4684e7bae9197c5c335e41a68e20", "committedDate": "2020-08-28T17:10:23Z", "message": "Added tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f2ea16c28eb4684e7bae9197c5c335e41a68e20", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1f2ea16c28eb4684e7bae9197c5c335e41a68e20", "committedDate": "2020-08-28T17:10:23Z", "message": "Added tests"}, "afterCommit": {"oid": "8113fb8b2054c6bcc84309097e861939836e579f", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8113fb8b2054c6bcc84309097e861939836e579f", "committedDate": "2020-08-28T17:13:22Z", "message": "Added tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8113fb8b2054c6bcc84309097e861939836e579f", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8113fb8b2054c6bcc84309097e861939836e579f", "committedDate": "2020-08-28T17:13:22Z", "message": "Added tests"}, "afterCommit": {"oid": "738323dbc82e74d744bdc4230582ebda34620c14", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/738323dbc82e74d744bdc4230582ebda34620c14", "committedDate": "2020-08-28T17:42:37Z", "message": "Added tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "738323dbc82e74d744bdc4230582ebda34620c14", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/738323dbc82e74d744bdc4230582ebda34620c14", "committedDate": "2020-08-28T17:42:37Z", "message": "Added tests"}, "afterCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f332e338611c643f8b2e7cde9bf2e8894230a56a", "committedDate": "2020-08-31T17:12:04Z", "message": "Fix unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODM4NzEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-478838712", "createdAt": "2020-08-31T18:20:37Z", "commit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODoyMDozN1rOHKDhiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODo0MjozMFrOHKEQwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMwNTU0NA==", "bodyText": "DynamicComponentConfigurationValidator.class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480305544", "createdAt": "2020-08-31T18:20:37Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMwOTI0NQ==", "bodyText": "What if proposed is null? (the new serviceConfig doesn't have \"parameter\" part)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480309245", "createdAt": "2020-08-31T18:27:19Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMTk4Mw==", "bodyText": "This can cause one report blocking on future reports. Could you add a TODo here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480311983", "createdAt": "2020-08-31T18:32:19Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects.deepEquals(proposedConfig,\n+                        currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component\" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;\n+                }\n+            }\n+            if (validationRequested) {\n+                try {\n+                    // TODO : Use configurable timeout from deployment document\n+                    CompletableFuture.allOf(componentsToValidate.stream().map(ComponentToValidate::getResponse)\n+                            .collect(Collectors.toSet()).toArray(new CompletableFuture[0]))\n+                            .get(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n+                    failureMsg = \"Components reported that their to-be-deployed configuration is invalid\";\n+                    for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                        ConfigurationValidityReport report = componentToValidate.response.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMzk2MA==", "bodyText": "Will this override the previous failure message?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480313960", "createdAt": "2020-08-31T18:35:50Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(60).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DeploymentConfigMerger.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (String serviceName : servicesConfig.keySet()) {\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(servicesConfig.get(serviceName) instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) servicesConfig.get(serviceName);\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        Topics current = currentServiceConfig.findTopics(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects.deepEquals(proposedConfig,\n+                        currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component\" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;\n+                }\n+            }\n+            if (validationRequested) {\n+                try {\n+                    // TODO : Use configurable timeout from deployment document\n+                    CompletableFuture.allOf(componentsToValidate.stream().map(ComponentToValidate::getResponse)\n+                            .collect(Collectors.toSet()).toArray(new CompletableFuture[0]))\n+                            .get(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n+                    failureMsg = \"Components reported that their to-be-deployed configuration is invalid\";\n+                    for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                        ConfigurationValidityReport report = componentToValidate.response.join();\n+                        if (ConfigurationValidityStatus.INVALID.equals(report.getStatus())) {\n+                            failureMsg = String.format(\"%s { name = %s, message = %s }\", failureMsg,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNDg3MA==", "bodyText": "make this a private method such as\neventReceivedByClient = subscribeValidator((configMap) -> {\n  assertThat(configMap, IsMapContaining.hasEntry(\"\"));\n  return VALID;\n});", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480314870", "createdAt": "2020-08-31T18:37:28Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNzYzMg==", "bodyText": "NIT: rename to createTestDeployment()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480317632", "createdAt": "2020-08-31T18:42:30Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_invalidates_config_THEN_deployment_fails()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.INVALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE, result.getDeploymentStatus());\n+            assertTrue(result.getFailureCause() instanceof DynamicConfigurationValidationException);\n+            assertTrue(result.getFailureCause().getMessage() != null && result.getFailureCause().getMessage().contains(\"Components reported that their to-be-deployed configuration is invalid\"));\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    private Deployment testDeployment() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4ODY0ODU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-478864854", "createdAt": "2020-08-31T18:59:45Z", "commit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODo1OTo0NlrOHKE1Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxOTowNjo1MFrOHKFDgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMyNjkyMg==", "bodyText": "This can be in afterEach", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480326922", "createdAt": "2020-08-31T18:59:46Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DynamicComponentConfigurationValidationTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package com.aws.iot.evergreen.integrationtests.deployment;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentConfigMerger;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.deployment.model.DeploymentSafetyPolicy;\n+import com.aws.iot.evergreen.deployment.model.FailureHandlingPolicy;\n+import com.aws.iot.evergreen.ipc.IPCClient;\n+import com.aws.iot.evergreen.ipc.IPCClientImpl;\n+import com.aws.iot.evergreen.ipc.config.KernelIPCClientConfig;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStore;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.exceptions.ConfigStoreIPCException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.DEFAULT;\n+import static com.aws.iot.evergreen.integrationtests.ipc.IPCTestUtils.getIPCConfigForService;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICE_LIFECYCLE_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.kernel.GenericExternalService.LIFECYCLE_RUN_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DynamicComponentConfigurationValidationTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    private IPCClient client;\n+    private Kernel kernel;\n+    private DeploymentConfigMerger deploymentConfigMerger;\n+\n+    @BeforeEach\n+    void before() throws Exception {\n+        kernel = new Kernel();\n+        deploymentConfigMerger = new DeploymentConfigMerger(kernel);\n+\n+        // launch kernel\n+        kernel.launch();\n+        CountDownLatch mainRunning = new CountDownLatch(1);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING)) {\n+                mainRunning.countDown();\n+            }\n+        });\n+        kernel.launch();\n+\n+        // Start a new service\n+        AtomicBoolean mainRestarted = new AtomicBoolean(false);\n+        AtomicBoolean serviceStarted = new AtomicBoolean(false);\n+        kernel.getContext().addGlobalStateChangeListener((service, oldState, newState) -> {\n+            if (service.getName().equals(\"main\") && newState.equals(State.RUNNING) && oldState.equals(State.STARTING)) {\n+                mainRestarted.set(true);\n+            }\n+            if (service.getName().equals(\"OldService\") && newState.equals(State.RUNNING) && oldState\n+                    .equals(State.STARTING)) {\n+                serviceStarted.set(true);\n+            }\n+        });\n+        HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+            put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                put(\"OldService\", new HashMap<Object, Object>() {{\n+                    put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                        put(\"ConfigKey1\", \"ConfigValue1\");\n+                    }});\n+                    put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                        put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                    }});\n+                    put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                }});\n+            }});\n+        }};\n+        deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+\n+        assertTrue(mainRestarted.get());\n+        assertTrue(serviceStarted.get());\n+    }\n+\n+    @AfterEach\n+    void after() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_validates_config_THEN_deployment_is_successful()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.SUCCESSFUL, result.getDeploymentStatus());\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_deployment_changes_component_config_WHEN_component_invalidates_config_THEN_deployment_fails()\n+            throws Throwable {\n+        try {\n+            // Subscribe to config validation on behalf of the running service\n+            KernelIPCClientConfig config = getIPCConfigForService(\"OldService\", kernel);\n+            client = new IPCClientImpl(config);\n+            ConfigStore c = new ConfigStoreImpl(client);\n+\n+            CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+            c.subscribeToValidateConfiguration((configMap) -> {\n+                assertThat(configMap, IsMapContaining.hasEntry(\"ConfigKey1\", \"ConfigValue2\"));\n+                eventReceivedByClient.countDown();\n+                try {\n+                    c.sendConfigurationValidityReport(ConfigurationValidityStatus.INVALID, null);\n+                } catch (ConfigStoreIPCException e) {\n+                }\n+            });\n+\n+            // Attempt changing the configuration for the running service\n+            HashMap<Object, Object> newConfig = new HashMap<Object, Object>() {{\n+                put(SERVICES_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                    put(\"OldService\", new HashMap<Object, Object>() {{\n+                        put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                            put(\"ConfigKey1\", \"ConfigValue2\");\n+                        }});\n+                        put(SERVICE_LIFECYCLE_NAMESPACE_TOPIC, new HashMap<Object, Object>() {{\n+                            put(LIFECYCLE_RUN_NAMESPACE_TOPIC, \"echo Running OldService\");\n+                        }});\n+                        put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+                    }});\n+                }});\n+            }};\n+            DeploymentResult result =\n+                    deploymentConfigMerger.mergeInNewConfig(testDeployment(), newConfig).get(60, TimeUnit.SECONDS);\n+            assertEquals(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE, result.getDeploymentStatus());\n+            assertTrue(result.getFailureCause() instanceof DynamicConfigurationValidationException);\n+            assertTrue(result.getFailureCause().getMessage() != null && result.getFailureCause().getMessage().contains(\"Components reported that their to-be-deployed configuration is invalid\"));\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            client.disconnect();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMzMDYyNg==", "bodyText": "Why using lenient here?Is it expected that the API not called?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r480330626", "createdAt": "2020-08-31T19:06:50Z", "author": {"login": "ShirleyZheng92"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidatorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static com.aws.iot.evergreen.testcommons.testutilities.ExceptionLogProtector.ignoreExceptionUltimateCauseWithMessage;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class DynamicComponentConfigurationValidatorTest {\n+    private static final String DEFAULT_EXISTING_SERVICE_VERSION = \"1.0.0\";\n+    private static final long DEFAULT_EXISTING_NODE_MOD_TIME = 10;\n+    private static final long DEFAULT_DEPLOYMENT_TIMESTAMP = 100;\n+\n+    @Mock\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private Context context;\n+\n+    @Mock\n+    private CompletableFuture<DeploymentResult> deploymentResultFuture;\n+\n+    private DynamicComponentConfigurationValidator validator;\n+\n+    @BeforeEach\n+    public void beforeEach() throws Exception {\n+        lenient().when(kernel.getContext()).thenReturn(context);\n+        validator = new DynamicComponentConfigurationValidator(kernel, configStoreIPCAgent);\n+    }\n+\n+    @AfterEach\n+    public void afterEach() throws Exception {\n+        context.close();\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_changes_service_config_WHEN_service_validates_config_THEN_succeed() throws Exception {\n+        lenient().when(configStoreIPCAgent.validateConfiguration(any(), any(), any())).thenAnswer(invocationOnMock -> {\n+            CompletableFuture<ConfigurationValidityReport> validityReportFuture = invocationOnMock.getArgument(2);\n+            validityReportFuture\n+                    .complete(ConfigurationValidityReport.builder().status(ConfigurationValidityStatus.VALID).build());\n+            return true;\n+        });\n+        createMockGenericExternalService(\"OldService\");\n+        HashMap<String, Object> servicesConfig = new HashMap<String, Object>() {{\n+            put(\"OldService\", new HashMap<Object, Object>() {{\n+                put(PARAMETERS_CONFIG_KEY, new HashMap<Object, Object>() {{\n+                    put(\"ConfigKey1\", \"ConfigValue2\");\n+                }});\n+                put(VERSION_CONFIG_KEY, DEFAULT_EXISTING_SERVICE_VERSION);\n+            }});\n+        }};\n+        assertTrue(validator.validate(servicesConfig, createTestDeployment(), deploymentResultFuture));\n+    }\n+\n+    @Test\n+    public void GIVEN_deployment_changes_service_config_WHEN_service_invalidates_config_THEN_fail_deployment()\n+            throws Exception {\n+        lenient().when(configStoreIPCAgent.validateConfiguration(any(), any(), any())).thenAnswer(invocationOnMock -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a"}, "originalPosition": 96}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f332e338611c643f8b2e7cde9bf2e8894230a56a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f332e338611c643f8b2e7cde9bf2e8894230a56a", "committedDate": "2020-08-31T17:12:04Z", "message": "Fix unit tests"}, "afterCommit": {"oid": "f2a3ce7f6fde4e36bef52f6a7e5fa838fff0f9b5", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f2a3ce7f6fde4e36bef52f6a7e5fa838fff0f9b5", "committedDate": "2020-09-01T01:18:38Z", "message": "Enhancements, addressing comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTU2OTM4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-480156938", "createdAt": "2020-09-01T22:20:11Z", "commit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjozMTozNlrOHLKf1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjo1MjoxOVrOHLK7dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2ODM3Mw==", "bodyText": "If currentConfig is null then if proposedConfig is null then it should return false right? Isn't this going to return true right now?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r481468373", "createdAt": "2020-09-01T22:31:36Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MzEwNw==", "bodyText": "Why marking validationRequested and valid as false when a service has not subscribed? Those which have subscribed will not be evaluated then ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r481473107", "createdAt": "2020-09-01T22:45:10Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {\n+                    validationRequested = false;\n+                    failureMsg = \"Error requesting validation from component \" + componentToValidate.componentName;\n+                    valid = false;\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTQ0NA==", "bodyText": "Isn't this exception thrown when IPC is already waiting for response from the component? Whereas here we want to identify if the service never subscribed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r481475444", "createdAt": "2020-09-01T22:52:19Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }\n+            } catch (ServiceLoadException e) {\n+                // service not found, service is new\n+                continue;\n+            }\n+            if (!(serviceConfig instanceof Map)) {\n+                throw new InvalidConfigFormatException(\"Services config must be a map\");\n+            }\n+            Map<String, Object> proposedServiceConfig = (Map) serviceConfig;\n+\n+            // TODO: Check recipe flag for if service can handle dynamic configuration if not, it'll be restarted\n+            //  since it's likely if services can't handle dynamic config they are not IPC aware at all\n+            if (!willChildTopicChange(proposedServiceConfig, currentServiceConfig, VERSION_CONFIG_KEY,\n+                    proposedTimestamp) && willChildTopicsChange(proposedServiceConfig, currentServiceConfig,\n+                    PARAMETERS_CONFIG_KEY, proposedTimestamp)) {\n+                componentsToValidate.add(new ComponentToValidate(serviceName,\n+                        (Map<String, Object>) proposedServiceConfig.get(PARAMETERS_CONFIG_KEY)));\n+            }\n+        }\n+        return componentsToValidate;\n+    }\n+\n+    private boolean willChildTopicsChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                          String key, long proposedTimestamp) throws InvalidConfigFormatException {\n+        Object proposed = proposedServiceConfig.get(key);\n+        if (!(proposed instanceof Map)) {\n+            throw new InvalidConfigFormatException(\"Config for \" + key + \" must be a map\");\n+        }\n+        Topics current = currentServiceConfig.findTopics(key);\n+        return willNodeChange(proposed, current, proposedTimestamp);\n+    }\n+\n+    private boolean willChildTopicChange(Map<String, Object> proposedServiceConfig, Topics currentServiceConfig,\n+                                         String key, long proposedTimestamp) {\n+        return willNodeChange(proposedServiceConfig.get(key), currentServiceConfig.findNode(key), proposedTimestamp);\n+    }\n+\n+    private boolean willNodeChange(Object proposedConfig, Node currentConfig, long proposedTimestamp) {\n+        return Objects.isNull(currentConfig) ? Objects.isNull(proposedConfig)\n+                : proposedTimestamp > currentConfig.getModtime() && !Objects\n+                        .deepEquals(proposedConfig, currentConfig.toPOJO());\n+    }\n+\n+    private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n+                                    CompletableFuture deploymentResultFuture) {\n+        try {\n+            String failureMsg = null;\n+            boolean validationRequested = false;\n+            boolean valid = true;\n+            for (ComponentToValidate componentToValidate : componentsToValidate) {\n+                try {\n+                    if (configStoreIPCAgent\n+                            .validateConfiguration(componentToValidate.componentName, componentToValidate.configuration,\n+                                    componentToValidate.response)) {\n+                        validationRequested = true;\n+                    }\n+                    // Do nothing if service has not subscribed for validation\n+                } catch (ValidateEventRegistrationException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76"}, "originalPosition": 164}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "41c20f29eeb04e4f41872fe37f86d8c56b0aab76", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/41c20f29eeb04e4f41872fe37f86d8c56b0aab76", "committedDate": "2020-09-01T17:02:31Z", "message": "Fix spotbugs"}, "afterCommit": {"oid": "21d8cc5063ac78fdbcf33131bb35d9ee45cc3103", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21d8cc5063ac78fdbcf33131bb35d9ee45cc3103", "committedDate": "2020-09-02T17:54:08Z", "message": "Address comments, fix registration failure handling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjUyMTI4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-481252128", "createdAt": "2020-09-02T19:54:53Z", "commit": {"oid": "21d8cc5063ac78fdbcf33131bb35d9ee45cc3103"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo1NDo1M1rOHMBx8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxOTo1NDo1M1rOHMBx8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM3NDEzMQ==", "bodyText": "Why skip here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#discussion_r482374131", "createdAt": "2020-09-02T19:54:53Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package com.aws.iot.evergreen.deployment;\n+\n+import com.aws.iot.evergreen.builtin.services.configstore.ConfigStoreIPCAgent;\n+import com.aws.iot.evergreen.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.exceptions.DynamicConfigurationValidationException;\n+import com.aws.iot.evergreen.deployment.exceptions.InvalidConfigFormatException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GenericExternalService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.time.Duration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+/**\n+ * Asks component processes over IPC to validate proposed component configuration a deployment brings.\n+ */\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class DynamicComponentConfigurationValidator {\n+    public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n+    // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final Logger logger = LogManager.getLogger(DynamicComponentConfigurationValidator.class);\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    @Inject\n+    private ConfigStoreIPCAgent configStoreIPCAgent;\n+\n+    /**\n+     * Dynamically validate proposed configuration for a deployment.\n+     *\n+     * @param servicesConfig         aggregate configuration map for services proposed by the deployment\n+     * @param deployment             deployment context\n+     * @param deploymentResultFuture deployment result future, completed with failure result when validation fails\n+     * @return if all component processes reported that their proposed configuration is valid\n+     */\n+    public boolean validate(Map<String, Object> servicesConfig, Deployment deployment,\n+                            CompletableFuture deploymentResultFuture) {\n+        logger.addDefaultKeyValue(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());\n+        Set<ComponentToValidate> componentsToValidate;\n+        try {\n+            componentsToValidate =\n+                    getComponentsToValidate(servicesConfig, deployment.getDeploymentDocumentObj().getTimestamp());\n+        } catch (InvalidConfigFormatException e) {\n+            deploymentResultFuture.complete(\n+                    new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE,\n+                            new DynamicConfigurationValidationException(e)));\n+            return false;\n+        }\n+\n+        return validateOverIpc(componentsToValidate, deploymentResultFuture);\n+    }\n+\n+    /**\n+     * A component will not be asked to validate configuration if the deployment also intends to change its version.\n+     * This helps prevent failures when the configuration to be validated has new keys or schema that the running\n+     * version of the component doesn't understand and won't be able to validate. We rely on the fact that since the\n+     * component will restart on version change, its startup logic will handle any configuration usage.\n+     */\n+    private Set<ComponentToValidate> getComponentsToValidate(Map<String, Object> servicesConfig, long proposedTimestamp)\n+            throws InvalidConfigFormatException {\n+        Set<ComponentToValidate> componentsToValidate = new HashSet<>();\n+\n+        for (Map.Entry<String, Object> serviceConfigEntry : servicesConfig.entrySet()) {\n+            String serviceName = serviceConfigEntry.getKey();\n+            Object serviceConfig = serviceConfigEntry.getValue();\n+            Topics currentServiceConfig;\n+            try {\n+                EvergreenService service = kernel.locate(serviceName);\n+                if (!(service instanceof GenericExternalService)) {\n+                    // No validation for internal services since currently all customer services are external\n+                    continue;\n+                }\n+                currentServiceConfig = service.getServiceConfig();\n+                if (currentServiceConfig == null) {\n+                    continue;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21d8cc5063ac78fdbcf33131bb35d9ee45cc3103"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMjY0NDEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-481264412", "createdAt": "2020-09-02T20:12:39Z", "commit": {"oid": "21d8cc5063ac78fdbcf33131bb35d9ee45cc3103"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c54ce001feae9a6bb60dfbe50c3f4ac38ce27359", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c54ce001feae9a6bb60dfbe50c3f4ac38ce27359", "committedDate": "2020-09-03T08:49:23Z", "message": "First pass at validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bc9acc457d0dca7d46e6216eae860a9871af1c1", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2bc9acc457d0dca7d46e6216eae860a9871af1c1", "committedDate": "2020-09-03T08:49:23Z", "message": "Simplify criteria"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "903f6a7a232c1cf1fc4840f437127274c63e5988", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/903f6a7a232c1cf1fc4840f437127274c63e5988", "committedDate": "2020-09-03T08:49:23Z", "message": "Added tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29b033ab15102be998ce84e38977677302269390", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/29b033ab15102be998ce84e38977677302269390", "committedDate": "2020-09-03T08:49:23Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc8f5dc4c124c1f0f61e27580c6eb1a6ef2f4447", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cc8f5dc4c124c1f0f61e27580c6eb1a6ef2f4447", "committedDate": "2020-09-03T08:49:23Z", "message": "Fix unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6caf7f2f535ce4345281ac89ab535b98e49c55cf", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6caf7f2f535ce4345281ac89ab535b98e49c55cf", "committedDate": "2020-09-03T08:49:23Z", "message": "Enhancements, addressing comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7465c3da0410b6f8e9067cbb61d421dddcbe9c6", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d7465c3da0410b6f8e9067cbb61d421dddcbe9c6", "committedDate": "2020-09-03T08:49:23Z", "message": "Fix spotbugs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34ec4da57e07f57f3f95767f8a95a61313846c6b", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/34ec4da57e07f57f3f95767f8a95a61313846c6b", "committedDate": "2020-09-03T08:49:23Z", "message": "Address comments, fix registration failure handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e9f2c6d1efca415f95cdc34428789f4858e9382", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1e9f2c6d1efca415f95cdc34428789f4858e9382", "committedDate": "2020-09-03T08:49:23Z", "message": "Fix integ tests, and fix bug that the integ test failure uncovered"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd127069ab00b406d11077d20add5416fcb7150c", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fd127069ab00b406d11077d20add5416fcb7150c", "committedDate": "2020-09-02T23:18:54Z", "message": "Merge branch 'master' into validation"}, "afterCommit": {"oid": "1e9f2c6d1efca415f95cdc34428789f4858e9382", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1e9f2c6d1efca415f95cdc34428789f4858e9382", "committedDate": "2020-09-03T08:49:23Z", "message": "Fix integ tests, and fix bug that the integ test failure uncovered"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDcwNDkz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-482070493", "createdAt": "2020-09-03T17:50:00Z", "commit": {"oid": "1e9f2c6d1efca415f95cdc34428789f4858e9382"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDcxNjk3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/391#pullrequestreview-482071697", "createdAt": "2020-09-03T17:51:47Z", "commit": {"oid": "1e9f2c6d1efca415f95cdc34428789f4858e9382"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5912722a33c6aeb728351e6bf30810880bcfc34", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f5912722a33c6aeb728351e6bf30810880bcfc34", "committedDate": "2020-09-03T17:54:00Z", "message": "Merge branch 'master' into validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffd9975a5fb70fa9a23cf2dc40fed9679c84bcdd", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ffd9975a5fb70fa9a23cf2dc40fed9679c84bcdd", "committedDate": "2020-09-03T19:37:53Z", "message": "Merge branch 'master' into validation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3210, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}