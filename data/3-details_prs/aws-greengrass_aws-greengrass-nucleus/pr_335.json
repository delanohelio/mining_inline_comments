{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MDQ0MzMz", "number": 335, "title": "Implement Fleet Status Service", "bodyText": "Issue #, if available:\nDescription of changes:\nThe fleet status service will be gathering state from the device and providing it to the customers. The fleet status service is an important feature to provide insight to the customer on the devices which have greengrass V2 running on them and answering questions like Is the device running the greengrass application as expected? What happened on the device after the recent deployment, did a service start failing/flapping after it? etc. Based on these statuses, the customer can take appropriate actions to build their infrastructure to take actions on them.\nThe fleet status service will be an auto-started service within the kernel since we always need the status information about the device during deployments. The customer can configure the periodic update interval from the configuration parameters.\nThe fleet status service will update the fleet information in two scenarios:\n\nEvent Based updates: The event based triggers will only update the statuses of those services whose state changed. The event based triggers are:\n\n\nDeployment finishes.\nComponent goes into BROKEN state after deployment.\n\n\nPeriodic updates. The default interval is 1 day. The update will contain statuses of all the components running on the device.\n\nWhy is this change necessary:\nThis change will give the customer an insight into how the different components within a fleet are doing during and after deployment. This will enable the customer to act on any changes needed to make the group run smoothly.\nHow was this change tested:\nAdded UTs for the service. Also added an E2E test for it.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-07-28T20:43:56Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335", "merged": true, "mergeCommit": {"oid": "e6bd149c8f60c37413a16656c5ebf16dfc01c6f9"}, "closed": true, "closedAt": "2020-08-14T18:33:15Z", "author": {"login": "nikkhilmuthye"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5G9wZgH2gAyNDU4MDQ0MzMzOjEyOGRkMGRjOGQ4MzY1YzVhNzI1NWFlYmY5ZmFhZmUzMjQ1ZGIwNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-4oZuAFqTQ2Nzc3NDE2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "128dd0dc8d8365c5a7255aebf9faafe3245db062", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/128dd0dc8d8365c5a7255aebf9faafe3245db062", "committedDate": "2020-07-27T19:26:39Z", "message": "Implment Fleet Status Service."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8552e1ffb051ce3248ecf548aa498181c83588dd", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8552e1ffb051ce3248ecf548aa498181c83588dd", "committedDate": "2020-07-27T20:54:48Z", "message": "Add more unit tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b2d9fecfb5d97eb5df95a6048a820987304caf53", "committedDate": "2020-07-28T20:01:54Z", "message": "Adding logic to handle getting dependencies fleet config from root components."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDAxMDY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-457001067", "createdAt": "2020-07-28T20:49:29Z", "commit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDo0OToyOVrOG4eTQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDo0OToyOVrOG4eTQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2OTg5MQ==", "bodyText": "why do we need the account id? That should be kept somewhat private.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461869891", "createdAt": "2020-07-28T20:49:29Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeviceConfiguration.java", "diffHunk": "@@ -73,10 +74,11 @@ public DeviceConfiguration(Kernel kernel) {\n      * @param certificateFilePath certificate location on device\n      * @param rootCaFilePath      downloaded RootCA location on device\n      * @param awsRegion           aws region for the device\n+     * @param accountId           aws region for the device\n      */\n     public DeviceConfiguration(Kernel kernel, String thingName, String iotDataEndpoint, String iotCredEndpoint,\n                                String privateKeyPath, String certificateFilePath, String rootCaFilePath,\n-                               String awsRegion) {\n+                               String awsRegion, String accountId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDAyNDI3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-457002427", "createdAt": "2020-07-28T20:51:31Z", "commit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDo1MTozMlrOG4eXjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDo1MzowNVrOG4eamg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MDk4OQ==", "bodyText": "don't log. We already log this elsewhere", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461870989", "createdAt": "2020-07-28T20:51:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    public static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+    public static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    /**\n+     * Constructor for EvergreenService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        logger.atTrace().log(\"Service name: {}, oldState: {}, newState: {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MTU3MA==", "bodyText": "OverallStatus", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461871570", "createdAt": "2020-07-28T20:52:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/OverAllStatus.java", "diffHunk": "@@ -0,0 +1,11 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+public enum OverAllStatus {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MTc3MA==", "bodyText": "perform a nullcheck", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461871770", "createdAt": "2020-07-28T20:53:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -509,6 +510,7 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n             context.get(Kernel.class).clearODcache();\n+            context.get(FleetStatusService.class).updateRemovedDependencies(removedDependencies);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDA4Mjc2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-457008276", "createdAt": "2020-07-28T21:00:07Z", "commit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTowMDowN1rOG4eqIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTowMDowN1rOG4eqIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NTc0Nw==", "bodyText": "This is a really bad idea.\nIf you want the full arn, which I'm not sure that you do because just the group name should be fine, then save the full arn from the deployment instead of trying to reconstruct it (incorrectly).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461875747", "createdAt": "2020-07-28T21:00:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    public static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+    public static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    /**\n+     * Constructor for EvergreenService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        logger.atTrace().log(\"Service name: {}, oldState: {}, newState: {}\",\n+                evergreenService.getName(), oldState, newState);\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverAllStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        return true;\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverAllStatus overAllStatus) {\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (ExecutionException | InterruptedException | TimeoutException | JsonProcessingException e) {\n+            logger.atError().cause(e);\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();\n+\n+        try {\n+            EvergreenService deploymentService2 = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            Topics groupsToRootPackages2 =\n+                    deploymentService2.getConfig().lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS);\n+\n+            // Get all the groups associated to the root components.\n+            groupsToRootPackages2.iterator().forEachRemaining(groupNode -> {\n+                Topics groupTopics = (Topics) groupNode;\n+                String groupName = groupTopics.getName();\n+                groupNamesSet.add(groupName);\n+\n+                groupTopics.iterator().forEachRemaining(pkgNode -> {\n+                    Topics pkgTopics = (Topics) pkgNode;\n+                    Topic lookup = pkgTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY);\n+                    String groupVersion = (String) lookup.getOnce();\n+                    String groupName2 = Arn.builder()\n+                            .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                            .withService(FLEET_STATUS_ARN_SERVICE)\n+                            .withAccountId(Coerce.toString(deviceConfiguration.getAccountId()))\n+                            .withRegion(Coerce.toString(deviceConfiguration.getAWSRegion()))\n+                            .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, groupName,\n+                                    groupVersion))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MDA4NzU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-457008755", "createdAt": "2020-07-28T21:00:49Z", "commit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTowMDo1MFrOG4ervg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMTowMDo1MFrOG4ervg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NjE1OA==", "bodyText": "this won't do anything. You need to end all logs with .log() so that it actually logs", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r461876158", "createdAt": "2020-07-28T21:00:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    public static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+    public static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    /**\n+     * Constructor for EvergreenService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        logger.atTrace().log(\"Service name: {}, oldState: {}, newState: {}\",\n+                evergreenService.getName(), oldState, newState);\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverAllStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        AtomicReference<OverAllStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverAllStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        return true;\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverAllStatus overAllStatus) {\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (ExecutionException | InterruptedException | TimeoutException | JsonProcessingException e) {\n+            logger.atError().cause(e);\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();\n+\n+        try {\n+            EvergreenService deploymentService2 = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            Topics groupsToRootPackages2 =\n+                    deploymentService2.getConfig().lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS);\n+\n+            // Get all the groups associated to the root components.\n+            groupsToRootPackages2.iterator().forEachRemaining(groupNode -> {\n+                Topics groupTopics = (Topics) groupNode;\n+                String groupName = groupTopics.getName();\n+                groupNamesSet.add(groupName);\n+\n+                groupTopics.iterator().forEachRemaining(pkgNode -> {\n+                    Topics pkgTopics = (Topics) pkgNode;\n+                    Topic lookup = pkgTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_VERSION_KEY);\n+                    String groupVersion = (String) lookup.getOnce();\n+                    String groupName2 = Arn.builder()\n+                            .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                            .withService(FLEET_STATUS_ARN_SERVICE)\n+                            .withAccountId(Coerce.toString(deviceConfiguration.getAccountId()))\n+                            .withRegion(Coerce.toString(deviceConfiguration.getAWSRegion()))\n+                            .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, groupName,\n+                                    groupVersion))\n+                            .build().toString();\n+                    Set<String> groupSet = packageToGroupsMappingCache\n+                            .getOrDefault(pkgTopics.getName(), new HashSet<>());\n+                    groupSet.add(groupName2);\n+                    packageToGroupsMappingCache.put(pkgTopics.getName(), groupSet);\n+                    pendingPackagesList.add(pkgTopics.getName());\n+                });\n+            });\n+        } catch (ServiceLoadException e) {\n+            return packageToGroupsMappingCache;\n+        }\n+\n+        // Associate the groups to the dependant services based on the services it is depending on.\n+        while (!pendingPackagesList.isEmpty()) {\n+            String pkgList = pendingPackagesList.get(0);\n+            try {\n+                EvergreenService evergreenService = this.kernel.locate(pkgList);\n+                Set<String> groupName2 = packageToGroupsMappingCache\n+                        .getOrDefault(evergreenService.getName(), new HashSet<>());\n+\n+                evergreenService.getDependencies().forEach((evergreenService1, dependencyType) -> {\n+                    pendingPackagesList.add(evergreenService1.getName());\n+                    Set<String> groupSet = packageToGroupsMappingCache\n+                            .getOrDefault(evergreenService1.getName(), new HashSet<>());\n+                    groupSet.addAll(groupName2);\n+                    packageToGroupsMappingCache.put(evergreenService1.getName(), groupSet);\n+                });\n+            } catch (ServiceLoadException ex) {\n+                logger.atError().cause(ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2d9fecfb5d97eb5df95a6048a820987304caf53"}, "originalPosition": 289}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64abcf5ae449710fc424588f4e63bf7e1daced48", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/64abcf5ae449710fc424588f4e63bf7e1daced48", "committedDate": "2020-07-28T21:44:10Z", "message": "Address PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55f06d0295042ffc8bb46985d92a115ecc3a0806", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/55f06d0295042ffc8bb46985d92a115ecc3a0806", "committedDate": "2020-07-28T21:51:29Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ff7bf1dca17179164bb861d0836572f9d13f8b5", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2ff7bf1dca17179164bb861d0836572f9d13f8b5", "committedDate": "2020-07-28T22:02:02Z", "message": "Fix build after addressing PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec534235d151d68e0f8949c3d8d2c8c97223f6b3", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec534235d151d68e0f8949c3d8d2c8c97223f6b3", "committedDate": "2020-07-28T23:31:34Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "398d2e48386806279227544a24b080f012e13177", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/398d2e48386806279227544a24b080f012e13177", "committedDate": "2020-07-29T03:35:55Z", "message": "Handle MQTT connection interruptions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be9543ba5a68c5b762b4b4caae2837121a6bfcc5", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/be9543ba5a68c5b762b4b4caae2837121a6bfcc5", "committedDate": "2020-07-29T03:36:54Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae4a15d8a0908fe5e944fca412405d11b410e342", "committedDate": "2020-07-29T03:53:11Z", "message": "fix build."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4Nzg1NTEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-458785512", "createdAt": "2020-07-30T21:59:17Z", "commit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMTo1OToxOFrOG51TBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMjozOTo0NFrOG52QbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NTIzNw==", "bodyText": "Is this duplicate information? deploymentGroupTopics already is a map of group name (1:1 mapping to deployment ID) to deploymentGroupToRootPackages map", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463295237", "createdAt": "2020-07-30T21:59:18Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -210,23 +211,25 @@ private void finishCurrentDeployment() throws InterruptedException {\n             DeploymentResult result = currentDeploymentTaskMetadata.getDeploymentResultFuture().get();\n             if (result != null) {\n                 DeploymentResult.DeploymentStatus deploymentStatus = result.getDeploymentStatus();\n+\n                 Map<String, String> statusDetails = new HashMap<>();\n                 statusDetails.put(\"detailed-deployment-status\", deploymentStatus.name());\n                 if (deploymentStatus.equals(DeploymentResult.DeploymentStatus.SUCCESSFUL)) {\n                     //Add the root packages of successful deployment to the configuration\n                     DeploymentDocument deploymentDocument = currentDeploymentTaskMetadata.getDeploymentDocument();\n                     Topics deploymentGroupTopics = config.lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS,\n                             deploymentDocument.getGroupName());\n+\n                     Map<Object, Object> deploymentGroupToRootPackages = new HashMap<>();\n                     // TODO: Removal of group from the mappings. Currently there is no action taken when a device is\n                     //  removed from a thing group. Empty configuration is treated as a valid config for a group but\n                     //  not treated as removal.\n                     deploymentDocument.getDeploymentPackageConfigurationList().stream().forEach(pkgConfig -> {\n-                        if (pkgConfig.isRootComponent()) {\n-                            Map<Object, Object> pkgDetails = new HashMap<>();\n-                            pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());\n-                            deploymentGroupToRootPackages.put(pkgConfig.getPackageName(), pkgDetails);\n-                        }\n+                        Map<Object, Object> pkgDetails = new HashMap<>();\n+                        pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());\n+                        pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                                deploymentDocument.getDeploymentId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NTc5Nw==", "bodyText": "This version is used to resolve component version among multiple groups. Could you keep the same logic to only persist version for root components?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463295797", "createdAt": "2020-07-30T22:00:31Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -210,23 +211,25 @@ private void finishCurrentDeployment() throws InterruptedException {\n             DeploymentResult result = currentDeploymentTaskMetadata.getDeploymentResultFuture().get();\n             if (result != null) {\n                 DeploymentResult.DeploymentStatus deploymentStatus = result.getDeploymentStatus();\n+\n                 Map<String, String> statusDetails = new HashMap<>();\n                 statusDetails.put(\"detailed-deployment-status\", deploymentStatus.name());\n                 if (deploymentStatus.equals(DeploymentResult.DeploymentStatus.SUCCESSFUL)) {\n                     //Add the root packages of successful deployment to the configuration\n                     DeploymentDocument deploymentDocument = currentDeploymentTaskMetadata.getDeploymentDocument();\n                     Topics deploymentGroupTopics = config.lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS,\n                             deploymentDocument.getGroupName());\n+\n                     Map<Object, Object> deploymentGroupToRootPackages = new HashMap<>();\n                     // TODO: Removal of group from the mappings. Currently there is no action taken when a device is\n                     //  removed from a thing group. Empty configuration is treated as a valid config for a group but\n                     //  not treated as removal.\n                     deploymentDocument.getDeploymentPackageConfigurationList().stream().forEach(pkgConfig -> {\n-                        if (pkgConfig.isRootComponent()) {\n-                            Map<Object, Object> pkgDetails = new HashMap<>();\n-                            pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());\n-                            deploymentGroupToRootPackages.put(pkgConfig.getPackageName(), pkgDetails);\n-                        }\n+                        Map<Object, Object> pkgDetails = new HashMap<>();\n+                        pkgDetails.put(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgConfig.getResolvedVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NjUzNQ==", "bodyText": "Does it have to be a map instead of list?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463296535", "createdAt": "2020-07-30T22:02:20Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -33,26 +33,32 @@\n \n     private Topics processedDeployments;\n \n-    private final Map<DeploymentType, Function<Map<String, Object>, Boolean>> deploymentStatusConsumer\n+    private final Map<DeploymentType, Map<String, Function<Map<String, Object>, Boolean>>> deploymentStatusConsumerMap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzQ0OA==", "bodyText": "nit: is this thing name or thing arn? Same for thinggroups?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463297448", "createdAt": "2020-07-30T22:04:28Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzkwNQ==", "bodyText": "Is this a list of groups? Is it intended to be String?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463297905", "createdAt": "2020-07-30T22:05:37Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;\n+\n+    @JsonProperty(\"thingGroups\")\n+    private String thingGroups;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5ODYwMg==", "bodyText": "Maybe we should have a \"unstable\" if soft dependencies are broken.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463298602", "createdAt": "2020-07-30T22:07:30Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/OverallStatus.java", "diffHunk": "@@ -0,0 +1,11 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+public enum OverallStatus {\n+    HEALTHY,\n+    UNHEALTHY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5OTQ4MA==", "bodyText": "I'm not so sure about this. If a dependency is removed from one service, it can still be used by another. You may need a reference index map or simply list all services from kernel periodically", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463299480", "createdAt": "2020-07-30T22:09:53Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -552,6 +553,10 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n             context.get(Kernel.class).clearODcache();\n+            FleetStatusService fleetStatusService = context.get(FleetStatusService.class);\n+            if (fleetStatusService != null) {\n+                fleetStatusService.updateRemovedDependencies(removedDependencies);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5OTc5Mg==", "bodyText": "extract this to be a helper function", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463299792", "createdAt": "2020-07-30T22:10:40Z", "author": {"login": "hui-yang"}, "path": "src/test/java/com/aws/iot/evergreen/easysetup/DeviceProvisioningHelperTest.java", "diffHunk": "@@ -169,8 +170,11 @@ public void GIVEN_test_update_device_config_WHEN_thing_info_provided_THEN_add_co\n         Kernel kernel = new Kernel()\n                 .parseArgs(\"-i\", getClass().getResource(\"blank_config.yaml\").toString(), \"-r\", tempRootDir.toString());\n \n+        String thingArn = Arn.builder().withService(\"testService\")\n+                .withRegion(TEST_REGION).withAccountId(\"12345\").withPartition(\"testPartition\").withResource(\"testResoruce\")\n+                .build().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMDEzNQ==", "bodyText": "Intentional? Could you explain why?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463300135", "createdAt": "2020-07-30T22:11:34Z", "author": {"login": "hui-yang"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "diffHunk": "@@ -183,7 +183,7 @@ void GIVEN_package_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_ver\n \n             DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(pkgA), Collections\n                     .singletonList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, DeploymentSafetyPolicy.CHECK_SAFETY);\n+                     \"\", 1L, FailureHandlingPolicy.DO_NOTHING, DeploymentSafetyPolicy.CHECK_SAFETY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMTI1MQ==", "bodyText": "Why only IOT_JOBS?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463301251", "createdAt": "2020-07-30T22:14:42Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMTc1MA==", "bodyText": "Do you plan to cancel periodicUpdateFuture and restart a new one in this case?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463301750", "createdAt": "2020-07-30T22:15:55Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNDU1Mg==", "bodyText": "Is this correct? If overAllStatus is unhealthy due to svc1, it can be set back to healthy by svc2?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463304552", "createdAt": "2020-07-30T22:23:20Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNDc0MQ==", "bodyText": "same as above.\nThis common logic may be extracted to a function", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463304741", "createdAt": "2020-07-30T22:23:49Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNTgyNw==", "bodyText": "Thanks for the comment. It helps understanding the reasoning", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463305827", "createdAt": "2020-07-30T22:26:45Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNjI5OQ==", "bodyText": "Why is this generated each time? Is it possible to change thingname in kernel runtime?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463306299", "createdAt": "2020-07-30T22:28:04Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNzc5OA==", "bodyText": "Is this thread-safe? Can event-triggered and periodic update happen at the same time?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463307798", "createdAt": "2020-07-30T22:31:00Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTk5Mg==", "bodyText": "Why do we need this while loop? What is pendingPackagesList?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463309992", "createdAt": "2020-07-30T22:36:43Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();\n+\n+        try {\n+            EvergreenService deploymentService2 = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            Topics groupsToRootPackages2 =\n+                    deploymentService2.getConfig().lookupTopics(GROUP_TO_ROOT_COMPONENTS_TOPICS);\n+\n+            // Get all the groups associated to the root components.\n+            groupsToRootPackages2.iterator().forEachRemaining(groupNode -> {\n+                Topics groupTopics = (Topics) groupNode;\n+                String groupName = groupTopics.getName();\n+                groupNamesSet.add(groupName);\n+\n+                groupTopics.iterator().forEachRemaining(pkgNode -> {\n+                    Topics pkgTopics = (Topics) pkgNode;\n+                    Topic lookup = pkgTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID);\n+                    String groupDeploymentId = (String) lookup.getOnce();\n+                    Set<String> groupDeploymentIdSet = packageToGroupsMappingCache\n+                            .getOrDefault(pkgTopics.getName(), new HashSet<>());\n+                    groupDeploymentIdSet.add(groupDeploymentId);\n+                    packageToGroupsMappingCache.put(pkgTopics.getName(), groupDeploymentIdSet);\n+                    pendingPackagesList.add(pkgTopics.getName());\n+                });\n+            });\n+        } catch (ServiceLoadException e) {\n+            return packageToGroupsMappingCache;\n+        }\n+\n+        // Associate the groups to the dependant services based on the services it is depending on.\n+        while (!pendingPackagesList.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxMDk1Ng==", "bodyText": "Why are evergreenServiceMap and removedDependencies maps instead of sets?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463310956", "createdAt": "2020-07-30T22:39:44Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4OTE0NjM2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-458914636", "createdAt": "2020-07-31T04:52:52Z", "commit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNDo1Mjo1MlrOG577gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwNjoxNzowNFrOG59Npg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwMzkwNw==", "bodyText": "overAllStatus -> overallStatus", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463403907", "createdAt": "2020-07-31T04:52:52Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;\n+\n+    @JsonProperty(\"thingGroups\")\n+    private String thingGroups;\n+\n+    @JsonProperty(\"overallDeviceStatus\")\n+    private OverallStatus overAllStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwMzk5Mw==", "bodyText": "What's sequenceNumber for?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463403993", "createdAt": "2020-07-31T04:53:22Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;\n+\n+    @JsonProperty(\"thingGroups\")\n+    private String thingGroups;\n+\n+    @JsonProperty(\"overallDeviceStatus\")\n+    private OverallStatus overAllStatus;\n+\n+    @JsonProperty(\"sequenceNumber\")\n+    private long sequenceNumber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDE3MQ==", "bodyText": "What's fleetConfigArn? Why is it included here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463404171", "createdAt": "2020-07-31T04:54:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/ComponentStatusDetails.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ComponentStatusDetails {\n+    @JsonProperty(\"componentName\")\n+    private String componentName;\n+\n+    @JsonProperty(\"version\")\n+    private String version;\n+\n+    @JsonProperty(\"fleetConfigArn\")\n+    private String fleetConfigArn;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDQwOA==", "bodyText": "What's the difference between these two? Why do you need both?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463404408", "createdAt": "2020-07-31T04:54:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/ComponentStatusDetails.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ComponentStatusDetails {\n+    @JsonProperty(\"componentName\")\n+    private String componentName;\n+\n+    @JsonProperty(\"version\")\n+    private String version;\n+\n+    @JsonProperty(\"fleetConfigArn\")\n+    private String fleetConfigArn;\n+\n+    @JsonProperty(\"statusDetails\")\n+    private String statusDetails;\n+\n+    @JsonProperty(\"status\")\n+    private State state;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNjA1NQ==", "bodyText": "Or you do this way:\nSet<EvergreenService> services = Collections.newSetFromMap(new ConcurrentHashMap<>());", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463406055", "createdAt": "2020-07-31T05:02:02Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxMDk1Ng=="}, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTM5MA==", "bodyText": "Why is newState.equals(State.ERRORED part of the condition?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409390", "createdAt": "2020-07-31T05:16:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTc0NQ==", "bodyText": "Debug level? Why info?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409745", "createdAt": "2020-07-31T05:18:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTgwNA==", "bodyText": "Debug level is sufficient.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409804", "createdAt": "2020-07-31T05:18:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwOTg0Ng==", "bodyText": "Debug level", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463409846", "createdAt": "2020-07-31T05:18:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTMxNw==", "bodyText": "Why? If deployment service is broken, we don't want to report to FSS?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463411317", "createdAt": "2020-07-31T05:24:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMjg3Mg==", "bodyText": "Why do you put the service into the map before the condition check?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463412872", "createdAt": "2020-07-31T05:31:26Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDAwMA==", "bodyText": "Why are these two different methods? Isn't schedulePeriodicFssDataUpdate part of handleMqttConnectionResumed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463414000", "createdAt": "2020-07-31T05:36:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDU1MQ==", "bodyText": "Why not just roll this into schedulePeriodicFssDataUpdate() method? You can define when to start the first scheduled task using lastPeriodicUpdateTime.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463414551", "createdAt": "2020-07-31T05:38:29Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDgwMw==", "bodyText": "Why is this necessary? Shouldn't this be only triggered by deployment or service broken?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463414803", "createdAt": "2020-07-31T05:39:29Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNTM4Mg==", "bodyText": "This variable is updated by different threads. It needs to be synchronized. Using volatile or atomic variable.\nAlso isConnected is a better name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463415382", "createdAt": "2020-07-31T05:41:53Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNjIxMg==", "bodyText": "How do you know it's healthy? What if a service has been broken for two days?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463416212", "createdAt": "2020-07-31T05:45:07Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMDI1MA==", "bodyText": "Why LinkedList?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463420250", "createdAt": "2020-07-31T06:00:07Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {\n+        if (packageToGroupsMappingCache != null) {\n+            return packageToGroupsMappingCache;\n+        }\n+        packageToGroupsMappingCache = new ConcurrentHashMap<>();\n+        List<String> pendingPackagesList = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMTI2OA==", "bodyText": "Have you thought about using Periodicity class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463421268", "createdAt": "2020-07-31T06:03:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA==", "bodyText": "Don't use Package. We rename it to component now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463422158", "createdAt": "2020-07-31T06:07:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjg5MA==", "bodyText": "Also please don't use parameter to get output.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463422890", "createdAt": "2020-07-31T06:09:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA=="}, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyNDkzNA==", "bodyText": "The whole methods seems messy. Can we try not to compute it every time here? Why can't the deployment compute the information and update it in every deployment?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r463424934", "createdAt": "2020-07-31T06:17:04Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && (newState.equals(State.BROKEN) || newState.equals(State.ERRORED))) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atInfo().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            // Do not update status of auto-started services.\n+            if (!evergreenService.isAutostart()) {\n+                evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            }\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            packageToGroupsMappingCache = null;\n+            return true;\n+        }\n+        logger.atInfo().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+        overAllStatus.set(OverallStatus.HEALTHY);\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+    }\n+\n+    private void handleMqttConnectionResumed() {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any).\n+        if (lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else {\n+            updateEventTriggeredFssData();\n+        }\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (isMqttConnectionInterrupted) {\n+            logger.atInfo().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        String thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        String updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+        Set<String> groupNamesSet = new HashSet<>();\n+        Map<String, Set<String>> pkgToGroupMap = getPackagesToGroupsMapping(groupNamesSet);\n+\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = pkgToGroupMap.getOrDefault(serviceName, new HashSet<>()).stream()\n+                    .map(String::valueOf).collect(Collectors.joining(\",\"));\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+        String thingGroups = groupNamesSet.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overAllStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .thingGroups(thingGroups)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private Map<String, Set<String>> getPackagesToGroupsMapping(Set<String> groupNamesSet) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQyMjE1OA=="}, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 281}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "078dd74d2338e05eff66ad262f35d01fd2d7ea07", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/078dd74d2338e05eff66ad262f35d01fd2d7ea07", "committedDate": "2020-07-31T19:20:09Z", "message": "Address PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73c1b6fa7f1ea934244faf5de2dc319b7c84c683", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/73c1b6fa7f1ea934244faf5de2dc319b7c84c683", "committedDate": "2020-07-31T22:06:31Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae678893914cbc3204240aaa23dc8d2c13944e5b", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae678893914cbc3204240aaa23dc8d2c13944e5b", "committedDate": "2020-08-03T14:16:31Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b752cd7684eed191d797a9651c91a283e374eb4", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b752cd7684eed191d797a9651c91a283e374eb4", "committedDate": "2020-08-03T16:04:57Z", "message": "Address more PR comments. Move component to groups mapping in Deployment Service."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46b5456ba80bda6f79061adc84501e2d2348beaa", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/46b5456ba80bda6f79061adc84501e2d2348beaa", "committedDate": "2020-08-03T19:08:54Z", "message": "Add unit test for DeploymentService."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2106eb3b605303948e4f100df101d5d8f315654", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2106eb3b605303948e4f100df101d5d8f315654", "committedDate": "2020-08-03T19:16:06Z", "message": "Fix build."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjczMDgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-460273080", "createdAt": "2020-08-03T19:07:30Z", "commit": {"oid": "0b752cd7684eed191d797a9651c91a283e374eb4"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOTowNzozMFrOG7FZpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOToxNjo1NlrOG7FrMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzY1NA==", "bodyText": "I guess you just copied this over but for better readability\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Thread.sleep(10_000);\n          \n          \n            \n                    TimeUnit.SECONDS.sleep(10);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464607654", "createdAt": "2020-08-03T19:07:30Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        Thread.sleep(10_000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b752cd7684eed191d797a9651c91a283e374eb4"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzc2OQ==", "bodyText": "nice name. very clear", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464607769", "createdAt": "2020-08-03T19:07:45Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        Thread.sleep(10_000);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b752cd7684eed191d797a9651c91a283e374eb4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwOTE2Mw==", "bodyText": "What about test for trigger when broken? I'd say that's also an important one?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464609163", "createdAt": "2020-08-03T19:10:37Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        Thread.sleep(10_000);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYwNzc2OQ=="}, "originalCommit": {"oid": "0b752cd7684eed191d797a9651c91a283e374eb4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMDI1Nw==", "bodyText": "If that's the case (extra info only for error) then name it statusErrorMessage.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464610257", "createdAt": "2020-08-03T19:13:04Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/fss/ComponentStatusDetails.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ComponentStatusDetails {\n+    @JsonProperty(\"componentName\")\n+    private String componentName;\n+\n+    @JsonProperty(\"version\")\n+    private String version;\n+\n+    @JsonProperty(\"fleetConfigArn\")\n+    private String fleetConfigArn;\n+\n+    @JsonProperty(\"statusDetails\")\n+    private String statusDetails;\n+\n+    @JsonProperty(\"status\")\n+    private State state;\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQwNDQwOA=="}, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMTM4OA==", "bodyText": "Should also verify it doesn't contain removed services? maybe by assert on fleetStatusDetails2. getComponentStatusDetails.size()?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464611388", "createdAt": "2020-08-03T19:15:30Z", "author": {"login": "leaf94"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        Thread.sleep(10_000);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(String.format(\"$aws/things/%s/evergreen/health/json\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")\n+                        .withConfiguration(\"{\\\"sampleText\\\":\\\"FCS integ test\\\"}\"))\n+                .addPackagesEntry(\"SomeService\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult1 = setAndPublishFleetConfiguration(setRequest1);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult1.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        String someServiceName = getCloudDeployedComponent(\"SomeService\").getName();\n+\n+        // Second deployment to remove some services deployed previously\n+        SetConfigurationRequest setRequest2 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult2 = setAndPublishFleetConfiguration(setRequest2);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult2.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        // Ensure that main is finished, which is its terminal state, so this means that all updates ought to be done\n+        assertThat(kernel.getMain()::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThat(getCloudDeployedComponent(\"CustomerApp\")::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThrows(ServiceLoadException.class, () -> getCloudDeployedComponent(\"SomeService\").getState());\n+\n+        assertTrue(cdl.await(1, TimeUnit.MINUTES), \"All messages published and received\");\n+        assertEquals(2, mqttMessagesList.get().size());\n+\n+        Arn arn = Arn.builder()\n+                .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                .withService(FLEET_STATUS_ARN_SERVICE)\n+                .withAccountId(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getAccountId()))\n+                .withRegion(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getRegion()))\n+                .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, \"thinggroup/\" + thingGroupName, \"1\"))\n+                .build();\n+\n+        Set<String> userComponentsCloudName = new HashSet<>();\n+        userComponentsCloudName.add(getCloudDeployedComponent(\"Mosquitto\").getName());\n+        userComponentsCloudName.add(getCloudDeployedComponent(\"CustomerApp\").getName());\n+        userComponentsCloudName.add(getCloudDeployedComponent(\"GreenSignal\").getName());\n+        userComponentsCloudName.add(someServiceName);\n+        // Check the MQTT messages.\n+        MqttMessage receivedMqttMessage1 = mqttMessagesList.get().get(0);\n+        assertNotNull(receivedMqttMessage1.getPayload());\n+        FleetStatusDetails fleetStatusDetails1 = DESERIALIZER.readValue(receivedMqttMessage1.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails1.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails1.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails1.getOverallStatus());\n+        assertThat(fleetStatusDetails1.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(getCloudDeployedComponent(\"Mosquitto\").getName(), someServiceName,\n+                        getCloudDeployedComponent(\"CustomerApp\").getName(),\n+                        getCloudDeployedComponent(\"GreenSignal\").getName(),\n+                        \"main\", \"pubsubipc\", \"IPCService\", \"FleetStatusService\", \"lifecycleipc\", \"configstoreipc\",\n+                        \"SafeSystemUpdate\", \"DeploymentService\", \"servicediscovery\"));\n+        fleetStatusDetails1.getComponentStatusDetails().forEach(componentStatusDetails -> {\n+            if (userComponentsCloudName.contains(componentStatusDetails.getComponentName())) {\n+                assertEquals(arn.toString(), componentStatusDetails.getFleetConfigArn());\n+            }\n+        });\n+\n+        MqttMessage receivedMqttMessage2 = mqttMessagesList.get().get(1);\n+        assertNotNull(receivedMqttMessage2.getPayload());\n+        FleetStatusDetails fleetStatusDetails2 = DESERIALIZER.readValue(receivedMqttMessage2.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails2.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails2.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails2.getOverallStatus());\n+        assertThat(fleetStatusDetails2.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(someServiceName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b752cd7684eed191d797a9651c91a283e374eb4"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxMjE0Nw==", "bodyText": "Good job", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r464612147", "createdAt": "2020-08-03T19:16:56Z", "author": {"login": "leaf94"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -73,8 +76,8 @@\n \n     private static final VerificationWithTimeout WAIT_FOUR_SECONDS = timeout(Duration.ofSeconds(4).toMillis());\n \n-    @Spy\n-    Kernel mockKernel;\n+    @Mock\n+    private Kernel mockKernel;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2106eb3b605303948e4f100df101d5d8f315654"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ab528e77b23609514fda0fe1cbf7eaa18fcad46", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1ab528e77b23609514fda0fe1cbf7eaa18fcad46", "committedDate": "2020-08-03T22:02:48Z", "message": "Fix flaky unit test. Address some PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b37fc029b907693b9b15232ed1a4ea241a93e88f", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b37fc029b907693b9b15232ed1a4ea241a93e88f", "committedDate": "2020-08-03T22:17:43Z", "message": "Fix one more flaky test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c01c5a0bb197627b9692a929d4a097c15c405dcf", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c01c5a0bb197627b9692a929d4a097c15c405dcf", "committedDate": "2020-08-03T22:45:10Z", "message": "Do not update FSS data during initialization."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f0b74db98f1b6f95bbb5ebfbaad06418e082a187", "committedDate": "2020-08-03T22:50:11Z", "message": "Fix build."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTE5MDc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-460919075", "createdAt": "2020-08-04T15:21:06Z", "commit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNToyMTowNlrOG7lYug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo1MTowOVrOG7mquw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMTcwNg==", "bodyText": "This reminds me ask that have you done re-connect test (manual) ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465131706", "createdAt": "2020-08-04T15:21:06Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzQzOA==", "bodyText": "I'd say this worths a README.md to explain how FSS agent works", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465137438", "createdAt": "2020-08-04T15:29:10Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjU2OA==", "bodyText": "Why not List and use , joining?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465142568", "createdAt": "2020-08-04T15:36:23Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        Topics componentsToGroupsTopics = null;\n+        try {\n+            EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                    DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+        }\n+\n+        Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = \"\";\n+            if (finalComponentsToGroupsTopics != null) {\n+                Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                        .map(String::valueOf).collect(Collectors.joining(\",\"));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA1NQ==", "bodyText": "This catch looks weird. JsonProcessingException is thrown by SERIALIZER? That should not be \"Unable to publish xxx\".\nInstead, do you want to catch all other exception so that this thread can continue even if mqttClient is throwing some error?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465144055", "createdAt": "2020-08-04T15:38:31Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();\n+    }\n+\n+    private void updateFleetStatusServiceData(Map<String, EvergreenService> evergreenServiceMap,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        // If there are no evergreen services to be updated, do not send an update.\n+        if (evergreenServiceMap.isEmpty()) {\n+            return;\n+        }\n+\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        Topics componentsToGroupsTopics = null;\n+        try {\n+            EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                    DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+        }\n+\n+        Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+        evergreenServiceMap.forEach((serviceName, service) -> {\n+            String thingGroups = \"\";\n+            if (finalComponentsToGroupsTopics != null) {\n+                Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                        .map(String::valueOf).collect(Collectors.joining(\",\"));\n+            }\n+\n+            Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+            ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                    .componentName(service.getName())\n+                    .state(service.getState())\n+                    .version(Coerce.toString(versionTopic))\n+                    .fleetConfigArn(thingGroups)\n+                    .build();\n+            components.add(componentStatusDetails);\n+        });\n+\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.getAndIncrement())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjM3NA==", "bodyText": "Is passing overAllStatus.get() into it necessary? Seems the only place of .set is getting the result by getOverallStatusBasedOnServiceState  so you always compute from the evergreen service map.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465146374", "createdAt": "2020-08-04T15:41:57Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjY5OQ==", "bodyText": "Since both evergreenServiceMap can be update by other threads, during updateFleetStatusServiceData (specifically after reading from the map), there might be some data added in, which would be cleared here.\nI will recommend moving the clear to right after you read the map. Although there are still tiny bit of chance without a readAndClear atomic operation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465152699", "createdAt": "2020-08-04T15:51:09Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalMs = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFssDataUpdate(false);\n+                    }\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (isDuringConnectionResumed\n+                && lastPeriodicUpdateTime.get().plusMillis(periodicUpdateIntervalMs).isBefore(Instant.now())) {\n+            updatePeriodicFssData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFssData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress && newState.equals(State.BROKEN)) {\n+            updateFleetStatusServiceData(evergreenServiceMap, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFssData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Map<String, EvergreenService> evergreenServiceMap = new HashMap<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceMap.put(evergreenService.getName(), evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+    }\n+\n+    @SuppressWarnings(\"PMD.NullAssignment\")\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress = true;\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress = false;\n+        updateEventTriggeredFssData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFssData() {\n+        if (!isConnected) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            removedDependencies.remove(evergreenService.getName());\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        removedDependencies.forEach(evergreenServiceMap::putIfAbsent);\n+        updateFleetStatusServiceData(evergreenServiceMap, overAllStatus.get());\n+        evergreenServiceMap.clear();\n+        removedDependencies.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 220}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwOTI5MzA0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-460929304", "createdAt": "2020-08-04T15:32:22Z", "commit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "state": "DISMISSED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTozMjoyMlrOG7l4KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNTo1OTo0N1rOG7nBmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzOTc1Mg==", "bodyText": "If the JSON key is the same as the variable name, you don't need the annotation.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465139752", "createdAt": "2020-08-04T15:32:22Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/ComponentStatusDetails.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.dependency.State;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ComponentStatusDetails {\n+    @JsonProperty(\"componentName\")\n+    private String componentName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjQ1Mw==", "bodyText": "Its not an arn. Its the thing name and the group name.\n\nWhat \"group name\"?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465142453", "createdAt": "2020-08-04T15:36:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusDetails.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.List;\n+\n+@Data\n+@Builder\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class FleetStatusDetails {\n+    @JsonProperty(\"ggcVersion\")\n+    private String ggcVersion;\n+\n+    @JsonProperty(\"platform\")\n+    private String platform;\n+\n+    @JsonProperty(\"architecture\")\n+    private String architecture;\n+\n+    @JsonProperty(\"thing\")\n+    private String thing;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5NzQ0OA=="}, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA5Nw==", "bodyText": "evergreen is just a code name. We shouldn't use evergreen in the topic name.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465144097", "createdAt": "2020-08-04T15:38:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDY2NA==", "bodyText": "Should this be static? Shouldn't it be final?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465144664", "createdAt": "2020-08-04T15:39:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NTA0OQ==", "bodyText": "Isn't millisecond a bit extreme? Why not just use second as unit?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465145049", "createdAt": "2020-08-04T15:39:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjIyNQ==", "bodyText": "This is probably not sufficient across different platforms. Add a TODO to refactor this out to be more robust.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465146225", "createdAt": "2020-08-04T15:41:44Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected = false;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected = true;\n+            schedulePeriodicFssDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDE3MA==", "bodyText": "Is this correct? Let's say, yesterday at 8pm the device sent out status update to the cloud; today at 7:59 the machine is restarted or FleetStatusService is restarted, now the lastPeriodicUpdateTime is 7:59 today and next update will be tomorrow.\nThe lastPeriodicUpdateTime needs to be persisted in the config object.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465150170", "createdAt": "2020-08-04T15:47:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjIyNg==", "bodyText": "I believe in the previous round of review, two methods are suggested on concurrentSet. Can you update it? It's a minor detail but it does reflect our coding bar. This repository is intended to be open-source and many ppl will read this code.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465152226", "createdAt": "2020-08-04T15:50:28Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NjM5NQ==", "bodyText": "This variable needs to be synchronized and thread-safe.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465156395", "createdAt": "2020-08-04T15:56:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NzA3NQ==", "bodyText": "And why are they static?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465157075", "createdAt": "2020-08-04T15:57:36Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private static final Map<String, EvergreenService> evergreenServiceMap = new ConcurrentHashMap<>();\n+    private static final Map<String, EvergreenService> removedDependencies = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjIyNg=="}, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NzgxMw==", "bodyText": "Why is it a static variable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465157813", "createdAt": "2020-08-04T15:58:38Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static volatile boolean isConnected = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1ODU1NQ==", "bodyText": "Why do you put the service into the map before the condition check?\n\nCan you address the comment?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r465158555", "createdAt": "2020-08-04T15:59:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static AtomicLong sequenceNumber = new AtomicLong();\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_MS = 86_400_000;\n+\n+    private final String kernelVersion;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private static boolean isMqttConnectionInterrupted = false;\n+    private static AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.MIN);\n+    private static final Map<String, EvergreenService> evergreenServiceMap =\n+            new ConcurrentHashMap<>();\n+    private Map<String, Set<String>> packageToGroupsMappingCache;\n+    private static final Map<String, EvergreenService> removedDependencies =\n+            new ConcurrentHashMap<>();\n+    private int periodicUpdateIntervalMs;\n+    private boolean isDeploymentInProgress;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isMqttConnectionInterrupted = true;\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isMqttConnectionInterrupted = false;\n+            handleMqttConnectionResumed();\n+            schedulePeriodicFssDataUpdate();\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_MS)\n+                .subscribe((why, newv) ->\n+                        periodicUpdateIntervalMs = Coerce.toInt(newv));\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFssDataUpdate();\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFssDataUpdate() {\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFssData, periodicUpdateIntervalMs,\n+                periodicUpdateIntervalMs, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                                       State newState) {\n+        // Do not update status of auto-started services.\n+        if (evergreenService.isAutostart()) {\n+            return;\n+        }\n+        evergreenServiceMap.put(evergreenService.getName(), evergreenService);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMjg3Mg=="}, "originalCommit": {"oid": "ae4a15d8a0908fe5e944fca412405d11b410e342"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deea385d5d81782257b6a81f6d732b9cf9ca7d54", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/deea385d5d81782257b6a81f6d732b9cf9ca7d54", "committedDate": "2020-08-04T23:35:14Z", "message": "Address PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9880e4ca20f5b818bbf9291c6757a34e90f43b3d", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9880e4ca20f5b818bbf9291c6757a34e90f43b3d", "committedDate": "2020-08-04T23:36:08Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/23041bda698ec4eab619263f4bf97c40a08cc6dd", "committedDate": "2020-08-05T16:06:06Z", "message": "Refactor some code."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjM3NzEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-463637713", "createdAt": "2020-08-07T21:16:52Z", "commit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMToxNjo1MlrOG9oDOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTozNTowNFrOG9owog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MjUwNg==", "bodyText": "shutdown can throw. Put the cleanup inside of a finally block so that it always cleans up", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467272506", "createdAt": "2020-08-07T21:16:52Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mjc4MQ==", "bodyText": "let's get a const for this format", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467272781", "createdAt": "2020-08-07T21:17:47Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(String.format(\"$aws/things/%s/evergreen/health/json\", thingInfo.getThingName()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MzMyNw==", "bodyText": "can we not hardcode these services? Their names and existence is likely to change.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467273327", "createdAt": "2020-08-07T21:19:22Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (kernel != null) {\n+            kernel.shutdown();\n+        }\n+        // Cleanup all IoT thing resources we created\n+        cleanup();\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(String.format(\"$aws/things/%s/evergreen/health/json\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")\n+                        .withConfiguration(\"{\\\"sampleText\\\":\\\"FCS integ test\\\"}\"))\n+                .addPackagesEntry(\"SomeService\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult1 = setAndPublishFleetConfiguration(setRequest1);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult1.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        String someServiceName = getCloudDeployedComponent(\"SomeService\").getName();\n+\n+        // Second deployment to remove some services deployed previously\n+        SetConfigurationRequest setRequest2 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult2 = setAndPublishFleetConfiguration(setRequest2);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult2.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        // Ensure that main is finished, which is its terminal state, so this means that all updates ought to be done\n+        assertThat(kernel.getMain()::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThat(getCloudDeployedComponent(\"CustomerApp\")::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThrows(ServiceLoadException.class, () -> getCloudDeployedComponent(\"SomeService\").getState());\n+\n+        assertTrue(cdl.await(1, TimeUnit.MINUTES), \"All messages published and received\");\n+        assertEquals(2, mqttMessagesList.get().size());\n+\n+        Arn arn = Arn.builder()\n+                .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                .withService(FLEET_STATUS_ARN_SERVICE)\n+                .withAccountId(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getAccountId()))\n+                .withRegion(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getRegion()))\n+                .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, \"thinggroup/\" + thingGroupName, \"1\"))\n+                .build();\n+\n+        // Check the MQTT messages.\n+        // The first MQTT message should have all the services whose status changed during the first deployment.\n+        // This will include the system and user components.\n+        MqttMessage receivedMqttMessage1 = mqttMessagesList.get().get(0);\n+        assertNotNull(receivedMqttMessage1.getPayload());\n+        FleetStatusDetails fleetStatusDetails1 = DESERIALIZER.readValue(receivedMqttMessage1.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails1.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails1.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails1.getOverallStatus());\n+        assertThat(fleetStatusDetails1.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(getCloudDeployedComponent(\"Mosquitto\").getName(), someServiceName,\n+                        getCloudDeployedComponent(\"CustomerApp\").getName(),\n+                        getCloudDeployedComponent(\"GreenSignal\").getName(),\n+                        \"main\", \"pubsubipc\", \"IPCService\", \"FleetStatusService\", \"lifecycleipc\", \"configstoreipc\",\n+                        \"SafeSystemUpdate\", \"DeploymentService\", \"servicediscovery\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mzc4OA==", "bodyText": "do not read from children it should be private anyway", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467273788", "createdAt": "2020-08-07T21:20:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -418,4 +432,56 @@ void setDeploymentsQueue(LinkedBlockingQueue<Deployment> deploymentsQueue) {\n     public DeploymentTaskMetadata getCurrentDeploymentTaskMetadata() {\n         return currentDeploymentTaskMetadata;\n     }\n+\n+    private void setComponentsToGroupsMapping(Topics groupsToRootComponents) {\n+         if (groupsToRootComponents.children == null || groupsToRootComponents.children.size() == 0) {\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mzg5Mg==", "bodyText": "use Coerce.toString(lookup)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467273892", "createdAt": "2020-08-07T21:21:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -418,4 +432,56 @@ void setDeploymentsQueue(LinkedBlockingQueue<Deployment> deploymentsQueue) {\n     public DeploymentTaskMetadata getCurrentDeploymentTaskMetadata() {\n         return currentDeploymentTaskMetadata;\n     }\n+\n+    private void setComponentsToGroupsMapping(Topics groupsToRootComponents) {\n+         if (groupsToRootComponents.children == null || groupsToRootComponents.children.size() == 0) {\n+            return;\n+        }\n+        List<String> pendingComponentsList = new LinkedList<>();\n+        Map<Object, Object> componentsToGroupsMappingCache = new ConcurrentHashMap<>();\n+        Topics componentsToGroupsTopics;\n+\n+        componentsToGroupsTopics = getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        // Get all the groups associated to the root components.\n+        groupsToRootComponents.iterator().forEachRemaining(groupNode -> {\n+            Topics componentTopics = (Topics) groupNode;\n+\n+            Topic lookup = componentTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID);\n+            String groupDeploymentId = (String) lookup.getOnce();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NTU3MA==", "bodyText": "instead of reduce, you should be able to do allMatch", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467275570", "createdAt": "2020-08-07T21:23:49Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -118,7 +125,10 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n                 DeploymentType deploymentType = (DeploymentType)\n                         deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE);\n \n-                if (!getConsumerForDeploymentType(deploymentType).apply(deploymentDetails)) {\n+                boolean allConsumersUpdated = getConsumersForDeploymentType(deploymentType).stream()\n+                        .map(consumer -> consumer.apply(deploymentDetails))\n+                        .reduce(true, (a, b) -> a && b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4MzQyNQ==", "bodyText": "Don't put this logic here. Now you're making all services dependent on FSS.\nInstead, have FSS subscribe to the services topic in the config store and listen for changes to that.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467283425", "createdAt": "2020-08-07T21:34:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -555,7 +556,13 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 DependencyInfo dependencyInfo = dependencies.remove(dependency);\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n-            context.get(Kernel.class).clearODcache();\n+            Kernel kernel = context.get(Kernel.class);\n+            kernel.clearODcache();\n+            FleetStatusService fleetStatusService = (FleetStatusService) kernel\n+                    .locate(FleetStatusService.FLEET_STATUS_SERVICE_TOPICS);\n+            if (fleetStatusService != null) {\n+                fleetStatusService.updateRemovedDependencies(removedDependencies);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4NDEzMA==", "bodyText": "put this in a finally, or after each to make sure that it is always shutdown.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r467284130", "createdAt": "2020-08-07T21:35:04Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -167,20 +174,78 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_correctly_map_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics deploymentGroupTopics = Topics.of(context, EXPECTED_GROUP_NAME, allGroupTopics);\n+            Topic pkgTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\");\n+            Topic groupTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                    \"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\");\n+            Map<String, Node> pkgDetails = new HashMap<>();\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgTopic1);\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID, groupTopic1);\n+            Topics pkgTopics = Topics.of(context, EXPECTED_ROOT_PACKAGE_NAME, deploymentGroupTopics);\n+            pkgTopics.children.putAll(pkgDetails);\n+            deploymentGroupTopics.children.put(EXPECTED_ROOT_PACKAGE_NAME, pkgTopics);\n+\n+            doNothing().when(mockComponentsToGroupPackages).replaceAndWait(any());\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(deploymentGroupTopics);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(mockComponentsToGroupPackages);\n+            when(mockKernel.locate(any())).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }\n+            }).when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            jobSucceededLatch.await(10, TimeUnit.SECONDS);\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(mockComponentsToGroupPackages).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",\n+                    ((Map<String, Boolean>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                            .containsKey(\"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\"));\n+\n+            deploymentService.shutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23041bda698ec4eab619263f4bf97c40a08cc6dd"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8d0b4b76686323e858681b93d0030ad707b5f34c", "committedDate": "2020-08-10T15:11:20Z", "message": "Address PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/efb1b09410111b5fb71e74c0316fd424959f6a92", "committedDate": "2020-08-11T18:33:56Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzIwMzQ3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-465320347", "createdAt": "2020-08-11T18:25:29Z", "commit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODoyNToyOVrOG_D-fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODo1NTo1MlrOG_FIjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3ODYyMw==", "bodyText": "I'm not sure this is still correct. We're now using random names for our components. Have a look at the other tests and verify that this still passes.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468778623", "createdAt": "2020-08-11T18:25:29Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusService;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (kernel != null) {\n+                kernel.shutdown();\n+            }\n+        } finally {\n+            // Cleanup all IoT thing resources we created\n+            cleanup();\n+        }\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(FleetStatusService.FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3OTQ2OA==", "bodyText": "Why check against empty list? Just assertThat(..., is(empty())", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468779468", "createdAt": "2020-08-11T18:27:04Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.integrationtests.e2e.fss;\n+\n+import com.amazonaws.arn.Arn;\n+import com.amazonaws.services.evergreen.model.PackageMetaData;\n+import com.amazonaws.services.evergreen.model.PublishConfigurationResult;\n+import com.amazonaws.services.evergreen.model.SetConfigurationRequest;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.fss.ComponentStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusDetails;\n+import com.aws.iot.evergreen.fss.FleetStatusService;\n+import com.aws.iot.evergreen.fss.OverallStatus;\n+import com.aws.iot.evergreen.integrationtests.e2e.BaseE2ETestCase;\n+import com.aws.iot.evergreen.integrationtests.e2e.util.IotJobsUtils;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.SubscribeRequest;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import software.amazon.awssdk.crt.mqtt.MqttMessage;\n+import software.amazon.awssdk.services.iot.model.JobExecutionStatus;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static com.github.grantwest.eventually.EventuallyLambdaMatcher.eventuallyEval;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@SuppressWarnings(\"PMD.CloseResource\")\n+@Tag(\"E2E\")\n+public class FleetStatusServiceTest extends BaseE2ETestCase {\n+    private static final ObjectMapper DESERIALIZER = new ObjectMapper();\n+    private static final String FLEET_STATUS_ARN_RESOURCE_PREFIX = \"configuration:%s:%s\";\n+    private static final String FLEET_STATUS_ARN_SERVICE = \"greengrass\";\n+    private static final String FLEET_STATUS_ARN_PARTITION = \"aws\";\n+\n+    @AfterEach\n+    void afterEach() {\n+        try {\n+            if (kernel != null) {\n+                kernel.shutdown();\n+            }\n+        } finally {\n+            // Cleanup all IoT thing resources we created\n+            cleanup();\n+        }\n+    }\n+\n+    @BeforeEach\n+    void launchKernel() throws Exception {\n+        initKernel();\n+        kernel.launch();\n+\n+        // TODO: Without this sleep, DeploymentService sometimes is not able to pick up new IoT job created here,\n+        // causing these tests to fail. There may be a race condition between DeploymentService startup logic and\n+        // creating new IoT job here.\n+        TimeUnit.SECONDS.sleep(10);\n+    }\n+\n+    @Timeout(value = 10, unit = TimeUnit.MINUTES)\n+    @Test\n+    void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_fss_data_is_uploaded() throws Exception {\n+        MqttClient client = kernel.getContext().get(MqttClient.class);\n+\n+        CountDownLatch cdl = new CountDownLatch(2);\n+        AtomicReference<List<MqttMessage>> mqttMessagesList = new AtomicReference<>();\n+        mqttMessagesList.set(new ArrayList<>());\n+        client.subscribe(SubscribeRequest.builder()\n+                .topic(FleetStatusService.FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingInfo.getThingName()))\n+                .callback((m) -> {\n+                    cdl.countDown();\n+                    mqttMessagesList.get().add(m);\n+                }).build());\n+\n+        // First Deployment to have some services running in Kernel which can be removed later\n+        SetConfigurationRequest setRequest1 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\")\n+                        .withConfiguration(\"{\\\"sampleText\\\":\\\"FCS integ test\\\"}\"))\n+                .addPackagesEntry(\"SomeService\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult1 = setAndPublishFleetConfiguration(setRequest1);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult1.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        String someServiceName = getCloudDeployedComponent(\"SomeService\").getName();\n+        Set<String> componentNames = new HashSet<>();\n+        componentNames.add(getCloudDeployedComponent(\"Mosquitto\").getName());\n+        componentNames.add(someServiceName);\n+        componentNames.add(getCloudDeployedComponent(\"CustomerApp\").getName());\n+        componentNames.add(getCloudDeployedComponent(\"GreenSignal\").getName());\n+        kernel.orderedDependencies().forEach(evergreenService -> {\n+            if(evergreenService.isAutostart() || evergreenService.getName().equals(\"main\")) {\n+                componentNames.add(evergreenService.getName());\n+            }\n+        });\n+\n+        // Second deployment to remove some services deployed previously\n+        SetConfigurationRequest setRequest2 = new SetConfigurationRequest()\n+                .withTargetName(thingGroupName)\n+                .withTargetType(THING_GROUP_TARGET_TYPE)\n+                .addPackagesEntry(\"CustomerApp\", new PackageMetaData().withRootComponent(true).withVersion(\"1.0.0\"));\n+        PublishConfigurationResult publishResult2 = setAndPublishFleetConfiguration(setRequest2);\n+\n+        IotJobsUtils.waitForJobExecutionStatusToSatisfy(iotClient, publishResult2.getJobId(), thingInfo.getThingName(),\n+                Duration.ofMinutes(5), s -> s.equals(JobExecutionStatus.SUCCEEDED));\n+\n+        // Ensure that main is finished, which is its terminal state, so this means that all updates ought to be done\n+        assertThat(kernel.getMain()::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThat(getCloudDeployedComponent(\"CustomerApp\")::getState, eventuallyEval(is(State.FINISHED)));\n+        assertThrows(ServiceLoadException.class, () -> getCloudDeployedComponent(\"SomeService\").getState());\n+\n+        assertTrue(cdl.await(1, TimeUnit.MINUTES), \"All messages published and received\");\n+        assertEquals(2, mqttMessagesList.get().size());\n+\n+        Arn arn = Arn.builder()\n+                .withPartition(FLEET_STATUS_ARN_PARTITION)\n+                .withService(FLEET_STATUS_ARN_SERVICE)\n+                .withAccountId(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getAccountId()))\n+                .withRegion(Coerce.toString(Arn.fromString(thingInfo.getThingArn()).getRegion()))\n+                .withResource(String.format(FLEET_STATUS_ARN_RESOURCE_PREFIX, \"thinggroup/\" + thingGroupName, \"1\"))\n+                .build();\n+\n+        // Check the MQTT messages.\n+        // The first MQTT message should have all the services whose status changed during the first deployment.\n+        // This will include the system and user components.\n+        MqttMessage receivedMqttMessage1 = mqttMessagesList.get().get(0);\n+        assertNotNull(receivedMqttMessage1.getPayload());\n+        FleetStatusDetails fleetStatusDetails1 = DESERIALIZER.readValue(receivedMqttMessage1.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails1.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails1.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails1.getOverallStatus());\n+        fleetStatusDetails1.getComponentStatusDetails().forEach(componentStatusDetails -> {\n+            componentNames.remove(componentStatusDetails.getComponentName());\n+        });\n+        assertTrue(componentNames.isEmpty());\n+        fleetStatusDetails1.getComponentStatusDetails().forEach(componentStatusDetails -> {\n+            assertEquals(Collections.singletonList(arn.toString()), componentStatusDetails.getFleetConfigArns());\n+        });\n+\n+        // The second MQTT message should contain only one component information which was removed during the second\n+        // deployment.\n+        // The configuration arns for that component should be empty to indicate that it was removed from all groups.\n+        MqttMessage receivedMqttMessage2 = mqttMessagesList.get().get(1);\n+        assertNotNull(receivedMqttMessage2.getPayload());\n+        FleetStatusDetails fleetStatusDetails2 = DESERIALIZER.readValue(receivedMqttMessage2.getPayload(), FleetStatusDetails.class);\n+        assertEquals(thingInfo.getThingName(), fleetStatusDetails2.getThing());\n+        assertEquals(\"1.0.0\", fleetStatusDetails2.getGgcVersion());\n+        assertEquals(OverallStatus.HEALTHY, fleetStatusDetails2.getOverallStatus());\n+        assertEquals(1, fleetStatusDetails2.getComponentStatusDetails().size());\n+        assertThat(fleetStatusDetails2.getComponentStatusDetails().stream().map(ComponentStatusDetails::getComponentName).collect(Collectors.toList()),\n+                containsInAnyOrder(someServiceName));\n+        assertEquals(Collections.emptyList(), fleetStatusDetails2.getComponentStatusDetails().get(0).getFleetConfigArns());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MDEyNw==", "bodyText": "when using coerce, don't call getOnce.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468780127", "createdAt": "2020-08-11T18:28:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -418,4 +432,51 @@ void setDeploymentsQueue(LinkedBlockingQueue<Deployment> deploymentsQueue) {\n     public DeploymentTaskMetadata getCurrentDeploymentTaskMetadata() {\n         return currentDeploymentTaskMetadata;\n     }\n+\n+    private void setComponentsToGroupsMapping(Topics groupsToRootComponents) {\n+        List<String> pendingComponentsList = new LinkedList<>();\n+        Map<Object, Object> componentsToGroupsMappingCache = new ConcurrentHashMap<>();\n+        Topics componentsToGroupsTopics = getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+        // Get all the groups associated to the root components.\n+        groupsToRootComponents.iterator().forEachRemaining(groupNode -> {\n+            Topics componentTopics = (Topics) groupNode;\n+\n+            Topic lookup = componentTopics.lookup(GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID);\n+            String groupDeploymentId = Coerce.toString(lookup.getOnce());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MjQyNQ==", "bodyText": "this can be simplified to stream().filter().map().collect()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468782425", "createdAt": "2020-08-11T18:32:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -128,12 +137,14 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n         }\n     }\n \n-    protected Function<Map<String, Object>, Boolean> getConsumerForDeploymentType(DeploymentType type) {\n-        return deploymentStatusConsumer.computeIfAbsent(type, deploymentType -> {\n-            logger.atDebug().kv(\"DeploymentType\", deploymentType)\n-                    .log(\"Consumer for type not found, dropping status update\");\n-            return (status) -> true;\n+    protected List<Function<Map<String, Object>, Boolean>> getConsumersForDeploymentType(DeploymentType type) {\n+        List<Function<Map<String, Object>, Boolean>> callbacks = new ArrayList<>();\n+        deploymentStatusConsumerMap.forEach((deploymentType, stringFunctionMap) -> {\n+            if (deploymentType == type) {\n+                stringFunctionMap.forEach((s, mapBooleanFunction) -> callbacks.add(mapBooleanFunction));\n+            }\n         });\n+        return callbacks;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MzA0Mg==", "bodyText": "do all these need to be public? If not, let's scope it down. If you need it in testing, make it package-private.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468783042", "createdAt": "2020-08-11T18:33:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MzE1MQ==", "bodyText": "This will need to be configurable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468783151", "createdAt": "2020-08-11T18:34:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_MS = \"periodicUpdateIntervalMs\";\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA5Nw=="}, "originalCommit": {"oid": "f0b74db98f1b6f95bbb5ebfbaad06418e082a187"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MzgwNQ==", "bodyText": "thing name can change. This needs to be a subscribe.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468783805", "createdAt": "2020-08-11T18:35:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NDM4Mg==", "bodyText": "Why store these as fields at all? If you're using the config store for persistence, then don't copy it into local fields; that's just going to cause synchronization issues.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468784382", "createdAt": "2020-08-11T18:36:12Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NTQyNw==", "bodyText": "I do see that your usages look safe, but why not just have this method cancel the old scheduled task? That way it is much safer and won't be broken by future changes.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468785427", "createdAt": "2020-08-11T18:38:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d0b4b76686323e858681b93d0030ad707b5f34c"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NjE2Mg==", "bodyText": "Why only if there's no deployment? BROKEN at any time is bad.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468786162", "createdAt": "2020-08-11T18:39:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4Njg4MQ==", "bodyText": "[nit]\nYou don't need to call 'toString'", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468786881", "createdAt": "2020-08-11T18:40:52Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NzQ3Ng==", "bodyText": "This logic is awfully familiar. Extract it out to a private method.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468787476", "createdAt": "2020-08-11T18:41:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4NzgxNQ==", "bodyText": "this doesn't need to be threadsafe as far as I can tell.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468787815", "createdAt": "2020-08-11T18:41:56Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4OTEyMg==", "bodyText": "why do you need to synchronize? You're only adding to this set which is fine to do. Also, this set is based on a concurrent hashmap, so all concurrent operations ought to be safe.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468789122", "createdAt": "2020-08-11T18:43:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MDc0Nw==", "bodyText": "Why is this map named like this? What is the Instant for?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468790747", "createdAt": "2020-08-11T18:45:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MTYzMg==", "bodyText": "Why are you keeping a set of services? If you want a set of service, call kernel.orderedDependencies().\nIt looks like there's a lot of duplicated data in this service which exists elsewhere in Evergreen.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468791632", "createdAt": "2020-08-11T18:45:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5Mjc2NQ==", "bodyText": "getName returns a string. You shouldn't need valueOf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468792765", "createdAt": "2020-08-11T18:47:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5MzI4MA==", "bodyText": "instead of materializing a list and then doing addAll, you can just add in a foreach of the stream.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468793280", "createdAt": "2020-08-11T18:47:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDQ2Nw==", "bodyText": "this log isn't helping anyone. We already log when things start", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794467", "createdAt": "2020-08-11T18:50:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDY0Nw==", "bodyText": "you don't need to override startup at all if this is all you're doing. You can just let the super class handle it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794647", "createdAt": "2020-08-11T18:50:31Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDczMw==", "bodyText": "again, not a helpful log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794733", "createdAt": "2020-08-11T18:50:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        logger.atInfo().log(\"Stopping Fleet status service.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NDkwOA==", "bodyText": "make this package-private if it is only for unit tests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468794908", "createdAt": "2020-08-11T18:50:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        logger.atInfo().log(\"Stopping Fleet status service.\");\n+        if (!this.periodicUpdateFuture.isCancelled()) {\n+            this.periodicUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * Used for unit tests only. Adds a list of evergreen services of previously\n+     *\n+     * @param evergreenServices List of evergreen services to add\n+     * @param instant last time the service was processed.\n+     */\n+    public void addEvergreenServicesToPreviouslyKnownServicesList(List<EvergreenService> evergreenServices,\n+                                                                  Instant instant) {\n+        evergreenServices.forEach(evergreenService -> allEvergreenServicesNameMap.put(evergreenService, instant));\n+    }\n+\n+    /**\n+     * Used for unit tests only.\n+     */\n+    public void clearEvergreenServiceSet() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NTAyMQ==", "bodyText": "package-private", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468795021", "createdAt": "2020-08-11T18:51:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    public static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    public static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    public static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String FLEET_STATUS_SERVICE_PUBLISH_TOPIC = \"$aws/things/{thingName}/evergreen/health/json\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private final String updateFssDataTopic;\n+    private final String thingName;\n+    private final MqttClient mqttClient;\n+    private final DeviceConfiguration deviceConfiguration;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final AtomicReference<Instant> lastPeriodicUpdateTime = new AtomicReference<>(Instant.now());\n+    private final Set<EvergreenService> evergreenServiceSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final AtomicLong sequenceNumber = new AtomicLong();\n+    private int periodicUpdateIntervalSec;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeviceConfiguration deviceConfiguration,\n+                              DeploymentStatusKeeper deploymentStatusKeeper, Kernel kernel) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deviceConfiguration = deviceConfiguration;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        this.thingName = Coerce.toString(this.deviceConfiguration.getThingName());\n+        this.updateFssDataTopic = FLEET_STATUS_SERVICE_PUBLISH_TOPIC.replace(\"{thingName}\", thingName);\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        periodicUpdateFuture.cancel(false);\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)\n+                .dflt(new AtomicLong())\n+                .subscribe((why, newv) -> sequenceNumber.set(Coerce.toLong(newv)));\n+\n+        topics.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .dflt(Instant.now().toEpochMilli())\n+                .subscribe((why, newv) -> lastPeriodicUpdateTime.set(Instant.ofEpochMilli(Coerce.toLong(newv))));\n+\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (lastPeriodicUpdateTime.get().plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+            updatePeriodicFleetStatusData();\n+        } else if (isDuringConnectionResumed) {\n+            updateEventTriggeredFleetStatusData();\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (evergreenServiceSet) {\n+            evergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(evergreenServiceSet, OverallStatus.UNHEALTHY);\n+        }\n+    }\n+\n+    private void updatePeriodicFleetStatusData() {\n+        // Do not update periodic updates if there is an ongoing deployment.\n+        if (isDeploymentInProgress.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since there is an ongoing deployment.\");\n+            return;\n+        }\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on a periodic basis since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        logger.atDebug().log(\"Updating FSS data on a periodic basis.\");\n+        Set<EvergreenService> evergreenServiceSet = new HashSet<>();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Get all running services from the kernel to update the fleet status.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            evergreenServiceSet.add(evergreenService);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+        lastPeriodicUpdateTime.set(Instant.now());\n+        config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)\n+                .withValue(lastPeriodicUpdateTime.get().toEpochMilli());\n+    }\n+\n+    private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        if (JobStatus.IN_PROGRESS.toString().equals(status)) {\n+            isDeploymentInProgress.set(true);\n+            return true;\n+        }\n+        logger.atDebug().log(\"Updating Fleet Status service for deployment job with ID: {}\",\n+                deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString());\n+        isDeploymentInProgress.set(false);\n+        updateEventTriggeredFleetStatusData();\n+        return true;\n+    }\n+\n+    private void updateEventTriggeredFleetStatusData() {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating FSS data on event triggered since MQTT connection is interrupted.\");\n+            return;\n+        }\n+\n+        Instant now = Instant.now();\n+        AtomicReference<OverallStatus> overAllStatus = new AtomicReference<>();\n+\n+        // Check if the removed dependency is still running (Probably as a dependant service to another service).\n+        // If so, then remove it from the removedDependencies collection.\n+        this.kernel.orderedDependencies().forEach(evergreenService -> {\n+            allEvergreenServicesNameMap.put(evergreenService, now);\n+            overAllStatus.set(getOverallStatusBasedOnServiceState(overAllStatus.get(), evergreenService));\n+        });\n+        Set<EvergreenService> removedDependenciesSet = Collections.newSetFromMap(new ConcurrentHashMap<>());\n+\n+        // Add all the removed dependencies to the collection of services to update.\n+        synchronized (evergreenServiceSet) {\n+            allEvergreenServicesNameMap.forEach((evergreenService, instant) -> {\n+                if (!instant.equals(now)) {\n+                    evergreenServiceSet.add(evergreenService);\n+                    removedDependenciesSet.add(evergreenService);\n+                }\n+            });\n+            removedDependenciesSet.forEach(allEvergreenServicesNameMap::remove);\n+            removedDependenciesSet.clear();\n+        }\n+        uploadFleetStatusServiceData(evergreenServiceSet, overAllStatus.get());\n+    }\n+\n+    private void uploadFleetStatusServiceData(Set<EvergreenService> evergreenServiceSet,\n+                                              OverallStatus overAllStatus) {\n+        if (!isConnected.get()) {\n+            logger.atDebug().log(\"Not updating fleet status data since MQTT connection is interrupted.\");\n+            return;\n+        }\n+        List<ComponentStatusDetails> components = new ArrayList<>();\n+\n+        synchronized (evergreenServiceSet) {\n+            // If there are no evergreen services to be updated, do not send an update.\n+            if (evergreenServiceSet.isEmpty()) {\n+                return;\n+            }\n+\n+            Topics componentsToGroupsTopics = null;\n+            HashSet<String> allGroups = new HashSet<>();\n+            try {\n+                EvergreenService deploymentService = this.kernel.locate(DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+                componentsToGroupsTopics = deploymentService.getConfig().lookupTopics(COMPONENTS_TO_GROUPS_TOPICS);\n+            } catch (ServiceLoadException e) {\n+                logger.atError().cause(e).log(\"Unable to locate {} service while uploading FSS data\",\n+                        DeploymentService.DEPLOYMENT_SERVICE_TOPICS);\n+            }\n+\n+            Topics finalComponentsToGroupsTopics = componentsToGroupsTopics;\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (isSystemLevelService(service)) {\n+                    return;\n+                }\n+                List<String> thingGroups = new ArrayList<>();\n+                if (finalComponentsToGroupsTopics != null) {\n+                    Topics groupsTopics = finalComponentsToGroupsTopics.lookupTopics(service.getName());\n+                    thingGroups = groupsTopics.children.values().stream().map(n -> (Topic) n).map(Topic::getName)\n+                            .map(String::valueOf).collect(Collectors.toList());\n+                    // Get all the group names from the user components.\n+                    allGroups.addAll(thingGroups);\n+                }\n+\n+\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(thingGroups)\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+\n+            evergreenServiceSet.forEach((service) -> {\n+                if (!isSystemLevelService(service)) {\n+                    return;\n+                }\n+                Topic versionTopic = service.getServiceConfig().findLeafChild(KernelConfigResolver.VERSION_CONFIG_KEY);\n+                ComponentStatusDetails componentStatusDetails = ComponentStatusDetails.builder()\n+                        .componentName(service.getName())\n+                        .state(service.getState())\n+                        .version(Coerce.toString(versionTopic))\n+                        .fleetConfigArns(new ArrayList<>(allGroups))\n+                        .build();\n+                components.add(componentStatusDetails);\n+            });\n+            evergreenServiceSet.clear();\n+        }\n+\n+        config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC).withValue(sequenceNumber.getAndIncrement());\n+        FleetStatusDetails fleetStatusDetails = FleetStatusDetails.builder()\n+                .overallStatus(overAllStatus)\n+                .componentStatusDetails(components)\n+                .architecture(this.architecture)\n+                .platform(this.platform)\n+                .thing(thingName)\n+                .ggcVersion(this.kernelVersion)\n+                .sequenceNumber(sequenceNumber.get())\n+                .build();\n+        try {\n+            this.mqttClient.publish(PublishRequest.builder()\n+                    .qos(QualityOfService.AT_LEAST_ONCE)\n+                    .topic(this.updateFssDataTopic)\n+                    .payload(SERIALIZER.writeValueAsBytes(fleetStatusDetails)).build());\n+        } catch (JsonProcessingException e) {\n+            logger.atError().cause(e).log(\"Unable to publish fleet status service.\");\n+        }\n+    }\n+\n+    private boolean isSystemLevelService(EvergreenService service) {\n+        return service.isAutostart() || service.getName().equals(\"main\");\n+    }\n+\n+    private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallStatus,\n+                                                              EvergreenService evergreenService) {\n+        if (State.BROKEN.equals(evergreenService.getState())\n+                || OverallStatus.UNHEALTHY.equals(overallStatus)) {\n+            return OverallStatus.UNHEALTHY;\n+        }\n+        return OverallStatus.HEALTHY;\n+    }\n+\n+\n+    @Override\n+    public void startup() {\n+        logger.atInfo().log(\"Starting Fleet status service.\");\n+        reportState(State.RUNNING);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        logger.atInfo().log(\"Stopping Fleet status service.\");\n+        if (!this.periodicUpdateFuture.isCancelled()) {\n+            this.periodicUpdateFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * Used for unit tests only. Adds a list of evergreen services of previously\n+     *\n+     * @param evergreenServices List of evergreen services to add\n+     * @param instant last time the service was processed.\n+     */\n+    public void addEvergreenServicesToPreviouslyKnownServicesList(List<EvergreenService> evergreenServices,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NTE0Nw==", "bodyText": "undo this", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468795147", "createdAt": "2020-08-11T18:51:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -556,7 +556,8 @@ private synchronized void setupDependencies(Iterable<String> dependencyList)\n                 DependencyInfo dependencyInfo = dependencies.remove(dependency);\n                 dependency.removeStateSubscriber(dependencyInfo.stateTopicSubscriber);\n             });\n-            context.get(Kernel.class).clearODcache();\n+            Kernel kernel = context.get(Kernel.class);\n+            kernel.clearODcache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NTkyNg==", "bodyText": "instead of this, you can use verify with a timeout.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468795926", "createdAt": "2020-08-11T18:52:53Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,128 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }\n+            }).when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NzAzNw==", "bodyText": "same here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468797037", "createdAt": "2020-08-11T18:54:53Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,128 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }\n+            }).when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            jobSucceededLatch.await(10, TimeUnit.SECONDS);\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",\n+                    ((Map<String, Boolean>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                            .get(TEST_CONFIGURATION_ARN).equals(true));\n+\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_correctly_map_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics deploymentGroupTopics = Topics.of(context, EXPECTED_GROUP_NAME, allGroupTopics);\n+            Topic pkgTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\");\n+            Topic groupTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                    \"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\");\n+            Map<String, Node> pkgDetails = new HashMap<>();\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgTopic1);\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID, groupTopic1);\n+            Topics pkgTopics = Topics.of(context, EXPECTED_ROOT_PACKAGE_NAME, deploymentGroupTopics);\n+            pkgTopics.children.putAll(pkgDetails);\n+            deploymentGroupTopics.children.put(EXPECTED_ROOT_PACKAGE_NAME, pkgTopics);\n+\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(deploymentGroupTopics);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(mockComponentsToGroupPackages);\n+            when(mockKernel.locate(any())).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+            CountDownLatch jobSucceededLatch = new CountDownLatch(1);\n+            doAnswer(new Answer() {\n+                @Override\n+                public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n+                    jobSucceededLatch.countDown();\n+                    return null;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NzQ4NQ==", "bodyText": "shut this down at the end of each test", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468797485", "createdAt": "2020-08-11T18:55:42Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,693 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.config.EvergreenLogConfig;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGServiceTestUtil;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.slf4j.event.Level;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_SEQUENCE_NUMBER_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class FleetStatusServiceTest extends EGServiceTestUtil {\n+    @Mock\n+    private MqttClient mockMqttClient;\n+    @Mock\n+    private DeviceConfiguration mockDeviceConfiguration;\n+    @Mock\n+    private DeploymentStatusKeeper mockDeploymentStatusKeeper;\n+    @Mock\n+    private Kernel mockKernel;\n+    @Mock\n+    private EvergreenService mockEvergreenService1;\n+    @Mock\n+    private EvergreenService mockEvergreenService2;\n+    @Mock\n+    private DeploymentService mockDeploymentService;\n+    @Captor\n+    private ArgumentCaptor<Function<Map<String, Object>, Boolean>> consumerArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<MqttClientConnectionEvents> mqttClientConnectionEventsArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<GlobalStateChangeListener> addGlobalStateChangeListenerArgumentCaptor;\n+\n+    private ScheduledThreadPoolExecutor ses;\n+    private FleetStatusService fleetStatusService;\n+\n+    @BeforeEach\n+    public void setup() {\n+        serviceFullName = \"FleetStatusService\";\n+        initializeMockedConfig();\n+        ses = new ScheduledThreadPoolExecutor(4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc5NzU4MQ==", "bodyText": "Do not use order", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468797581", "createdAt": "2020-08-11T18:55:52Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -0,0 +1,693 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.impl.config.EvergreenLogConfig;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGServiceTestUtil;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.slf4j.event.Level;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.deployment.DeviceConfiguration.DEVICE_PARAM_THING_NAME;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC;\n+import static com.aws.iot.evergreen.fss.FleetStatusService.FLEET_STATUS_SEQUENCE_NUMBER_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class FleetStatusServiceTest extends EGServiceTestUtil {\n+    @Mock\n+    private MqttClient mockMqttClient;\n+    @Mock\n+    private DeviceConfiguration mockDeviceConfiguration;\n+    @Mock\n+    private DeploymentStatusKeeper mockDeploymentStatusKeeper;\n+    @Mock\n+    private Kernel mockKernel;\n+    @Mock\n+    private EvergreenService mockEvergreenService1;\n+    @Mock\n+    private EvergreenService mockEvergreenService2;\n+    @Mock\n+    private DeploymentService mockDeploymentService;\n+    @Captor\n+    private ArgumentCaptor<Function<Map<String, Object>, Boolean>> consumerArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<PublishRequest> publishRequestArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<MqttClientConnectionEvents> mqttClientConnectionEventsArgumentCaptor;\n+    @Captor\n+    private ArgumentCaptor<GlobalStateChangeListener> addGlobalStateChangeListenerArgumentCaptor;\n+\n+    private ScheduledThreadPoolExecutor ses;\n+    private FleetStatusService fleetStatusService;\n+\n+    @BeforeEach\n+    public void setup() {\n+        serviceFullName = \"FleetStatusService\";\n+        initializeMockedConfig();\n+        ses = new ScheduledThreadPoolExecutor(4);\n+        Topic thingNameTopic = Topic.of(context, DEVICE_PARAM_THING_NAME, \"testThing\");\n+        lenient().when(mockDeviceConfiguration.getThingName()).thenReturn(thingNameTopic);\n+        lenient().when(mockEvergreenService2.getName()).thenReturn(\"MockService2\");\n+        lenient().when(mockEvergreenService1.getName()).thenReturn(\"MockService\");\n+        EvergreenLogConfig.getInstance().setLevel(Level.DEBUG);\n+        Topic sequenceNumberTopic = Topic.of(context, FLEET_STATUS_SEQUENCE_NUMBER_TOPIC, \"0\");\n+        when(config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)).thenReturn(sequenceNumberTopic);\n+        Topic lastPeriodicUpdateTime = Topic.of(context, FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC, Instant.now().toEpochMilli());\n+        when(config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)).thenReturn(lastPeriodicUpdateTime);\n+    }\n+\n+    @AfterEach\n+    public void cleanUp() {\n+        fleetStatusService.shutdown();\n+        fleetStatusService.clearEvergreenServiceSet();\n+    }\n+\n+    @Test\n+    @Order(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efb1b09410111b5fb71e74c0316fd424959f6a92"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9c5311f43f61725a316d2881e0bafabba5c17053", "committedDate": "2020-08-11T22:26:01Z", "message": "Address PR comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDc1MDkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-465475091", "createdAt": "2020-08-11T22:36:56Z", "commit": {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNjo1NlrOG_LlAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNjo1NlrOG_LlAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMzE2OA==", "bodyText": "completely remove this log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468903168", "createdAt": "2020-08-11T22:36:56Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -349,14 +364,14 @@ private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallS\n \n \n     @Override\n-    public void startup() {\n-        logger.atInfo().log(\"Starting Fleet status service.\");\n-        reportState(State.RUNNING);\n+    public void startup() throws InterruptedException {\n+        logger.atDebug().log(\"Starting Fleet status service.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053"}, "originalPosition": 324}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDc1MTcy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-465475172", "createdAt": "2020-08-11T22:37:07Z", "commit": {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNzowN1rOG_LlPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNzowN1rOG_LlPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMzIzMA==", "bodyText": "completely remove", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468903230", "createdAt": "2020-08-11T22:37:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -349,14 +364,14 @@ private OverallStatus getOverallStatusBasedOnServiceState(OverallStatus overallS\n \n \n     @Override\n-    public void startup() {\n-        logger.atInfo().log(\"Starting Fleet status service.\");\n-        reportState(State.RUNNING);\n+    public void startup() throws InterruptedException {\n+        logger.atDebug().log(\"Starting Fleet status service.\");\n+        super.startup();\n     }\n \n     @Override\n     public void shutdown() {\n-        logger.atInfo().log(\"Stopping Fleet status service.\");\n+        logger.atDebug().log(\"Stopping Fleet status service.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053"}, "originalPosition": 331}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDc1MzUz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-465475353", "createdAt": "2020-08-11T22:37:32Z", "commit": {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNzozMlrOG_Ll4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjozNzozMlrOG_Ll4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkwMzM5NA==", "bodyText": "use shutdownNow", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468903394", "createdAt": "2020-08-11T22:37:32Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -102,26 +101,27 @@ public void setup() {\n         initializeMockedConfig();\n         ses = new ScheduledThreadPoolExecutor(4);\n         Topic thingNameTopic = Topic.of(context, DEVICE_PARAM_THING_NAME, \"testThing\");\n-        lenient().when(mockDeviceConfiguration.getThingName()).thenReturn(thingNameTopic);\n         lenient().when(mockEvergreenService2.getName()).thenReturn(\"MockService2\");\n         lenient().when(mockEvergreenService1.getName()).thenReturn(\"MockService\");\n         EvergreenLogConfig.getInstance().setLevel(Level.DEBUG);\n+        when(config.lookup(DEVICE_PARAM_THING_NAME)).thenReturn(thingNameTopic);\n+        when(mockDeviceConfiguration.getThingName()).thenReturn(thingNameTopic);\n         Topic sequenceNumberTopic = Topic.of(context, FLEET_STATUS_SEQUENCE_NUMBER_TOPIC, \"0\");\n-        when(config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)).thenReturn(sequenceNumberTopic);\n+        lenient().when(config.lookup(FLEET_STATUS_SEQUENCE_NUMBER_TOPIC)).thenReturn(sequenceNumberTopic);\n         Topic lastPeriodicUpdateTime = Topic.of(context, FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC, Instant.now().toEpochMilli());\n-        when(config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)).thenReturn(lastPeriodicUpdateTime);\n+        lenient().when(config.lookup(FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC)).thenReturn(lastPeriodicUpdateTime);\n     }\n \n     @AfterEach\n     public void cleanUp() {\n+        ses.shutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c5311f43f61725a316d2881e0bafabba5c17053"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46e0cc4b4439f2e5f762bc8564b4283b08e29af0", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/46e0cc4b4439f2e5f762bc8564b4283b08e29af0", "committedDate": "2020-08-11T23:01:40Z", "message": "Address more PR comments. Make publish topic configurable."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5ee6593054658179276e4da214f40276de4ecd6", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5ee6593054658179276e4da214f40276de4ecd6", "committedDate": "2020-08-11T23:04:26Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDkwNjc5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-465490679", "createdAt": "2020-08-11T23:17:33Z", "commit": {"oid": "d5ee6593054658179276e4da214f40276de4ecd6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMzoxNzozM1rOG_MZ2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMzoxODo1MlrOG_MbVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNjY5Nw==", "bodyText": "use hamcrest to your advantage. http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/core/AnyOf.html\nhttp://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/collection/IsEmptyCollection.html\nhttp://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/core/IsNull.html", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468916697", "createdAt": "2020-08-11T23:17:33Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,114 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5ee6593054658179276e4da214f40276de4ecd6"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNjg4MA==", "bodyText": "use hamcrest to properly check equality.\nassertThat(x, is(true))", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468916880", "createdAt": "2020-08-11T23:18:08Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,114 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5ee6593054658179276e4da214f40276de4ecd6"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNzA3Nw==", "bodyText": "use hamcrest\nassertThat(x, hasKey(y))\nhttp://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/collection/IsMapContaining.html#hasKey(K)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r468917077", "createdAt": "2020-08-11T23:18:52Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -170,20 +179,114 @@ public Object answer(InvocationOnMock invocationOnMock) throws Throwable {\n             jobSucceededLatch.await(10, TimeUnit.SECONDS);\n             verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n                     eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n-            ArgumentCaptor<Map<Object, Object>>  mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n             verify(mockGroupPackages).replaceAndWait(mapCaptor.capture());\n             Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n             assertThat(\"Missing group to root package entries\",\n                     groupToRootPackages != null || !groupToRootPackages.isEmpty());\n             assertThat(\"Expected root package not found\",\n                     groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n             assertThat(\"Expected package version not found\",\n-                    ((Map<String, String>)groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                    ((Map<String, String>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n                             .get(\"version\").equals(\"1.0.0\"));\n \n             deploymentService.shutdown();\n         }\n \n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_set_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics groupTopics = allGroupTopics.createInteriorChild(EXPECTED_GROUP_NAME);\n+            Topics componentTopics = groupTopics.createInteriorChild(EXPECTED_ROOT_PACKAGE_NAME);\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).withValue(\"1.0.0\");\n+            componentTopics.createLeafChild(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID)\n+                    .withValue(TEST_CONFIGURATION_ARN);\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(groupTopics);\n+            Topics componentToGroupsTopics =  mock(Topics.class);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(componentToGroupsTopics);\n+            when(mockKernel.locate(EXPECTED_ROOT_PACKAGE_NAME)).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getDependencies()).thenReturn(new HashMap<>());\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(componentToGroupsTopics).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",\n+                    groupToRootPackages.containsKey(EXPECTED_ROOT_PACKAGE_NAME));\n+            assertThat(\"Expected package version not found\",\n+                    ((Map<String, Boolean>) groupToRootPackages.get(EXPECTED_ROOT_PACKAGE_NAME))\n+                            .get(TEST_CONFIGURATION_ARN).equals(true));\n+\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_job_WHEN_deployment_process_succeeds_THEN_correctly_map_components_to_groups()\n+                throws Exception {\n+            Topics allGroupTopics = Topics.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+            Topics deploymentGroupTopics = Topics.of(context, EXPECTED_GROUP_NAME, allGroupTopics);\n+            Topic pkgTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\");\n+            Topic groupTopic1 = Topic.of(context, DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID,\n+                    \"arn:aws:greengrass:testRegion:12345:configuration:testGroup:12\");\n+            Map<String, Node> pkgDetails = new HashMap<>();\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, pkgTopic1);\n+            pkgDetails.put(DeploymentService.GROUP_TO_ROOT_COMPONENTS_GROUP_DEPLOYMENT_ID, groupTopic1);\n+            Topics pkgTopics = Topics.of(context, EXPECTED_ROOT_PACKAGE_NAME, deploymentGroupTopics);\n+            pkgTopics.children.putAll(pkgDetails);\n+            deploymentGroupTopics.children.put(EXPECTED_ROOT_PACKAGE_NAME, pkgTopics);\n+\n+            when(config.lookupTopics(DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS, EXPECTED_GROUP_NAME)).thenReturn(deploymentGroupTopics);\n+            when(config.lookupTopics(DeploymentService.COMPONENTS_TO_GROUPS_TOPICS)).thenReturn(mockComponentsToGroupPackages);\n+            when(mockKernel.locate(any())).thenReturn(mockEvergreenService);\n+            when(mockEvergreenService.getName()).thenReturn(EXPECTED_ROOT_PACKAGE_NAME);\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+            when(mockExecutorService.submit(any(DefaultDeploymentTask.class))).thenReturn(mockFuture);\n+\n+            doNothing().when(deploymentStatusKeeper).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+\n+            startDeploymentServiceInAnotherThread();\n+            verify(deploymentStatusKeeper, timeout(1000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.IN_PROGRESS), any());\n+            verify(deploymentStatusKeeper, timeout(10000))\n+                    .persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                            eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+\n+            verify(mockExecutorService, timeout(1000)).submit(any(DefaultDeploymentTask.class));\n+            verify(deploymentStatusKeeper, timeout(2000)).persistAndPublishDeploymentStatus(eq(TEST_JOB_ID_1),\n+                    eq(Deployment.DeploymentType.IOT_JOBS), eq(JobStatus.SUCCEEDED), any());\n+            ArgumentCaptor<Map<Object, Object>> mapCaptor = ArgumentCaptor.forClass(Map.class);\n+            verify(mockComponentsToGroupPackages).replaceAndWait(mapCaptor.capture());\n+            Map<Object, Object> groupToRootPackages = mapCaptor.getValue();\n+            assertThat(\"Missing group to root package entries\",\n+                    groupToRootPackages != null || !groupToRootPackages.isEmpty());\n+            assertThat(\"Expected root package not found\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5ee6593054658179276e4da214f40276de4ecd6"}, "originalPosition": 189}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/189cb87cc5ecfd6402df103a84959bb18a4af11e", "committedDate": "2020-08-11T23:54:17Z", "message": "Address PR comments on tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTMwNjky", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-467130692", "createdAt": "2020-08-13T21:07:36Z", "commit": {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTcyOTc0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-467172974", "createdAt": "2020-08-13T22:28:04Z", "commit": {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjoyODowNFrOHAf0vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjozNzoyOVrOHAgBPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MzQ1NA==", "bodyText": "Do we need a filter here? Why not map.get(type)?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470283454", "createdAt": "2020-08-13T22:28:04Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -128,12 +137,11 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n         }\n     }\n \n-    protected Function<Map<String, Object>, Boolean> getConsumerForDeploymentType(DeploymentType type) {\n-        return deploymentStatusConsumer.computeIfAbsent(type, deploymentType -> {\n-            logger.atDebug().kv(\"DeploymentType\", deploymentType)\n-                    .log(\"Consumer for type not found, dropping status update\");\n-            return (status) -> true;\n-        });\n+    protected List<Function<Map<String, Object>, Boolean>> getConsumersForDeploymentType(DeploymentType type) {\n+        return deploymentStatusConsumerMap.entrySet().stream()\n+                .filter(deploymentTypeMapEntry -> type.equals(deploymentTypeMapEntry.getKey()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NDA4OA==", "bodyText": "Can you add a javadoc? What is the boolean in the return object?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470284088", "createdAt": "2020-08-13T22:29:58Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -128,12 +137,11 @@ public void publishPersistedStatusUpdates(DeploymentType type) {\n         }\n     }\n \n-    protected Function<Map<String, Object>, Boolean> getConsumerForDeploymentType(DeploymentType type) {\n-        return deploymentStatusConsumer.computeIfAbsent(type, deploymentType -> {\n-            logger.atDebug().kv(\"DeploymentType\", deploymentType)\n-                    .log(\"Consumer for type not found, dropping status update\");\n-            return (status) -> true;\n-        });\n+    protected List<Function<Map<String, Object>, Boolean>> getConsumersForDeploymentType(DeploymentType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NTEyNg==", "bodyText": "You can use KERNEL_VERSION in kernel pkg for now", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470285126", "createdAt": "2020-08-13T22:32:55Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC =\n+            \"$aws/things/{thingName}/evergreen/health/json\";\n+    static final String FLEET_STATUS_SERVICE_PUBLISH_TOPICS = \"fleetStatusServicePublishTopic\";\n+    static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private String updateFssDataTopic;\n+    private String thingName;\n+    private final MqttClient mqttClient;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final Set<EvergreenService> updatedEvergreenServiceSet =\n+            Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final Object periodicUpdateInProgressLock = new Object();\n+    private int periodicUpdateIntervalSec;\n+    public String fleetStatusServicePublishTopic = DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeploymentStatusKeeper deploymentStatusKeeper,\n+                              Kernel kernel, DeviceConfiguration deviceConfiguration) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        updateThingNameAndPublishTopic(Coerce.toString(deviceConfiguration.getThingName()));\n+        topics.lookup(DeviceConfiguration.DEVICE_PARAM_THING_NAME)\n+                .subscribe((why, node) -> updateThingNameAndPublishTopic(Coerce.toString(node)));\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_SERVICE_PUBLISH_TOPICS)\n+                .dflt(DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC)\n+                .subscribe((why, newv) -> {\n+                    fleetStatusServicePublishTopic = Coerce.toString(newv);\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NjY1NQ==", "bodyText": "I saw this call in 3 places, here, updatePeriodicFleetStatusData and updateEventTriggeredFleetStatusData. How are these 3 coordinated?\nI was assuming updateEventTriggeredFleetStatusData to be synchronized, unless you can explain the reasons", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470286655", "createdAt": "2020-08-13T22:37:29Z", "author": {"login": "hui-yang"}, "path": "src/main/java/com/aws/iot/evergreen/fss/FleetStatusService.java", "diffHunk": "@@ -0,0 +1,402 @@\n+/*\n+ *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *   SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.fss;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.DeploymentService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.DeviceConfiguration;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.mqtt.MqttClient;\n+import com.aws.iot.evergreen.mqtt.PublishRequest;\n+import com.aws.iot.evergreen.packagemanager.KernelConfigResolver;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import lombok.Getter;\n+import software.amazon.awssdk.crt.mqtt.MqttClientConnectionEvents;\n+import software.amazon.awssdk.crt.mqtt.QualityOfService;\n+import software.amazon.awssdk.iot.iotjobs.model.JobStatus;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.inject.Inject;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentService.COMPONENTS_TO_GROUPS_TOPICS;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+@ImplementsService(name = FleetStatusService.FLEET_STATUS_SERVICE_TOPICS, autostart = true, version = \"1.0.0\")\n+public class FleetStatusService extends EvergreenService {\n+    public static final String FLEET_STATUS_SERVICE_TOPICS = \"FleetStatusService\";\n+    // TODO: update the topic name to remove the evergreen code name from it.\n+    public static final String DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC =\n+            \"$aws/things/{thingName}/evergreen/health/json\";\n+    static final String FLEET_STATUS_SERVICE_PUBLISH_TOPICS = \"fleetStatusServicePublishTopic\";\n+    static final String FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC = \"periodicUpdateIntervalSec\";\n+    static final String FLEET_STATUS_SEQUENCE_NUMBER_TOPIC = \"sequenceNumber\";\n+    static final String FLEET_STATUS_LAST_PERIODIC_UPDATE_TIME_TOPIC = \"lastPeriodicUpdateTime\";\n+    private static final ObjectMapper SERIALIZER = new ObjectMapper();\n+    private static final int DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC = 86_400;\n+\n+    private final String kernelVersion;\n+    private String updateFssDataTopic;\n+    private String thingName;\n+    private final MqttClient mqttClient;\n+    private final Kernel kernel;\n+    private final String architecture;\n+    private final String platform;\n+    private final DeploymentStatusKeeper deploymentStatusKeeper;\n+    private final AtomicBoolean isConnected = new AtomicBoolean(true);\n+    private final Set<EvergreenService> updatedEvergreenServiceSet =\n+            Collections.newSetFromMap(new ConcurrentHashMap<>());\n+    // TODO: Remove this variable after implementing callbacks for getting services being removed notifications.\n+    private final ConcurrentHashMap<EvergreenService, Instant> allEvergreenServicesNameMap = new ConcurrentHashMap<>();\n+    private final AtomicBoolean isDeploymentInProgress = new AtomicBoolean(false);\n+    private final Object periodicUpdateInProgressLock = new Object();\n+    private int periodicUpdateIntervalSec;\n+    public String fleetStatusServicePublishTopic = DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC;\n+    private ScheduledFuture<?> periodicUpdateFuture;\n+\n+    @Getter\n+    public MqttClientConnectionEvents callbacks = new MqttClientConnectionEvents() {\n+        @Override\n+        public void onConnectionInterrupted(int errorCode) {\n+            isConnected.set(false);\n+        }\n+\n+        @Override\n+        public void onConnectionResumed(boolean sessionPresent) {\n+            isConnected.set(true);\n+            schedulePeriodicFleetStatusDataUpdate(true);\n+        }\n+    };\n+\n+    /**\n+     * Constructor for FleetStatusService.\n+     *\n+     * @param topics                 root Configuration topic for this service\n+     * @param mqttClient             {@link MqttClient}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     * @param kernel                 {@link Kernel}\n+     * @param deviceConfiguration    {@link DeviceConfiguration}\n+     */\n+    @Inject\n+    public FleetStatusService(Topics topics, MqttClient mqttClient, DeploymentStatusKeeper deploymentStatusKeeper,\n+                              Kernel kernel, DeviceConfiguration deviceConfiguration) {\n+        super(topics);\n+\n+        this.mqttClient = mqttClient;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+        this.kernel = kernel;\n+        this.architecture = System.getProperty(\"os.arch\");\n+\n+        // TODO: Make this more robust to handle all platforms.\n+        this.platform = System.getProperty(\"os.name\");\n+\n+        updateThingNameAndPublishTopic(Coerce.toString(deviceConfiguration.getThingName()));\n+        topics.lookup(DeviceConfiguration.DEVICE_PARAM_THING_NAME)\n+                .subscribe((why, node) -> updateThingNameAndPublishTopic(Coerce.toString(node)));\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .dflt(DEFAULT_PERIODIC_UPDATE_INTERVAL_SEC)\n+                .subscribe((why, newv) -> {\n+                    periodicUpdateIntervalSec = Coerce.toInt(newv);\n+                    if (periodicUpdateFuture != null) {\n+                        schedulePeriodicFleetStatusDataUpdate(false);\n+                    }\n+                });\n+\n+        topics.lookup(PARAMETERS_CONFIG_KEY, FLEET_STATUS_SERVICE_PUBLISH_TOPICS)\n+                .dflt(DEFAULT_FLEET_STATUS_SERVICE_PUBLISH_TOPIC)\n+                .subscribe((why, newv) -> {\n+                    fleetStatusServicePublishTopic = Coerce.toString(newv);\n+                });\n+\n+        //TODO: Get the kernel version once its implemented.\n+        this.kernelVersion = \"1.0.0\";\n+        topics.getContext().addGlobalStateChangeListener(this::handleServiceStateChange);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.IOT_JOBS,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        this.deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                this::deploymentStatusChanged, FLEET_STATUS_SERVICE_TOPICS);\n+        schedulePeriodicFleetStatusDataUpdate(false);\n+\n+        this.mqttClient.addToCallbackEvents(callbacks);\n+    }\n+\n+    private void updateThingNameAndPublishTopic(String newThingName) {\n+        if (newThingName != null) {\n+            thingName = newThingName;\n+            updateFssDataTopic = fleetStatusServicePublishTopic.replace(\"{thingName}\", thingName);\n+        }\n+    }\n+\n+    private void schedulePeriodicFleetStatusDataUpdate(boolean isDuringConnectionResumed) {\n+        // If the last periodic update was missed, update the fleet status service for all running services.\n+        // Else update only the statuses of the services whose status changed (if any) and if the method is called\n+        // due to a MQTT connection resumption.\n+        if (periodicUpdateFuture != null) {\n+            periodicUpdateFuture.cancel(false);\n+        }\n+\n+        synchronized (periodicUpdateInProgressLock) {\n+            Instant lastPeriodicUpdateTime = Instant.ofEpochMilli(Coerce.toLong(getPeriodicUpdateTimeTopic()));\n+\n+            if (lastPeriodicUpdateTime.plusSeconds(periodicUpdateIntervalSec).isBefore(Instant.now())) {\n+                updatePeriodicFleetStatusData();\n+            } else if (isDuringConnectionResumed) {\n+                updateEventTriggeredFleetStatusData();\n+            }\n+        }\n+\n+        ScheduledExecutorService ses = getContext().get(ScheduledExecutorService.class);\n+        this.periodicUpdateFuture = ses.scheduleWithFixedDelay(this::updatePeriodicFleetStatusData,\n+                periodicUpdateIntervalSec, periodicUpdateIntervalSec, TimeUnit.SECONDS);\n+    }\n+\n+    @SuppressWarnings(\"PMD.UnusedFormalParameter\")\n+    private void handleServiceStateChange(EvergreenService evergreenService, State oldState,\n+                                          State newState) {\n+        synchronized (updatedEvergreenServiceSet) {\n+            updatedEvergreenServiceSet.add(evergreenService);\n+        }\n+\n+        // if there is no ongoing deployment and we encounter a BROKEN component, update the fleet status as UNHEALTHY.\n+        if (!isDeploymentInProgress.get() && newState.equals(State.BROKEN)) {\n+            uploadFleetStatusServiceData(updatedEvergreenServiceSet, OverallStatus.UNHEALTHY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189cb87cc5ecfd6402df103a84959bb18a4af11e"}, "originalPosition": 188}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a79c19640b4702496015c639b5e7af6fa434cd66", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a79c19640b4702496015c639b5e7af6fa434cd66", "committedDate": "2020-08-13T23:41:53Z", "message": "Address PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4d26e45d46522f5c1fe92e99106c03794f56799", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b4d26e45d46522f5c1fe92e99106c03794f56799", "committedDate": "2020-08-13T23:43:06Z", "message": "Merge branch 'master' into fss"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjQyMzM0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-467242334", "createdAt": "2020-08-14T00:45:16Z", "commit": {"oid": "a79c19640b4702496015c639b5e7af6fa434cd66"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMDo0NToxNlrOHAjQcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMDo0NToxNlrOHAjQcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzOTY5Ng==", "bodyText": "instead of hardcoding this, why not grab it from the const?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#discussion_r470339696", "createdAt": "2020-08-14T00:45:16Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/fss/FleetStatusServiceTest.java", "diffHunk": "@@ -171,7 +171,7 @@ void GIVEN_kernel_running_with_deployed_services_WHEN_deployment_finishes_THEN_f\n         assertNotNull(receivedMqttMessage2.getPayload());\n         FleetStatusDetails fleetStatusDetails2 = DESERIALIZER.readValue(receivedMqttMessage2.getPayload(), FleetStatusDetails.class);\n         assertEquals(thingInfo.getThingName(), fleetStatusDetails2.getThing());\n-        assertEquals(\"1.0.0\", fleetStatusDetails2.getGgcVersion());\n+        assertEquals(\"2.0.0\", fleetStatusDetails2.getGgcVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a79c19640b4702496015c639b5e7af6fa434cd66"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e939a1b82a7343f6e4f945df66f3339a73ddde29", "author": {"user": {"login": "nikkhilmuthye", "name": "Nikkhil Muthye"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e939a1b82a7343f6e4f945df66f3339a73ddde29", "committedDate": "2020-08-14T16:36:33Z", "message": "Use const KERNEL_VERSION in tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NzI2NzIy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-467726722", "createdAt": "2020-08-14T16:54:00Z", "commit": {"oid": "e939a1b82a7343f6e4f945df66f3339a73ddde29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3Nzc0MTY5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/335#pullrequestreview-467774169", "createdAt": "2020-08-14T18:08:12Z", "commit": {"oid": "e939a1b82a7343f6e4f945df66f3339a73ddde29"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2950, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}