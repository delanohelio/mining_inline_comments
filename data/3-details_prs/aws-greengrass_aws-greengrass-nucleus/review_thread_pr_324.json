{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0NjkzNzg5", "number": 324, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToxNDozM1rOEQwthw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMDo0NDozN1rOERqbpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDEwNzU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToxNDozNFrOG1GMeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToxNDozNFrOG1GMeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMyOTIwOA==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and put() may not be thread-safe at lines: 115 and 123. Two threads can perform this same check at the same time and one thread can overwrite the value written by the other thread.\nFix\nConsider replacing put() with putIfAbsent() to help prevent accidental overwriting. putIfAbsent() puts the value only if the ConcurrentHashMap does not contain the key and therefore avoids overwriting the value written there by the other thread's putIfAbsent().\nMore info\nIf the key already exists, the code should throw an error at line: 116. putIfAbsent() returns null if the value did not exist and returns the value in the map if one already exists.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458329208", "createdAt": "2020-07-21T19:14:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        List<String> operationsCopy = new ArrayList<>(operations);\n+        if (!operationsCopy.contains(ANY_REGEX)) {\n+            operationsCopy.add(ANY_REGEX);\n+        }\n+        serviceToOperationsMap.put(serviceName, operationsCopy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDEzNDA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyMjoyN1rOG1GdPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMDo0NjozN1rOG1JJJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzMzUwMQ==", "bodyText": "inject the auth module for easier testing", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458333501", "createdAt": "2020-07-21T19:22:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3NzUxMQ==", "bodyText": "I wanted to test them together as part of UT as authModule is just a store only used by this class. This way UT is more closer to real scenarios. Let me know if that makes sense.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458377511", "createdAt": "2020-07-21T20:46:37Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzMzUwMQ=="}, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE0MzY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyNTozNlrOG1Gjhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMToyMzo1NFrOG1KToQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTExMQ==", "bodyText": "maybe use a Set instead? Then you can just add ANY_REGEX", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458335111", "createdAt": "2020-07-21T19:25:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        List<String> operationsCopy = new ArrayList<>(operations);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjU3Nw==", "bodyText": "changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458396577", "createdAt": "2020-07-21T21:23:54Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        List<String> operationsCopy = new ArrayList<>(operations);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTExMQ=="}, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE0NzAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyNjozOVrOG1Glpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMToyMzo0OVrOG1KTaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTY1NA==", "bodyText": "use Utils.isEmpty?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458335654", "createdAt": "2020-07-21T19:26:39Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjUyMw==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458396523", "createdAt": "2020-07-21T21:23:49Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    public static final String AUTHZ_TOPIC = \"accessControl\";\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, List<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations List of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, List<String> operations)\n+            throws AuthZException {\n+        if (operations.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNTY1NA=="}, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE1NjU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOToyOTozNFrOG1Gryg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMToyMzo0MVrOG1KTLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzIyNg==", "bodyText": "may want to make these lists into sets so the contains check is faster", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458337226", "createdAt": "2020-07-21T19:29:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.List;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {\n+    @NonNull String policyId;\n+    String policyDescription;\n+    @NonNull List<String> sources;\n+    @NonNull List<String> operations;\n+    List<String> resources;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjQ2Mg==", "bodyText": "Yeah. I was thinking this to be public model which customer specifies in kernel config, but lets do set for now. We will revisit that later when we make end to end changes.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458396462", "createdAt": "2020-07-21T21:23:41Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.List;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {\n+    @NonNull String policyId;\n+    String policyDescription;\n+    @NonNull List<String> sources;\n+    @NonNull List<String> operations;\n+    List<String> resources;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzIyNg=="}, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDE1ODQxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOTozMDoxMlrOG1Gs9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTowNzo1NVrOG1J0Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzUyNg==", "bodyText": "maybe also assert on what the message is in the exception", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458337526", "createdAt": "2020-07-21T19:30:12Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthZHandlerTest {\n+\n+    @Mock\n+    private Kernel mockKernel;\n+\n+    @Mock\n+    private Topics mockTopics;\n+\n+    private AuthZPolicy getAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getAuthZPolicyB() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id2\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"ServiceC\", \"ServiceD\"))\n+                .operations(Arrays.asList(\"OpD\", \"OpE\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarOperationsAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"*\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarSourcesAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"*\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    @Test\n+    void GIVEN_AuthZ_manager_WHEN_service_registered_twice_THEN_errors() throws AuthZException {\n+        AuthZHandler authZHandler = new AuthZHandler(mockKernel);\n+        final List<String> serviceOps = Arrays.asList(\"OpA\", \"OpB\", \"OpC\");\n+        authZHandler.registerService(\"ServiceA\", serviceOps);\n+\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps));\n+        final List<String> serviceOps_2 = Arrays.asList(\"OpA\");\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps_2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4ODU3NQ==", "bodyText": "I have a task to add fine grained exceptions. I will add that as part of that task", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458388575", "createdAt": "2020-07-21T21:07:55Z", "author": {"login": "prateek-y"}, "path": "src/test/java/com/aws/iot/evergreen/auth/AuthZHandlerTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class AuthZHandlerTest {\n+\n+    @Mock\n+    private Kernel mockKernel;\n+\n+    @Mock\n+    private Topics mockTopics;\n+\n+    private AuthZPolicy getAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getAuthZPolicyB() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id2\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"ServiceC\", \"ServiceD\"))\n+                .operations(Arrays.asList(\"OpD\", \"OpE\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarOperationsAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"compA\", \"compB\"))\n+                .operations(Arrays.asList(\"*\"))\n+                .build();\n+    }\n+\n+    private AuthZPolicy getStarSourcesAuthZPolicy() {\n+        return AuthZPolicy.builder()\n+                .policyId(\"Id1\")\n+                .policyDescription(\"Test policy\")\n+                .sources(Arrays.asList(\"*\"))\n+                .operations(Arrays.asList(\"OpA\", \"OpB\", \"OpC\"))\n+                .build();\n+    }\n+\n+    @Test\n+    void GIVEN_AuthZ_manager_WHEN_service_registered_twice_THEN_errors() throws AuthZException {\n+        AuthZHandler authZHandler = new AuthZHandler(mockKernel);\n+        final List<String> serviceOps = Arrays.asList(\"OpA\", \"OpB\", \"OpC\");\n+        authZHandler.registerService(\"ServiceA\", serviceOps);\n+\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps));\n+        final List<String> serviceOps_2 = Arrays.asList(\"OpA\");\n+        assertThrows(AuthZException.class, () -> authZHandler.registerService(\"ServiceA\", serviceOps_2));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzNzUyNg=="}, "originalCommit": {"oid": "5011ff64d8764389fffb8ece36b5f3e059df4c4a"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDYxNDMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTo1MToxM1rOG1LGwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMDoxMDoyMVrOG1OIgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwOTY2Ng==", "bodyText": "why copy it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458409666", "createdAt": "2020-07-21T21:51:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ff2ee02726c325fc7e3d1453999f68d75d442a2"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1ODUxOQ==", "bodyText": "Did not want to keep a reference to an object writable by the caller. Not sure if this is the right way to avoid it. Do you have suggestions?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458458519", "createdAt": "2020-07-22T00:07:43Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwOTY2Ng=="}, "originalCommit": {"oid": "9ff2ee02726c325fc7e3d1453999f68d75d442a2"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1OTI2NA==", "bodyText": "The caller is within our kernel, we should be able to trust that it is fine.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458459264", "createdAt": "2020-07-22T00:10:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwOTY2Ng=="}, "originalCommit": {"oid": "9ff2ee02726c325fc7e3d1453999f68d75d442a2"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDAzNjg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjo1ODoxNlrOG1rrYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoxNTo1MlrOG2eq9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0MzMzMQ==", "bodyText": "just set these in the field definition?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458943331", "createdAt": "2020-07-22T16:58:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODgwNw==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778807", "createdAt": "2020-07-23T23:15:52Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0MzMzMQ=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDA0NDkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowMDoxMFrOG1rwPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowMDoxMFrOG1rwPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NDU3Mw==", "bodyText": "[nit]\nFormatting, reformat all files just in case.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458944573", "createdAt": "2020-07-22T17:00:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)\n+            throws AuthZException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Service name is not specified\");\n+        }\n+        if (config == null) {\n+            throw new AuthZException(\"config is null\");\n+        }\n+        isServiceRegistered(serviceName);\n+\n+        // First validate if all sources and operations are valid\n+        for (AuthZPolicy policy: config) {\n+            validateSources(policy);\n+            validateOperations(serviceName, policy);\n+        }\n+        // now start adding the config as permissions\n+        for (AuthZPolicy policy: config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDA1MTMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowMTo1M1rOG1r0OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowMTo1M1rOG1r0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTU5Mw==", "bodyText": "[nit]\nWhen you have all the data in one place, just use the constructor instead of builder.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458945593", "createdAt": "2020-07-22T17:01:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)\n+            throws AuthZException {\n+        // TODO: Make this method atomic operation or thread safe for manipulating\n+        // underlying permission store.\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Service name is not specified\");\n+        }\n+        if (config == null) {\n+            throw new AuthZException(\"config is null\");\n+        }\n+        isServiceRegistered(serviceName);\n+\n+        // First validate if all sources and operations are valid\n+        for (AuthZPolicy policy: config) {\n+            validateSources(policy);\n+            validateOperations(serviceName, policy);\n+        }\n+        // now start adding the config as permissions\n+        for (AuthZPolicy policy: config) {\n+            addPermission(serviceName, policy.getSources(), policy.getOperations(), policy.getResources());\n+        }\n+        this.serviceToAuthZConfig.put(serviceName, config);\n+    }\n+\n+    private void isServiceRegistered(String serviceName) throws AuthZException {\n+        if (Utils.isEmpty(serviceName)) {\n+            throw new AuthZException(\"Invalid service name: \" + serviceName);\n+        }\n+        if (!serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service not registered: \" + serviceName);\n+        }\n+    }\n+\n+    private void isOperationValid(String serviceName, String operation)\n+            throws AuthZException {\n+        isServiceRegistered(serviceName);\n+        if (!serviceToOperationsMap.get(serviceName).contains(operation)) {\n+            throw new AuthZException(String.format(\"Service %s not registered for operation %s\",\n+                    serviceName, operation));\n+        }\n+\n+    }\n+\n+    private void validateOperations(String serviceName, AuthZPolicy policy) throws AuthZException {\n+        Set<String> operations = policy.getOperations();\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"Malformed policy with invalid/empty operations: \"\n+                    + policy.getPolicyId());\n+        }\n+        Set<String> supportedOps = serviceToOperationsMap.get(serviceName);\n+        // check if operations are valid and registered.\n+        if (operations.stream().anyMatch(o -> !supportedOps.contains(o))) {\n+            throw new AuthZException(String.format(\"Operation not registered with service %s\", serviceName));\n+        }\n+    }\n+\n+    private void validateSources(AuthZPolicy policy) throws AuthZException {\n+        Set<String> sources = policy.getSources();\n+        if (Utils.isEmpty(sources)) {\n+            throw new AuthZException(\"Malformed policy with invalid/empty source: \" + policy.getPolicyId());\n+        }\n+        // check if source is a valid EG service\n+        List<String> unknownSources = sources.stream().filter(s -> !s.equals(ANY_REGEX)).filter(s ->\n+                kernel.findServiceTopic(s) == null).collect(Collectors.toList());\n+\n+        if (!unknownSources.isEmpty()) {\n+            throw new AuthZException(String.format(\"Source %s in auth policy are not valid services\", unknownSources));\n+        }\n+    }\n+\n+    private void addPermission(String destination,\n+                               Set<String> sources,\n+                               Set<String> operations,\n+                               Set<String> resources) throws AuthZException {\n+        // Method assumes that all inputs are valid now\n+        for (String source: sources) {\n+            for (String operation: operations) {\n+                if (resources == null || resources.isEmpty()) {\n+                    authModule.addPermission(destination,\n+                            Permission.builder().source(source).operation(operation).resource(null).build());\n+                } else {\n+                    for (String resource : resources) {\n+                        authModule.addPermission(destination,\n+                                Permission.builder().source(source).operation(operation).resource(resource).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDA1MjA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowMjowN1rOG1r0yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoxNTo0N1rOG2eq3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTczOQ==", "bodyText": "just set in field definition?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458945739", "createdAt": "2020-07-22T17:02:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODc4Mw==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778783", "createdAt": "2020-07-23T23:15:47Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTczOQ=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDA1NTM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzowMzowNlrOG1r29g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoyNDowOFrOG2e0jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NjI5NA==", "bodyText": "consider using DefaultConcurrentHashMap which implements get in this same way, so you can do permissions.get(destination).add(permission), without needing a nullcheck or computeIfAbsent.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r458946294", "createdAt": "2020-07-22T17:03:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();\n+    }\n+\n+    /**\n+     * Add permission for the given input set.\n+     * @param destination destination entity\n+     * @param permission set of source, operation, resource.\n+     * @throws AuthZException when arguments are invalid\n+     */\n+    public void addPermission(final String destination, Permission permission) throws AuthZException {\n+        // resource is allowed to be null\n+        if (Utils.isEmpty(permission.getSource())\n+                || Utils.isEmpty(destination)\n+                || Utils.isEmpty(permission.getOperation())) {\n+            throw new AuthZException(\"Either one parameter is empty\");\n+        }\n+        // resource as null is ok, but it should not be empty\n+        String resource = permission.getResource();\n+        if (resource != null && Utils.isEmpty(resource)) {\n+            throw new AuthZException(\"Resource cannot be empty\");\n+        }\n+        permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MTI2Mw==", "bodyText": "will try to modify this in later cr's", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459781263", "createdAt": "2020-07-23T23:24:08Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {\n+    ConcurrentHashMap<String, List<Permission>> permissions;\n+\n+    AuthZModule() {\n+        permissions = new ConcurrentHashMap<>();\n+    }\n+\n+    /**\n+     * Add permission for the given input set.\n+     * @param destination destination entity\n+     * @param permission set of source, operation, resource.\n+     * @throws AuthZException when arguments are invalid\n+     */\n+    public void addPermission(final String destination, Permission permission) throws AuthZException {\n+        // resource is allowed to be null\n+        if (Utils.isEmpty(permission.getSource())\n+                || Utils.isEmpty(destination)\n+                || Utils.isEmpty(permission.getOperation())) {\n+            throw new AuthZException(\"Either one parameter is empty\");\n+        }\n+        // resource as null is ok, but it should not be empty\n+        String resource = permission.getResource();\n+        if (resource != null && Utils.isEmpty(resource)) {\n+            throw new AuthZException(\"Resource cannot be empty\");\n+        }\n+        permissions.computeIfAbsent(destination, a -> new ArrayList<>()).add(permission);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NjI5NA=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTEzNTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoyNTo0OVrOG12XpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoxNTo0MVrOG2eqtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODUwMA==", "bodyText": "Use full name? AuthorizationException", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459118500", "createdAt": "2020-07-22T22:25:49Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.iot.evergreen.auth.exceptions;\n+\n+public class AuthZException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODc0Mw==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778743", "createdAt": "2020-07-23T23:15:41Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/exceptions/AuthZException.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.aws.iot.evergreen.auth.exceptions;\n+\n+public class AuthZException extends Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODUwMA=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTEzOTI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoyNzoyOFrOG12aCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoxNTozN1rOG2eqrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTExMg==", "bodyText": "Use Principal? source is a bit vague.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459119112", "createdAt": "2020-07-22T22:27:28Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "diffHunk": "@@ -0,0 +1,16 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+@Builder\n+@Value\n+public class Permission {\n+    @NonNull String source;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODczMg==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778732", "createdAt": "2020-07-23T23:15:37Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/Permission.java", "diffHunk": "@@ -0,0 +1,16 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+@Builder\n+@Value\n+public class Permission {\n+    @NonNull String source;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTExMg=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTE0MzE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjoyOToxN1rOG12cZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoxNTozNFrOG2eqmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTcxNw==", "bodyText": "Use full name: AuthorizationPolicy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459119717", "createdAt": "2020-07-22T22:29:17Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.Set;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3ODcxMg==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459778712", "createdAt": "2020-07-23T23:15:34Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZPolicy.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.Value;\n+\n+import java.util.Set;\n+\n+@Value\n+@Builder\n+public class AuthZPolicy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExOTcxNw=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTE2NDI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjozODoyMFrOG12pZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoyMToxN1rOG2exaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzA0NQ==", "bodyText": "nit: AuthorizationHandler?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459123045", "createdAt": "2020-07-22T22:38:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MDQ1OQ==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459780459", "createdAt": "2020-07-23T23:21:17Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyMzA0NQ=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTE3NDM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjo0Mjo1MVrOG12vjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoxNzozMlrOG2eszg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDYyMA==", "bodyText": "What is flow? It's a weird name. Why not just isAuthorized? Also do you separate destination and permission? Can't they be modeled in one object, such as AuthorizationRequest?\nclass AuthorizationRequest {\nString principal;\nString operation;\nResource resource;\n}\n\nclass Resource {\nString target;\nList<String> subresources;\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459124620", "createdAt": "2020-07-22T22:42:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTI3OA==", "bodyText": "renamed the method. For the object, I have all the policies partitioned based on destination principal. Also the customer also configures the policies on a component. We can decide on a composite object when we open this up for API's in future, but intent here was to keep the interfaces keyed on principal destination.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779278", "createdAt": "2020-07-23T23:17:32Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDYyMA=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTIwOTMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMjo1NzoyN1rOG13EKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QyMjo1NzoyNFrOG32diA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng==", "bodyText": "Who will call this method? Why is it needed? is this registering the principal? Also I would not sure the name \"service\". It's an overloaded term.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459129896", "createdAt": "2020-07-22T22:57:27Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTcxNg==", "bodyText": "This is needed for services to register their operations. For kernel this is pre defined, but for components in future, we dont know what operations they need. This method is called to register a component with authZ and defines the set of operations that services intends to register.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779716", "createdAt": "2020-07-23T23:18:46Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTkyMQ==", "bodyText": "regarding the name, registerComponent?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779921", "createdAt": "2020-07-23T23:19:23Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxNzE2MA==", "bodyText": "Let's call registerComponent.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r461217160", "createdAt": "2020-07-27T22:57:24Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyOTg5Ng=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTIyMDUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMzowMjozNVrOG13K1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoxOToyOFrOG2evZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMTYwNA==", "bodyText": "Call it loadAuthorizationPolicy(). Don't introduce another term Config if it's already called Policy.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459131604", "createdAt": "2020-07-22T23:02:35Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3OTk0MA==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459779940", "createdAt": "2020-07-23T23:19:28Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+/**\n+ * Main module which is responsible for handling AuthZ for evergreen. This only manages\n+ * the AuthZ configuration and performs lookups based on the config. Config is just a copy of\n+ * customer config and this module does not try to optimize storage. For instance,\n+ * if customer specifies same policies twice, we treat and store them separately. Services are\n+ * identified by their service identifiers (component names) and operation/resources are assumed to be\n+ * opaque strings. They are not treated as confidential and it should be the responsibility\n+ * of the caller to use proxy identifiers for confidential data. Implementation optimizes for fast lookups\n+ * and not for storage.\n+ */\n+@Singleton\n+public class AuthZHandler {\n+    private static final String ANY_REGEX = \"*\";\n+    private static final Logger logger = LogManager.getLogger(AuthZHandler.class);\n+    private final AuthZModule authModule;\n+    private final ConcurrentHashMap<String, Set<String>> serviceToOperationsMap;\n+    private final ConcurrentHashMap<String, List<AuthZPolicy>> serviceToAuthZConfig;\n+    private final Kernel kernel;\n+\n+    /**\n+     * Constructor for AuthZ.\n+     * @param kernel kernel module for getting service information\n+     */\n+    @Inject\n+    public AuthZHandler(Kernel kernel) {\n+        authModule = new AuthZModule();\n+        serviceToOperationsMap = new ConcurrentHashMap<>();\n+        serviceToAuthZConfig = new ConcurrentHashMap<>();\n+        this.kernel = kernel;\n+    }\n+\n+    /**\n+     * Check if the combination of source, destination, operation and resource is an allowed flow.\n+     * Flow can be thought of as a request which originates from {@code source} service destined for\n+     * {@code destination} service, which needs access to {@code resource} using API {@code operation}.\n+     * @param destination Destination service which is being accessed.\n+     * @param permission container for source, operation and resource\n+     * @return whether the input combination is a valid flow.\n+     * @throws AuthZException when flow is not authorized.\n+     */\n+    public boolean isFlowAuthorized(String destination, Permission permission) throws AuthZException {\n+        String source = permission.getSource();\n+        String operation = permission.getOperation();\n+        String resource = permission.getResource();\n+        // If the operation is not registered with the destination service, then fail\n+        isOperationValid(destination, operation);\n+\n+        // Lookup all possible allow configurations starting from most specific to least\n+        // This helps for access logs, as customer can figure out which policy is being hit.\n+        String[][] combinations = {\n+                {destination, source, operation, resource},\n+                {destination, source, operation, ANY_REGEX},\n+                {destination, source, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, operation, resource},\n+                {destination, source, ANY_REGEX, ANY_REGEX},\n+                {destination, ANY_REGEX, operation, ANY_REGEX},\n+                {destination, ANY_REGEX, ANY_REGEX, resource},\n+                {destination, ANY_REGEX, ANY_REGEX, ANY_REGEX},\n+        };\n+\n+        for (String[] combination: combinations) {\n+            if (authModule.isPresent(combination[0],\n+                    Permission.builder()\n+                            .source(combination[1])\n+                            .operation(combination[2])\n+                            .resource(combination[3])\n+                            .build())) {\n+                logger.atDebug().log(\"Hit policy with source {}, operation {}, resource {}\",\n+                        combination[1],\n+                        combination[2],\n+                        combination[3]);\n+                return true;\n+            }\n+        }\n+        throw new AuthZException(\n+                String.format(\"Source %s is not authorized to perform %s:%s on resource %s\",\n+                        source,\n+                        destination,\n+                        operation,\n+                        resource));\n+    }\n+\n+    /**\n+     * Register a service with AuthZ module. This should only be called once in a lifetime of kernel\n+     * and operations are strings which the service intends to match for incoming requests by calling\n+     * {@link #isFlowAuthorized(Permission) isFlowAuthorized} method\n+     * @param serviceName Name of the service to be registered.\n+     * @param operations Set of operations the service needs to register with AuthZ.\n+     * @throws AuthZException If service is already registered.\n+     */\n+    public void registerService(String serviceName, Set<String> operations)\n+            throws AuthZException {\n+        if (Utils.isEmpty(operations)) {\n+            throw new AuthZException(\"operations is empty\");\n+        }\n+        if (serviceToOperationsMap.containsKey(serviceName)) {\n+            throw new AuthZException(\"Service already registered: \" + serviceName);\n+        }\n+\n+        operations.add(ANY_REGEX);\n+        Set<String> operationsCopy = Collections.unmodifiableSet(new HashSet<>(operations));\n+        serviceToOperationsMap.putIfAbsent(serviceName, operationsCopy);\n+    }\n+\n+    /**\n+     * Loads authZ config for future auth lookups. The config should not have confidential\n+     * values. This method assumes that the service names for source and destination,\n+     * the operations and resources must not be secret and can be logged or shared if required.\n+     * @param serviceName Destination service which intents to supply auth config\n+     * @param config config which has list of policies. All policies are treated as separate\n+     *               and no merging or joins happen. Duplicated config would result in duplicated\n+     *               permissions but would not impact functionality.\n+     * @throws AuthZException if there is a problem loading the config.\n+     */\n+    public void loadAuthZConfig(String serviceName, List<AuthZPolicy> config)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMTYwNA=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NTMyNTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMzo1MzozM1rOG14H5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzoyMDoyMFrOG2ewew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0NzIzOQ==", "bodyText": "Why modeling this as as a separate class in stead of part of AuthZHandler?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459147239", "createdAt": "2020-07-22T23:53:33Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc4MDIxOQ==", "bodyText": "I just wanted to add UT's targeting table to better test * and null scenarios, so decided to keep this separate.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459780219", "createdAt": "2020-07-23T23:20:20Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0 */\n+\n+package com.aws.iot.evergreen.auth;\n+\n+import com.aws.iot.evergreen.auth.exceptions.AuthZException;\n+import com.aws.iot.evergreen.util.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Simple permission table which stores permissions. A permission is a\n+ * 4 value set of destination,source,operation,resource.\n+ */\n+public class AuthZModule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0NzIzOQ=="}, "originalCommit": {"oid": "0908e6cd982710af8b4ba270ef442e6a85d8cd7d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTU2NDU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMDo0NDozN1rOG2gIPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMzo1Mjo0MlrOG3AiRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMjY4NQ==", "bodyText": "Should this also be renamed to use the full form instead of AuthZ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r459802685", "createdAt": "2020-07-24T00:44:37Z", "author": {"login": "avipinku"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecaf782ff24c4e775a8653c1c483cdabf591b55e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMzMzYzNg==", "bodyText": "changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/324#discussion_r460333636", "createdAt": "2020-07-24T23:52:42Z", "author": {"login": "prateek-y"}, "path": "src/main/java/com/aws/iot/evergreen/auth/AuthZModule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwMjY4NQ=="}, "originalCommit": {"oid": "ecaf782ff24c4e775a8653c1c483cdabf591b55e"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4432, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}