{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NTc3NTI1", "number": 40, "title": "POC implementation of service discovery. Implement auth for IPC connnections", "bodyText": "#35 was mistakenly merged and then reverted. This PR replaces that bad merge.\nIssue #, if available:\nDescription of changes:\nThis PR implements the service discovery backend within the Kernel space. It also enables IPC authentication using the SVCID key which is randomly generated for each service.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-01-23T21:32:22Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40", "merged": true, "mergeCommit": {"oid": "ee695baaa3e15ec4e2475c37d3195bed37d0741b"}, "closed": true, "closedAt": "2020-01-24T18:08:12Z", "author": {"login": "MikeDombo"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9RPzAgH2gAyMzY2NTc3NTI1OjA3OGUyMGYxNzQ3ZWRiOTNiMjY3ZTdiODE3NTAzNjkxMDcxOWNkZGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9izh9AFqTM0ODEyNDMzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/078e20f1747edb93b267e7b8175036910719cddd", "committedDate": "2020-01-23T21:29:57Z", "message": "POC implementation of service discovery. Implement auth for IPC connections"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3Njc1NjAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#pullrequestreview-347675600", "createdAt": "2020-01-23T23:27:43Z", "commit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyNzo0M1rOFhP8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyNzo0M1rOFhP8Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA==", "bodyText": "Why do we need an atomic reference here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370408534", "createdAt": "2020-01-23T23:27:43Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,56 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public RequestContext doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n-        }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        AtomicReference<String> serviceName = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3Njc2MjA4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#pullrequestreview-347676208", "createdAt": "2020-01-23T23:29:24Z", "commit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyOToyNFrOFhP-Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyOToyNFrOFhP-Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTA0Ng==", "bodyText": "Can we store the token in a different map so the lookup during auth is not a linear search", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409046", "createdAt": "2020-01-23T23:29:24Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -24,6 +24,10 @@ public GenericExternalService(Topics c) {\n                 setState(child.childOf(\"install\") ? State.Installing : State.AwaitingStartup);\n             }\n         });\n+\n+        // Set a unique ID used for IPC Auth\n+        Topic uid = c.createLeafChild(\"_UID\").setParentNeedsToKnow(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3Njc2MzI5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#pullrequestreview-347676329", "createdAt": "2020-01-23T23:29:39Z", "commit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyOTo0MFrOFhP-tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzoyOTo0MFrOFhP-tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwOTE0MA==", "bodyText": "add TODO: for synchronization between requests?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370409140", "createdAt": "2020-01-23T23:29:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "205381a05a894f1d27be5eec952afbb35281e7fa", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/205381a05a894f1d27be5eec952afbb35281e7fa", "committedDate": "2020-01-23T23:35:17Z", "message": "Merge branch 'master' into service_discovery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/524fc3ad38ad170d9ba5215e51f1fe48459a4225", "committedDate": "2020-01-24T00:56:44Z", "message": "Make IPC Auth have a response"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NzQ1NDcx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#pullrequestreview-347745471", "createdAt": "2020-01-24T04:22:45Z", "commit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNDoyMjo0NVrOFhTn6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjoyNToxM1rOFhU0kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2ODg0MQ==", "bodyText": "What's the reason of having SDAResource instead of directly using Resource class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370468841", "createdAt": "2020-01-24T04:22:45Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTAyNA==", "bodyText": "I would add a comment explaining why this method is synchronized. Also, java doc?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469024", "createdAt": "2020-01-24T04:24:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTE2Nw==", "bodyText": "Create a SIM and add a link to the SIM here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469167", "createdAt": "2020-01-24T04:25:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2OTMwNw==", "bodyText": "Unnecessary comment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370469307", "createdAt": "2020-01-24T04:26:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+            response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+            return response;\n+        }\n+\n+        // Save resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjU2Ng==", "bodyText": "nonnull?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370486566", "createdAt": "2020-01-24T06:13:58Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/SDAResource.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import lombok.Builder;\n+import lombok.Data;\n+\n+@Data\n+@Builder\n+public class SDAResource {\n+    private Resource resource;\n+    private boolean publishedToDNSSD;\n+    private String owningService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NjcwNA==", "bodyText": "Unnecessary comment", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370486704", "createdAt": "2020-01-24T06:14:48Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    public synchronized GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+        if (isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+            response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+            return response;\n+        }\n+\n+        // Save resource\n+        SDAResource sdaResource = SDAResource.builder()\n+                .resource(request.getResource())\n+                .publishedToDNSSD(request.isPublishToDNSSD())\n+                .owningService(serviceName).build();\n+        config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+        response.setError(ServiceDiscoveryResponseStatus.Success);\n+        response.setResponse(request.getResource());\n+        return response;\n+    }\n+\n+    private boolean isRegistered(String resourcePath) {\n+        return config.find(REGISTERED_RESOURCES, resourcePath) != null;\n+    }\n+\n+    public synchronized GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+            response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.getOwningService().equals(serviceName)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        // update resource (only some fields are updatable)\n+        resource.getResource().setTxtRecords(request.getResource().getTxtRecords());\n+        resource.getResource().setUri(request.getResource().getUri());\n+        resource.setPublishedToDNSSD(request.isPublishToDNSSD());\n+\n+        response.setError(ServiceDiscoveryResponseStatus.Success);\n+        return response;\n+    }\n+\n+    public synchronized GeneralResponse<Void, ServiceDiscoveryResponseStatus> removeResource(RemoveResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation\n+\n+        if (!isRegistered(resourcePath)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+            response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+            return response;\n+        }\n+\n+        SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+        if (!resource.getOwningService().equals(serviceName)) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to remove %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        // Remove from master list", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4NzkxMw==", "bodyText": "Extract the address to a constant?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370487913", "createdAt": "2020-01-24T06:21:52Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/common/Server.java", "diffHunk": "@@ -36,7 +36,7 @@ public void startup() throws IPCException {\n             serverSocket = new ServerSocket();\n             // specifying port 0 causes  the system to pick an ephemeral port and a valid local address to bind the socket\n             serverSocket.bind(new InetSocketAddress(0));\n-            String serverUri = \"tcp://\" + serverSocket.getInetAddress().getHostAddress() + \":\" + serverSocket.getLocalPort();\n+            String serverUri = \"tcp://127.0.0.1:\" + serverSocket.getLocalPort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ4ODQ2Nw==", "bodyText": "There should be an inline comment explaining why having a atomic reference", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370488467", "createdAt": "2020-01-24T06:25:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/handler/AuthHandler.java", "diffHunk": "@@ -1,37 +1,56 @@\n package com.aws.iot.evergreen.ipc.handler;\n \n-import com.aws.iot.evergreen.ipc.common.Constants;\n-import com.aws.iot.evergreen.ipc.common.Connection;\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.common.RequestContext;\n import com.aws.iot.evergreen.ipc.exceptions.IPCClientNotAuthorizedException;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+\n+import javax.inject.Inject;\n+import java.nio.charset.StandardCharsets;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import static com.aws.iot.evergreen.ipc.common.Constants.AUTH_SERVICE;\n import static com.aws.iot.evergreen.ipc.common.FrameReader.MessageFrame;\n \n-public class AuthHandler {\n+public class AuthHandler implements InjectionActions {\n+    public static final String AUTH_TOKEN_TOPIC_NAME = \"auth-tokens\";\n+\n+    @Inject\n+    private Configuration config;\n+    @Inject\n+    private Kernel kernel;\n+\n     /**\n      *\n      * @param request\n-     * @param connection\n      * @return\n      * @throws Exception\n      */\n-\n-    public String doAuth(MessageFrame request, Connection connection) throws IPCClientNotAuthorizedException {\n-\n+    public RequestContext doAuth(MessageFrame request) throws IPCClientNotAuthorizedException {\n         // First frame should be the auth request\n         if (!request.destination.equals(AUTH_SERVICE)) {\n             throw new IPCClientNotAuthorizedException(\"Invalid Auth request\");\n         }\n \n-        if(!connection.isLocal()){\n-            //TODO: Do Auth\n-        }\n-        //TODO: do this in a backward compatible way\n-        String clientId = new String(request.message.getPayload());\n-        if(clientId.isEmpty()){\n-            throw new IPCClientNotAuthorizedException(\"ClientId is empty\");\n+        String authToken = new String(request.message.getPayload(), StandardCharsets.UTF_8);\n+        String clientId = UUID.randomUUID().toString();\n+\n+        // Lookup the provided auth token to associate it with a service (or reject it)\n+        AtomicReference<String> serviceName = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQwODUzNA=="}, "originalCommit": {"oid": "078e20f1747edb93b267e7b8175036910719cddd"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTAxMTEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#pullrequestreview-348101112", "createdAt": "2020-01-24T17:14:54Z", "commit": {"oid": "524fc3ad38ad170d9ba5215e51f1fe48459a4225"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTEzODY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#pullrequestreview-348113864", "createdAt": "2020-01-24T17:38:03Z", "commit": {"oid": "7febfd634fa1666594b67ae2708c6cd195516168"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzozODowM1rOFhlKFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzozOTo0MFrOFhlM8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NjExNw==", "bodyText": "The try...finally can be replaced by a LockScope object we used in stream manager: https://code.amazon.com/packages/AWSGreengrassGreenlake/blobs/mainline/--/src/com/amazonaws/iot/greengrass/streammanager/utils/LockScope.java", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370756117", "createdAt": "2020-01-24T17:38:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to handle the business logic for Service Discovery including CRUD operations.\n+ */\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    /**\n+     * Register a resource with Service Discovery. Will throw if the resource is already registered.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        boolean pathIsReserved =\n+                kernel.orderedDependencies().parallelStream()\n+                        .map(service -> config.findResolvedTopic(service.getName(), SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY))\n+                        .filter(Objects::nonNull)\n+                        .anyMatch(t -> {\n+                            Object o = t.getOnce();\n+                            if (o instanceof Collection) {\n+                                String name = t.name;\n+                                Topics p = t.parent;\n+                                while (p.name != null) {\n+                                    name = p.name;\n+                                    p = p.parent;\n+                                }\n+                                return ((Collection) o).contains(resourcePath) && !serviceName.equals(name);\n+                            }\n+                            return false;\n+                        });\n+\n+        if (pathIsReserved) {\n+            response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+            response.setErrorMessage(String.format(\"Service %s is not allowed to register %s\", serviceName, resourcePath));\n+            return response;\n+        }\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.AlreadyRegistered);\n+                response.setErrorMessage(String.format(\"%s already exists\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource sdaResource = SDAResource.builder()\n+                    .resource(request.getResource())\n+                    .publishedToDNSSD(request.isPublishToDNSSD())\n+                    .owningService(serviceName).build();\n+            config.lookup(REGISTERED_RESOURCES, resourcePath).setValue(sdaResource);\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            response.setResponse(request.getResource());\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    /**\n+     * Update an already existing resource. The update will only update the URI, TXT Records, and whether\n+     * it is published to DNS-SD or not.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Void, ServiceDiscoveryResponseStatus> updateResource(UpdateResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Void, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+\n+        try {\n+            lock.writeLock().lock();\n+\n+            if (!isRegistered(resourcePath)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotFound);\n+                response.setErrorMessage(String.format(\"%s was not found\", resourcePath));\n+                return response;\n+            }\n+\n+            SDAResource resource = (SDAResource) config.find(REGISTERED_RESOURCES, resourcePath).getOnce();\n+            if (!resource.getOwningService().equals(serviceName)) {\n+                response.setError(ServiceDiscoveryResponseStatus.ResourceNotOwned);\n+                response.setErrorMessage(String.format(\"Service %s is not allowed to update %s\", serviceName, resourcePath));\n+                return response;\n+            }\n+\n+            // update resource (only some fields are updatable)\n+            resource.getResource().setTxtRecords(request.getResource().getTxtRecords());\n+            resource.getResource().setUri(request.getResource().getUri());\n+            resource.setPublishedToDNSSD(request.isPublishToDNSSD());\n+\n+            response.setError(ServiceDiscoveryResponseStatus.Success);\n+            return response;\n+        } finally {\n+            lock.writeLock().unlock();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7febfd634fa1666594b67ae2708c6cd195516168"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1Njg0OA==", "bodyText": "remove empty line", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#discussion_r370756848", "createdAt": "2020-01-24T17:39:40Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/servicediscovery/ServiceDiscoveryAgent.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package com.aws.iot.evergreen.builtin.services.servicediscovery;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.InjectionActions;\n+import com.aws.iot.evergreen.ipc.services.common.GeneralResponse;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.LookupResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RegisterResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.RemoveResourceRequest;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.Resource;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.ServiceDiscoveryResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.servicediscovery.UpdateResourceRequest;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.util.Log;\n+\n+import javax.inject.Inject;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to handle the business logic for Service Discovery including CRUD operations.\n+ */\n+public class ServiceDiscoveryAgent implements InjectionActions {\n+    public static final String REGISTERED_RESOURCES = \"registered-resources\";\n+    public static final String SERVICE_DISCOVERY_RESOURCE_CONFIG_KEY = \"resources\";\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @Inject\n+    private Configuration config;\n+\n+    @Inject\n+    private Log log;\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ServiceDiscoveryAgent() {\n+    }\n+\n+    /**\n+     * Register a resource with Service Discovery. Will throw if the resource is already registered.\n+     *\n+     * @param request\n+     * @param serviceName\n+     * @return\n+     */\n+    public GeneralResponse<Resource, ServiceDiscoveryResponseStatus> registerResource(RegisterResourceRequest request, String serviceName) {\n+        String resourcePath = resourceToPath(request.getResource());\n+        GeneralResponse<Resource, ServiceDiscoveryResponseStatus> response = new GeneralResponse<>();\n+\n+        // TODO input validation. https://sim.amazon.com/issues/P32540011\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7febfd634fa1666594b67ae2708c6cd195516168"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "800277a58091d443e6b9010306e1843d93f307c0", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/800277a58091d443e6b9010306e1843d93f307c0", "committedDate": "2020-01-24T17:50:15Z", "message": "Address PR comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7febfd634fa1666594b67ae2708c6cd195516168", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7febfd634fa1666594b67ae2708c6cd195516168", "committedDate": "2020-01-24T17:28:49Z", "message": "Address PR comments"}, "afterCommit": {"oid": "800277a58091d443e6b9010306e1843d93f307c0", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/800277a58091d443e6b9010306e1843d93f307c0", "committedDate": "2020-01-24T17:50:15Z", "message": "Address PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTI0MzMz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/40#pullrequestreview-348124333", "createdAt": "2020-01-24T17:57:22Z", "commit": {"oid": "800277a58091d443e6b9010306e1843d93f307c0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2446, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}