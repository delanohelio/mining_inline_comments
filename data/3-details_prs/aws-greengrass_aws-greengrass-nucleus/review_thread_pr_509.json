{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NjU0MTAw", "number": 509, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNDo1MzowMFrOErchjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0ODo0NVrOEwiwuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzOTkxNTY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNDo1MzowMFrOHeN6Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNDo1MzowMFrOHeN6Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0NzIwNg==", "bodyText": "Recommendation generated by Amazon CodeGuru Reviewer. Leave feedback on this recommendation by replying to the comment or by reacting to the comment using emoji.\nProblem\nYou are using a ConcurrentHashMap, but your usage of containsKey() and get() may not be thread-safe at lines: 130 and 135. In between the check and the get() another thread can remove the key and the get() will return null. The removes that can remove the key are at lines: 139 and 497.\nFix\nConsider calling get(), checking instead of your current check if the returned object is null, and then using that object only, without calling get() again.\nMore info\nView an example on GitHub (external link).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r501447206", "createdAt": "2020-10-08T04:53:00Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,499 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.amazonaws.services.evergreen.model.InternalServerException;\n+import com.aws.greengrass.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.greengrass.config.ChildChanged;\n+import com.aws.greengrass.config.Node;\n+import com.aws.greengrass.config.Subscriber;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.UnsupportedInputTypeException;\n+import com.aws.greengrass.config.Watcher;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractGetConfigurationOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSendConfigurationValidityReportOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass\n+        .GeneratedAbstractSubscribeToValidateConfigurationUpdatesOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.GeneratedAbstractUpdateConfigurationOperationHandler;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ConfigurationUpdateEvent;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ConfigurationUpdateEvents;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ConfigurationValidityReport;\n+import generated.software.amazon.awssdk.iot.greengrass.model.FailedUpdateConditionCheckError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.GetConfigurationRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.GetConfigurationResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.InvalidArgumentError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ResourceNotFoundError;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SendConfigurationValidityReportRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SendConfigurationValidityReportResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UpdateConfigurationRequest;\n+import generated.software.amazon.awssdk.iot.greengrass.model.UpdateConfigurationResponse;\n+import generated.software.amazon.awssdk.iot.greengrass.model.ValidateConfigurationUpdateEvent;\n+import software.amazon.eventstream.iot.EventStreamableJsonMessage;\n+import software.amazon.eventstream.iot.server.OperationContinuationHandlerContext;\n+import software.amazon.eventstream.iot.server.ServerStreamEventPublisher;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+public class ConfigStoreIPCEventStreamAgent {\n+    private static final Logger logger = LogManager.getLogger(ConfigStoreIPCEventStreamAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private final ConcurrentHashMap<String, Set<ServerStreamEventPublisher<ConfigurationUpdateEvents>>>\n+            configUpdateListeners = new ConcurrentHashMap<>();\n+    private final ConcurrentHashMap<String, Consumer<Map<String, Object>>>\n+            configValidationListeners = new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    private Kernel kernel;\n+\n+    public ConfigurationUpdateOperationHandler getConfigurationUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ConfigurationUpdateOperationHandler(context);\n+    }\n+\n+    public ValidateConfigurationUpdatesOperationHandler getValidateConfigurationUpdatesHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ValidateConfigurationUpdatesOperationHandler(context);\n+    }\n+\n+    public UpdateConfigurationOperationHandler getUpdateConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateConfigurationOperationHandler(context);\n+    }\n+\n+    public GetConfigurationOperationHandler getGetConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new GetConfigurationOperationHandler(context);\n+    }\n+\n+    public SendConfigurationValidityReportOperationHandler getSendConfigurationValidityReportHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SendConfigurationValidityReportOperationHandler(context);\n+    }\n+\n+    class SendConfigurationValidityReportOperationHandler extends\n+            GeneratedAbstractSendConfigurationValidityReportOperationHandler {\n+        private final String serviceName;\n+\n+        protected SendConfigurationValidityReportOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Handle user service's response to config validation request.\n+         *\n+         * @param request request to report validation status for config\n+         * @return response data\n+         */\n+        @Override\n+        public SendConfigurationValidityReportResponse handleRequest(SendConfigurationValidityReportRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+            logger.atDebug().log(\"Config IPC report config validation request\");\n+            // TODO : Edge case - With the current API model, there is no way to associate a validation report from\n+            //  client with the event sent from server, meaning if event 1 from server was abandoned due to timeout,\n+            //  then event 2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+            if (!configValidationReportFutures.containsKey(serviceName)) {\n+                throw new InvalidArgumentError(\"Validation request either timed out or was never made\");\n+            }\n+\n+            CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                    configValidationReportFutures.get(serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b5f7896e057220943f28f077d0a42db900d6fa2"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODAyNjc4OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxMDo0NVrOHlWpZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMToxMDo0NVrOHlWpZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzMDQwNg==", "bodyText": "this should be extracted to something common, like we had earlier.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r508930406", "createdAt": "2020-10-21T01:10:45Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -461,32 +485,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n-        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n-        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n-\n         AtomicInteger deferCount = new AtomicInteger(0);\n         AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n         CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n-        lifecycle.subscribeToComponentUpdate((event) -> {\n-\n-            if (event instanceof PreComponentUpdateEvent) {\n-                preComponentUpdateCount.getAndIncrement();\n-                //defer update the first time\n-                //no response the second time causes the kernel to move forward after default wait time\n-                if (deferCount.get() < 1) {\n-                    try {\n-                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n-                        deferCount.getAndIncrement();\n-                    } catch (LifecycleIPCException e) {\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"nondisruptable\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aca347879e61af3bba3ffab4ffc793e10fd1bd"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA4Mjk3OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0MjoxMFrOHlXJ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0MjoxMFrOHlXJ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzODcyMw==", "bodyText": "pass the exception to the fail otherwise we don't know why", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r508938723", "createdAt": "2020-10-21T01:42:10Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -199,33 +216,184 @@ void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_va\n         });\n         c.subscribeToValidateConfiguration(cb.getRight());\n \n-        CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+        CompletableFuture<com.aws.greengrass.ipc.services.configstore.ConfigurationValidityReport> responseTracker =\n+                new CompletableFuture<>();\n         ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n         agent.validateConfiguration(\"ServiceName\",\n                 Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n         cb.getLeft().get(TIMEOUT_FOR_CONFIG_STORE_SECONDS, TimeUnit.SECONDS);\n \n-        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n-        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n+        c.sendConfigurationValidityReport(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                null);\n+        assertEquals(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                responseTracker.get().getStatus());\n     }\n \n+\n     @Test\n-    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n+    void GIVEN_ConfigStoreEventStreamClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+\n+            SubscribeToValidateConfigurationUpdatesRequest subscribe = new SubscribeToValidateConfigurationUpdatesRequest();\n+            greengrassCoreIPCClient.subscribeToValidateConfigurationUpdates(subscribe, Optional.of(new StreamResponseHandler<EventStreamJsonMessage>() {\n+\n+                @Override\n+                public void onStreamEvent(EventStreamJsonMessage events) {\n+                    assertNotNull(events);\n+                    // TODO: Once the model is fixed.\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent());\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent().getConfiguration());\n+                    //assertThat(events.getValidateConfigurationUpdateEvent().getConfiguration(),\n+                    //        IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+                    cdl.countDown();\n+\n+                    SendConfigurationValidityReportRequest reportRequest =\n+                            new SendConfigurationValidityReportRequest();\n+                    ConfigurationValidityReport report = new ConfigurationValidityReport();\n+                    report.setStatus(ConfigurationValidityStatus.ACCEPTED);\n+                    reportRequest.setConfigurationValidityReport(report);\n+\n+                    try {\n+                        greengrassCoreIPCClient.sendConfigurationValidityReport(reportRequest, Optional.empty()).getResponse()\n+                                .get(10, TimeUnit.SECONDS);\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        fail(\"received invalid update validate configuration event\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aca347879e61af3bba3ffab4ffc793e10fd1bd"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA4MzA3OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0MjoxNFrOHlXJ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0MjoxNFrOHlXJ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzODczNQ==", "bodyText": "log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r508938735", "createdAt": "2020-10-21T01:42:14Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -199,33 +216,184 @@ void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_va\n         });\n         c.subscribeToValidateConfiguration(cb.getRight());\n \n-        CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+        CompletableFuture<com.aws.greengrass.ipc.services.configstore.ConfigurationValidityReport> responseTracker =\n+                new CompletableFuture<>();\n         ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n         agent.validateConfiguration(\"ServiceName\",\n                 Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n         cb.getLeft().get(TIMEOUT_FOR_CONFIG_STORE_SECONDS, TimeUnit.SECONDS);\n \n-        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n-        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n+        c.sendConfigurationValidityReport(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                null);\n+        assertEquals(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                responseTracker.get().getStatus());\n     }\n \n+\n     @Test\n-    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n+    void GIVEN_ConfigStoreEventStreamClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+\n+            SubscribeToValidateConfigurationUpdatesRequest subscribe = new SubscribeToValidateConfigurationUpdatesRequest();\n+            greengrassCoreIPCClient.subscribeToValidateConfigurationUpdates(subscribe, Optional.of(new StreamResponseHandler<EventStreamJsonMessage>() {\n+\n+                @Override\n+                public void onStreamEvent(EventStreamJsonMessage events) {\n+                    assertNotNull(events);\n+                    // TODO: Once the model is fixed.\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent());\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent().getConfiguration());\n+                    //assertThat(events.getValidateConfigurationUpdateEvent().getConfiguration(),\n+                    //        IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+                    cdl.countDown();\n+\n+                    SendConfigurationValidityReportRequest reportRequest =\n+                            new SendConfigurationValidityReportRequest();\n+                    ConfigurationValidityReport report = new ConfigurationValidityReport();\n+                    report.setStatus(ConfigurationValidityStatus.ACCEPTED);\n+                    reportRequest.setConfigurationValidityReport(report);\n+\n+                    try {\n+                        greengrassCoreIPCClient.sendConfigurationValidityReport(reportRequest, Optional.empty()).getResponse()\n+                                .get(10, TimeUnit.SECONDS);\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        fail(\"received invalid update validate configuration event\");\n+                    }\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aca347879e61af3bba3ffab4ffc793e10fd1bd"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA4MzkyOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0Mjo0MFrOHlXKWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0Mjo0MFrOHlXKWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzODg0Mw==", "bodyText": "you know how I feel about random sleeps. Is there any other way to do this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r508938843", "createdAt": "2020-10-21T01:42:40Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -199,33 +216,184 @@ void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_va\n         });\n         c.subscribeToValidateConfiguration(cb.getRight());\n \n-        CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+        CompletableFuture<com.aws.greengrass.ipc.services.configstore.ConfigurationValidityReport> responseTracker =\n+                new CompletableFuture<>();\n         ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n         agent.validateConfiguration(\"ServiceName\",\n                 Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n         cb.getLeft().get(TIMEOUT_FOR_CONFIG_STORE_SECONDS, TimeUnit.SECONDS);\n \n-        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n-        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n+        c.sendConfigurationValidityReport(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                null);\n+        assertEquals(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                responseTracker.get().getStatus());\n     }\n \n+\n     @Test\n-    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n+    void GIVEN_ConfigStoreEventStreamClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+\n+            SubscribeToValidateConfigurationUpdatesRequest subscribe = new SubscribeToValidateConfigurationUpdatesRequest();\n+            greengrassCoreIPCClient.subscribeToValidateConfigurationUpdates(subscribe, Optional.of(new StreamResponseHandler<EventStreamJsonMessage>() {\n+\n+                @Override\n+                public void onStreamEvent(EventStreamJsonMessage events) {\n+                    assertNotNull(events);\n+                    // TODO: Once the model is fixed.\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent());\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent().getConfiguration());\n+                    //assertThat(events.getValidateConfigurationUpdateEvent().getConfiguration(),\n+                    //        IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+                    cdl.countDown();\n+\n+                    SendConfigurationValidityReportRequest reportRequest =\n+                            new SendConfigurationValidityReportRequest();\n+                    ConfigurationValidityReport report = new ConfigurationValidityReport();\n+                    report.setStatus(ConfigurationValidityStatus.ACCEPTED);\n+                    reportRequest.setConfigurationValidityReport(report);\n+\n+                    try {\n+                        greengrassCoreIPCClient.sendConfigurationValidityReport(reportRequest, Optional.empty()).getResponse()\n+                                .get(10, TimeUnit.SECONDS);\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        fail(\"received invalid update validate configuration event\");\n+                    }\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;\n+                }\n+\n+                @Override\n+                public void onStreamClosed() {\n+\n+                }\n+            }));\n+\n+            CountDownLatch subscriptionLatch = new CountDownLatch(1);\n+            Slf4jLogAdapter.addGlobalListener(m -> {\n+                if (m.getMessage().contains(\"Config IPC subscribe to config validation request\")) {\n+                    subscriptionLatch.countDown();\n+                }\n+            });\n+            assertTrue(subscriptionLatch.await(20, TimeUnit.SECONDS));\n \n+            TimeUnit.SECONDS.sleep(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aca347879e61af3bba3ffab4ffc793e10fd1bd"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA4NDUzOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0MzowMVrOHlXKtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0MzowMVrOHlXKtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzODkzNQ==", "bodyText": "log", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r508938935", "createdAt": "2020-10-21T01:43:01Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/greengrass/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -199,33 +216,184 @@ void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_va\n         });\n         c.subscribeToValidateConfiguration(cb.getRight());\n \n-        CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+        CompletableFuture<com.aws.greengrass.ipc.services.configstore.ConfigurationValidityReport> responseTracker =\n+                new CompletableFuture<>();\n         ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n         agent.validateConfiguration(\"ServiceName\",\n                 Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n         cb.getLeft().get(TIMEOUT_FOR_CONFIG_STORE_SECONDS, TimeUnit.SECONDS);\n \n-        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n-        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n+        c.sendConfigurationValidityReport(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                null);\n+        assertEquals(com.aws.greengrass.ipc.services.configstore.ConfigurationValidityStatus.VALID,\n+                responseTracker.get().getStatus());\n     }\n \n+\n     @Test\n-    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n+    void GIVEN_ConfigStoreEventStreamClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+\n+            SubscribeToValidateConfigurationUpdatesRequest subscribe = new SubscribeToValidateConfigurationUpdatesRequest();\n+            greengrassCoreIPCClient.subscribeToValidateConfigurationUpdates(subscribe, Optional.of(new StreamResponseHandler<EventStreamJsonMessage>() {\n+\n+                @Override\n+                public void onStreamEvent(EventStreamJsonMessage events) {\n+                    assertNotNull(events);\n+                    // TODO: Once the model is fixed.\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent());\n+                    //assertNotNull(events.getValidateConfigurationUpdateEvent().getConfiguration());\n+                    //assertThat(events.getValidateConfigurationUpdateEvent().getConfiguration(),\n+                    //        IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+                    cdl.countDown();\n+\n+                    SendConfigurationValidityReportRequest reportRequest =\n+                            new SendConfigurationValidityReportRequest();\n+                    ConfigurationValidityReport report = new ConfigurationValidityReport();\n+                    report.setStatus(ConfigurationValidityStatus.ACCEPTED);\n+                    reportRequest.setConfigurationValidityReport(report);\n+\n+                    try {\n+                        greengrassCoreIPCClient.sendConfigurationValidityReport(reportRequest, Optional.empty()).getResponse()\n+                                .get(10, TimeUnit.SECONDS);\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        fail(\"received invalid update validate configuration event\");\n+                    }\n+                }\n+\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;\n+                }\n+\n+                @Override\n+                public void onStreamClosed() {\n+\n+                }\n+            }));\n+\n+            CountDownLatch subscriptionLatch = new CountDownLatch(1);\n+            Slf4jLogAdapter.addGlobalListener(m -> {\n+                if (m.getMessage().contains(\"Config IPC subscribe to config validation request\")) {\n+                    subscriptionLatch.countDown();\n+                }\n+            });\n+            assertTrue(subscriptionLatch.await(20, TimeUnit.SECONDS));\n \n+            TimeUnit.SECONDS.sleep(10);\n+            CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+            ConfigStoreIPCEventStreamAgent agent = kernel.getContext().get(ConfigStoreIPCEventStreamAgent.class);\n+            agent.validateConfiguration(\"ServiceName\",\n+                    Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n+            assertTrue(cdl.await(20, TimeUnit.SECONDS));\n+\n+            assertEquals(ConfigurationValidityStatus.ACCEPTED, responseTracker.get().getStatus());\n+        }\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreEventStreamClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n         Topics configuration = kernel.findServiceTopic(\"ServiceName\").createInteriorChild(PARAMETERS_CONFIG_KEY);\n         Topic configToUpdate = configuration.lookup(\"SomeKeyToUpdate\").withNewerValue(0, \"InitialValue\");\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        Topics servicePrivateConfig = kernel.getConfig().findTopics(SERVICES_NAMESPACE_TOPIC, \"ServiceName\",\n+                PRIVATE_STORE_NAMESPACE_TOPIC);\n+        String authToken = Coerce.toString(servicePrivateConfig.find(SERVICE_UNIQUE_ID_KEY));\n+        try (EventStreamRPCConnection clientConnection =\n+                     IPCTestUtils.connectToGGCOverEventStreamIPC(socketOptions, authToken, kernel)) {\n+            GreengrassCoreIPCClient greengrassCoreIPCClient = new GreengrassCoreIPCClient(clientConnection);\n+\n+            SubscribeToConfigurationUpdateRequest subscribe = new SubscribeToConfigurationUpdateRequest();\n+            subscribe.setComponentName(\"ServiceName\");\n+            subscribe.setKeyPath(Collections.singletonList(\"SomeKeyToUpdate\"));\n+            greengrassCoreIPCClient.subscribeToConfigurationUpdate(subscribe, Optional.of(new StreamResponseHandler<ConfigurationUpdateEvents>() {\n+                @Override\n+                public void onStreamEvent(ConfigurationUpdateEvents event) {\n+                    assertNotNull(event.getConfigurationUpdateEvent());\n+                    assertEquals(\"ServiceName\", event.getConfigurationUpdateEvent().getComponentName());\n+                    assertNotNull(event.getConfigurationUpdateEvent().getKeyPath());\n+                    cdl.countDown();\n+                }\n \n-        CountDownLatch configUpdated = new CountDownLatch(1);\n-        configToUpdate.subscribe((what, node) -> configUpdated.countDown());\n+                @Override\n+                public boolean onStreamError(Throwable error) {\n+                    return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aca347879e61af3bba3ffab4ffc793e10fd1bd"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA4OTY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0NTo1NVrOHlXNxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0NTo1NVrOHlXNxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzOTcxOQ==", "bodyText": "we need a threadsafe set here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r508939719", "createdAt": "2020-10-21T01:45:55Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,519 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.amazonaws.services.evergreen.model.InternalServerException;\n+import com.aws.greengrass.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.greengrass.config.ChildChanged;\n+import com.aws.greengrass.config.Node;\n+import com.aws.greengrass.config.Subscriber;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.UnsupportedInputTypeException;\n+import com.aws.greengrass.config.Watcher;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSendConfigurationValidityReportOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToValidateConfigurationUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+public class ConfigStoreIPCEventStreamAgent {\n+    private static final Logger logger = LogManager.getLogger(ConfigStoreIPCEventStreamAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ConfigurationUpdateEvents>>>\n+            configUpdateListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Consumer<Map<String, Object>>>\n+            configValidationListeners = new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public ConfigurationUpdateOperationHandler getConfigurationUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ConfigurationUpdateOperationHandler(context);\n+    }\n+\n+    public ValidateConfigurationUpdatesOperationHandler getValidateConfigurationUpdatesHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ValidateConfigurationUpdatesOperationHandler(context);\n+    }\n+\n+    public UpdateConfigurationOperationHandler getUpdateConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateConfigurationOperationHandler(context);\n+    }\n+\n+    public GetConfigurationOperationHandler getGetConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new GetConfigurationOperationHandler(context);\n+    }\n+\n+    public SendConfigurationValidityReportOperationHandler getSendConfigurationValidityReportHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SendConfigurationValidityReportOperationHandler(context);\n+    }\n+\n+    class SendConfigurationValidityReportOperationHandler extends\n+            GeneratedAbstractSendConfigurationValidityReportOperationHandler {\n+        private final String serviceName;\n+\n+        protected SendConfigurationValidityReportOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Handle user service's response to config validation request.\n+         *\n+         * @param request request to report validation status for config\n+         * @return response data\n+         */\n+        @Override\n+        public SendConfigurationValidityReportResponse handleRequest(SendConfigurationValidityReportRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC report config validation request\");\n+            // TODO : Edge case - With the current API model, there is no way to associate a validation report from\n+            //  client with the event sent from server, meaning if event 1 from server was abandoned due to timeout,\n+            //  then event 2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+            CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                    configValidationReportFutures.get(serviceName);\n+            if (reportFuture == null) {\n+                throw new InvalidArgumentError(\"Validation request either timed out or was never made\");\n+            }\n+\n+            if (!reportFuture.isCancelled()) {\n+                reportFuture.complete(request.getConfigurationValidityReport());\n+            }\n+            configValidationReportFutures.remove(serviceName);\n+\n+            return new SendConfigurationValidityReportResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class GetConfigurationOperationHandler extends GeneratedAbstractGetConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected GetConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Read specified key from the service's dynamic config.\n+         *\n+         * @param request   request\n+         * @return response data\n+         */\n+        @Override\n+        public GetConfigurationResponse handleRequest(GetConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC get config request\");\n+            String finalServiceName = request.getComponentName() == null ? this.serviceName\n+                    : request.getComponentName();\n+            Topics serviceTopics = kernel.findServiceTopic(finalServiceName);\n+\n+            if (serviceTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Topics configTopics = serviceTopics.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (configTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Node node;\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                // Request is for reading all configuration\n+                node = configTopics;\n+            } else {\n+                String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+                node = configTopics.findNode(keyPath);\n+                if (node == null) {\n+                    throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+                }\n+            }\n+\n+            GetConfigurationResponse response = new GetConfigurationResponse();\n+            response.setComponentName(finalServiceName);\n+            if (node instanceof Topic) {\n+                Map<String, Object> map = new HashMap<>();\n+                map.put(node.getName(), ((Topic) node).getOnce());\n+                response.setValue(map);\n+            } else if (node instanceof Topics) {\n+                response.setValue(((Topics) node).toPOJO());\n+            } else {\n+                logger.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+                throw new InternalServerException(\"Node has an unknown type\");\n+            }\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class UpdateConfigurationOperationHandler extends GeneratedAbstractUpdateConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected UpdateConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Update specified key in the service's configuration.\n+         *\n+         * @param request update config request\n+         * @return response data\n+         */\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public UpdateConfigurationResponse handleRequest(UpdateConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC config update request\");\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                throw new InvalidArgumentError(\"Key is required\");\n+            }\n+\n+            if (request.getComponentName() != null && !serviceName.equals(request.getComponentName())) {\n+                throw new InvalidArgumentError(\"Cross component updates are not allowed\");\n+            }\n+\n+            Topics serviceTopics = kernel.findServiceTopic(serviceName);\n+            if (serviceTopics == null) {\n+                throw new InvalidArgumentError(\"Service config not found\");\n+            }\n+            Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+            String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+            Node node = configTopics.findNode(keyPath);\n+            if (node == null) {\n+                try {\n+                    configTopics.lookup(keyPath).withValueChecked(request.getNewValue().get(keyPath[0]));\n+                } catch (UnsupportedInputTypeException e) {\n+                    throw new InvalidArgumentError(e.getMessage());\n+                }\n+                return new UpdateConfigurationResponse();\n+            }\n+            // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+            //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+            //  nested config support at the component recipe and deployment level is hashed out.\n+            if (node instanceof Topics) {\n+                throw new InvalidArgumentError(\"Cannot update a \" + \"non-leaf config node\");\n+            }\n+            if (!(node instanceof Topic)) {\n+                logger.atError().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Somehow Node has an unknown type {}\", node.getClass());\n+                throw new InvalidArgumentError(\"Node has an unknown type\");\n+            }\n+            Topic topic = (Topic) node;\n+\n+            // Perform compare and swap if the customer has specified current value to compare\n+            if (request.getOldValue() != null && request.getOldValue().get(topic.getName()) != null\n+                    && !request.getOldValue().get(topic.getName()).equals(topic.getOnce())) {\n+                throw new FailedUpdateConditionCheckError(\n+                        \"Current value for config is different from the current value needed for the update\");\n+            }\n+\n+            try {\n+                Topic updatedNode = topic.withValueChecked(request.getTimestamp().toEpochMilli(),\n+                        request.getNewValue().get(topic.getName()));\n+                if (request.getTimestamp().toEpochMilli() != updatedNode.getModtime() && !request.getNewValue()\n+                        .equals(updatedNode.getOnce())) {\n+                    throw new FailedUpdateConditionCheckError(\n+                            \"Proposed timestamp is older than the config's latest modified timestamp\");\n+                }\n+            } catch (UnsupportedInputTypeException e) {\n+                throw new InvalidArgumentError(e.getMessage());\n+            }\n+\n+            return new UpdateConfigurationResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    public class ConfigurationUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler {\n+        private final String serviceName;\n+        private Node subscribedToNode;\n+        private Watcher subscribedToWatcher;\n+\n+        public ConfigurationUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            logger.atInfo().kv(SERVICE_NAME, serviceName)\n+                    .log(\"Stream closed for subscribeToConfigurationUpdate for {}\", serviceName);\n+            if (subscribedToNode != null) {\n+                subscribedToNode.remove(subscribedToWatcher);\n+            }\n+            configUpdateListeners.get(serviceName).remove(this);\n+            if (configUpdateListeners.get(serviceName).isEmpty()) {\n+                configUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        public SubscribeToConfigurationUpdateResponse handleRequest(SubscribeToConfigurationUpdateRequest request) {\n+            String componentName = request.getComponentName() == null ? this.serviceName : request.getComponentName();\n+\n+            Topics serviceTopics = kernel.findServiceTopic(componentName);\n+            if (serviceTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+            if (configurationTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+            if (subscribeTo == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Optional<Watcher> watcher = registerWatcher(subscribeTo, componentName);\n+            if (!watcher.isPresent()) {\n+                throw new InternalServerException(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            logger.atInfo().kv(SERVICE_NAME, serviceName)\n+                    .log(\"{} subscribed to configuration update\", serviceName);\n+            subscribedToNode = subscribeTo;\n+            subscribedToWatcher = watcher.get();\n+            configUpdateListeners.putIfAbsent(serviceName, new HashSet<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aca347879e61af3bba3ffab4ffc793e10fd1bd"}, "originalPosition": 365}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODA5NTM3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0OToxN1rOHlXRLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwMTo0OToxN1rOHlXRLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk0MDU5MQ==", "bodyText": "close the context in an after", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r508940591", "createdAt": "2020-10-21T01:49:17Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,566 @@\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityStatus;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.crt.eventstream.MessageType;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class ConfigStoreIPCEventStreamAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+    private static final String TEST_CONFIG_KEY_3 = \"air pressure\";\n+    private static final int TEST_CONFIG_KEY_1_INITIAL_VALUE = 20;\n+    private static final int TEST_CONFIG_KEY_2_INITIAL_VALUE = 15;\n+    private static final int TEST_CONFIG_KEY_3_INITIAL_VALUE = 100;\n+\n+    @Mock\n+    private Kernel kernel;\n+    @Mock\n+    OperationContinuationHandlerContext mockContext;\n+    @Mock\n+    AuthenticationData mockAuthenticationData;\n+    @Mock\n+    OperationContinuationHandlerContext mockContext2;\n+    @Mock\n+    AuthenticationData mockAuthenticationData2;\n+    @Mock\n+    ServerConnectionContinuation mockServerConnectionContinuation;\n+    @Captor\n+    ArgumentCaptor<byte[]> byteArrayCaptor;\n+\n+    private ConfigStoreIPCEventStreamAgent agent;\n+    private Configuration configuration;\n+\n+    @BeforeEach\n+    public void setup() {\n+        configuration = new Configuration(new Context());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74aca347879e61af3bba3ffab4ffc793e10fd1bd"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIwMjI2OnYy", "diffSide": "RIGHT", "path": "codestyle/checkstyle.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjoyNzo0N1rOHl1HWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjoyNzo0N1rOHl1HWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyOTU5NQ==", "bodyText": "don't change this", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509429595", "createdAt": "2020-10-21T16:27:47Z", "author": {"login": "MikeDombo"}, "path": "codestyle/checkstyle.xml", "diffHunk": "@@ -69,7 +69,7 @@\n         <module name=\"AvoidStarImport\"/>\n         <module name=\"OneTopLevelClass\"/>\n         <module name=\"NoLineWrap\">\n-            <property name=\"tokens\" value=\"PACKAGE_DEF, IMPORT, STATIC_IMPORT\"/>\n+            <property name=\"tokens\" value=\"PACKAGE_DEF, STATIC_IMPORT\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIyNTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/DynamicComponentConfigurationValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMzozMFrOHl1WTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozMzozMFrOHl1WTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzMzQyMQ==", "bodyText": "Would the ServiceError not happen at line 172? Why would is throw the ServiceError here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509433421", "createdAt": "2020-10-21T16:33:30Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -190,17 +191,18 @@ private boolean validateOverIpc(Set<ComponentToValidate> componentsToValidate,\n                         // so we will no longer be blocked on any of the response futures\n                         ConfigurationValidityReport report = componentToValidate.response.join();\n \n-                        if (ConfigurationValidityStatus.INVALID.equals(report.getStatus())) {\n+                        if (ConfigurationValidityStatus.REJECTED.equals(report.getStatus())) {\n                             failureMsg = String.format(\"%s { name = %s, message = %s }\", failureMsg,\n                                     componentToValidate.componentName, report.getMessage());\n                             logger.atError().kv(\"component\", componentToValidate.componentName)\n                                     .kv(\"message\", report.getMessage())\n                                     .log(\"Component reported that its to-be-deployed configuration is invalid\");\n                             valid = false;\n                         }\n+                        componentToValidate.response.join();\n                     }\n                 } catch (InterruptedException | ExecutionException | TimeoutException | CancellationException\n-                        | CompletionException e) {\n+                        | CompletionException | ServiceError e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIyOTkxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozNDozMVrOHl1Yzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozNDozMVrOHl1Yzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNDA2Mg==", "bodyText": "Add license header", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509434062", "createdAt": "2020-10-21T16:34:31Z", "author": {"login": "philcali"}, "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package com.aws.greengrass.builtin.services.configstore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTIzMzkwOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/deployment/DynamicComponentConfigurationValidatorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozNToyNlrOHl1bOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozNToyNlrOHl1bOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNDY4Mg==", "bodyText": "Add license header", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509434682", "createdAt": "2020-10-21T16:35:26Z", "author": {"login": "philcali"}, "path": "src/test/java/com/aws/greengrass/deployment/DynamicComponentConfigurationValidatorTest.java", "diffHunk": "@@ -1,6 +1,6 @@\n package com.aws.greengrass.deployment;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI0MzY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/ipc/modules/ConfigStoreIPCService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozNzo1MVrOHl1hJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0NzoxN1rOHmLnaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjE5OA==", "bodyText": "Is it possible to simplify these?\ngreengrassCoreIPCService.setUpdateConfigurationHandler(eventStreamAgent::getUpdateConfigurationHandler);", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509436198", "createdAt": "2020-10-21T16:37:51Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -129,5 +139,17 @@ public void startup() {\n                     .addKeyValue(\"destination\", destination.name())\n                     .log(\"Failed to register service callback to destination\");\n         }\n+\n+        greengrassCoreIPCService.setUpdateConfigurationHandler(\n+                (context) -> eventStreamAgent.getUpdateConfigurationHandler(context));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3NDY0NA==", "bodyText": "I dont think so. I get a java.lang.IllegalAccessError when i do that.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509574644", "createdAt": "2020-10-21T18:49:09Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -129,5 +139,17 @@ public void startup() {\n                     .addKeyValue(\"destination\", destination.name())\n                     .log(\"Failed to register service callback to destination\");\n         }\n+\n+        greengrassCoreIPCService.setUpdateConfigurationHandler(\n+                (context) -> eventStreamAgent.getUpdateConfigurationHandler(context));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjE5OA=="}, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU3ODY0OQ==", "bodyText": "Phil is right, and your IDE should even be suggesting this simplification.\nAny message in the IllegalAccessError", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509578649", "createdAt": "2020-10-21T18:52:04Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/greengrass/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -129,5 +139,17 @@ public void startup() {\n                     .addKeyValue(\"destination\", destination.name())\n                     .log(\"Failed to register service callback to destination\");\n         }\n+\n+        greengrassCoreIPCService.setUpdateConfigurationHandler(\n+                (context) -> eventStreamAgent.getUpdateConfigurationHandler(context));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjE5OA=="}, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzIxNg==", "bodyText": "Why is this resolved? Did you try mvn compile with the suggestion?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509797216", "createdAt": "2020-10-21T23:43:57Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -129,5 +139,17 @@ public void startup() {\n                     .addKeyValue(\"destination\", destination.name())\n                     .log(\"Failed to register service callback to destination\");\n         }\n+\n+        greengrassCoreIPCService.setUpdateConfigurationHandler(\n+                (context) -> eventStreamAgent.getUpdateConfigurationHandler(context));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjE5OA=="}, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5ODI0OQ==", "bodyText": "I did try the suggestion. It compiles. But there is a runtime exception.\njava.lang.BootstrapMethodError: java.lang.IllegalAccessError: tried to access class com.aws.greengrass.builtin.services.configstore.ConfigStoreIPCEventStreamAgent$UpdateConfigurationOperationHandler from class com.aws.greengrass.ipc.modules.ConfigStoreIPCService", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509798249", "createdAt": "2020-10-21T23:47:17Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -129,5 +139,17 @@ public void startup() {\n                     .addKeyValue(\"destination\", destination.name())\n                     .log(\"Failed to register service callback to destination\");\n         }\n+\n+        greengrassCoreIPCService.setUpdateConfigurationHandler(\n+                (context) -> eventStreamAgent.getUpdateConfigurationHandler(context));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjE5OA=="}, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MTI0Nzc5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozODo1MlrOHl1jzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjo1NTozNFrOHl2QCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjg3Ng==", "bodyText": "Curious: is space a valid character in a config key?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509436876", "createdAt": "2020-10-21T16:38:52Z", "author": {"login": "philcali"}, "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityStatus;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.crt.eventstream.MessageType;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class ConfigStoreIPCEventStreamAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+    private static final String TEST_CONFIG_KEY_3 = \"air pressure\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0NjkxMg==", "bodyText": "Will remove the space.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509446912", "createdAt": "2020-10-21T16:53:50Z", "author": {"login": "nikkhilmuthye"}, "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityStatus;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.crt.eventstream.MessageType;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class ConfigStoreIPCEventStreamAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+    private static final String TEST_CONFIG_KEY_3 = \"air pressure\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjg3Ng=="}, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0ODIwMw==", "bodyText": "Space is legit, keep it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509448203", "createdAt": "2020-10-21T16:55:34Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgentTest.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.aws.greengrass.config.Configuration;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.dependency.Context;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.testcommons.testutilities.GGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityStatus;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.crt.eventstream.MessageType;\n+import software.amazon.awssdk.crt.eventstream.ServerConnectionContinuation;\n+import software.amazon.awssdk.eventstreamrpc.AuthenticationData;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static com.aws.greengrass.lifecyclemanager.GreengrassService.SERVICES_NAMESPACE_TOPIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyList;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith({MockitoExtension.class, GGExtension.class})\n+class ConfigStoreIPCEventStreamAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+    private static final String TEST_CONFIG_KEY_3 = \"air pressure\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjg3Ng=="}, "originalCommit": {"oid": "6ddee908bcfabe331cb1c33589d2ece23d2ab118"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM1MTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0MTowMlrOHmLgIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0MTowMlrOHmLgIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NjM4Ng==", "bodyText": "Can we drop the internal link here? Just reference the P32540011 ID?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509796386", "createdAt": "2020-10-21T23:41:02Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.amazonaws.services.evergreen.model.InternalServerException;\n+import com.aws.greengrass.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.greengrass.config.ChildChanged;\n+import com.aws.greengrass.config.Node;\n+import com.aws.greengrass.config.Subscriber;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.UnsupportedInputTypeException;\n+import com.aws.greengrass.config.Watcher;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSendConfigurationValidityReportOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToValidateConfigurationUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+public class ConfigStoreIPCEventStreamAgent {\n+    private static final Logger logger = LogManager.getLogger(ConfigStoreIPCEventStreamAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ConfigurationUpdateEvents>>>\n+            configUpdateListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Consumer<Map<String, Object>>>\n+            configValidationListeners = new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public ConfigurationUpdateOperationHandler getConfigurationUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ConfigurationUpdateOperationHandler(context);\n+    }\n+\n+    public ValidateConfigurationUpdatesOperationHandler getValidateConfigurationUpdatesHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ValidateConfigurationUpdatesOperationHandler(context);\n+    }\n+\n+    public UpdateConfigurationOperationHandler getUpdateConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateConfigurationOperationHandler(context);\n+    }\n+\n+    public GetConfigurationOperationHandler getGetConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new GetConfigurationOperationHandler(context);\n+    }\n+\n+    public SendConfigurationValidityReportOperationHandler getSendConfigurationValidityReportHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SendConfigurationValidityReportOperationHandler(context);\n+    }\n+\n+    class SendConfigurationValidityReportOperationHandler extends\n+            GeneratedAbstractSendConfigurationValidityReportOperationHandler {\n+        private final String serviceName;\n+\n+        protected SendConfigurationValidityReportOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Handle user service's response to config validation request.\n+         *\n+         * @param request request to report validation status for config\n+         * @return response data\n+         */\n+        @Override\n+        public SendConfigurationValidityReportResponse handleRequest(SendConfigurationValidityReportRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC report config validation request\");\n+            // TODO : Edge case - With the current API model, there is no way to associate a validation report from\n+            //  client with the event sent from server, meaning if event 1 from server was abandoned due to timeout,\n+            //  then event 2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+            CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                    configValidationReportFutures.get(serviceName);\n+            if (reportFuture == null) {\n+                throw new InvalidArgumentError(\"Validation request either timed out or was never made\");\n+            }\n+\n+            if (!reportFuture.isCancelled()) {\n+                reportFuture.complete(request.getConfigurationValidityReport());\n+            }\n+            configValidationReportFutures.remove(serviceName);\n+\n+            return new SendConfigurationValidityReportResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class GetConfigurationOperationHandler extends GeneratedAbstractGetConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected GetConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Read specified key from the service's dynamic config.\n+         *\n+         * @param request   request\n+         * @return response data\n+         */\n+        @Override\n+        public GetConfigurationResponse handleRequest(GetConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC get config request\");\n+            String finalServiceName = request.getComponentName() == null ? this.serviceName\n+                    : request.getComponentName();\n+            Topics serviceTopics = kernel.findServiceTopic(finalServiceName);\n+\n+            if (serviceTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Topics configTopics = serviceTopics.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (configTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Node node;\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                // Request is for reading all configuration\n+                node = configTopics;\n+            } else {\n+                String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+                node = configTopics.findNode(keyPath);\n+                if (node == null) {\n+                    throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+                }\n+            }\n+\n+            GetConfigurationResponse response = new GetConfigurationResponse();\n+            response.setComponentName(finalServiceName);\n+            if (node instanceof Topic) {\n+                Map<String, Object> map = new HashMap<>();\n+                map.put(node.getName(), ((Topic) node).getOnce());\n+                response.setValue(map);\n+            } else if (node instanceof Topics) {\n+                response.setValue(((Topics) node).toPOJO());\n+            } else {\n+                logger.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+                throw new InternalServerException(\"Node has an unknown type\");\n+            }\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class UpdateConfigurationOperationHandler extends GeneratedAbstractUpdateConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected UpdateConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Update specified key in the service's configuration.\n+         *\n+         * @param request update config request\n+         * @return response data\n+         */\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public UpdateConfigurationResponse handleRequest(UpdateConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC config update request\");\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                throw new InvalidArgumentError(\"Key is required\");\n+            }\n+\n+            if (request.getComponentName() != null && !serviceName.equals(request.getComponentName())) {\n+                throw new InvalidArgumentError(\"Cross component updates are not allowed\");\n+            }\n+\n+            Topics serviceTopics = kernel.findServiceTopic(serviceName);\n+            if (serviceTopics == null) {\n+                throw new InvalidArgumentError(\"Service config not found\");\n+            }\n+            Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+            String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+            Node node = configTopics.findNode(keyPath);\n+            if (node == null) {\n+                try {\n+                    configTopics.lookup(keyPath).withValueChecked(request.getNewValue().get(keyPath[0]));\n+                } catch (UnsupportedInputTypeException e) {\n+                    throw new InvalidArgumentError(e.getMessage());\n+                }\n+                return new UpdateConfigurationResponse();\n+            }\n+            // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+            //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+            //  nested config support at the component recipe and deployment level is hashed out.\n+            if (node instanceof Topics) {\n+                throw new InvalidArgumentError(\"Cannot update a \" + \"non-leaf config node\");\n+            }\n+            if (!(node instanceof Topic)) {\n+                logger.atError().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Somehow Node has an unknown type {}\", node.getClass());\n+                throw new InvalidArgumentError(\"Node has an unknown type\");\n+            }\n+            Topic topic = (Topic) node;\n+\n+            // Perform compare and swap if the customer has specified current value to compare\n+            if (request.getOldValue() != null && request.getOldValue().get(topic.getName()) != null\n+                    && !request.getOldValue().get(topic.getName()).equals(topic.getOnce())) {\n+                throw new FailedUpdateConditionCheckError(\n+                        \"Current value for config is different from the current value needed for the update\");\n+            }\n+\n+            try {\n+                Topic updatedNode = topic.withValueChecked(request.getTimestamp().toEpochMilli(),\n+                        request.getNewValue().get(topic.getName()));\n+                if (request.getTimestamp().toEpochMilli() != updatedNode.getModtime() && !request.getNewValue()\n+                        .equals(updatedNode.getOnce())) {\n+                    throw new FailedUpdateConditionCheckError(\n+                            \"Proposed timestamp is older than the config's latest modified timestamp\");\n+                }\n+            } catch (UnsupportedInputTypeException e) {\n+                throw new InvalidArgumentError(e.getMessage());\n+            }\n+\n+            return new UpdateConfigurationResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    public class ConfigurationUpdateOperationHandler extends\n+            GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler {\n+        private final String serviceName;\n+        private Node subscribedToNode;\n+        private Watcher subscribedToWatcher;\n+\n+        public ConfigurationUpdateOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            logger.atInfo().kv(SERVICE_NAME, serviceName)\n+                    .log(\"Stream closed for subscribeToConfigurationUpdate for {}\", serviceName);\n+            if (subscribedToNode != null) {\n+                subscribedToNode.remove(subscribedToWatcher);\n+            }\n+            configUpdateListeners.get(serviceName).remove(this);\n+            if (configUpdateListeners.get(serviceName).isEmpty()) {\n+                configUpdateListeners.remove(serviceName);\n+            }\n+        }\n+\n+        @Override\n+        public SubscribeToConfigurationUpdateResponse handleRequest(SubscribeToConfigurationUpdateRequest request) {\n+            String componentName = request.getComponentName() == null ? this.serviceName : request.getComponentName();\n+\n+            Topics serviceTopics = kernel.findServiceTopic(componentName);\n+            if (serviceTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+            if (configurationTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+            if (subscribeTo == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Optional<Watcher> watcher = registerWatcher(subscribeTo, componentName);\n+            if (!watcher.isPresent()) {\n+                throw new InternalServerException(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            logger.atInfo().kv(SERVICE_NAME, serviceName)\n+                    .log(\"{} subscribed to configuration update\", serviceName);\n+            subscribedToNode = subscribeTo;\n+            subscribedToWatcher = watcher.get();\n+            configUpdateListeners.putIfAbsent(serviceName, ConcurrentHashMap.newKeySet());\n+            configUpdateListeners.get(serviceName).add(this);\n+\n+            return new SubscribeToConfigurationUpdateResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+            // NA\n+\n+        }\n+\n+        private Optional<Watcher> registerWatcher(Node subscribeTo, String componentName) {\n+            if (subscribeTo instanceof Topics) {\n+                ChildChanged childChanged =\n+                        (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, componentName);\n+\n+                ((Topics) subscribeTo).subscribe(childChanged);\n+                return Optional.of(childChanged);\n+\n+            } else if (subscribeTo instanceof Topic) {\n+                Subscriber subscriber =\n+                        (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, componentName);\n+\n+                ((Topic) subscribeTo).subscribe(subscriber);\n+                return Optional.of(subscriber);\n+            }\n+            return Optional.empty();\n+        }\n+\n+        private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, String componentName) {\n+            // Blocks from sending an event on subscription\n+            if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+                return;\n+            }\n+            // The path sent in config update event should be the path for the changed node within the component\n+            // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+            // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+            // then the path in update event should be key_1.nested_key_1\n+            int configurationTopicsIndex =\n+                    kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+            String[] keyPath = Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                    changedNode.path().length);\n+\n+            sendConfigUpdateToListener(componentName).accept(keyPath);\n+        }\n+\n+        private Consumer<String[]> sendConfigUpdateToListener(String componentName) {\n+            return changedKeyPath -> {\n+                ConfigurationUpdateEvents configurationUpdateEvents = new ConfigurationUpdateEvents();\n+                ConfigurationUpdateEvent valueChangedEvent = new ConfigurationUpdateEvent();\n+                valueChangedEvent.setComponentName(componentName);\n+                valueChangedEvent.setKeyPath(Arrays.asList(changedKeyPath));\n+                configurationUpdateEvents.setConfigurationUpdateEvent(valueChangedEvent);\n+                logger.atInfo().kv(SERVICE_NAME, serviceName)\n+                        .log(\"Sending component {}'s updated config key {}\", componentName, changedKeyPath);\n+\n+                this.sendStreamEvent(configurationUpdateEvents);\n+            };\n+        }\n+\n+        private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n+            Node subscribeTo = configurationTopics;\n+            if (keyPath != null && !keyPath.isEmpty()) {\n+                subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n+            }\n+            return subscribeTo;\n+        }\n+    }\n+\n+    class ValidateConfigurationUpdatesOperationHandler extends\n+            GeneratedAbstractSubscribeToValidateConfigurationUpdatesOperationHandler {\n+\n+        private final String serviceName;\n+\n+        protected ValidateConfigurationUpdatesOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+            configValidationListeners.remove(serviceName);\n+        }\n+\n+        @Override\n+        public SubscribeToValidateConfigurationUpdatesResponse handleRequest(\n+                SubscribeToValidateConfigurationUpdatesRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fd63162aa3748371811824b002775fa095e4d2"}, "originalPosition": 452}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM1NDI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/deployment/DynamicComponentConfigurationValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0Mjo0MVrOHmLh_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDoxMjoxNlrOHmMF5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Njg2MQ==", "bodyText": "What timeout? Connection timeout?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509796861", "createdAt": "2020-10-21T23:42:41Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -47,14 +52,14 @@\n public class DynamicComponentConfigurationValidator {\n     public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n     // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n-    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(20).toMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fd63162aa3748371811824b002775fa095e4d2"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNjA1Mw==", "bodyText": "Timeout to validate configuration from a component during deployment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509806053", "createdAt": "2020-10-22T00:12:16Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/deployment/DynamicComponentConfigurationValidator.java", "diffHunk": "@@ -47,14 +52,14 @@\n public class DynamicComponentConfigurationValidator {\n     public static final String DEPLOYMENT_ID_LOG_KEY = \"deploymentId\";\n     // TODO : Add configurable timeout and change this to a more appropriate(probably longer) default value\n-    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(10).toMillis();\n+    private static final long DEFAULT_TIMEOUT = Duration.ofSeconds(20).toMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Njg2MQ=="}, "originalCommit": {"oid": "f6fd63162aa3748371811824b002775fa095e4d2"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM2Mzk5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0NzoyOFrOHmLnnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDoyMjo1M1rOHmMRdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5ODMwMQ==", "bodyText": "Is this comment is valid?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509798301", "createdAt": "2020-10-21T23:47:28Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.amazonaws.services.evergreen.model.InternalServerException;\n+import com.aws.greengrass.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.greengrass.config.ChildChanged;\n+import com.aws.greengrass.config.Node;\n+import com.aws.greengrass.config.Subscriber;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.UnsupportedInputTypeException;\n+import com.aws.greengrass.config.Watcher;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSendConfigurationValidityReportOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToValidateConfigurationUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+public class ConfigStoreIPCEventStreamAgent {\n+    private static final Logger logger = LogManager.getLogger(ConfigStoreIPCEventStreamAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ConfigurationUpdateEvents>>>\n+            configUpdateListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Consumer<Map<String, Object>>>\n+            configValidationListeners = new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public ConfigurationUpdateOperationHandler getConfigurationUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ConfigurationUpdateOperationHandler(context);\n+    }\n+\n+    public ValidateConfigurationUpdatesOperationHandler getValidateConfigurationUpdatesHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ValidateConfigurationUpdatesOperationHandler(context);\n+    }\n+\n+    public UpdateConfigurationOperationHandler getUpdateConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateConfigurationOperationHandler(context);\n+    }\n+\n+    public GetConfigurationOperationHandler getGetConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new GetConfigurationOperationHandler(context);\n+    }\n+\n+    public SendConfigurationValidityReportOperationHandler getSendConfigurationValidityReportHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SendConfigurationValidityReportOperationHandler(context);\n+    }\n+\n+    class SendConfigurationValidityReportOperationHandler extends\n+            GeneratedAbstractSendConfigurationValidityReportOperationHandler {\n+        private final String serviceName;\n+\n+        protected SendConfigurationValidityReportOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Handle user service's response to config validation request.\n+         *\n+         * @param request request to report validation status for config\n+         * @return response data\n+         */\n+        @Override\n+        public SendConfigurationValidityReportResponse handleRequest(SendConfigurationValidityReportRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC report config validation request\");\n+            // TODO : Edge case - With the current API model, there is no way to associate a validation report from\n+            //  client with the event sent from server, meaning if event 1 from server was abandoned due to timeout,\n+            //  then event 2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+            CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                    configValidationReportFutures.get(serviceName);\n+            if (reportFuture == null) {\n+                throw new InvalidArgumentError(\"Validation request either timed out or was never made\");\n+            }\n+\n+            if (!reportFuture.isCancelled()) {\n+                reportFuture.complete(request.getConfigurationValidityReport());\n+            }\n+            configValidationReportFutures.remove(serviceName);\n+\n+            return new SendConfigurationValidityReportResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class GetConfigurationOperationHandler extends GeneratedAbstractGetConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected GetConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Read specified key from the service's dynamic config.\n+         *\n+         * @param request   request\n+         * @return response data\n+         */\n+        @Override\n+        public GetConfigurationResponse handleRequest(GetConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC get config request\");\n+            String finalServiceName = request.getComponentName() == null ? this.serviceName\n+                    : request.getComponentName();\n+            Topics serviceTopics = kernel.findServiceTopic(finalServiceName);\n+\n+            if (serviceTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Topics configTopics = serviceTopics.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (configTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Node node;\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                // Request is for reading all configuration\n+                node = configTopics;\n+            } else {\n+                String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+                node = configTopics.findNode(keyPath);\n+                if (node == null) {\n+                    throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+                }\n+            }\n+\n+            GetConfigurationResponse response = new GetConfigurationResponse();\n+            response.setComponentName(finalServiceName);\n+            if (node instanceof Topic) {\n+                Map<String, Object> map = new HashMap<>();\n+                map.put(node.getName(), ((Topic) node).getOnce());\n+                response.setValue(map);\n+            } else if (node instanceof Topics) {\n+                response.setValue(((Topics) node).toPOJO());\n+            } else {\n+                logger.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+                throw new InternalServerException(\"Node has an unknown type\");\n+            }\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class UpdateConfigurationOperationHandler extends GeneratedAbstractUpdateConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected UpdateConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Update specified key in the service's configuration.\n+         *\n+         * @param request update config request\n+         * @return response data\n+         */\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public UpdateConfigurationResponse handleRequest(UpdateConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC config update request\");\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                throw new InvalidArgumentError(\"Key is required\");\n+            }\n+\n+            if (request.getComponentName() != null && !serviceName.equals(request.getComponentName())) {\n+                throw new InvalidArgumentError(\"Cross component updates are not allowed\");\n+            }\n+\n+            Topics serviceTopics = kernel.findServiceTopic(serviceName);\n+            if (serviceTopics == null) {\n+                throw new InvalidArgumentError(\"Service config not found\");\n+            }\n+            Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+            String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+            Node node = configTopics.findNode(keyPath);\n+            if (node == null) {\n+                try {\n+                    configTopics.lookup(keyPath).withValueChecked(request.getNewValue().get(keyPath[0]));\n+                } catch (UnsupportedInputTypeException e) {\n+                    throw new InvalidArgumentError(e.getMessage());\n+                }\n+                return new UpdateConfigurationResponse();\n+            }\n+            // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+            //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+            //  nested config support at the component recipe and deployment level is hashed out.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fd63162aa3748371811824b002775fa095e4d2"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwOTAxMw==", "bodyText": "Current impl does not support it. Might address it in a later PR.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509809013", "createdAt": "2020-10-22T00:22:53Z", "author": {"login": "nikkhilmuthye"}, "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.amazonaws.services.evergreen.model.InternalServerException;\n+import com.aws.greengrass.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.greengrass.config.ChildChanged;\n+import com.aws.greengrass.config.Node;\n+import com.aws.greengrass.config.Subscriber;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.UnsupportedInputTypeException;\n+import com.aws.greengrass.config.Watcher;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSendConfigurationValidityReportOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToValidateConfigurationUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+public class ConfigStoreIPCEventStreamAgent {\n+    private static final Logger logger = LogManager.getLogger(ConfigStoreIPCEventStreamAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ConfigurationUpdateEvents>>>\n+            configUpdateListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Consumer<Map<String, Object>>>\n+            configValidationListeners = new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public ConfigurationUpdateOperationHandler getConfigurationUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ConfigurationUpdateOperationHandler(context);\n+    }\n+\n+    public ValidateConfigurationUpdatesOperationHandler getValidateConfigurationUpdatesHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ValidateConfigurationUpdatesOperationHandler(context);\n+    }\n+\n+    public UpdateConfigurationOperationHandler getUpdateConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateConfigurationOperationHandler(context);\n+    }\n+\n+    public GetConfigurationOperationHandler getGetConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new GetConfigurationOperationHandler(context);\n+    }\n+\n+    public SendConfigurationValidityReportOperationHandler getSendConfigurationValidityReportHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SendConfigurationValidityReportOperationHandler(context);\n+    }\n+\n+    class SendConfigurationValidityReportOperationHandler extends\n+            GeneratedAbstractSendConfigurationValidityReportOperationHandler {\n+        private final String serviceName;\n+\n+        protected SendConfigurationValidityReportOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Handle user service's response to config validation request.\n+         *\n+         * @param request request to report validation status for config\n+         * @return response data\n+         */\n+        @Override\n+        public SendConfigurationValidityReportResponse handleRequest(SendConfigurationValidityReportRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC report config validation request\");\n+            // TODO : Edge case - With the current API model, there is no way to associate a validation report from\n+            //  client with the event sent from server, meaning if event 1 from server was abandoned due to timeout,\n+            //  then event 2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+            CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                    configValidationReportFutures.get(serviceName);\n+            if (reportFuture == null) {\n+                throw new InvalidArgumentError(\"Validation request either timed out or was never made\");\n+            }\n+\n+            if (!reportFuture.isCancelled()) {\n+                reportFuture.complete(request.getConfigurationValidityReport());\n+            }\n+            configValidationReportFutures.remove(serviceName);\n+\n+            return new SendConfigurationValidityReportResponse();\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class GetConfigurationOperationHandler extends GeneratedAbstractGetConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected GetConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Read specified key from the service's dynamic config.\n+         *\n+         * @param request   request\n+         * @return response data\n+         */\n+        @Override\n+        public GetConfigurationResponse handleRequest(GetConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC get config request\");\n+            String finalServiceName = request.getComponentName() == null ? this.serviceName\n+                    : request.getComponentName();\n+            Topics serviceTopics = kernel.findServiceTopic(finalServiceName);\n+\n+            if (serviceTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Topics configTopics = serviceTopics.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+            if (configTopics == null) {\n+                throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+            }\n+\n+            Node node;\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                // Request is for reading all configuration\n+                node = configTopics;\n+            } else {\n+                String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+                node = configTopics.findNode(keyPath);\n+                if (node == null) {\n+                    throw new ResourceNotFoundError(KEY_NOT_FOUND_ERROR_MESSAGE);\n+                }\n+            }\n+\n+            GetConfigurationResponse response = new GetConfigurationResponse();\n+            response.setComponentName(finalServiceName);\n+            if (node instanceof Topic) {\n+                Map<String, Object> map = new HashMap<>();\n+                map.put(node.getName(), ((Topic) node).getOnce());\n+                response.setValue(map);\n+            } else if (node instanceof Topics) {\n+                response.setValue(((Topics) node).toPOJO());\n+            } else {\n+                logger.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+                throw new InternalServerException(\"Node has an unknown type\");\n+            }\n+            return response;\n+        }\n+\n+        @Override\n+        public void handleStreamEvent(EventStreamJsonMessage streamRequestEvent) {\n+\n+        }\n+    }\n+\n+    class UpdateConfigurationOperationHandler extends GeneratedAbstractUpdateConfigurationOperationHandler {\n+        private final String serviceName;\n+\n+        protected UpdateConfigurationOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Update specified key in the service's configuration.\n+         *\n+         * @param request update config request\n+         * @return response data\n+         */\n+        @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+        @Override\n+        public UpdateConfigurationResponse handleRequest(UpdateConfigurationRequest request) {\n+            logger.atDebug().kv(SERVICE_NAME, serviceName).log(\"Config IPC config update request\");\n+            if (Utils.isEmpty(request.getKeyPath())) {\n+                throw new InvalidArgumentError(\"Key is required\");\n+            }\n+\n+            if (request.getComponentName() != null && !serviceName.equals(request.getComponentName())) {\n+                throw new InvalidArgumentError(\"Cross component updates are not allowed\");\n+            }\n+\n+            Topics serviceTopics = kernel.findServiceTopic(serviceName);\n+            if (serviceTopics == null) {\n+                throw new InvalidArgumentError(\"Service config not found\");\n+            }\n+            Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+            String[] keyPath = request.getKeyPath().toArray(new String[0]);\n+            Node node = configTopics.findNode(keyPath);\n+            if (node == null) {\n+                try {\n+                    configTopics.lookup(keyPath).withValueChecked(request.getNewValue().get(keyPath[0]));\n+                } catch (UnsupportedInputTypeException e) {\n+                    throw new InvalidArgumentError(e.getMessage());\n+                }\n+                return new UpdateConfigurationResponse();\n+            }\n+            // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+            //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+            //  nested config support at the component recipe and deployment level is hashed out.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5ODMwMQ=="}, "originalCommit": {"oid": "f6fd63162aa3748371811824b002775fa095e4d2"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM2NjM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0ODo0NVrOHmLpFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0ODo0NVrOHmLpFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5ODY3Ng==", "bodyText": "Can we drop the internal link? use P32540011 as a reference ID instead?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/509#discussion_r509798676", "createdAt": "2020-10-21T23:48:45Z", "author": {"login": "philcali"}, "path": "src/main/java/com/aws/greengrass/builtin/services/configstore/ConfigStoreIPCEventStreamAgent.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.builtin.services.configstore;\n+\n+import com.amazonaws.services.evergreen.model.InternalServerException;\n+import com.aws.greengrass.builtin.services.configstore.exceptions.ValidateEventRegistrationException;\n+import com.aws.greengrass.config.ChildChanged;\n+import com.aws.greengrass.config.Node;\n+import com.aws.greengrass.config.Subscriber;\n+import com.aws.greengrass.config.Topic;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.config.UnsupportedInputTypeException;\n+import com.aws.greengrass.config.Watcher;\n+import com.aws.greengrass.config.WhatHappened;\n+import com.aws.greengrass.lifecyclemanager.Kernel;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.aws.greengrass.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.Setter;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractGetConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSendConfigurationValidityReportOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToConfigurationUpdateOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractSubscribeToValidateConfigurationUpdatesOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.GeneratedAbstractUpdateConfigurationOperationHandler;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationUpdateEvents;\n+import software.amazon.awssdk.aws.greengrass.model.ConfigurationValidityReport;\n+import software.amazon.awssdk.aws.greengrass.model.FailedUpdateConditionCheckError;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.GetConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.InvalidArgumentError;\n+import software.amazon.awssdk.aws.greengrass.model.ResourceNotFoundError;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SendConfigurationValidityReportResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToConfigurationUpdateResponse;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesRequest;\n+import software.amazon.awssdk.aws.greengrass.model.SubscribeToValidateConfigurationUpdatesResponse;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationRequest;\n+import software.amazon.awssdk.aws.greengrass.model.UpdateConfigurationResponse;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvent;\n+import software.amazon.awssdk.aws.greengrass.model.ValidateConfigurationUpdateEvents;\n+import software.amazon.awssdk.eventstreamrpc.OperationContinuationHandlerContext;\n+import software.amazon.awssdk.eventstreamrpc.StreamEventPublisher;\n+import software.amazon.awssdk.eventstreamrpc.model.EventStreamJsonMessage;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.componentmanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+\n+public class ConfigStoreIPCEventStreamAgent {\n+    private static final Logger logger = LogManager.getLogger(ConfigStoreIPCEventStreamAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String SERVICE_NAME = \"service-name\";\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Set<StreamEventPublisher<ConfigurationUpdateEvents>>>\n+            configUpdateListeners = new ConcurrentHashMap<>();\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ConcurrentHashMap<String, Consumer<Map<String, Object>>>\n+            configValidationListeners = new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    @Getter(AccessLevel.PACKAGE)\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n+\n+    @Inject\n+    @Setter(AccessLevel.PACKAGE)\n+    private Kernel kernel;\n+\n+    public ConfigurationUpdateOperationHandler getConfigurationUpdateHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ConfigurationUpdateOperationHandler(context);\n+    }\n+\n+    public ValidateConfigurationUpdatesOperationHandler getValidateConfigurationUpdatesHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new ValidateConfigurationUpdatesOperationHandler(context);\n+    }\n+\n+    public UpdateConfigurationOperationHandler getUpdateConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new UpdateConfigurationOperationHandler(context);\n+    }\n+\n+    public GetConfigurationOperationHandler getGetConfigurationHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new GetConfigurationOperationHandler(context);\n+    }\n+\n+    public SendConfigurationValidityReportOperationHandler getSendConfigurationValidityReportHandler(\n+            OperationContinuationHandlerContext context) {\n+        return new SendConfigurationValidityReportOperationHandler(context);\n+    }\n+\n+    class SendConfigurationValidityReportOperationHandler extends\n+            GeneratedAbstractSendConfigurationValidityReportOperationHandler {\n+        private final String serviceName;\n+\n+        protected SendConfigurationValidityReportOperationHandler(OperationContinuationHandlerContext context) {\n+            super(context);\n+            this.serviceName = context.getAuthenticationData().getIdentityLabel();\n+        }\n+\n+        @Override\n+        protected void onStreamClosed() {\n+\n+        }\n+\n+        /**\n+         * Handle user service's response to config validation request.\n+         *\n+         * @param request request to report validation status for config\n+         * @return response data\n+         */\n+        @Override\n+        public SendConfigurationValidityReportResponse handleRequest(SendConfigurationValidityReportRequest request) {\n+            // TODO: Input validation. https://sim.amazon.com/issues/P32540011", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6fd63162aa3748371811824b002775fa095e4d2"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 626, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}