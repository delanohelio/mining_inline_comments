{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxMTA0Mzcx", "number": 168, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo0MzoxM1rODwNDkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOToyOFrODwmI9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxODcyMTQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo0MzoxM1rOGDEu7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMTowODoyN1rOGDGNMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NjQ2MA==", "bodyText": "do we always continue in INSTALLED?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405876460", "createdAt": "2020-04-08T23:43:13Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.annotation.Nonnull;\n+\n+@SuppressFBWarnings(value = \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\",\n+        justification = \"We're synchronizing on the desired state list which is fine\")\n+public class Lifecycle {\n+    public static final String SERVICE_INVALID_STATE_ERROR = \"service-invalid-state-error\";\n+    private final EvergreenService evergreenService;\n+    private final Topic stateTopic;\n+    private final Logger logger;\n+    private Future backingTask = CompletableFuture.completedFuture(null);\n+    private String backingTaskName;\n+    private State prevState;\n+    @Getter\n+    private Future<?> lifecycleFuture;\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+    private final Object stateEventLock = new Object();\n+    // DesiredStateList is used to set desired path of state transition.\n+    // Eg. Start a service will need DesiredStateList to be <RUNNING>\n+    // ReInstall a service will set DesiredStateList to <FINISHED->NEW->RUNNING>\n+    private final List<State> desiredStateList = new CopyOnWriteArrayList<>();\n+    private static final Set<State> ALLOWED_STATES_FOR_REPORTING =\n+            new HashSet<>(Arrays.asList(State.RUNNING, State.ERRORED, State.FINISHED));\n+    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+    /**\n+     * Constructor for lifecycle.\n+     *\n+     * @param evergreenService service that this is the lifecycle for\n+     * @param state            service's state topic\n+     */\n+    public Lifecycle(EvergreenService evergreenService, Topic state) {\n+        this.evergreenService = evergreenService;\n+        this.prevState = State.NEW;\n+        this.stateTopic = state;\n+        this.logger = evergreenService.getLogger();\n+    }\n+\n+    private void updateStateAndBroadcast(State newState) {\n+        final State currentState = evergreenService.getState();\n+\n+        if (newState.equals(currentState)) {\n+            return;\n+        }\n+\n+        // TODO: Add validation\n+        logger.atInfo().setEventType(\"service-set-state\").kv(EvergreenService.CURRENT_STATE_METRIC_NAME, currentState)\n+                .kv(\"newState\", newState).log();\n+\n+        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+        // across different services.\n+        synchronized (State.class) {\n+            prevState = currentState;\n+            stateTopic.withValue(newState);\n+            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+        }\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are RUNNING, FINISHED, ERRORED.\n+     *\n+     * @param newState reported state from the service which should eventually be set as the service's\n+     *                 actual state\n+     */\n+    synchronized void reportState(State newState) {\n+        logger.atInfo().setEventType(\"service-report-state\").kv(\"newState\", newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atError().setEventType(SERVICE_INVALID_STATE_ERROR).kv(\"newState\", newState)\n+                    .log(\"Invalid report state\");\n+        }\n+        // TODO: Add more validations\n+\n+        if (evergreenService.getState().equals(State.INSTALLED) && newState.equals(State.FINISHED)) {\n+            // if a service doesn't have any run logic, request stop on service to clean up DesiredStateList\n+            requestStop();\n+        }\n+\n+        enqueueStateEvent(newState);\n+    }\n+\n+    private Optional<State> getReportState() {\n+        Object top = stateEventQueue.poll();\n+        if (top instanceof State) {\n+            return Optional.of((State) top);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Returns true if the service has reached its desired state.\n+     *\n+     * @return\n+     */\n+    public boolean reachedDesiredState() {\n+        synchronized (desiredStateList) {\n+            return desiredStateList.isEmpty()\n+                    // when reachedDesiredState() is called in global state listener,\n+                    // service lifecycle thread hasn't drained the desiredStateList yet.\n+                    // Therefore adding this check.\n+                    || desiredStateList.stream().allMatch(s -> s == evergreenService.getState());\n+        }\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return Optional.empty();\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first.equals(activeState)) {\n+                desiredStateList.remove(first);\n+                // ignore remove() return value as it's possible that desiredStateList update\n+            }\n+            return Optional.ofNullable(first);\n+        }\n+    }\n+\n+    void setDesiredState(State... state) {\n+        // Set desiredStateList and override existing desiredStateList.\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private void enqueueStateEvent(Object event) {\n+        synchronized (stateEventLock) {\n+            if (event instanceof State) {\n+                // override existing reportState\n+                stateEventQueue.clear();\n+                stateEventQueue.offer(event);\n+            } else {\n+                stateEventQueue.offer(event);\n+\n+                // Ignore returned value of offer().\n+                // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+                // trigger to process state transition.\n+            }\n+        }\n+    }\n+\n+    void startStateTransition() throws InterruptedException {\n+        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+            Optional<State> desiredState;\n+            State current = evergreenService.getState();\n+            logger.atInfo().setEventType(\"service-state-transition-start\")\n+                    .kv(EvergreenService.CURRENT_STATE_METRIC_NAME, current).log();\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState.isPresent() && desiredState.get().equals(current)) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+            switch (current) {\n+                case BROKEN:\n+                    return;\n+                case NEW:\n+                    if (handleCurrentStateNew(desiredState)) {\n+                        break;\n+                    }\n+                    continue;\n+                case INSTALLED:\n+                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n+                        break;\n+                    }\n+                    continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1816d832067d7e49c44920b75ed0dcae11d14d1c"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwMDU5NA==", "bodyText": "No, fixed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405900594", "createdAt": "2020-04-09T01:08:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.annotation.Nonnull;\n+\n+@SuppressFBWarnings(value = \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\",\n+        justification = \"We're synchronizing on the desired state list which is fine\")\n+public class Lifecycle {\n+    public static final String SERVICE_INVALID_STATE_ERROR = \"service-invalid-state-error\";\n+    private final EvergreenService evergreenService;\n+    private final Topic stateTopic;\n+    private final Logger logger;\n+    private Future backingTask = CompletableFuture.completedFuture(null);\n+    private String backingTaskName;\n+    private State prevState;\n+    @Getter\n+    private Future<?> lifecycleFuture;\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+    private final Object stateEventLock = new Object();\n+    // DesiredStateList is used to set desired path of state transition.\n+    // Eg. Start a service will need DesiredStateList to be <RUNNING>\n+    // ReInstall a service will set DesiredStateList to <FINISHED->NEW->RUNNING>\n+    private final List<State> desiredStateList = new CopyOnWriteArrayList<>();\n+    private static final Set<State> ALLOWED_STATES_FOR_REPORTING =\n+            new HashSet<>(Arrays.asList(State.RUNNING, State.ERRORED, State.FINISHED));\n+    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+    /**\n+     * Constructor for lifecycle.\n+     *\n+     * @param evergreenService service that this is the lifecycle for\n+     * @param state            service's state topic\n+     */\n+    public Lifecycle(EvergreenService evergreenService, Topic state) {\n+        this.evergreenService = evergreenService;\n+        this.prevState = State.NEW;\n+        this.stateTopic = state;\n+        this.logger = evergreenService.getLogger();\n+    }\n+\n+    private void updateStateAndBroadcast(State newState) {\n+        final State currentState = evergreenService.getState();\n+\n+        if (newState.equals(currentState)) {\n+            return;\n+        }\n+\n+        // TODO: Add validation\n+        logger.atInfo().setEventType(\"service-set-state\").kv(EvergreenService.CURRENT_STATE_METRIC_NAME, currentState)\n+                .kv(\"newState\", newState).log();\n+\n+        // Sync on State.class to make sure the order of setValue and globalNotifyStateChanged are consistent\n+        // across different services.\n+        synchronized (State.class) {\n+            prevState = currentState;\n+            stateTopic.withValue(newState);\n+            evergreenService.getContext().globalNotifyStateChanged(evergreenService, prevState, newState);\n+        }\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are RUNNING, FINISHED, ERRORED.\n+     *\n+     * @param newState reported state from the service which should eventually be set as the service's\n+     *                 actual state\n+     */\n+    synchronized void reportState(State newState) {\n+        logger.atInfo().setEventType(\"service-report-state\").kv(\"newState\", newState).log();\n+        if (!ALLOWED_STATES_FOR_REPORTING.contains(newState)) {\n+            logger.atError().setEventType(SERVICE_INVALID_STATE_ERROR).kv(\"newState\", newState)\n+                    .log(\"Invalid report state\");\n+        }\n+        // TODO: Add more validations\n+\n+        if (evergreenService.getState().equals(State.INSTALLED) && newState.equals(State.FINISHED)) {\n+            // if a service doesn't have any run logic, request stop on service to clean up DesiredStateList\n+            requestStop();\n+        }\n+\n+        enqueueStateEvent(newState);\n+    }\n+\n+    private Optional<State> getReportState() {\n+        Object top = stateEventQueue.poll();\n+        if (top instanceof State) {\n+            return Optional.of((State) top);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Returns true if the service has reached its desired state.\n+     *\n+     * @return\n+     */\n+    public boolean reachedDesiredState() {\n+        synchronized (desiredStateList) {\n+            return desiredStateList.isEmpty()\n+                    // when reachedDesiredState() is called in global state listener,\n+                    // service lifecycle thread hasn't drained the desiredStateList yet.\n+                    // Therefore adding this check.\n+                    || desiredStateList.stream().allMatch(s -> s == evergreenService.getState());\n+        }\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return Optional.empty();\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first.equals(activeState)) {\n+                desiredStateList.remove(first);\n+                // ignore remove() return value as it's possible that desiredStateList update\n+            }\n+            return Optional.ofNullable(first);\n+        }\n+    }\n+\n+    void setDesiredState(State... state) {\n+        // Set desiredStateList and override existing desiredStateList.\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n+    }\n+\n+    @SuppressFBWarnings(\"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private void enqueueStateEvent(Object event) {\n+        synchronized (stateEventLock) {\n+            if (event instanceof State) {\n+                // override existing reportState\n+                stateEventQueue.clear();\n+                stateEventQueue.offer(event);\n+            } else {\n+                stateEventQueue.offer(event);\n+\n+                // Ignore returned value of offer().\n+                // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+                // trigger to process state transition.\n+            }\n+        }\n+    }\n+\n+    void startStateTransition() throws InterruptedException {\n+        while (!(isClosed.get() && evergreenService.getState().isClosable())) {\n+            Optional<State> desiredState;\n+            State current = evergreenService.getState();\n+            logger.atInfo().setEventType(\"service-state-transition-start\")\n+                    .kv(EvergreenService.CURRENT_STATE_METRIC_NAME, current).log();\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState.isPresent() && desiredState.get().equals(current)) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+            AtomicReference<Future> triggerTimeOutReference = new AtomicReference<>();\n+            switch (current) {\n+                case BROKEN:\n+                    return;\n+                case NEW:\n+                    if (handleCurrentStateNew(desiredState)) {\n+                        break;\n+                    }\n+                    continue;\n+                case INSTALLED:\n+                    if (handleCurrentStateInstalled(desiredState, triggerTimeOutReference)) {\n+                        break;\n+                    }\n+                    continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NjQ2MA=="}, "originalCommit": {"oid": "1816d832067d7e49c44920b75ed0dcae11d14d1c"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxODcyNTg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo0NToxM1rOGDExWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo0NToxM1rOGDExWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzA4MQ==", "bodyText": "NIT: i believe you reverted Feng's change", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405877081", "createdAt": "2020-04-08T23:45:13Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -793,11 +373,8 @@ private boolean dependersExited(List<EvergreenService> dependers) {\n \n     private boolean dependencyReady() {\n         List<EvergreenService> ret =\n-                dependencies.entrySet()\n-                        .stream()\n-                        .filter(e -> !dependencyReady(e.getKey(), e.getValue().startWhen))\n-                        .map(Map.Entry::getKey)\n-                        .collect(Collectors.toList());\n+                dependencies.entrySet().stream().filter(e -> !dependencyReady(e.getKey(), e.getValue().startWhen))\n+                        .map(Map.Entry::getKey).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1816d832067d7e49c44920b75ed0dcae11d14d1c"}, "originalPosition": 623}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxODcyODIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo0NjozNVrOGDEyvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMzo0NjozNVrOGDEyvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzQzOA==", "bodyText": "I feel LifecycletTopic can be a field in lifecycle class", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405877438", "createdAt": "2020-04-08T23:46:35Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -970,21 +531,12 @@ public boolean satisfiedBy(Set<EvergreenService> ready) {\n         return ready.containsAll(dependencies.keySet());\n     }\n \n-    public enum RunStatus {\n-        OK, NothingDone, Errored\n-    }\n-\n-    public interface GlobalStateChangeListener {\n-        void globalServiceStateChanged(EvergreenService l, State oldState, State newState);\n+    protected Topics getLifecycleTopic() {\n+        return config.findInteriorChild(SERVICE_LIFECYCLE_NAMESPACE_TOPIC);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1816d832067d7e49c44920b75ed0dcae11d14d1c"}, "originalPosition": 684}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxODk5NDI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMjoxNDowMFrOGDHPHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMjoxNDowMFrOGDHPHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxNzQ3MA==", "bodyText": "This seems unused in this class now, could just move it to Lifecycle class and make it a private constant there", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405917470", "createdAt": "2020-04-09T02:14:00Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -57,43 +46,25 @@\n     public static final String TIMEOUT_NAMESPACE_TOPIC = \"timeout\";\n     public static final Integer DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC = 120;\n     public static final Integer DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC = 120;\n-    private static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n-    private static final String INVALID_STATE_ERROR_EVENT = \"service-invalid-state-error\";\n+    static final String CURRENT_STATE_METRIC_NAME = \"currentState\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f4a6393042932e7c999e3bfb78bdd5eaa85a77e"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTAwNDI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMjoxOTo1NlrOGDHU9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwMjoxOTo1NlrOGDHU9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxODk2Ng==", "bodyText": "Nit- I would pass in the logger to the constructor of Lifecycle or make it default, that way it is accessible only where you intend it to be, a public getter method exposes it to everyone, and doing that for the logger instance is a bit odd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r405918966", "createdAt": "2020-04-09T02:19:56Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -57,43 +46,25 @@\n     public static final String TIMEOUT_NAMESPACE_TOPIC = \"timeout\";\n     public static final Integer DEFAULT_INSTALL_STAGE_TIMEOUT_IN_SEC = 120;\n     public static final Integer DEFAULT_STARTUP_STAGE_TIMEOUT_IN_SEC = 120;\n-    private static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n-    private static final String INVALID_STATE_ERROR_EVENT = \"service-invalid-state-error\";\n+    static final String CURRENT_STATE_METRIC_NAME = \"currentState\";\n \n     protected final Topics config;\n     public Context context;\n \n-    private final Object dependencyReadyLock = new Object();\n-    private final Object dependersExitedLock = new Object();\n     private final Topic state;\n+    private final Lifecycle lifecycle;\n+    private final Object dependersExitedLock = new Object();\n     private Throwable error;\n-    private Future backingTask = CompletableFuture.completedFuture(null);\n-    private String backingTaskName;\n     private Periodicity periodicityInformation;\n-    private State prevState = State.NEW;\n-    private Future<?> lifecycleFuture;\n-    private final AtomicBoolean isClosed = new AtomicBoolean(false);\n-\n-    // A state event can be a state transition event, or a desired state updated notification.\n-    // TODO: make class of StateEvent instead of generic object.\n-    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n-    private final Object stateEventLock = new Object();\n-\n-    // DesiredStateList is used to set desired path of state transition.\n-    // Eg. Start a service will need DesiredStateList to be <RUNNING>\n-    // ReInstall a service will set DesiredStateList to <FINISHED->NEW->RUNNING>\n-    private final List<State> desiredStateList = new CopyOnWriteArrayList<>();\n-\n-    private static final Set<State> ALLOWED_STATES_FOR_REPORTING =\n-            new HashSet<>(Arrays.asList(State.RUNNING, State.ERRORED, State.FINISHED));\n+    private final Object dependencyReadyLock = new Object();\n \n     // dependencies that are explicitly declared by customer in config store.\n     private final Topic externalDependenciesTopic;\n     // Services that this service depends on.\n     // Includes both explicit declared dependencies and implicit ones added through 'autoStart' and @Inject annotation.\n     protected final ConcurrentHashMap<EvergreenService, DependencyInfo> dependencies = new ConcurrentHashMap<>();\n-\n     // Service logger instance\n+    @Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f4a6393042932e7c999e3bfb78bdd5eaa85a77e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjgyMjIxOnYy", "diffSide": "LEFT", "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowNDowNVrOGDsOjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowNToxOFrOGDsPtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMzUzMg==", "bodyText": "Seems this reverted Feng's change?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406523532", "createdAt": "2020-04-09T23:04:05Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -115,16 +115,8 @@ public void fire(WhatHappened what) {\n                 .addKeyValue(\"reason\", what.name()).log();\n         if (watchers != null) {\n             for (Watcher s : watchers) {\n-                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62ff57b548c3db99882bded24494c348260c19a7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMzgyOQ==", "bodyText": "His was a bad merge, so mine fixes his.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406523829", "createdAt": "2020-04-09T23:05:18Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -115,16 +115,8 @@ public void fire(WhatHappened what) {\n                 .addKeyValue(\"reason\", what.name()).log();\n         if (watchers != null) {\n             for (Watcher s : watchers) {\n-                try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyMzUzMg=="}, "originalCommit": {"oid": "62ff57b548c3db99882bded24494c348260c19a7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjgzMTI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOToyOVrOGDsULg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoyNDo1MVrOGDsmPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNDk3NA==", "bodyText": "Curious, does this have to be on method level?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406524974", "createdAt": "2020-04-09T23:09:29Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.annotation.Nonnull;\n+\n+@SuppressFBWarnings(value = \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\",\n+        justification = \"We're synchronizing on the desired state list which is fine\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62ff57b548c3db99882bded24494c348260c19a7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyOTU5Ng==", "bodyText": "It applied to all methods that synchronized on the desired state list, so I just added this at the class level instead of all those individual places.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/168#discussion_r406529596", "createdAt": "2020-04-09T23:24:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Lifecycle.java", "diffHunk": "@@ -0,0 +1,633 @@\n+/*\n+ * Copyright Amazon.com Inc. or its affiliates.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.kernel;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import lombok.Getter;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.annotation.Nonnull;\n+\n+@SuppressFBWarnings(value = \"JLM_JSR166_UTILCONCURRENT_MONITORENTER\",\n+        justification = \"We're synchronizing on the desired state list which is fine\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNDk3NA=="}, "originalCommit": {"oid": "62ff57b548c3db99882bded24494c348260c19a7"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 28, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}