{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1ODE3MTQw", "number": 362, "title": "Kernel detects and resumes persisted deployment on launch", "bodyText": "Issue #, if available:\nDescription of changes:\n\nPersist deployment object for context in order to resume after kernel restart\nComplete KernelUpdateDeploymentTask to finish deployment and report result\nPersist a list for bootstrap tasks in BootstrapManager\nIntegrate KernelUpdateActivator with execution of bootstrap tasks\nIntegrate Kernel.launch with execution of bootstrap tasks\n\nWhy is this change necessary:\nTo complete the workflow for kernel update deployment.\nHow was this change tested:\nAdded unit tests for new code.\nAny additional information or context required to review the change:\nDeployment readme and vWhOAWhGwA6q/Kernel-Update-Design\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-08-11T01:55:53Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362", "merged": true, "mergeCommit": {"oid": "a94b1818575e06a89454cb62e7e81d39b0b0c928"}, "closed": true, "closedAt": "2020-08-13T22:54:34Z", "author": {"login": "hui-yang"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc96blQgFqTQ2NTI2MTM2OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-n2s7AFqTQ2NzE3NjAyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjYxMzY4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#pullrequestreview-465261368", "createdAt": "2020-08-11T17:03:58Z", "commit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzowMzo1OFrOG_BHRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzozMzo1NVrOG_CLXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczMTcxNw==", "bodyText": "Add the service update exception details in the result as well?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468731717", "createdAt": "2020-08-11T17:03:58Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -25,32 +29,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());\n \n             DeploymentResult result = null;\n             if (KERNEL_ACTIVATION.equals(stage)) {\n                 result = new DeploymentResult(DeploymentResult.DeploymentStatus.SUCCESSFUL, null);\n+                kernelAlts.activationSucceeds();\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, null);\n+                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE,\n+                        new ServiceUpdateException(deployment.getStageDetails()));\n+                kernelAlts.rollbackCompletes();\n             }\n             return result;\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException | IOException e) {\n             logger.atError(\"deployment-interrupted\", e).kv(\"deployment\", deployment).log();\n-            // TODO: interrupted workflow. Maybe shutdown kernel and retry this step.\n+            saveDeploymentStatusDetails(e.getMessage());\n+            // Interrupted workflow. Shutdown kernel and retry this stage.\n+            kernel.shutdown(30, REQUEST_RESTART);\n             return null;\n         } catch (ServiceUpdateException e) {\n             logger.atError(\"deployment-errored\", e).kv(\"deployment\", deployment).log();\n             if (KERNEL_ACTIVATION.equals(stage)) {\n-                // TODO: rollback workflow. Flip symlinks and restart\n+                try {\n+                    saveDeploymentStatusDetails(e.getMessage());\n+                    // Rollback workflow. Flip symlinks and restart kernel\n+                    kernelAlts.prepareRollback();\n+                    kernel.shutdown(30, REQUEST_RESTART);\n+                } catch (IOException ioException) {\n+                    return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczNDA5MA==", "bodyText": "RollbackCompletes() delete the old  \"broken\" directory. I guess we want to keep the last broken dir", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468734090", "createdAt": "2020-08-11T17:08:08Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -25,32 +29,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());\n \n             DeploymentResult result = null;\n             if (KERNEL_ACTIVATION.equals(stage)) {\n                 result = new DeploymentResult(DeploymentResult.DeploymentStatus.SUCCESSFUL, null);\n+                kernelAlts.activationSucceeds();\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, null);\n+                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE,\n+                        new ServiceUpdateException(deployment.getStageDetails()));\n+                kernelAlts.rollbackCompletes();\n             }\n             return result;\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException | IOException e) {\n             logger.atError(\"deployment-interrupted\", e).kv(\"deployment\", deployment).log();\n-            // TODO: interrupted workflow. Maybe shutdown kernel and retry this step.\n+            saveDeploymentStatusDetails(e.getMessage());\n+            // Interrupted workflow. Shutdown kernel and retry this stage.\n+            kernel.shutdown(30, REQUEST_RESTART);\n             return null;\n         } catch (ServiceUpdateException e) {\n             logger.atError(\"deployment-errored\", e).kv(\"deployment\", deployment).log();\n             if (KERNEL_ACTIVATION.equals(stage)) {\n-                // TODO: rollback workflow. Flip symlinks and restart\n+                try {\n+                    saveDeploymentStatusDetails(e.getMessage());\n+                    // Rollback workflow. Flip symlinks and restart kernel\n+                    kernelAlts.prepareRollback();\n+                    kernel.shutdown(30, REQUEST_RESTART);\n+                } catch (IOException ioException) {\n+                    return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK,\n+                            ioException);\n+                }\n                 return null;\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, null);\n+                try {\n+                    kernelAlts.rollbackCompletes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0NTg1NA==", "bodyText": "I'm wondering if we should swallow the exception here. Maybe it's better to handle in the rollback failure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468745854", "createdAt": "2020-08-11T17:28:10Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/activator/KernelUpdateActivator.java", "diffHunk": "@@ -5,121 +5,99 @@\n \n package com.aws.iot.evergreen.deployment.activator;\n \n-import com.aws.iot.evergreen.deployment.ConfigSnapshotUtils;\n import com.aws.iot.evergreen.deployment.bootstrap.BootstrapManager;\n import com.aws.iot.evergreen.deployment.exceptions.ServiceUpdateException;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n import com.aws.iot.evergreen.deployment.model.DeploymentResult;\n-import com.aws.iot.evergreen.kernel.EvergreenService;\n import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.KernelAlternatives;\n import com.aws.iot.evergreen.kernel.KernelLifecycle;\n \n import java.io.IOException;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.Map;\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutorService;\n import javax.inject.Inject;\n \n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_CONFIG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.MERGE_ERROR_LOG_EVENT_KEY;\n-import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.waitForServicesToStart;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_REBOOT;\n+import static com.aws.iot.evergreen.deployment.bootstrap.BootstrapSuccessCode.REQUEST_RESTART;\n+import static com.aws.iot.evergreen.deployment.model.Deployment.DeploymentStage.KERNEL_ROLLBACK;\n \n /**\n  * Activation and rollback of Kernel update deployments.\n  */\n public class KernelUpdateActivator extends DeploymentActivator {\n     private final BootstrapManager bootstrapManager;\n+    private final KernelAlternatives kernelAlternatives;\n \n     @Inject\n     protected KernelUpdateActivator(Kernel kernel, BootstrapManager bootstrapManager) {\n         super(kernel);\n         this.bootstrapManager = bootstrapManager;\n+        this.kernelAlternatives = kernel.getContext().get(KernelAlternatives.class);\n     }\n \n     @Override\n-    public void activate(Map<Object, Object> newConfig, DeploymentDocument deploymentDocument,\n+    public void activate(Map<Object, Object> newConfig, Deployment deployment,\n                          CompletableFuture<DeploymentResult> totallyCompleteFuture) {\n-        String deploymentId = deploymentDocument.getDeploymentId();\n-        if (!takeConfigSnapshot(deploymentId, totallyCompleteFuture)) {\n+        if (!takeConfigSnapshot(totallyCompleteFuture)) {\n             return;\n         }\n \n+        DeploymentDocument deploymentDocument = deployment.getDeploymentDocumentObj();\n         // Wait for all services to close\n-        kernel.getContext().get(KernelLifecycle.class).stopAllServices(-1);\n+        kernel.getContext().get(KernelLifecycle.class).stopAllServices(30);\n         kernel.getConfig().mergeMap(deploymentDocument.getTimestamp(), newConfig);\n+        Path bootstrapTaskFilePath;\n         try {\n-            // TODO: use kernel alts to resolve deployment folder and save to target.tlog\n-            Path path = kernel.getConfigPath().resolve(String.format(\"target_%s.tlog\",\n-                    deploymentId.replace(':', '.').replace('/', '+')));\n-            ConfigSnapshotUtils.takeSnapshot(kernel, path);\n+            bootstrapTaskFilePath = deploymentDirectoryManager.getBootstrapTaskFilePath();\n+            deploymentDirectoryManager.takeConfigSnapshot(deploymentDirectoryManager.getTargetConfigFilePath());\n+            bootstrapManager.persistBootstrapTaskList(bootstrapTaskFilePath);\n+\n+            kernelAlternatives.prepareBootstrap(deploymentDocument.getDeploymentId());\n         } catch (IOException e) {\n-            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            rollback(deployment, e);\n             return;\n         }\n-        // TODO: point to correct file bootstrapManager.persistBootstrapTaskList(out);\n-        bootstrapManager.persistBootstrapTaskList();\n-        // TODO: KernelAlts prepare bootstrap\n \n         try {\n-            int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially();\n+            int exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(bootstrapTaskFilePath);\n             if (!bootstrapManager.hasNext()) {\n-                // TODO: flip symlinks, new to current\n                 logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n             }\n             // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n             // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.\n-            logger.atInfo().log((exitCode == 101 ? \"device reboot\" : \"kernel restart\")\n+            logger.atInfo().log((exitCode == REQUEST_REBOOT ? \"device reboot\" : \"kernel restart\")\n                     + \" requested to complete bootstrap task\");\n-            // TODO: Kernel shutdown supports exit code\n-            // System.exit(exitCode == 101 ? 101 : 100);\n \n-        } catch (ServiceUpdateException e) {\n-            rollback(deploymentDocument, totallyCompleteFuture, e);\n+            kernel.shutdown(30, exitCode == REQUEST_REBOOT ? REQUEST_REBOOT : REQUEST_RESTART);\n+        } catch (ServiceUpdateException | IOException e) {\n+            rollback(deployment, e);\n             return;\n         }\n     }\n \n-    void rollback(DeploymentDocument deploymentDocument, CompletableFuture<DeploymentResult> totallyCompleteFuture,\n-                  Throwable failureCause) {\n-        String deploymentId = deploymentDocument.getDeploymentId();\n-        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+    void rollback(Deployment deployment, Throwable failureCause) {\n+        logger.atInfo(MERGE_CONFIG_EVENT_KEY, failureCause)\n+                .kv(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId())\n                 .log(\"Rolling back failed deployment\");\n+        deployment.setStageDetails(failureCause.getMessage());\n+        deployment.setDeploymentStage(KERNEL_ROLLBACK);\n \n-        // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n-        long mergeTime = rollbackConfig(deploymentId, totallyCompleteFuture, failureCause);\n-        if (mergeTime == -1) {\n-            return;\n+        try {\n+            deploymentDirectoryManager.writeDeploymentMetadata(deployment);\n+        } catch (IOException ioException) {\n+            logger.atError().setCause(ioException).log(\"Failed to persist deployment details\");\n         }\n-\n-        kernel.getContext().get(ExecutorService.class).execute(() -> {\n-            // TODO: Add timeout\n-            try {\n-                kernel.getContext().get(KernelLifecycle.class).startupAllServices();\n-\n-                Collection<EvergreenService> servicesToTrackForRollback = kernel.orderedDependencies();\n-\n-                waitForServicesToStart(servicesToTrackForRollback, mergeTime);\n-\n-                logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n-                        .log(\"All services rolled back\");\n-\n-                ConfigSnapshotUtils.cleanUpSnapshot(\n-                        ConfigSnapshotUtils.getSnapshotFilePath(kernel, deploymentId), logger);\n-\n-                totallyCompleteFuture.complete(new DeploymentResult(\n-                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n-            } catch (InterruptedException | ServiceUpdateException e) {\n-                // Rollback execution failed\n-                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n-                        .log(\"Failed to rollback deployment\");\n-                // TODO : Run user provided script to reach user defined safe state and\n-                //  set deployment status based on the success of the script run\n-                totallyCompleteFuture.complete(new DeploymentResult(\n-                        DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n-            }\n-        });\n+        try {\n+            kernelAlternatives.prepareRollback();\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).log(\"Failed to set up rollback directory\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0ODEwOQ==", "bodyText": "maybe Use Jackson?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468748109", "createdAt": "2020-08-11T17:31:52Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/bootstrap/BootstrapTaskStatus.java", "diffHunk": "@@ -9,11 +9,17 @@\n import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.EqualsAndHashCode;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.Serializable;\n \n @Data\n @EqualsAndHashCode\n @AllArgsConstructor(access = AccessLevel.PACKAGE)\n-public class BootstrapTaskStatus {\n+@NoArgsConstructor(access = AccessLevel.PACKAGE)\n+public class BootstrapTaskStatus implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc0OTE1MQ==", "bodyText": "NIT: I feel it a little weird to pass bootstrapManager and deploymentDirManager as parameter here. These can be private fields of KernelAlts and set from either context or KernelCommandline", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468749151", "createdAt": "2020-08-11T17:33:55Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dd5a2d8291773ec1d911c2366c8cf932ef79163", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3dd5a2d8291773ec1d911c2366c8cf932ef79163", "committedDate": "2020-08-11T19:49:38Z", "message": "Kernel detects and resumes persisted deployment on launch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bdda28da660228c499c587729f82fae382ee876", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3bdda28da660228c499c587729f82fae382ee876", "committedDate": "2020-08-11T19:49:39Z", "message": "Address comments and fix integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c0172257ac29862d2251a125b7a41f4e59a0055", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7c0172257ac29862d2251a125b7a41f4e59a0055", "committedDate": "2020-08-11T19:57:16Z", "message": "Merge remote-tracking branch 'origin/master' into ku05update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/450c51ef23d3c0c4ed645c840b4034d8dab89618", "committedDate": "2020-08-11T01:54:45Z", "message": "Kernel detects and resumes persisted deployment on launch"}, "afterCommit": {"oid": "7c0172257ac29862d2251a125b7a41f4e59a0055", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7c0172257ac29862d2251a125b7a41f4e59a0055", "committedDate": "2020-08-11T19:57:16Z", "message": "Merge remote-tracking branch 'origin/master' into ku05update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a53ed3c683a2ce81faa2f9d5d72f5d7da3de360", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0a53ed3c683a2ce81faa2f9d5d72f5d7da3de360", "committedDate": "2020-08-11T20:55:18Z", "message": "Fix build and cleanup"}, "afterCommit": {"oid": "90c2b5f8c06f35d38dd5df1a91d2b6f7eaa3e83a", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/90c2b5f8c06f35d38dd5df1a91d2b6f7eaa3e83a", "committedDate": "2020-08-11T21:05:16Z", "message": "Fix build and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbf69c8606e993c584943b036cca4a3373612279", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cbf69c8606e993c584943b036cca4a3373612279", "committedDate": "2020-08-11T22:43:38Z", "message": "Fix build and cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cc51cd285397a46501c172ceeaf10732814ac1d", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cc51cd285397a46501c172ceeaf10732814ac1d", "committedDate": "2020-08-11T22:45:26Z", "message": "Merge remote-tracking branch 'origin/master' into ku05update"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90c2b5f8c06f35d38dd5df1a91d2b6f7eaa3e83a", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/90c2b5f8c06f35d38dd5df1a91d2b6f7eaa3e83a", "committedDate": "2020-08-11T21:05:16Z", "message": "Fix build and cleanup"}, "afterCommit": {"oid": "3cc51cd285397a46501c172ceeaf10732814ac1d", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cc51cd285397a46501c172ceeaf10732814ac1d", "committedDate": "2020-08-11T22:45:26Z", "message": "Merge remote-tracking branch 'origin/master' into ku05update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66194487c9e07ade221a98936c32540d4e8598f4", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/66194487c9e07ade221a98936c32540d4e8598f4", "committedDate": "2020-08-11T23:08:36Z", "message": "fix build"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NTAzOTk1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#pullrequestreview-465503995", "createdAt": "2020-08-11T23:55:45Z", "commit": {"oid": "66194487c9e07ade221a98936c32540d4e8598f4"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMzo1NTo0NVrOG_NHig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwMTowNTowOFrOG_ORPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkyODM5NA==", "bodyText": "make this default value in logger?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468928394", "createdAt": "2020-08-11T23:55:45Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DefaultDeploymentTask.java", "diffHunk": "@@ -49,9 +51,10 @@ public DeploymentResult call()\n             throws NonRetryableDeploymentTaskFailureException, RetryableDeploymentTaskFailureException {\n         Future<Void> preparePackagesFuture = null;\n         Future<DeploymentResult> deploymentMergeFuture = null;\n+        DeploymentDocument deploymentDocument = deployment.getDeploymentDocumentObj();\n         try {\n             logger.atInfo().setEventType(DEPLOYMENT_TASK_EVENT_TYPE)\n-                    .addKeyValue(DEPLOYMENT_ID_LOGGING_KEY, deploymentDocument.getDeploymentId())\n+                    .addKeyValue(DEPLOYMENT_ID_LOG_KEY, deploymentDocument.getDeploymentId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66194487c9e07ade221a98936c32540d4e8598f4"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzOTYwOQ==", "bodyText": "curious why use this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468939609", "createdAt": "2020-08-12T00:36:09Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -29,44 +30,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66194487c9e07ade221a98936c32540d4e8598f4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0NTc5OQ==", "bodyText": "throw the exception instead?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468945799", "createdAt": "2020-08-12T00:59:44Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -29,44 +30,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());\n \n             DeploymentResult result = null;\n             if (KERNEL_ACTIVATION.equals(stage)) {\n                 result = new DeploymentResult(DeploymentResult.DeploymentStatus.SUCCESSFUL, null);\n-                try {\n-                    kernel.getContext().get(KernelAlternatives.class).activationSucceeds();\n-                } catch (IOException e) {\n-                    logger.atError().setCause(e).log(\"Fail to complete activation succeeds\");\n-                }\n-\n+                kernelAlts.activationSucceeds();\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, null);\n+                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE,\n+                        new ServiceUpdateException(deployment.getStageDetails()));\n+                kernelAlts.rollbackCompletes();\n             }\n             return result;\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException | IOException e) {\n             logger.atError(\"deployment-interrupted\", e).kv(\"deployment\", deployment).log();\n-            // TODO: interrupted workflow. Maybe shutdown kernel and retry this step.\n+            saveDeploymentStatusDetails(e.getMessage());\n+            // Interrupted workflow. Shutdown kernel and retry this stage.\n+            kernel.shutdown(30, REQUEST_RESTART);\n             return null;\n         } catch (ServiceUpdateException e) {\n             logger.atError(\"deployment-errored\", e).kv(\"deployment\", deployment).log();\n             if (KERNEL_ACTIVATION.equals(stage)) {\n-                // TODO: rollback workflow. Flip symlinks and restart\n                 try {\n-                    kernel.getContext().get(KernelAlternatives.class).prepareRollback();\n-                } catch (IOException ioE) {\n-                    logger.atError().setCause(ioE).log(\"fail to flip symlink on roll back\");\n-                    // TODO: error handle\n+                    saveDeploymentStatusDetails(e.getMessage());\n+                    // Rollback workflow. Flip symlinks and restart kernel\n+                    kernelAlts.prepareRollback();\n+                    kernel.shutdown(30, REQUEST_RESTART);\n+                } catch (IOException ioException) {\n+                    logger.atError().log(\"Failed to set up Kernel rollback directory\", ioException);\n+                    return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, e);\n                 }\n                 return null;\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, null);\n+                try {\n+                    kernelAlts.rollbackCompletes();\n+                } catch (IOException ioException) {\n+                    logger.atError().log(\"Failed to reset Kernel launch directory\", ioException);\n+                }\n+                return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, e);\n             }\n             return null;\n         }\n     }\n+\n+    private void saveDeploymentStatusDetails(String message) {\n+        deployment.setStageDetails(message);\n+        try {\n+            kernel.getContext().get(DeploymentDirectoryManager.class).writeDeploymentMetadata(deployment);\n+        } catch (IOException ioException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66194487c9e07ade221a98936c32540d4e8598f4"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0NzI2MQ==", "bodyText": "If rollback fails and we call rollbackComplete() , then the broken dir is the failed deployment dir, and current dir is the deployment before that (which was once successful). I'm ok with this for now. We can discuss offline", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r468947261", "createdAt": "2020-08-12T01:05:08Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/KernelUpdateDeploymentTask.java", "diffHunk": "@@ -25,32 +29,58 @@\n     @Override\n     public DeploymentResult call() {\n         Deployment.DeploymentStage stage = deployment.getDeploymentStage();\n+        KernelAlternatives kernelAlts = kernel.getContext().get(KernelAlternatives.class);\n         try {\n             DeploymentConfigMerger.waitForServicesToStart(kernel.orderedDependencies(),\n-                    kernel.getConfig().lookup().getModtime());\n+                    kernel.getConfig().lookup(\"system\", \"rootpath\").getModtime());\n \n             DeploymentResult result = null;\n             if (KERNEL_ACTIVATION.equals(stage)) {\n                 result = new DeploymentResult(DeploymentResult.DeploymentStatus.SUCCESSFUL, null);\n+                kernelAlts.activationSucceeds();\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE, null);\n+                result = new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_COMPLETE,\n+                        new ServiceUpdateException(deployment.getStageDetails()));\n+                kernelAlts.rollbackCompletes();\n             }\n             return result;\n-        } catch (InterruptedException e) {\n+        } catch (InterruptedException | IOException e) {\n             logger.atError(\"deployment-interrupted\", e).kv(\"deployment\", deployment).log();\n-            // TODO: interrupted workflow. Maybe shutdown kernel and retry this step.\n+            saveDeploymentStatusDetails(e.getMessage());\n+            // Interrupted workflow. Shutdown kernel and retry this stage.\n+            kernel.shutdown(30, REQUEST_RESTART);\n             return null;\n         } catch (ServiceUpdateException e) {\n             logger.atError(\"deployment-errored\", e).kv(\"deployment\", deployment).log();\n             if (KERNEL_ACTIVATION.equals(stage)) {\n-                // TODO: rollback workflow. Flip symlinks and restart\n+                try {\n+                    saveDeploymentStatusDetails(e.getMessage());\n+                    // Rollback workflow. Flip symlinks and restart kernel\n+                    kernelAlts.prepareRollback();\n+                    kernel.shutdown(30, REQUEST_RESTART);\n+                } catch (IOException ioException) {\n+                    return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK,\n+                            ioException);\n+                }\n                 return null;\n             } else if (KERNEL_ROLLBACK.equals(stage)) {\n-                // TODO: add failure causes\n-                return new DeploymentResult(DeploymentResult.DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, null);\n+                try {\n+                    kernelAlts.rollbackCompletes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODczNDA5MA=="}, "originalCommit": {"oid": "450c51ef23d3c0c4ed645c840b4034d8dab89618"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/28a2e61eb0bcc6a15eea484d133e56dc4a5152c3", "committedDate": "2020-08-13T00:10:25Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MzY2MzI0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#pullrequestreview-466366324", "createdAt": "2020-08-13T00:29:34Z", "commit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMDoyOTozNFrOG_3nFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwMTowODoyMlrOG_4WHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYyNDU5Ng==", "bodyText": "NIT: this line can be moved to call() so that you don't need to break the @AllArgsConstructor :P", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r469624596", "createdAt": "2020-08-13T00:29:34Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DefaultDeploymentTask.java", "diffHunk": "@@ -45,6 +43,30 @@\n \n     private static final String DEPLOYMENT_TASK_EVENT_TYPE = \"deployment-task-execution\";\n \n+    /**\n+     * Constructor for DefaultDeploymentTask.\n+     *\n+     * @param dependencyResolver DependencyResolver instance\n+     * @param packageManager PackageManager instance\n+     * @param kernelConfigResolver KernelConfigResolver instance\n+     * @param deploymentConfigMerger DeploymentConfigMerger instance\n+     * @param logger Logger instance\n+     * @param deployment Deployment instance\n+     * @param deploymentServiceConfig Deployment service configuration Topics\n+     */\n+    public DefaultDeploymentTask(DependencyResolver dependencyResolver, PackageManager packageManager,\n+                                 KernelConfigResolver kernelConfigResolver,\n+                                 DeploymentConfigMerger deploymentConfigMerger, Logger logger, Deployment deployment,\n+                                 Topics deploymentServiceConfig) {\n+        this.dependencyResolver = dependencyResolver;\n+        this.packageManager = packageManager;\n+        this.kernelConfigResolver = kernelConfigResolver;\n+        this.deploymentConfigMerger = deploymentConfigMerger;\n+        this.logger = logger.dfltKv(DEPLOYMENT_ID_LOG_KEY, deployment.getDeploymentDocumentObj().getDeploymentId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYzNjYzOQ==", "bodyText": "This can be tricky because tempRootDir and e2eTestPkgStoreDir might be the same directory. It was causing problem before when prepare local deployment store and copy file recursively from one folder to another (I see you removed that copy file logic). I'll still prefer e2eTestPkgStoreDir = tempRootDir.resolve(\"eteTestPkgStore\");", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r469636639", "createdAt": "2020-08-13T01:08:22Z", "author": {"login": "ShirleyZheng92"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/e2e/BaseE2ETestCase.java", "diffHunk": "@@ -140,8 +140,9 @@\n             new DeviceProvisioningHelper(GAMMA_REGION.toString(), System.out);\n \n     @TempDir\n-    protected static Path tempRootDir;\n+    protected Path tempRootDir;\n \n+    @TempDir\n     protected static Path e2eTestPkgStoreDir;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDkyOTIy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#pullrequestreview-467092922", "createdAt": "2020-08-13T20:08:05Z", "commit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDowODowNVrOHAb0Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDoxOTozM1rOHAcMdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxNzgyNw==", "bodyText": "Is 100 coming from our design terminology?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470217827", "createdAt": "2020-08-13T20:08:05Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }\n+                    // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n+                    // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIxOTUyMA==", "bodyText": "Do we need shutdown in case when bootstrap did not happen correctly? The directories have been adjusted I believe as part of kernelAlts.prepareRollback(). Can't we push the deployment with rollback stage in the queue at this point?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470219520", "createdAt": "2020-08-13T20:11:02Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }\n+                    // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n+                    // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.\n+                    logger.atInfo().log((exitCode == REQUEST_REBOOT ? \"device reboot\" : \"kernel restart\")\n+                            + \" requested to complete bootstrap task\");\n+\n+                    shutdown(30, exitCode == REQUEST_REBOOT ? REQUEST_REBOOT : REQUEST_RESTART);\n+                } catch (ServiceUpdateException | IOException e) {\n+                    logger.atInfo().log(\"Deployment bootstrap failed\", e);\n+                    try {\n+                        kernelAlts.prepareRollback();\n+                        Deployment deployment = deploymentDirectoryManager.readDeploymentMetadata();\n+                        deployment.setStageDetails(e.getMessage());\n+                        deploymentDirectoryManager.writeDeploymentMetadata(deployment);\n+                    } catch (IOException ioException) {\n+                        logger.atError().setCause(ioException).log(\n+                                \"Something went wrong while preparing for rollback\");\n+                    }\n+                    shutdown(30, 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzMwOA==", "bodyText": "Does bootstrap tasks follow dependency order? If not can we restart only once after all tasks have finished?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470223308", "createdAt": "2020-08-13T20:18:10Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzk0Ng==", "bodyText": "Name seems to indicate that it will execute all the tasks and then return but it executes one by one and returns after executing one. Probably rename it to indicate this behavior, that would also make the if check in next line more intuitive.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470223946", "createdAt": "2020-08-13T20:19:28Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIyMzk5MQ==", "bodyText": "Where is the IOException coming from and does that need to be handled separately?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#discussion_r470223991", "createdAt": "2020-08-13T20:19:33Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -157,13 +159,38 @@ public static String findServiceForNode(Node node) {\n     public Kernel launch() {\n         BootstrapManager bootstrapManager = kernelCommandLine.getBootstrapManager();\n         DeploymentDirectoryManager deploymentDirectoryManager = kernelCommandLine.getDeploymentDirectoryManager();\n-        DeploymentStage stage = kernelCommandLine.getKernelAlternatives().determineDeploymentStage(\n-                bootstrapManager, deploymentDirectoryManager);\n+        KernelAlternatives kernelAlts = kernelCommandLine.getKernelAlternatives();\n+        DeploymentStage stage = kernelAlts.determineDeploymentStage(bootstrapManager, deploymentDirectoryManager);\n \n         switch (stage) {\n             case BOOTSTRAP:\n-                // TODO: load pending bootstrap tasks. Start with one execution here. Flip symlinks. Update task list.\n-                // System.exit(?)\n+                logger.atInfo().kv(\"deploymentStage\", stage).log(\"Resume deployment\");\n+                int exitCode;\n+                try {\n+                    exitCode = bootstrapManager.executeAllBootstrapTasksSequentially(\n+                            deploymentDirectoryManager.getBootstrapTaskFilePath());\n+                    if (!bootstrapManager.hasNext()) {\n+                        logger.atInfo().log(\"Completed all bootstrap tasks. Continue to activate deployment changes\");\n+                    }\n+                    // If exitCode is 0, which happens when all bootstrap tasks are completed, restart in new launch\n+                    // directories and verify handover is complete. As a result, exit code 0 is treated as 100 here.\n+                    logger.atInfo().log((exitCode == REQUEST_REBOOT ? \"device reboot\" : \"kernel restart\")\n+                            + \" requested to complete bootstrap task\");\n+\n+                    shutdown(30, exitCode == REQUEST_REBOOT ? REQUEST_REBOOT : REQUEST_RESTART);\n+                } catch (ServiceUpdateException | IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTc2MDI2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/362#pullrequestreview-467176026", "createdAt": "2020-08-13T22:35:26Z", "commit": {"oid": "28a2e61eb0bcc6a15eea484d133e56dc4a5152c3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2078, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}