{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1NzQ1NzQw", "number": 493, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjozNzowMVrOEpplMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzowNjo1OFrOEpp5aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTA4MzM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjozNzowMVrOHbcz9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzoyNDowM1rOHb1oJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTY1NA==", "bodyText": "What is an example where we are doing version checking of a built-in component? I'm suspecting this should simplify with the idea of describing installed updatable components with a Recipe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498545654", "createdAt": "2020-10-01T22:37:01Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -231,6 +230,21 @@ private Requirement mergeVersionRequirements(Map<String, Requirement> versionReq\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMTAzOA==", "bodyText": "In today's discussion, we decide to get rid of built-in component. The service will either be part of nucleus so configurable through nucleus or be plugin component. Then we can remove this special built-in component handling logic.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498601038", "createdAt": "2020-10-02T03:02:49Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -231,6 +230,21 @@ private Requirement mergeVersionRequirements(Map<String, Requirement> versionReq\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTY1NA=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MjIyOQ==", "bodyText": "Yay! Like the simplification!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498952229", "createdAt": "2020-10-02T17:24:03Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -231,6 +230,21 @@ private Requirement mergeVersionRequirements(Map<String, Requirement> versionReq\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTY1NA=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTA4NDUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjozNzo0NFrOHbc0sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMjo1OToyMFrOHbgJ6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTg0MQ==", "bodyText": "In current implementation, are we only negotiating one component at a time?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498545841", "createdAt": "2020-10-01T22:37:44Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n             // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n+            resolvedComponentId = localCandidateOptional.orElseThrow(() -> new NoAvailableComponentVersionException(\n+                    String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                            componentName, versionRequirements)));\n         } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+            // otherwise try to negotiate with cloud\n+            resolvedComponentId =\n+                    negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null),\n+                            deploymentConfigurationId);\n         }\n+\n+        return getComponentMetadata(resolvedComponentId);\n     }\n \n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+    private ComponentIdentifier negotiateVersionWithCloud(String componentName,\n+                                                          Map<String, Requirement> versionRequirements,\n+                                                          ComponentIdentifier localCandidate,\n+                                                          String deploymentConfigurationId) throws PackagingException {\n         ComponentContent componentContent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMDQyNg==", "bodyText": "yes, one component at a time.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498600426", "createdAt": "2020-10-02T02:59:20Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n             // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n+            resolvedComponentId = localCandidateOptional.orElseThrow(() -> new NoAvailableComponentVersionException(\n+                    String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                            componentName, versionRequirements)));\n         } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+            // otherwise try to negotiate with cloud\n+            resolvedComponentId =\n+                    negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null),\n+                            deploymentConfigurationId);\n         }\n+\n+        return getComponentMetadata(resolvedComponentId);\n     }\n \n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+    private ComponentIdentifier negotiateVersionWithCloud(String componentName,\n+                                                          Map<String, Requirement> versionRequirements,\n+                                                          ComponentIdentifier localCandidate,\n+                                                          String deploymentConfigurationId) throws PackagingException {\n         ComponentContent componentContent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTg0MQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTA4NTA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjozODowNlrOHbc1FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzoxNDozNlrOHbgTVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTk0MA==", "bodyText": "How did we land on a design that uses a Package requirement called \"LOCAL\" to indicate this is a local override? This is very fragile (are we expecting to document this as a reserved package name?) Also as this string is so important, pulling it from an enum that happens to have that string text, will cause the reserved-ness of this name to change if there is a code refactor. Let's fix this by at least defining an Enum to denote local overrides, and pass that enum as a parameter.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498545940", "createdAt": "2020-10-01T22:38:06Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMjgzOQ==", "bodyText": "LOCAL is defined as an enum\nhttps://github.com/aws/aws-greengrass-kernel/blob/master/src/main/java/com/aws/greengrass/deployment/model/Deployment.java#L82\nIt's for local override: for local override component, it's deployed as targets of LOCAL group. Because it's intended to be local override, so it skips the version negotiation with cloud.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498602839", "createdAt": "2020-10-02T03:14:36Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NTk0MA=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTA4NjY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjozODo1MlrOHbc2CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzowMzoxMFrOHbgMkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjE4NQ==", "bodyText": "We had established coding standards that included comments, let's use them", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498546185", "createdAt": "2020-10-01T22:38:52Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n             // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n+            resolvedComponentId = localCandidateOptional.orElseThrow(() -> new NoAvailableComponentVersionException(\n+                    String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                            componentName, versionRequirements)));\n         } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+            // otherwise try to negotiate with cloud\n+            resolvedComponentId =\n+                    negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null),\n+                            deploymentConfigurationId);\n         }\n+\n+        return getComponentMetadata(resolvedComponentId);\n     }\n \n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+    private ComponentIdentifier negotiateVersionWithCloud(String componentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMTEwNw==", "bodyText": "will add comments.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498601107", "createdAt": "2020-10-02T03:03:10Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -148,51 +148,50 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements,\n+                                              String deploymentConfigurationId) throws PackagingException {\n         // acquire ever possible local best candidate\n         Optional<ComponentIdentifier> localCandidateOptional =\n                 findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                .kv(\"localCandidate\", localCandidateOptional.orElse(null)).log(\"Resolve to local version\");\n+        ComponentIdentifier resolvedComponentId;\n         if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n             // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n+            resolvedComponentId = localCandidateOptional.orElseThrow(() -> new NoAvailableComponentVersionException(\n+                    String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                            componentName, versionRequirements)));\n         } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+            // otherwise try to negotiate with cloud\n+            resolvedComponentId =\n+                    negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null),\n+                            deploymentConfigurationId);\n         }\n+\n+        return getComponentMetadata(resolvedComponentId);\n     }\n \n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+    private ComponentIdentifier negotiateVersionWithCloud(String componentName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjE4NQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTA5MDA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjo0MDo0M1rOHbc4AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzowMzozMVrOHbgMww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjY4OQ==", "bodyText": "When reviewing code, let's try and review comments too - Better comments (this isn't useful), capitalization, etc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498546689", "createdAt": "2020-10-01T22:40:43Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -405,23 +419,13 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n             return Optional.empty();\n         }\n \n-        // If the component is builtin, then we won't be able to get the metadata from the filesystem,\n-        // so in that case we will try getting it from builtin. If that fails too, then we just rethrow.\n-        try {\n-            return Optional\n-                    .of(componentStore.getPackageMetadata(new ComponentIdentifier(componentName, activeVersion)));\n-        } catch (PackagingException e) {\n-            ComponentMetadata md = getBuiltinComponentMetadata(componentName, activeVersion);\n-            if (md != null) {\n-                return Optional.of(md);\n-            }\n-            throw e;\n-        }\n+        return Optional.of(getComponentMetadata(new ComponentIdentifier(componentName, activeVersion)));\n     }\n \n-    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n+    /**\n+     * Get active component version and dependencies, the component version satisfies dependent version requirements.\n      *\n-     * @param componentName component name\n+     * @param componentName  component name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMTE1NQ==", "bodyText": "Agree", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498601155", "createdAt": "2020-10-02T03:03:31Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -405,23 +419,13 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n             return Optional.empty();\n         }\n \n-        // If the component is builtin, then we won't be able to get the metadata from the filesystem,\n-        // so in that case we will try getting it from builtin. If that fails too, then we just rethrow.\n-        try {\n-            return Optional\n-                    .of(componentStore.getPackageMetadata(new ComponentIdentifier(componentName, activeVersion)));\n-        } catch (PackagingException e) {\n-            ComponentMetadata md = getBuiltinComponentMetadata(componentName, activeVersion);\n-            if (md != null) {\n-                return Optional.of(md);\n-            }\n-            throw e;\n-        }\n+        return Optional.of(getComponentMetadata(new ComponentIdentifier(componentName, activeVersion)));\n     }\n \n-    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n+    /**\n+     * Get active component version and dependencies, the component version satisfies dependent version requirements.\n      *\n-     * @param componentName component name\n+     * @param componentName  component name", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NjY4OQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTA5MzM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjo0MjoyNFrOHbc59Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzowMzo0OFrOHbgM9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NzE4OQ==", "bodyText": "This comment needs improving. Use JavaDoc to describe the interface as a black box (/** ...*/) and implementation details as \"//\" comments inside the function.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498547189", "createdAt": "2020-10-01T22:42:24Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -104,7 +105,8 @@ public ComponentServiceHelper(GreengrassComponentServiceClientFactory clientFact\n     // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMTIwNA==", "bodyText": "yes, will update.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498601204", "createdAt": "2020-10-02T03:03:48Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -104,7 +105,8 @@ public ComponentServiceHelper(GreengrassComponentServiceClientFactory clientFact\n     // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0NzE4OQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTEwOTQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjo1MTozMlrOHbdEHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzoxNTo1M1rOHbgUHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0OTc4OQ==", "bodyText": "In code below, downloadPackageRecipeAsString -- why don't we know the scope with the new changes? This seems very fragile if we resolved the PUBLIC version but then try to download PRIVATE version.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498549789", "createdAt": "2020-10-01T22:51:32Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -116,25 +118,30 @@ ComponentContent resolveComponentVersion(String componentName, Semver localCandi\n                 .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n                 .withVersionRequirements(versionRequirementsInString);\n         ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n+                .withComponentCandidates(Collections.singletonList(candidate))\n+                // TODO switch back deploymentConfigurationId once it's removed from URL path\n+                // use UUID to avoid ARN complication in URL, deploymentConfigurationId is used for logging purpose\n+                // in server, so could have this hack now\n+                .withDeploymentConfigurationId(UUID.randomUUID().toString());\n \n         ResolveComponentVersionsResult result;\n         try {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n+                            componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(\n+                    String.format(\"Component service error when resolving %s\", componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n+                \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MzQzMQ==", "bodyText": "Also lets have an action item to find and address ALL equalsIgnoreCase in the Kernel.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498553431", "createdAt": "2020-10-01T23:05:09Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -116,25 +118,30 @@ ComponentContent resolveComponentVersion(String componentName, Semver localCandi\n                 .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n                 .withVersionRequirements(versionRequirementsInString);\n         ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n+                .withComponentCandidates(Collections.singletonList(candidate))\n+                // TODO switch back deploymentConfigurationId once it's removed from URL path\n+                // use UUID to avoid ARN complication in URL, deploymentConfigurationId is used for logging purpose\n+                // in server, so could have this hack now\n+                .withDeploymentConfigurationId(UUID.randomUUID().toString());\n \n         ResolveComponentVersionsResult result;\n         try {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n+                            componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(\n+                    String.format(\"Component service error when resolving %s\", componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n+                \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0OTc4OQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMTgzOA==", "bodyText": "In new implemented process, the recipe will be in the response of resolveComponentVersions call. If cloud resolves to private, it will be private component recipe. So we don't need scope any more.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498601838", "createdAt": "2020-10-02T03:07:49Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -116,25 +118,30 @@ ComponentContent resolveComponentVersion(String componentName, Semver localCandi\n                 .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n                 .withVersionRequirements(versionRequirementsInString);\n         ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n+                .withComponentCandidates(Collections.singletonList(candidate))\n+                // TODO switch back deploymentConfigurationId once it's removed from URL path\n+                // use UUID to avoid ARN complication in URL, deploymentConfigurationId is used for logging purpose\n+                // in server, so could have this hack now\n+                .withDeploymentConfigurationId(UUID.randomUUID().toString());\n \n         ResolveComponentVersionsResult result;\n         try {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n+                            componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(\n+                    String.format(\"Component service error when resolving %s\", componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n+                \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0OTc4OQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMzAzNg==", "bodyText": "Yes, we will clean equalsIgnoreCase, make sure components are case sensitive.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498603036", "createdAt": "2020-10-02T03:15:53Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -116,25 +118,30 @@ ComponentContent resolveComponentVersion(String componentName, Semver localCandi\n                 .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n                 .withVersionRequirements(versionRequirementsInString);\n         ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n+                .withComponentCandidates(Collections.singletonList(candidate))\n+                // TODO switch back deploymentConfigurationId once it's removed from URL path\n+                // use UUID to avoid ARN complication in URL, deploymentConfigurationId is used for logging purpose\n+                // in server, so could have this hack now\n+                .withDeploymentConfigurationId(UUID.randomUUID().toString());\n \n         ResolveComponentVersionsResult result;\n         try {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n+                            componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(\n+                    String.format(\"Component service error when resolving %s\", componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n+                \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU0OTc4OQ=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTExMzA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/DependencyResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjo1MzoyOFrOHbdGRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjo1MzoyOFrOHbdGRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MDM0MA==", "bodyText": "I like this, why is this not applied consistently?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498550340", "createdAt": "2020-10-01T22:53:28Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/DependencyResolver.java", "diffHunk": "@@ -5,296 +5,174 @@\n \n package com.aws.greengrass.componentmanager;\n \n-import com.aws.greengrass.componentmanager.exceptions.ComponentVersionConflictException;\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n import com.aws.greengrass.config.Topics;\n import com.aws.greengrass.deployment.model.DeploymentDocument;\n import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n-import com.aws.greengrass.lifecyclemanager.Kernel;\n import com.aws.greengrass.logging.api.Logger;\n import com.aws.greengrass.logging.impl.LogManager;\n import com.vdurmont.semver4j.Requirement;\n-import com.vdurmont.semver4j.Semver;\n-import lombok.AllArgsConstructor;\n import lombok.NoArgsConstructor;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n+import java.util.Queue;\n import java.util.Set;\n-import java.util.stream.Collectors;\n import javax.inject.Inject;\n \n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n \n-@AllArgsConstructor\n @NoArgsConstructor\n public class DependencyResolver {\n     private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n     private static final String VERSION_KEY = \"version\";\n     private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n \n     @Inject\n     private ComponentManager componentManager;\n \n-    @Inject\n-    private Kernel kernel;\n-\n     /**\n-     * Create the full list of packages to be run on the device from a deployment document.\n-     * It also resolves the conflicts between the packages specified in the deployment document and the existing\n-     * running packages on the device.\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n      *\n-     * @param document                   deployment document\n-     * @param groupToRootPackagesDetails {@link Topics} providing package details for each group\n-     * @return a list of packages to be run on the device\n-     * @throws ComponentVersionConflictException when a package version conflict cannot be resolved\n-     * @throws PackagingException              for other package errors\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n      */\n-    public List<ComponentIdentifier> resolveDependencies(final DeploymentDocument document,\n-                                                         Topics groupToRootPackagesDetails)\n-            throws ComponentVersionConflictException, PackagingException {\n-\n-        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n-        // maintained and updated. This information needs to be tracked because: 1. One package can have multiple\n-        // depending packages posing different version constraints. 2. When the version of a depending package changes,\n-        // the version constraints will also change accordingly. 3. The information also shows the complete dependency\n-        // tree.\n-        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n-        Set<String> rootPackagesToResolve = new LinkedHashSet<>();\n-\n-        // Get a list of all package configurations with version constraints in the deployment document\n-        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n-            logger.atDebug().addKeyValue(COMPONENT_NAME_KEY, dpc.getPackageName())\n-                    .addKeyValue(VERSION_KEY, dpc.getResolvedVersion()).log(\"Found package configuration\");\n-            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n-\n-            // Only the group to package mapping before this deployment is guaranteed to be available, since config\n-            // updates happen in a separate thread.\n-            if (document.getRootPackages().contains(dpc.getPackageName())) {\n-                rootPackagesToResolve.add(dpc.getPackageName());\n-            }\n-            packageNameToVersionConstraints.get(dpc.getPackageName())\n-                    .put(document.getGroupName(), dpc.getResolvedVersion());\n-        }\n-\n-        //Get package version constraints for root packages corresponding to other groups\n-        updatePackageConstraintsFromOtherGroups(groupToRootPackagesDetails, document.getGroupName(),\n-                rootPackagesToResolve, packageNameToVersionConstraints);\n-\n-        logger.atInfo().setEventType(\"resolve-dependencies-start\")\n-                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints)\n-                .kv(\"RootPackagesToResolve\", rootPackagesToResolve).kv(\"DeploymentGroup\", document.getGroupName())\n-                .log(\"The root packages for deployment\");\n-\n-        // Map of package name and resolved version\n-        Map<String, ComponentIdentifier> resolvedPackageNameToVersion = new HashMap<>();\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTEyMzA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMjo1OTowOVrOHbdMhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzoxMTowOFrOHbgRUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MTk0Mw==", "bodyText": "findBestMatchAvailableComponent will potentially downgrade component version?\nI want an explicit test that will verify that given a local version 1.3 that does not satisfy dependencies, a local version 1.1 that does satisfy dependencies, and an active version 1.2 that does not satisfy dependencies (due to conflict), that we DO_NOT try to downgrade to 1.1, that would be bad (unless rollback, in which case we want to roll back to version last used, but I suspect we're not handling that correctly?).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498551943", "createdAt": "2020-10-01T22:59:09Z", "author": {"login": "JamieHunter"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -208,7 +207,7 @@ private ComponentMetadata negotiateVersionWithCloud(String componentName,\n             componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n         }\n \n-        return componentStore.getPackageMetadata(resolvedComponentId);\n+        return resolvedComponentId;\n     }\n \n     private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMjMyMg==", "bodyText": "It won't downgrade unless the version requirement specified upper bound is smaller than the current version, in such case I assume it's intentionally downgrade. Otherwise, local available ones will be sorted in descending order, so higher version will be picked if the current version is not picked.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498602322", "createdAt": "2020-10-02T03:11:08Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -208,7 +207,7 @@ private ComponentMetadata negotiateVersionWithCloud(String componentName,\n             componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n         }\n \n-        return componentStore.getPackageMetadata(resolvedComponentId);\n+        return resolvedComponentId;\n     }\n \n     private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1MTk0Mw=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTEzNTEzOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/greengrass/componentmanager/DependencyResolverTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMzowNjo1OFrOHbdUFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwMzowNTo0OVrOHbgOOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1Mzg3Ng==", "bodyText": "be careful about using any() in tests.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498553876", "createdAt": "2020-10-01T23:06:58Z", "author": {"login": "JamieHunter"}, "path": "src/test/java/com/aws/greengrass/componentmanager/DependencyResolverTest.java", "diffHunk": "@@ -19,431 +18,379 @@\n import com.aws.greengrass.testcommons.testutilities.GGExtension;\n import com.vdurmont.semver4j.Requirement;\n import com.vdurmont.semver4j.Semver;\n+import org.hamcrest.collection.IsMapContaining;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n import org.mockito.InjectMocks;\n import org.mockito.Mock;\n-import org.mockito.Mockito;\n import org.mockito.junit.jupiter.MockitoExtension;\n import software.amazon.awssdk.utils.ImmutableMap;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n-import static org.hamcrest.Matchers.containsString;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.hamcrest.core.Is.is;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, GGExtension.class})\n class DependencyResolverTest {\n+\n+    private static final Semver v2_0_0 = new Semver(\"2.0.0\");\n+    private static final Semver v1_5_0 = new Semver(\"1.5.0\");\n+    private static final Semver v1_2_0 = new Semver(\"1.2.0\");\n+    private static final Semver v1_1_0 = new Semver(\"1.1.0\");\n+    private static final Semver v1_0_0 = new Semver(\"1.0.0\");\n+    private static final String componentA = \"A\";\n+    private static final String componentB1 = \"B1\";\n+    private static final String componentB2 = \"B2\";\n+    private static final String componentC1 = \"C1\";\n+    private static final String componentX = \"X\";\n+\n     @InjectMocks\n-    private DependencyResolver resolver;\n+    private DependencyResolver dependencyResolver;\n \n     @Mock\n-    private ComponentManager mockComponentManager;\n+    private ComponentManager componentManager;\n \n-    private Topics groupToRootPackagesTopics;\n+    private Topics groupToTargetComponentsTopics;\n     private Context context;\n     private final ComponentUpdatePolicy componentUpdatePolicy =\n             new ComponentUpdatePolicy(60, ComponentUpdatePolicyAction.NOTIFY_COMPONENTS);\n \n     @BeforeEach\n     void setupTopics() {\n         context = new Context();\n-        groupToRootPackagesTopics = Topics.of(context, GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+        groupToTargetComponentsTopics = Topics.of(context, GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n     }\n \n     @AfterEach\n-    void cleanupTopics() throws IOException {\n+    void cleanTopics() throws IOException {\n         context.close();\n     }\n \n-    @Nested\n-    class MergeSemverRequirementsTest {\n-\n-        @Test\n-        void GIVEN_list_of_version_ranges_WHEN_get_union_THEN_get_version_range() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\"<3.0\");\n-            constraints.add(\">1.0\");\n-            constraints.add(\">2.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\"<3.0 >1.0 >2.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n-            assertTrue(r.isSatisfiedBy(\"2.0.1\"));\n-        }\n-\n-        @Test\n-        void GIVEN_list_of_version_range_and_pinned_version_WHEN_get_union_THEN_get_pinned_version() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\"<3.0\");\n-            constraints.add(\"1.0.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\"<3.0 =1.0.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n-            assertTrue(r.isSatisfiedBy(\"1.0.0\"));\n-        }\n-\n-        @Test\n-        void GIVEN_list_of_version_range_with_conflicts_WHEN_get_union_THEN_get_no_version_match() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\">4.0\");\n-            constraints.add(\"<3.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\">4.0 <3.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"4.0.1\"));\n-            assertFalse(r.isSatisfiedBy(\"2.0.0\"));\n-        }\n+    @Test\n+    void GIVEN_component_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_versions() throws Exception {\n+        /*\n+         *      group1\n+         *         \\(1.0.0)\n+         *          A\n+         * (1.0.0)/   \\(>1.0)\n+         *      B1     B2\n+         *       \\(1.0.0)\n+         *        C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+        dependenciesA_1_x.put(componentB2, \">1.0\");\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \"1.0.0\");\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        ComponentMetadata componentB2_1_2_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_2_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_2_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_0_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1), any(), anyString()))\n+                .thenReturn(componentC1_1_0_0);\n+\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(componentA), Collections\n+                .singletonList(\n+                        new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+\n+        List<ComponentIdentifier> result = dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics);\n+\n+        assertThat(result.size(), is(4));\n+        assertThat(result, containsInAnyOrder(new ComponentIdentifier(componentA, v1_0_0),\n+                new ComponentIdentifier(componentB1, v1_0_0), new ComponentIdentifier(componentB2, v1_2_0),\n+                new ComponentIdentifier(componentC1, v1_0_0)));\n+    }\n+\n+    @Test\n+    void GIVEN_component_A_B2_WHEN_dependencies_overlap_THEN_satisfy_both() throws Exception {\n+        /*\n+         *             group1\n+         *    (1.0.0)/      \\(1.1.0)\n+         *          A       B2\n+         *  (1.0.0)/       /\n+         *        B1      /\n+         * (>1.0.0)\\     /(<=1.1.0)\n+         *           C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \">1.0.0\");\n+\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        Map<String, String> dependenciesB2_1_x = new HashMap<>();\n+        dependenciesB2_1_x.put(componentC1, \"<=1.1.0\");\n+\n+        ComponentMetadata componentB2_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_1_0), dependenciesB2_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_1_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC_1_5_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_5_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1),\n+                eq(Collections.singletonMap(componentB1, Requirement.buildNPM(\">1.0.0\"))), anyString()))\n+                .thenReturn(componentC_1_5_0);\n+        ComponentMetadata componentC_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_1_0), Collections.emptyMap());\n+        Map<String, Requirement> versionRequirementMap = new HashMap<>();\n+        versionRequirementMap.put(componentB1, Requirement.buildNPM(\">1.0.0\"));\n+        versionRequirementMap.put(componentB2, Requirement.buildNPM(\"<=1.1.0\"));\n+        when(componentManager.resolveComponentVersion(eq(componentC1), eq(versionRequirementMap), anyString()))\n+                .thenReturn(componentC_1_1_0);\n+\n+        // top-level package order: A, B2\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(componentA, componentB2),\n+                Arrays.asList(new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>()),\n+                        new DeploymentPackageConfiguration(componentB2, true, v1_1_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentB2)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+        List<ComponentIdentifier> result = dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics);\n+\n+        assertThat(result.size(), is(4));\n+        assertThat(result, containsInAnyOrder(new ComponentIdentifier(componentA, v1_0_0),\n+                new ComponentIdentifier(componentB1, v1_0_0), new ComponentIdentifier(componentB2, v1_1_0),\n+                new ComponentIdentifier(componentC1, v1_1_0)));\n+        ArgumentCaptor<String> componentNameCaptor = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<Map<String, Requirement>> versionRequirementsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(componentManager, times(5))\n+                .resolveComponentVersion(componentNameCaptor.capture(), versionRequirementsCaptor.capture(),\n+                        eq(\"mockJob1\"));\n+        List<String> componentNameList = componentNameCaptor.getAllValues();\n+        assertThat(componentNameList, contains(\"A\", \"B1\", \"C1\", \"B2\", \"C1\"));\n+        List<Map<String, Requirement>> versionRequirementsList = versionRequirementsCaptor.getAllValues();\n+        assertThat(versionRequirementsList.size(), is(5));\n+        Map<String, Requirement> versionRequirements = versionRequirementsList.get(2);\n+        assertThat(versionRequirements.size(), is(1));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B1\", Requirement.buildNPM(\">1.0.0\")));\n+        versionRequirements = versionRequirementsList.get(4);\n+        assertThat(versionRequirements.size(), is(2));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B1\", Requirement.buildNPM(\">1.0.0\")));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B2\", Requirement.buildNPM(\"<=1.1.0\")));\n+    }\n+\n+    @Test\n+    void GIVEN_component_A_B2_WHEN_dependencies_conflict_THEN_throws_no_available_version_error() throws Exception {\n+        /*\n+         *             group1\n+         *    (1.0.0)/      \\(1.1.0)\n+         *          A       B2\n+         *  (1.0.0)/       /\n+         *        B1      /\n+         * (<=1.1.0)\\    /(>=1.2.0)\n+         *           C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \"<=1.1.0\");\n+\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        Map<String, String> dependenciesB2_1_x = new HashMap<>();\n+        dependenciesB2_1_x.put(componentC1, \">=1.2.0\");\n+\n+        ComponentMetadata componentB2_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_1_0), dependenciesB2_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_1_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_1_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1),\n+                eq(Collections.singletonMap(componentB1, Requirement.buildNPM(\"<=1.1.0\"))), anyString()))\n+                .thenReturn(componentC_1_1_0);\n+        Map<String, Requirement> versionRequirements = new HashMap<>();\n+        versionRequirements.put(componentB1, Requirement.buildNPM(\"<=1.1.0\"));\n+        versionRequirements.put(componentB2, Requirement.buildNPM(\">=1.2.0\"));\n+        when(componentManager.resolveComponentVersion(eq(componentC1), eq(versionRequirements), anyString()))\n+                .thenThrow(NoAvailableComponentVersionException.class);\n+\n+        // top-level package order: A, B2\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(componentA, componentB2),\n+                Arrays.asList(new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>()),\n+                        new DeploymentPackageConfiguration(componentB2, true, v1_1_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentB2)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+        assertThrows(NoAvailableComponentVersionException.class,\n+                () -> dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics));\n     }\n \n-    @Nested\n-    class ResolveDependenciesTest {\n-        private final Semver v1_2_0 = new Semver(\"1.2.0\");\n-        private final Semver v1_1_0 = new Semver(\"1.1.0\");\n-        private final Semver v1_0_0 = new Semver(\"1.0.0\");\n-        private static final String pkgA = \"A\";\n-        private static final String pkgB1 = \"B1\";\n-        private static final String pkgB2 = \"B2\";\n-        private static final String pkgC1 = \"C1\";\n-\n-        @Test\n-        void GIVEN_package_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_versions()\n-                throws ComponentVersionConflictException, IOException, PackagingException {\n-\n-            /*\n-             *      main\n-             *         \\(1.0.0)\n-             *          A\n-             * (1.0.0)/   \\(>1.0)\n-             *      B1     B2\n-             *       \\(1.0.0)\n-             *        C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-            dependenciesA_1_x.put(pkgB2, \">1.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            // B2 has both 1.1.0 and 1.2.0 satisfying >1.0\n-            // expected to pick 1.1.0\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), Collections.emptyMap());\n-            ComponentMetadata packageB2_1_2_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_2_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Arrays.asList(packageB2_1_1_0, packageB2_1_2_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_0_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(pkgA), Collections\n-                    .singletonList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-        }\n-\n-        @Test\n-        void GIVEN_package_A_B2_WHEN_dependencies_overlap_THEN_satisfy_both()\n-                throws ComponentVersionConflictException, IOException, PackagingException {\n-\n-            /*\n-             *             main\n-             *    (1.0.0)/      \\(1.0.0)\n-             *          A       B2\n-             *  (1.0.0)/       /\n-             *        B1      /\n-             * (<1.1.0)\\     /(>=1.0.0)\n-             *           C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"<1.1.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_0_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            // top-level package order: A, B2\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB2),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-            verify(mockComponentManager).listAvailablePackageMetadata(pkgC1, Requirement.buildNPM(\">=1.0.0 <1.1.0\"));\n-\n-            // top-level package order: B2, A\n-            // refresh iterator\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            doc = new DeploymentDocument(\"mockJob2\", Arrays.asList(pkgB2, pkgA),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-            verify(mockComponentManager).listAvailablePackageMetadata(pkgC1, Requirement.buildNPM(\">=1.0.0 <1.1.0\"));\n-\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-        }\n-\n-\n-        @Test\n-        void GIVEN_package_A_B2_WHEN_dependencies_conflict_THEN_throws_conflict_error()\n-                throws IOException, PackagingException {\n-\n-            /*\n-             *             main\n-             *    (1.0.0)/      \\(1.0.0)\n-             *          A       B2\n-             *  (1.0.0)/       /\n-             *        B1      /\n-             * (<1.0.0)\\     /(>1.1.0)\n-             *           C1\n-             */\n-\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"<1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">1.1.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            lenient().when(mockComponentManager\n-                    .listAvailablePackageMetadata(eq(pkgC1), eq(Requirement.buildNPM(\">1.1.0 <1.0.0\"))))\n-                    .thenReturn(Collections.emptyIterator());\n-\n-            // top-level package order: A, B2\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB2),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            Exception thrown = assertThrows(ComponentVersionConflictException.class,\n-                    () -> resolver.resolveDependencies(doc, groupToRootPackagesTopics));\n-            assertThat(thrown.getMessage(), containsString(\"C1\"));\n-            assertThat(thrown.getMessage(), containsString(\"{B2-v1.1.0=>1.1.0, B1-v1.0.0=<1.0.0}\"));\n-\n-\n-            // top-level package order: B2, A\n-            // refresh iterator for A B1 and B2\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_2_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_2_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), eq(Requirement.buildNPM(\">1.1.0\"))))\n-                    .thenReturn(Collections.singletonList(packageC_1_2_0).iterator());\n-\n-            DeploymentDocument doc2 = new DeploymentDocument(\"mockJob2\", Arrays.asList(pkgB2, pkgA),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-            thrown = assertThrows(ComponentVersionConflictException.class,\n-                    () -> resolver.resolveDependencies(doc2, groupToRootPackagesTopics));\n-            assertEquals(\"Package version C1-v1.2.0 does not satisfy requirements of B1-v1.0.0, which is: <1.0.0\",\n-                    thrown.getMessage());\n-        }\n-\n-\n-        @Test\n-        void GIVEN_active_packages_WHEN_merge_in_packages_THEN_add_or_update_or_keep_or_delete_accordingly()\n-                throws IOException, PackagingException, ComponentVersionConflictException {\n-\n-            /*\n-             * (add) A    (update) B1   (keep) B2   (delete) D\n-             *         \\        |        |         /\n-             *                  (update) C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgC1, \">=1.0.0\");\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_0 = new HashMap<>();\n-            dependenciesB1_1_0.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_1_0), dependenciesB1_1_0);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_0_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_1_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_1_0).iterator());\n-\n-            // New deployment: A, B1\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB1),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB1, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgB1)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup2\" ,pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-\n-            // DA gives A, B1, B2 as root packages, meaning B2 is a root package for another group\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_1_0),\n-                            new ComponentIdentifier(pkgB2, v1_0_0), new ComponentIdentifier(pkgC1, v1_1_0)));\n-        }\n+    @Test\n+    void GIVEN_other_group_have_same_dependency_WHEN_deploy_current_group_THEN_resolve_dependency_version()\n+            throws Exception {\n+        /*\n+         *             group1            group2\n+         *    (1.0.0)/      \\(1.1.0)      / (2.0.0)\n+         *          A       B2           X\n+         *  (1.0.0)/        /           /\n+         *        B1       /(<=1.2.0) / (>=1.0.0)\n+         * (>=1.1.0)\\     /         /\n+         *                C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 690}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMTUyOQ==", "bodyText": "It's for mocking return. In verify section, I explicitly verify the method arguments.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/493#discussion_r498601529", "createdAt": "2020-10-02T03:05:49Z", "author": {"login": "wikimonkey"}, "path": "src/test/java/com/aws/greengrass/componentmanager/DependencyResolverTest.java", "diffHunk": "@@ -19,431 +18,379 @@\n import com.aws.greengrass.testcommons.testutilities.GGExtension;\n import com.vdurmont.semver4j.Requirement;\n import com.vdurmont.semver4j.Semver;\n+import org.hamcrest.collection.IsMapContaining;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Nested;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n import org.mockito.InjectMocks;\n import org.mockito.Mock;\n-import org.mockito.Mockito;\n import org.mockito.junit.jupiter.MockitoExtension;\n import software.amazon.awssdk.utils.ImmutableMap;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_TOPICS;\n import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n-import static org.hamcrest.Matchers.containsString;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.hamcrest.core.Is.is;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n @ExtendWith({MockitoExtension.class, GGExtension.class})\n class DependencyResolverTest {\n+\n+    private static final Semver v2_0_0 = new Semver(\"2.0.0\");\n+    private static final Semver v1_5_0 = new Semver(\"1.5.0\");\n+    private static final Semver v1_2_0 = new Semver(\"1.2.0\");\n+    private static final Semver v1_1_0 = new Semver(\"1.1.0\");\n+    private static final Semver v1_0_0 = new Semver(\"1.0.0\");\n+    private static final String componentA = \"A\";\n+    private static final String componentB1 = \"B1\";\n+    private static final String componentB2 = \"B2\";\n+    private static final String componentC1 = \"C1\";\n+    private static final String componentX = \"X\";\n+\n     @InjectMocks\n-    private DependencyResolver resolver;\n+    private DependencyResolver dependencyResolver;\n \n     @Mock\n-    private ComponentManager mockComponentManager;\n+    private ComponentManager componentManager;\n \n-    private Topics groupToRootPackagesTopics;\n+    private Topics groupToTargetComponentsTopics;\n     private Context context;\n     private final ComponentUpdatePolicy componentUpdatePolicy =\n             new ComponentUpdatePolicy(60, ComponentUpdatePolicyAction.NOTIFY_COMPONENTS);\n \n     @BeforeEach\n     void setupTopics() {\n         context = new Context();\n-        groupToRootPackagesTopics = Topics.of(context, GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n+        groupToTargetComponentsTopics = Topics.of(context, GROUP_TO_ROOT_COMPONENTS_TOPICS, null);\n     }\n \n     @AfterEach\n-    void cleanupTopics() throws IOException {\n+    void cleanTopics() throws IOException {\n         context.close();\n     }\n \n-    @Nested\n-    class MergeSemverRequirementsTest {\n-\n-        @Test\n-        void GIVEN_list_of_version_ranges_WHEN_get_union_THEN_get_version_range() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\"<3.0\");\n-            constraints.add(\">1.0\");\n-            constraints.add(\">2.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\"<3.0 >1.0 >2.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n-            assertTrue(r.isSatisfiedBy(\"2.0.1\"));\n-        }\n-\n-        @Test\n-        void GIVEN_list_of_version_range_and_pinned_version_WHEN_get_union_THEN_get_pinned_version() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\"<3.0\");\n-            constraints.add(\"1.0.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\"<3.0 =1.0.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n-            assertTrue(r.isSatisfiedBy(\"1.0.0\"));\n-        }\n-\n-        @Test\n-        void GIVEN_list_of_version_range_with_conflicts_WHEN_get_union_THEN_get_no_version_match() {\n-            List<String> constraints = new LinkedList<>();\n-            constraints.add(\">4.0\");\n-            constraints.add(\"<3.0\");\n-            String req = resolver.mergeSemverRequirements(constraints);\n-            assertEquals(\">4.0 <3.0\", req);\n-\n-            Requirement r = Requirement.buildNPM(req);\n-            assertFalse(r.isSatisfiedBy(\"4.0.1\"));\n-            assertFalse(r.isSatisfiedBy(\"2.0.0\"));\n-        }\n+    @Test\n+    void GIVEN_component_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_versions() throws Exception {\n+        /*\n+         *      group1\n+         *         \\(1.0.0)\n+         *          A\n+         * (1.0.0)/   \\(>1.0)\n+         *      B1     B2\n+         *       \\(1.0.0)\n+         *        C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+        dependenciesA_1_x.put(componentB2, \">1.0\");\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \"1.0.0\");\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        ComponentMetadata componentB2_1_2_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_2_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_2_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_0_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1), any(), anyString()))\n+                .thenReturn(componentC1_1_0_0);\n+\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(componentA), Collections\n+                .singletonList(\n+                        new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+\n+        List<ComponentIdentifier> result = dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics);\n+\n+        assertThat(result.size(), is(4));\n+        assertThat(result, containsInAnyOrder(new ComponentIdentifier(componentA, v1_0_0),\n+                new ComponentIdentifier(componentB1, v1_0_0), new ComponentIdentifier(componentB2, v1_2_0),\n+                new ComponentIdentifier(componentC1, v1_0_0)));\n+    }\n+\n+    @Test\n+    void GIVEN_component_A_B2_WHEN_dependencies_overlap_THEN_satisfy_both() throws Exception {\n+        /*\n+         *             group1\n+         *    (1.0.0)/      \\(1.1.0)\n+         *          A       B2\n+         *  (1.0.0)/       /\n+         *        B1      /\n+         * (>1.0.0)\\     /(<=1.1.0)\n+         *           C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \">1.0.0\");\n+\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        Map<String, String> dependenciesB2_1_x = new HashMap<>();\n+        dependenciesB2_1_x.put(componentC1, \"<=1.1.0\");\n+\n+        ComponentMetadata componentB2_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_1_0), dependenciesB2_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_1_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC_1_5_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_5_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1),\n+                eq(Collections.singletonMap(componentB1, Requirement.buildNPM(\">1.0.0\"))), anyString()))\n+                .thenReturn(componentC_1_5_0);\n+        ComponentMetadata componentC_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_1_0), Collections.emptyMap());\n+        Map<String, Requirement> versionRequirementMap = new HashMap<>();\n+        versionRequirementMap.put(componentB1, Requirement.buildNPM(\">1.0.0\"));\n+        versionRequirementMap.put(componentB2, Requirement.buildNPM(\"<=1.1.0\"));\n+        when(componentManager.resolveComponentVersion(eq(componentC1), eq(versionRequirementMap), anyString()))\n+                .thenReturn(componentC_1_1_0);\n+\n+        // top-level package order: A, B2\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(componentA, componentB2),\n+                Arrays.asList(new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>()),\n+                        new DeploymentPackageConfiguration(componentB2, true, v1_1_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentB2)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+        List<ComponentIdentifier> result = dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics);\n+\n+        assertThat(result.size(), is(4));\n+        assertThat(result, containsInAnyOrder(new ComponentIdentifier(componentA, v1_0_0),\n+                new ComponentIdentifier(componentB1, v1_0_0), new ComponentIdentifier(componentB2, v1_1_0),\n+                new ComponentIdentifier(componentC1, v1_1_0)));\n+        ArgumentCaptor<String> componentNameCaptor = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<Map<String, Requirement>> versionRequirementsCaptor = ArgumentCaptor.forClass(Map.class);\n+        verify(componentManager, times(5))\n+                .resolveComponentVersion(componentNameCaptor.capture(), versionRequirementsCaptor.capture(),\n+                        eq(\"mockJob1\"));\n+        List<String> componentNameList = componentNameCaptor.getAllValues();\n+        assertThat(componentNameList, contains(\"A\", \"B1\", \"C1\", \"B2\", \"C1\"));\n+        List<Map<String, Requirement>> versionRequirementsList = versionRequirementsCaptor.getAllValues();\n+        assertThat(versionRequirementsList.size(), is(5));\n+        Map<String, Requirement> versionRequirements = versionRequirementsList.get(2);\n+        assertThat(versionRequirements.size(), is(1));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B1\", Requirement.buildNPM(\">1.0.0\")));\n+        versionRequirements = versionRequirementsList.get(4);\n+        assertThat(versionRequirements.size(), is(2));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B1\", Requirement.buildNPM(\">1.0.0\")));\n+        assertThat(versionRequirements, IsMapContaining.hasEntry(\"B2\", Requirement.buildNPM(\"<=1.1.0\")));\n+    }\n+\n+    @Test\n+    void GIVEN_component_A_B2_WHEN_dependencies_conflict_THEN_throws_no_available_version_error() throws Exception {\n+        /*\n+         *             group1\n+         *    (1.0.0)/      \\(1.1.0)\n+         *          A       B2\n+         *  (1.0.0)/       /\n+         *        B1      /\n+         * (<=1.1.0)\\    /(>=1.2.0)\n+         *           C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);\n+\n+        // prepare B1\n+        Map<String, String> dependenciesB1_1_x = new HashMap<>();\n+        dependenciesB1_1_x.put(componentC1, \"<=1.1.0\");\n+\n+        ComponentMetadata componentB1_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB1, v1_0_0), dependenciesB1_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB1), any(), anyString()))\n+                .thenReturn(componentB1_1_0_0);\n+\n+        // prepare B2\n+        Map<String, String> dependenciesB2_1_x = new HashMap<>();\n+        dependenciesB2_1_x.put(componentC1, \">=1.2.0\");\n+\n+        ComponentMetadata componentB2_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentB2, v1_1_0), dependenciesB2_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentB2), any(), anyString()))\n+                .thenReturn(componentB2_1_1_0);\n+\n+        // prepare C1\n+        ComponentMetadata componentC_1_1_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentC1, v1_1_0), Collections.emptyMap());\n+        when(componentManager.resolveComponentVersion(eq(componentC1),\n+                eq(Collections.singletonMap(componentB1, Requirement.buildNPM(\"<=1.1.0\"))), anyString()))\n+                .thenReturn(componentC_1_1_0);\n+        Map<String, Requirement> versionRequirements = new HashMap<>();\n+        versionRequirements.put(componentB1, Requirement.buildNPM(\"<=1.1.0\"));\n+        versionRequirements.put(componentB2, Requirement.buildNPM(\">=1.2.0\"));\n+        when(componentManager.resolveComponentVersion(eq(componentC1), eq(versionRequirements), anyString()))\n+                .thenThrow(NoAvailableComponentVersionException.class);\n+\n+        // top-level package order: A, B2\n+        DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(componentA, componentB2),\n+                Arrays.asList(new DeploymentPackageConfiguration(componentA, true, v1_0_0.getValue(), new HashMap<>()),\n+                        new DeploymentPackageConfiguration(componentB2, true, v1_1_0.getValue(), new HashMap<>())),\n+                \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n+\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentA)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n+        groupToTargetComponentsTopics.lookupTopics(\"mockGroup1\").lookupTopics(componentB2)\n+                .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n+        context.runOnPublishQueueAndWait(() -> System.out.println(\"Waiting for queue to finish updating the config\"));\n+        assertThrows(NoAvailableComponentVersionException.class,\n+                () -> dependencyResolver.resolveDependencies(doc, groupToTargetComponentsTopics));\n     }\n \n-    @Nested\n-    class ResolveDependenciesTest {\n-        private final Semver v1_2_0 = new Semver(\"1.2.0\");\n-        private final Semver v1_1_0 = new Semver(\"1.1.0\");\n-        private final Semver v1_0_0 = new Semver(\"1.0.0\");\n-        private static final String pkgA = \"A\";\n-        private static final String pkgB1 = \"B1\";\n-        private static final String pkgB2 = \"B2\";\n-        private static final String pkgC1 = \"C1\";\n-\n-        @Test\n-        void GIVEN_package_A_WHEN_resolve_dependencies_THEN_resolve_A_and_dependency_versions()\n-                throws ComponentVersionConflictException, IOException, PackagingException {\n-\n-            /*\n-             *      main\n-             *         \\(1.0.0)\n-             *          A\n-             * (1.0.0)/   \\(>1.0)\n-             *      B1     B2\n-             *       \\(1.0.0)\n-             *        C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-            dependenciesA_1_x.put(pkgB2, \">1.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            // B2 has both 1.1.0 and 1.2.0 satisfying >1.0\n-            // expected to pick 1.1.0\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), Collections.emptyMap());\n-            ComponentMetadata packageB2_1_2_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_2_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Arrays.asList(packageB2_1_1_0, packageB2_1_2_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_0_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Collections.singletonList(pkgA), Collections\n-                    .singletonList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-        }\n-\n-        @Test\n-        void GIVEN_package_A_B2_WHEN_dependencies_overlap_THEN_satisfy_both()\n-                throws ComponentVersionConflictException, IOException, PackagingException {\n-\n-            /*\n-             *             main\n-             *    (1.0.0)/      \\(1.0.0)\n-             *          A       B2\n-             *  (1.0.0)/       /\n-             *        B1      /\n-             * (<1.1.0)\\     /(>=1.0.0)\n-             *           C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"<1.1.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_0_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            // top-level package order: A, B2\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB2),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\").lookupTopics(pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-            verify(mockComponentManager).listAvailablePackageMetadata(pkgC1, Requirement.buildNPM(\">=1.0.0 <1.1.0\"));\n-\n-            // top-level package order: B2, A\n-            // refresh iterator\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_0_0).iterator());\n-\n-            doc = new DeploymentDocument(\"mockJob2\", Arrays.asList(pkgB2, pkgA),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-            verify(mockComponentManager).listAvailablePackageMetadata(pkgC1, Requirement.buildNPM(\">=1.0.0 <1.1.0\"));\n-\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_0_0),\n-                            new ComponentIdentifier(pkgB2, v1_1_0), new ComponentIdentifier(pkgC1, v1_0_0)));\n-        }\n-\n-\n-        @Test\n-        void GIVEN_package_A_B2_WHEN_dependencies_conflict_THEN_throws_conflict_error()\n-                throws IOException, PackagingException {\n-\n-            /*\n-             *             main\n-             *    (1.0.0)/      \\(1.0.0)\n-             *          A       B2\n-             *  (1.0.0)/       /\n-             *        B1      /\n-             * (<1.0.0)\\     /(>1.1.0)\n-             *           C1\n-             */\n-\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgB1, \"1.0.0\");\n-\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_x = new HashMap<>();\n-            dependenciesB1_1_x.put(pkgC1, \"<1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_0_0), dependenciesB1_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">1.1.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_1_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            lenient().when(mockComponentManager\n-                    .listAvailablePackageMetadata(eq(pkgC1), eq(Requirement.buildNPM(\">1.1.0 <1.0.0\"))))\n-                    .thenReturn(Collections.emptyIterator());\n-\n-            // top-level package order: A, B2\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB2),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-            Exception thrown = assertThrows(ComponentVersionConflictException.class,\n-                    () -> resolver.resolveDependencies(doc, groupToRootPackagesTopics));\n-            assertThat(thrown.getMessage(), containsString(\"C1\"));\n-            assertThat(thrown.getMessage(), containsString(\"{B2-v1.1.0=>1.1.0, B1-v1.0.0=<1.0.0}\"));\n-\n-\n-            // top-level package order: B2, A\n-            // refresh iterator for A B1 and B2\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_2_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_2_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), eq(Requirement.buildNPM(\">1.1.0\"))))\n-                    .thenReturn(Collections.singletonList(packageC_1_2_0).iterator());\n-\n-            DeploymentDocument doc2 = new DeploymentDocument(\"mockJob2\", Arrays.asList(pkgB2, pkgA),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgB2, true, v1_1_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-            thrown = assertThrows(ComponentVersionConflictException.class,\n-                    () -> resolver.resolveDependencies(doc2, groupToRootPackagesTopics));\n-            assertEquals(\"Package version C1-v1.2.0 does not satisfy requirements of B1-v1.0.0, which is: <1.0.0\",\n-                    thrown.getMessage());\n-        }\n-\n-\n-        @Test\n-        void GIVEN_active_packages_WHEN_merge_in_packages_THEN_add_or_update_or_keep_or_delete_accordingly()\n-                throws IOException, PackagingException, ComponentVersionConflictException {\n-\n-            /*\n-             * (add) A    (update) B1   (keep) B2   (delete) D\n-             *         \\        |        |         /\n-             *                  (update) C1\n-             */\n-\n-            // prepare A\n-            Map<String, String> dependenciesA_1_x = new HashMap<>();\n-            dependenciesA_1_x.put(pkgC1, \">=1.0.0\");\n-            ComponentMetadata packageA_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgA, v1_0_0), dependenciesA_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgA), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageA_1_0_0).iterator());\n-\n-            // prepare B1\n-            Map<String, String> dependenciesB1_1_0 = new HashMap<>();\n-            dependenciesB1_1_0.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB1_1_0_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB1, v1_1_0), dependenciesB1_1_0);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB1_1_0_0).iterator());\n-\n-            // prepare B2\n-            Map<String, String> dependenciesB2_1_x = new HashMap<>();\n-            dependenciesB2_1_x.put(pkgC1, \">=1.0.0\");\n-\n-            ComponentMetadata packageB2_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgB2, v1_0_0), dependenciesB2_1_x);\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgB2), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageB2_1_1_0).iterator());\n-\n-            // prepare C1\n-            ComponentMetadata packageC_1_1_0 =\n-                    new ComponentMetadata(new ComponentIdentifier(pkgC1, v1_1_0), Collections.emptyMap());\n-            when(mockComponentManager.listAvailablePackageMetadata(eq(pkgC1), Mockito.any()))\n-                    .thenReturn(Collections.singletonList(packageC_1_1_0).iterator());\n-\n-            // New deployment: A, B1\n-            DeploymentDocument doc = new DeploymentDocument(\"mockJob1\", Arrays.asList(pkgA, pkgB1),\n-                    Arrays.asList(new DeploymentPackageConfiguration(pkgA, true, v1_0_0.toString(), new HashMap<>()),\n-                            new DeploymentPackageConfiguration(pkgB1, true, v1_1_0.toString(), new HashMap<>())),\n-                    \"mockGroup1\", 1L, FailureHandlingPolicy.DO_NOTHING, componentUpdatePolicy);\n-\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgA)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup1\", pkgB1)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.1.0\"));\n-            groupToRootPackagesTopics.lookupTopics(\"mockGroup2\" ,pkgB2)\n-                    .replaceAndWait(ImmutableMap.of(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY, \"1.0.0\"));\n-            context.runOnPublishQueueAndWait(\n-                    () -> System.out.println(\"Waiting for queue to finish updating the config\"));\n-\n-            // DA gives A, B1, B2 as root packages, meaning B2 is a root package for another group\n-            List<ComponentIdentifier> result = resolver.resolveDependencies(doc, groupToRootPackagesTopics);\n-\n-            assertEquals(4, result.size());\n-            assertThat(result,\n-                    containsInAnyOrder(new ComponentIdentifier(pkgA, v1_0_0), new ComponentIdentifier(pkgB1, v1_1_0),\n-                            new ComponentIdentifier(pkgB2, v1_0_0), new ComponentIdentifier(pkgC1, v1_1_0)));\n-        }\n+    @Test\n+    void GIVEN_other_group_have_same_dependency_WHEN_deploy_current_group_THEN_resolve_dependency_version()\n+            throws Exception {\n+        /*\n+         *             group1            group2\n+         *    (1.0.0)/      \\(1.1.0)      / (2.0.0)\n+         *          A       B2           X\n+         *  (1.0.0)/        /           /\n+         *        B1       /(<=1.2.0) / (>=1.0.0)\n+         * (>=1.1.0)\\     /         /\n+         *                C1\n+         */\n+\n+        // prepare A\n+        Map<String, String> dependenciesA_1_x = new HashMap<>();\n+        dependenciesA_1_x.put(componentB1, \"1.0.0\");\n+\n+        ComponentMetadata componentA_1_0_0 =\n+                new ComponentMetadata(new ComponentIdentifier(componentA, v1_0_0), dependenciesA_1_x);\n+        when(componentManager.resolveComponentVersion(eq(componentA), any(), anyString())).thenReturn(componentA_1_0_0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU1Mzg3Ng=="}, "originalCommit": {"oid": "420616f13da4a4e4534224864bf1cf91cb675035"}, "originalPosition": 690}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 593, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}