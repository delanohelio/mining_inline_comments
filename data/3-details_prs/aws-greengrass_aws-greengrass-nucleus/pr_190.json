{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0ODY1OTA3", "number": 190, "title": "Deployment rollback", "bodyText": "Issue #, if available:\nDescription of changes:\nRollback failed deployments at the device if the customer requests autorollback in deployment configuration\nConvey status back to cloud accordingly\nAlso includes refactoring the service config merge code and its tests\nWhy is this change necessary:\nSee linked issue and the doc its description\nHow was this change tested:\nAll of the existing tests pass, newly added E2E test for rollback also passes\nAny additional information or context required to review the change:\nBelow is a sample tlog file which the E2E test scenario creates and reuses for rollback\n1,system.rootpath,\"/var/folders/7p/s1cz7lqs2p3gyqnw3m17v1b8yv45lw/T/junit7844564581586293475\"\n1587423682188,services.YellowSignal.lifecycle.run,\"echo proceed with caution This is a test\"\n1587423682188,services.YellowSignal.version,\"1.0.0\"\n1587423682188,services.YellowSignal.parameters.message,\"This is a test\"\n1587423682188,services.YellowSignal.dependencies,\"[]\"\n1,services.IPCService.dependencies,\"[]\"\n1587423672289,services.setenv.AWS_GG_KERNEL_URI,\"tcp://127.0.0.1:51717\"\n1587423666197,services.main.lifecycle.run,\"echo \\u0022Main Running\\u0022\"\n1587423682188,services.main.dependencies,\"[RedSignal, YellowSignal, lifecycleipc, servicediscovery, IPCService, DeploymentService, SafeSystemUpdate]\"\n1,services.lifecycleipc.dependencies,\"[]\"\n1587423682188,services.RedSignal.lifecycle.run,\"echo Stop what you are doing\"\n1587423682188,services.RedSignal.version,\"1.0.0\"\n1587423682188,services.RedSignal.dependencies,\"[]\"\n1,services.servicediscovery.dependencies,\"[]\"\n1,services.SafeSystemUpdate.dependencies,\"[]\"\n1587423670982,services.DeploymentService.privateKeyPath,\"/var/folders/7p/s1cz7lqs2p3gyqnw3m17v1b8yv45lw/T/junit7844564581586293475/privKey.key\"\n1587423670982,services.DeploymentService.rootCaPath,\"/var/folders/7p/s1cz7lqs2p3gyqnw3m17v1b8yv45lw/T/junit7844564581586293475/rootCA.pem\"\n1587423670982,services.DeploymentService.certificateFilePath,\"/var/folders/7p/s1cz7lqs2p3gyqnw3m17v1b8yv45lw/T/junit7844564581586293475/thingCert.crt\"\n1587423670982,services.DeploymentService.thingName,\"e2etest-773e4c8b-54b6-42e9-a568-5343237b293d\"\n1587423670982,services.DeploymentService.mqttClientEndpoint,\"aun2g37imm74n-ats.iot.us-east-1.amazonaws.com\"\n1,services.DeploymentService.dependencies,\"[]\"\n1587423671947,services._AUTH_TOKENS.SWUGXFQE30A5TED5,\"main\"\n1587423703491,services._AUTH_TOKENS.X2Q3CAH6TTCEDXGN,\"YellowSignal\"\n1587423703490,services._AUTH_TOKENS.MD46NFETE050AUBS,\"RedSignal\"\n\n\n\n\n\n\n\nSome context / FAQs that will help reviewers with this PR\n\n\nWhy is deployment snapshot needed to be taken explicitly when Kernel has the ability to write to tlog? -> Kernel at the time of launch attaches a ConfigurationWriter instance to itself and has listeners for updates, whenever a config is updated, it gets written to the tlog file created at the time of launch. But we cannot use this file for rollback, because when a deployment merge is performed, it will immediately add log lines to the file, but when the deployment fails, during rollback these updates must be discarded, which means those log lines will need to be removed from the file. It's much easier to take a new snapshot and clean it up than attempting to commit to this file atomically for each merge activity(doing this is hard because the write to tlog file happens for any individual config update immediately)\n\n\nWhy can we not merge a map of <Object, Object> using the mergeMap() method for rollback just like we do for a fresh deployment? -> For rollback, retaining the individual timestamps of config objects before the deployment is critical. Getting config in the form of <Object, Object> loses individual timestamp information because such objects are just the values of the config topic not timestamps, see this. Transaction logs is the only form that retains the timestamp information. Also, it will require us to store the config POJO either in memory or as a serialized file until it is needed back for rollback, which is also an unnecessary complexity.\n\n\nWhat does it mean we need to retain timestamps ? Why is it important to revert them?\n\n\nImagine this scenario -\ni) Kernel has a running service Service_1, which has run command config with (value V1, timestamp = T1). \nii) Deployment merge happens at T2 which changes the run command to V2 so the timestamp on that config becomes T2 i.e. (value = V2, timestamp = T2). \niii) But the service breaks, so now, at T3 we want to revert it. \n\nThis reverted config should have (value = V1, timestamp= T1) and not (value = V1, timestamp = T3). Otherwise not only do we lose information but also it can break certain deployment scenarios. For instance - deployments are queued on a device for a few hours, when the safe window opens, first deployment executes and changes some config timestamp, then fails then is rolled back, if we don't revert the timestamp of that config and the next deployment tries to update the same config, that update will be rejected by the kernel on account of having an older proposed timestamp. Things like this can get complex quickly and hard to debug if we don't start off right.\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-04-17T00:58:52Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190", "merged": true, "mergeCommit": {"oid": "1d66e5017e481f9ffd4d6c4f2407f068baa87b19"}, "closed": true, "closedAt": "2020-04-24T17:10:26Z", "author": {"login": "shaguptashaikh"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYWoLuABqjMyNDI0MjY5MjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABca0oRjAFqTQwMDEyMzY1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a79266bb8fe5dd5b1662d642310a1bc5dec17bf", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1a79266bb8fe5dd5b1662d642310a1bc5dec17bf", "committedDate": "2020-04-17T00:48:11Z", "message": "Refactor config merger and implement rollback"}, "afterCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/49183f26e8334fff19beb9f69fa2a335d4230cbf", "committedDate": "2020-04-17T01:01:53Z", "message": "Refactor config merger and implement rollback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/49183f26e8334fff19beb9f69fa2a335d4230cbf", "committedDate": "2020-04-17T01:01:53Z", "message": "Refactor config merger and implement rollback"}, "afterCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/52e13ac6c77df6422fca4c7424fc71e6f5adb55b", "committedDate": "2020-04-17T01:18:18Z", "message": "Refactor config merger and implement rollback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MDk4OTA3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-395098907", "createdAt": "2020-04-17T01:10:27Z", "commit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToxMDoyN1rOGG8fSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToyMzo0MVrOGG8t-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTY5MA==", "bodyText": "Please clean up this cutnpaste which doesn't do anything.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409935690", "createdAt": "2020-04-17T01:10:27Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "diffHunk": "@@ -0,0 +1,32 @@\n+---\n+services:\n+  plain:\n+    lifecycle:\n+      startup:\n+        all: \"{platform.invoke} {args}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTc4Nw==", "bodyText": "let's stop doing this as it just pollutes our logs.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409935787", "createdAt": "2020-04-17T01:10:45Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "diffHunk": "@@ -0,0 +1,32 @@\n+---\n+services:\n+  plain:\n+    lifecycle:\n+      startup:\n+        all: \"{platform.invoke} {args}\"\n+\n+  sleeperB:\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo sleeperB_running; sleep 5\n+        done\n+\n+  sleeperA:\n+    dependencies:\n+      - sleeperB\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo sleeperA_running; sleep 5\n+        done\n+\n+  main:\n+    dependencies:\n+      - sleeperA\n+      - sleeperB\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo main_running; sleep 5\n+        done", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTk3MQ==", "bodyText": "The main purpose of those tests was to show that the service's config can be updated, ie setting new envvars. Has this case been replaced?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409935971", "createdAt": "2020-04-17T01:11:31Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/KernelTest.java", "diffHunk": "@@ -35,9 +32,7 @@\n                     new ExpectedStdoutPattern(0, \"EVERGREEN_UID=\", \"generated unique token\"),\n                     new ExpectedStdoutPattern(0, \"version: 0.12.1\", \"moquette mqtt server\"),\n                     new ExpectedStdoutPattern(0, \"JUSTME=fancy a spot of tea?\", \"local setenv in main service\"),\n-                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\"),\n-                    new ExpectedStdoutPattern(2, \"JUSTME=fancy a spot of coffee?\", \"merge yaml\"),\n-                    new ExpectedStdoutPattern(2, \"I'm Frodo\", \"merge adding dependency\")};\n+                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\")};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNjI5Mw==", "bodyText": "prefer .equals()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409936293", "createdAt": "2020-04-17T01:12:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -222,8 +221,20 @@ private void finishCurrentDeployment() throws InterruptedException {\n             //No timeout is set here. Detection of error is delegated to downstream components like\n             // dependency resolver, package downloader, kernel which will have more visibility\n             // if something is going wrong\n-            currentProcessStatus.get();\n-            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+            DeploymentResult result = currentProcessStatus.get();\n+            if (result != null) {\n+                DeploymentResult.DeploymentStatus deploymentStatus = result.getDeploymentStatus();\n+                Map<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"detailed-deployment-status\", deploymentStatus.name());\n+                if (deploymentStatus == DeploymentResult.DeploymentStatus.SUCCESSFUL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNjQ2Mw==", "bodyText": "I believe this suppression may be removed by your change.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409936463", "createdAt": "2020-04-17T01:13:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -370,7 +380,7 @@ public int compare(Topic o1, Topic o2) {\n     }\n \n     @SuppressWarnings({\"PMD.LooseCoupling\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODUwMg==", "bodyText": "Of course I understand why you set this to the current time, but I don't think this is technically correct moving forward. When it rolls back, it should be in exactly the same state as before; timestamps and all. So that new deployments can update the values correctly.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409938502", "createdAt": "2020-04-17T01:20:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +48,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     AutoRollbackConfig autoRollbackConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        DesiredServicesStateManager servicesStateManager = new DesiredServicesStateManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesStateManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesStateManager.servicesToTrackForDeployment();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesStateManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesStateManager);\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture,\n+                          Throwable failureCause, DesiredServicesStateManager servicesStateManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+            kernel.config.read(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)),\n+                    System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ==", "bodyText": "not that it really matter, but why tlog instead of yaml?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409938729", "createdAt": "2020-04-17T01:21:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODk4MA==", "bodyText": "This is the same as L229, right? Shouldn't this be deleting the file?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409938980", "createdAt": "2020-04-17T01:22:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\n+                    \"Failed to record snapshot that's needed in case of \" + \"rollback\", e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzOTQ1MQ==", "bodyText": "Why restart and not just start?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409939451", "createdAt": "2020-04-17T01:23:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\n+                    \"Failed to record snapshot that's needed in case of \" + \"rollback\", e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                    .log(\"Error cleaning up kernel snapshot\");\n+        }\n+    }\n+\n+    private boolean isAutoRollbackRequested(AutoRollbackConfig autoRollbackConfig) {\n+        return autoRollbackConfig == AutoRollbackConfig.AUTO_ROLLBACK_REQUESTED;\n+    }\n+\n+    @Getter\n+    // TODO : Use better name, state is too ambiguous for Evergreen\n+    //  and clean up this code\n+    class DesiredServicesStateManager {\n+        private Set<String> servicesToAdd;\n+        private Set<String> servicesToUpdate;\n+        private Set<String> servicesToRemove;\n+\n+        public DesiredServicesStateManager(Kernel kernel, Map<String, Object> newServiceConfig) {\n+            Set<String> runningUserServices = kernel.orderedDependencies().stream()\n+                    .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                    .map(EvergreenService::getName).collect(Collectors.toSet());\n+\n+            this.servicesToAdd =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> !runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());\n+\n+            this.servicesToUpdate =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());\n+\n+            // TODO: handle removing services that are running within the JVM but defined via config\n+            this.servicesToRemove =\n+                    runningUserServices.stream().filter(serviceName -> !newServiceConfig.containsKey(serviceName))\n+                            .collect(Collectors.toSet());\n+        }\n+\n+        public void startNewServices() throws ServiceLoadException {\n+            startServices(servicesToAdd);\n+        }\n+\n+        public void startRemovedServicesForRollback() throws ServiceLoadException {\n+            startServices(servicesToRemove);\n+        }\n+\n+        private void startServices(Set<String> serviceNames) throws ServiceLoadException {\n+            for (String serviceName : serviceNames) {\n+                EvergreenService service = kernel.locate(serviceName);\n+                service.requestRestart();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 338}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/52e13ac6c77df6422fca4c7424fc71e6f5adb55b", "committedDate": "2020-04-17T01:18:18Z", "message": "Refactor config merger and implement rollback"}, "afterCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7d5fade4e164dfc2ff8ddc81745897079e82fdfa", "committedDate": "2020-04-17T01:25:52Z", "message": "Refactor config merger and implement rollback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjQ0NzU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-395644754", "createdAt": "2020-04-17T17:32:59Z", "commit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozMjo1OVrOGHW9fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo0MzowN1rOGHXRdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTQwNw==", "bodyText": "Why do we need to have different enums for FAILED? Don't we already include the detail failure message in the statusDetail field?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410369407", "createdAt": "2020-04-17T17:32:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentResult.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@ToString\n+@Builder\n+@Getter\n+public class DeploymentResult {\n+\n+    DeploymentStatus deploymentStatus;\n+    Throwable failureCause;\n+\n+    public enum DeploymentStatus {\n+        SUCCESSFUL,\n+        FAILED_NO_STATE_CHANGE,\n+        FAILED_ROLLBACK_NOT_REQUESTED,\n+        FAILED_ROLLBACK_COMPLETE,\n+        FAILED_UNABLE_TO_ROLLBACK", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDYzNA==", "bodyText": "I would rename the enum to FailureHandlingPolicy with values:\nROLLBACK and DO_NOTHING.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410370634", "createdAt": "2020-04-17T17:35:22Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/AutoRollbackConfig.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+public enum AutoRollbackConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3NDUxNw==", "bodyText": "Why do we need to take snapshot here? Don't we already take snapshot in KernelLifecycle class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410374517", "createdAt": "2020-04-17T17:43:07Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzM5Mzc2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-395739376", "createdAt": "2020-04-17T20:05:02Z", "commit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowNTowMlrOGHbfMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0MToxNFrOGHccfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MzU3MA==", "bodyText": "If we handle the auto rollback one level up in deployment task, would it be simpler? Deployment task will snapshot the current config and call mergeInconfig the the new config. If that fails, deployment tasks call mergeInConfig with the snapshoted config. The benefit is we do not have any special logic to rollback services. The mergeinconfig already handles adding/updating/removing services.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410443570", "createdAt": "2020-04-17T20:05:02Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTI2MA==", "bodyText": "I feel L146-151 is very similar to logic in mergeInConfig. can we void this duplication?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410459260", "createdAt": "2020-04-17T20:41:14Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     AutoRollbackConfig autoRollbackConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        DesiredServicesStateManager servicesStateManager = new DesiredServicesStateManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesStateManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesStateManager.servicesToTrackForDeployment();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesStateManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesStateManager);\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture,\n+                          Throwable failureCause, DesiredServicesStateManager servicesStateManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+            kernel.config.read(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)),\n+                    System.currentTimeMillis());\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.context.runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.context.get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesStateManager.startRemovedServicesForRollback();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 171}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7d5fade4e164dfc2ff8ddc81745897079e82fdfa", "committedDate": "2020-04-17T01:25:52Z", "message": "Refactor config merger and implement rollback"}, "afterCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0e2dacb8d75329e2c6522f8dae3c9af447f5fd02", "committedDate": "2020-04-20T17:25:05Z", "message": "Add E2E test for deployment rollback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODM2MDkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-396836091", "createdAt": "2020-04-20T21:45:41Z", "commit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo0NTo0MlrOGIpA9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjoxODoxN1rOGIp-Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMzc4Mw==", "bodyText": "Do you need to filter GenericExternalService same as L276?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411713783", "createdAt": "2020-04-20T21:45:42Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +224,142 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\"Failed to record snapshot that's needed in case of rollback\",\n+                    e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            Files.delete(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                    .log(\"Error cleaning up kernel snapshot\");\n+        }\n+    }\n+\n+    /*\n+     * Evaluate if the customer specified failure handling policy is to auto-rollback\n+     */\n+    private boolean isAutoRollbackRequested(FailureHandlingPolicy failureHandlingPolicy) {\n+        return FailureHandlingPolicy.ROLLBACK.equals(failureHandlingPolicy);\n+    }\n+\n+    @Getter\n+    @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+    private class AggregateServicesChangeManager {\n+        private Kernel kernel;\n+        private Set<String> servicesToAdd;\n+        private Set<String> servicesToUpdate;\n+        private Set<String> servicesToRemove;\n+\n+        /**\n+         * Constructs an object based on the current Kernel state and the config to be merged.\n+         *\n+         * @param kernel           evergreen kernel\n+         * @param newServiceConfig new config to be merged for deployment\n+         */\n+        public AggregateServicesChangeManager(Kernel kernel, Map<String, Object> newServiceConfig) {\n+            Set<String> runningUserServices = kernel.orderedDependencies().stream()\n+                    .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                    .map(EvergreenService::getName).collect(Collectors.toSet());\n+\n+            this.kernel = kernel;\n+\n+            this.servicesToAdd =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> !runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyODE0MQ==", "bodyText": "the mergeTime should be before calling mergeConfigForceTimestamps(), not system.currentMillisecond", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411728141", "createdAt": "2020-04-20T22:15:20Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,151 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture, Throwable failureCause,\n+                          AggregateServicesChangeManager servicesChangeManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+\n+            ConfigurationReader.mergeConfigForceTimestamps(kernel.config,\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.context.runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.context.get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        Set<EvergreenService> servicesToTrackForRollback = servicesChangeManager.servicesToTrack();\n+                        waitForServicesToStart(servicesToTrackForRollback, totallyCompleteFuture,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyOTQ5MA==", "bodyText": "Add check here\n// if the update is cancelled, don't perform merge\nif totallyCompleteFuture.isCancelled() {\n  return;\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411729490", "createdAt": "2020-04-20T22:18:17Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,151 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b895520ed8bb7cbbd5962016c9568d1e4b747815", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b895520ed8bb7cbbd5962016c9568d1e4b747815", "committedDate": "2020-04-20T23:44:02Z", "message": "Fix issues, improve tests"}, "afterCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c74077e12dbf8b5dfa2276694e445ffd6ab32947", "committedDate": "2020-04-21T00:22:22Z", "message": "Fix issues, improve tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTE5ODU4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-396919858", "createdAt": "2020-04-21T01:05:55Z", "commit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowNTo1NVrOGIt8SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowNTo1NVrOGIt8SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NDUwNA==", "bodyText": "This should not be here. This needs to be fixed by tlog parsing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411794504", "createdAt": "2020-04-21T01:05:55Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -136,6 +141,22 @@ private synchronized void initDependenciesTopic() {\n         }\n     }\n \n+    private Iterable<String> getDependencyNames(Object dependenciesNode) {\n+        if (dependenciesNode instanceof String) {\n+            // Dependencies topic is directly deserialized as a list into formats\n+            // such as tlog files, parse such specifications accordingly\n+            String depNodeStr = (String) dependenciesNode;\n+            depNodeStr = depNodeStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTIwNDc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-396920475", "createdAt": "2020-04-21T01:08:03Z", "commit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowODowM1rOGIt_EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowOTozNFrOGIuBLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTIxNg==", "bodyText": "builders aren't efficient. When it is something simple like this, let's just use a constructor.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411795216", "createdAt": "2020-04-21T01:08:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTQ1NQ==", "bodyText": "I think that even if they don't request it, it would be a good idea to snapshot anyway, just don't do the rollback.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411795455", "createdAt": "2020-04-21T01:08:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTc1OQ==", "bodyText": "Log the exception.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411795759", "createdAt": "2020-04-21T01:09:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 139}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c74077e12dbf8b5dfa2276694e445ffd6ab32947", "committedDate": "2020-04-21T00:22:22Z", "message": "Fix issues, improve tests"}, "afterCommit": {"oid": "5ff4f6e2ec58781c9d630db258e65d51f792a45e", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5ff4f6e2ec58781c9d630db258e65d51f792a45e", "committedDate": "2020-04-21T07:14:38Z", "message": "Integ tests for rollback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTQ2NTE3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-397546517", "createdAt": "2020-04-21T18:01:03Z", "commit": {"oid": "5ff4f6e2ec58781c9d630db258e65d51f792a45e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODowMTowM1rOGJRUIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODowMTowM1rOGJRUIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NDA1MQ==", "bodyText": "Moving top level discussion here so we can have proper comments and replies.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412374051", "createdAt": "2020-04-21T18:01:03Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -1,17 +1,23 @@\n /* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n  * SPDX-License-Identifier: Apache-2.0 */\n \n-package com.aws.iot.evergreen.integrationtests.kernel;\n+package com.aws.iot.evergreen.integrationtests.deployment;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff4f6e2ec58781c9d630db258e65d51f792a45e"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4d6a5de9e7857a5d08e4e671ce6d07edef07ff1", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c4d6a5de9e7857a5d08e4e671ce6d07edef07ff1", "committedDate": "2020-04-21T19:09:43Z", "message": "Fix serializing and deserializing of lists to and from tlog"}, "afterCommit": {"oid": "1a7df085d8f4271d4f1e3e0f90b3e2580eda2ad8", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1a7df085d8f4271d4f1e3e0f90b3e2580eda2ad8", "committedDate": "2020-04-21T19:29:11Z", "message": "Fix serializing and deserializing of lists to and from tlog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjQ5MTQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-397649146", "createdAt": "2020-04-21T20:26:22Z", "commit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNjoyMlrOGJXBiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNjoyMlrOGJXBiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NzU5Mw==", "bodyText": "Please remove sleep, we want all our tests to be super quick", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412467593", "createdAt": "2020-04-21T20:26:22Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/local_store_content/recipe/BreakingService-1.0.0.yaml", "diffHunk": "@@ -0,0 +1,13 @@\n+---\n+RecipeTemplateVersion: '2020-01-25'\n+PackageName: BreakingService\n+Description: A service that just can't run\n+Publisher: Me\n+Version: '1.0.0'\n+Lifecycle:\n+  startup: |-\n+    sleep 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/89023db247961020b44e44f23726ca1446ab47d7", "committedDate": "2020-04-21T19:34:21Z", "message": "fix bad rebase conflict resultion"}, "afterCommit": {"oid": "ffdf052f02e008191104d1cd78384ae2250c1340", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ffdf052f02e008191104d1cd78384ae2250c1340", "committedDate": "2020-04-21T21:11:22Z", "message": "fix bad rebase conflict resultion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjE0MDE3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-397614017", "createdAt": "2020-04-21T19:34:37Z", "commit": {"oid": "c4d6a5de9e7857a5d08e4e671ce6d07edef07ff1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTozNTo1MVrOGJVIog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMToxNjoxOVrOGJY13w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNjY0Mg==", "bodyText": "This method name can be more clear. How about\nmergeTlogToConfig(Path tlogPath, Configuration cfg, boolean ignoreTimestamp)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412436642", "createdAt": "2020-04-21T19:35:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2MzIwMA==", "bodyText": "readLine() throws IOException. How do we handle partial failure here when readLine() throws in the middle of while loop?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412463200", "createdAt": "2020-04-21T20:19:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {\n+        try (BufferedReader in = Files.newBufferedReader(p)) {\n+            String l = in.readLine();\n+            while (l != null) {\n+                java.util.regex.Matcher m = logLine.matcher(l);\n+                if (m.matches()) {\n+                    c.lookup(seperator.split(m.group(2))).withValue(parseLong(m.group(1)), toObject(m.group(3)), true);\n+                }\n+                l = in.readLine();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NTgxNA==", "bodyText": "withValue is not an ideal name here. It doesn't convey the information that only if the value is newer, then use the new value. It was okay previously because that is the only logic, but now we have withValue(long proposedModtime, final Object proposed, boolean forceTimestamp), it can cause confusion. Maybe name it withNewerValue()?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412465814", "createdAt": "2020-04-21T20:23:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -93,10 +93,22 @@ public Topic withValue(Object nv) {\n      * @param proposed        new value.\n      * @return this.\n      */\n-    public synchronized Topic withValue(long proposedModtime, final Object proposed) {\n+    public Topic withValue(long proposedModtime, final Object proposed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MzQ4NQ==", "bodyText": "Would like to correct my comment above - Yes, KernelLifecycle takes a snapshot by attaching a config writer to itself during launch, and it immediately updates the tlog file as soon as any config key is modified. Deployment merge will also be recoded in this same tlog file and at the time of rollback that file will have all the logs i.e. before deployment and afterdeployment. They'll either need to be removed from the file or not written to file until deployment success(I think this is what you mean by 'committing config only after deployment success is confirmed'). But since there are listeners attached to each config key that automatically write to the file, doing that is more complex. It's much easier to take a new snapshot and delete it as soon as done.\n\nAren't you doing the same thing here -- attach a config writer? This config writer will also record the deployment update to the deployment tlog file (snapshot). How is it different? Why not just copy and rename the original tlog before applying the merge?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412483485", "createdAt": "2020-04-21T20:52:54Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzU0NQ==", "bodyText": "This is really far from where the exception is thrown. Can we make this try...catch loop smaller?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412493545", "createdAt": "2020-04-21T21:09:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NzM3NQ==", "bodyText": "Same here. The try...catch block can be smaller.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412497375", "createdAt": "2020-04-21T21:16:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture, Throwable failureCause,\n+                          AggregateServicesChangeManager servicesChangeManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+\n+            // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n+            long mergeTime = System.currentTimeMillis();\n+            ConfigurationReader.mergeConfigForceTimestamps(kernel.getConfig(),\n+                    kernel.getConfigPath().resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.getContext().runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.getContext().get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+\n+                        Set<EvergreenService> servicesToTrackForRollback = servicesChangeManager.servicesToTrack();\n+\n+                        waitForServicesToStart(servicesToTrackForRollback, totallyCompleteFuture, mergeTime);\n+\n+                        servicesChangeManager.removeObsoleteServices();\n+                        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                                .log(\"All services rolled back\");\n+\n+                        cleanUpSnapshot(deploymentId);\n+\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n+                    } catch (InterruptedException | ServiceUpdateException | ExecutionException\n+                            | ServiceLoadException e) {\n+                        // Rollback execution failed\n+                        logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                                .log(\"Failed to rollback deployment\");\n+                        // TODO : Run user provided script to reach user defined safe state and\n+                        //  set deployment status based on the success of the script run\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n+                    }\n+                });\n+            });\n+        } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdf052f02e008191104d1cd78384ae2250c1340"}, "originalPosition": 211}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ffdf052f02e008191104d1cd78384ae2250c1340", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ffdf052f02e008191104d1cd78384ae2250c1340", "committedDate": "2020-04-21T21:11:22Z", "message": "fix bad rebase conflict resultion"}, "afterCommit": {"oid": "6b3f972e4cee38025bbd055b4fdf9d62b99ff74d", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6b3f972e4cee38025bbd055b4fdf9d62b99ff74d", "committedDate": "2020-04-21T21:47:21Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b3f972e4cee38025bbd055b4fdf9d62b99ff74d", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/6b3f972e4cee38025bbd055b4fdf9d62b99ff74d", "committedDate": "2020-04-21T21:47:21Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}, "afterCommit": {"oid": "21abb27f6e51d6301b5fb89938163d7916992191", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21abb27f6e51d6301b5fb89938163d7916992191", "committedDate": "2020-04-22T07:23:29Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "365079d963c3f5df927e530a595e231011b96939", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/365079d963c3f5df927e530a595e231011b96939", "committedDate": "2020-04-22T07:41:36Z", "message": "Fix benchmark compilation failure"}, "afterCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc8a5d02f1fb18be16983826378fc2055d672553", "committedDate": "2020-04-23T00:49:18Z", "message": "Fix benchmark compilation failure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjkzOTIy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-398693922", "createdAt": "2020-04-23T01:12:23Z", "commit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToxMjoyM1rOGKSOxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToyMToyMFrOGKSadw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzNzYzOA==", "bodyText": "use hamcrest matcher for ContainsInAnyOrder.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413437638", "createdAt": "2020-04-23T01:12:23Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODIyMQ==", "bodyText": "Likewise down here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413438221", "createdAt": "2020-04-23T01:14:11Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+        assertTrue(services.contains(\"BreakingService\"));\n+        assertTrue(services.contains(\"Mosquitto\"));\n+        assertTrue(services.contains(\"GreenSignal\"));\n+        assertEquals(State.BROKEN, kernel.locate(\"BreakingService\").getState());\n+        assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, result.getDeploymentStatus());\n+\n+    }\n+\n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service and the failure handling policy is to rollback\n+     * As a result, kernel should be reverted to the state before deployment\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(5)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_rollback_THEN_services_are_rolled_back(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureRollbackDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal, RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODI3Nw==", "bodyText": "Same here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413438277", "createdAt": "2020-04-23T01:14:22Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+        assertTrue(services.contains(\"BreakingService\"));\n+        assertTrue(services.contains(\"Mosquitto\"));\n+        assertTrue(services.contains(\"GreenSignal\"));\n+        assertEquals(State.BROKEN, kernel.locate(\"BreakingService\").getState());\n+        assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, result.getDeploymentStatus());\n+\n+    }\n+\n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service and the failure handling policy is to rollback\n+     * As a result, kernel should be reverted to the state before deployment\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(5)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_rollback_THEN_services_are_rolled_back(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODMyOA==", "bodyText": "And here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413438328", "createdAt": "2020-04-23T01:14:34Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzOTUyNQ==", "bodyText": "Shouldn't this still be withValue? It isn't forcing the timestamp.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413439525", "createdAt": "2020-04-23T01:17:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -93,10 +93,23 @@ public Topic withValue(Object nv) {\n      * @param proposed        new value.\n      * @return this.\n      */\n-    public synchronized Topic withValue(long proposedModtime, final Object proposed) {\n+    public Topic withNewerValue(long proposedModtime, final Object proposed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0MDYzMQ==", "bodyText": "this is missing a .log().", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413440631", "createdAt": "2020-04-23T01:21:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +52,158 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            try {\n-                // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n-                long mergeTime = System.currentTimeMillis();\n \n-                kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n+            // if the update is cancelled, don't perform merge\n+            if (totallyCompleteFuture.isCancelled()) {\n+                return;\n+            }\n+\n+            FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                try {\n+                    takeSnapshotForRollback(deploymentId);\n+                } catch (IOException e) {\n+                    // Failed to record snapshot hence did not execute merge, no rollback needed\n+                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 99}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dc8a5d02f1fb18be16983826378fc2055d672553", "committedDate": "2020-04-23T00:49:18Z", "message": "Fix benchmark compilation failure"}, "afterCommit": {"oid": "ae6dda88f17837bca83b1d02d44d1117ac6407f3", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae6dda88f17837bca83b1d02d44d1117ac6407f3", "committedDate": "2020-04-23T01:45:46Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzA0NzI4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-398704728", "createdAt": "2020-04-23T01:47:58Z", "commit": {"oid": "ae6dda88f17837bca83b1d02d44d1117ac6407f3"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae6dda88f17837bca83b1d02d44d1117ac6407f3", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae6dda88f17837bca83b1d02d44d1117ac6407f3", "committedDate": "2020-04-23T01:45:46Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}, "afterCommit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bf2c5c930486e880f758ce241303bea3694c2cbb", "committedDate": "2020-04-23T01:50:04Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MzA4NDIy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-399308422", "createdAt": "2020-04-23T17:12:31Z", "commit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb"}, "state": "DISMISSED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzoxMjozMVrOGKzEig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzozNTozNFrOGK0CzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3NTY5MA==", "bodyText": "What's difference between this test case and the one below (GIVEN_kernel_running_single_service_WHEN_merge_changes_service_THEN_service_restarts_with_new_config)?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413975690", "createdAt": "2020-04-23T17:12:31Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -54,7 +62,38 @@ void after() {\n     }\n \n     @Test\n-    void GIVEN_kernel_running_single_service_WHEN_merge_change_to_service_THEN_service_restarts_with_new_config()\n+    void GIVEN_kernel_running_with_some_config_WHEN_merge_simple_yaml_file_THEN_config_is_updated() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MTYyOQ==", "bodyText": "Might want to add a comment here that this potentially have memory issue if the transaction log is large.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413991629", "createdAt": "2020-04-23T17:35:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +60,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param config         configuration to merge into\n+     * @param tlogPath       path of the tlog file to read to-be-merged config from\n+     * @param forceTimestamp should ignore if the proposed timestamp is older than current\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeTlogIntoConfig(Configuration config, Path tlogPath, boolean forceTimestamp)\n+            throws IOException {\n+        Iterator<String> logLines = Files.readAllLines(tlogPath).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c8a74d363671894cc3982deca836834c69ca06e", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0c8a74d363671894cc3982deca836834c69ca06e", "committedDate": "2020-04-23T19:38:49Z", "message": "Add comment, add log to see integ test failure"}, "afterCommit": {"oid": "2aece121bc1e5920b293260ed3c8c6814607d7d2", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2aece121bc1e5920b293260ed3c8c6814607d7d2", "committedDate": "2020-04-23T19:48:25Z", "message": "Add comment, add log to see integ test failure"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2aece121bc1e5920b293260ed3c8c6814607d7d2", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2aece121bc1e5920b293260ed3c8c6814607d7d2", "committedDate": "2020-04-23T19:48:25Z", "message": "Add comment, add log to see integ test failure"}, "afterCommit": {"oid": "0f94b51d9636084c8523624a2b21b8c2e489a686", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0f94b51d9636084c8523624a2b21b8c2e489a686", "committedDate": "2020-04-23T20:27:13Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f94b51d9636084c8523624a2b21b8c2e489a686", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0f94b51d9636084c8523624a2b21b8c2e489a686", "committedDate": "2020-04-23T20:27:13Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}, "afterCommit": {"oid": "324f455ccc3143ad0203080d607ca180db7e9b92", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/324f455ccc3143ad0203080d607ca180db7e9b92", "committedDate": "2020-04-23T20:44:12Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "324f455ccc3143ad0203080d607ca180db7e9b92", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/324f455ccc3143ad0203080d607ca180db7e9b92", "committedDate": "2020-04-23T20:44:12Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}, "afterCommit": {"oid": "9acf83f2c4416045c73d877829499e76611f0dff", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9acf83f2c4416045c73d877829499e76611f0dff", "committedDate": "2020-04-23T23:04:20Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9acf83f2c4416045c73d877829499e76611f0dff", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9acf83f2c4416045c73d877829499e76611f0dff", "committedDate": "2020-04-23T23:04:20Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}, "afterCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e3bf18afca668477ee865f261a4bc532c42b921a", "committedDate": "2020-04-24T01:45:58Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NjA2OTU4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-399606958", "createdAt": "2020-04-24T02:54:57Z", "commit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMjo1NDo1N1rOGLEG9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMjo1Nzo0MVrOGLEKMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NDgzOA==", "bodyText": "These are not the sane, right? Before it kept a running log, but now it is a 1 time thing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414254838", "createdAt": "2020-04-24T02:54:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -191,7 +190,7 @@ public void writeEffectiveConfig(Path p) {\n      * @throws IOException if writing fails\n      */\n     public void writeEffectiveConfigAsTransactionLog(Path transactionLogPath) throws IOException {\n-        ConfigurationWriter.logTransactionsTo(config, transactionLogPath).flushImmediately(true);\n+        ConfigurationWriter.dump(config, transactionLogPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NTIyMg==", "bodyText": "Let's add testing for this in the utils or coerce unit test.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414255222", "createdAt": "2020-04-24T02:56:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/util/Coerce.java", "diffHunk": "@@ -318,6 +330,9 @@ public static Object toObject(String s) {\n         if (\"null\".equals(s)) {\n             return null;\n         }\n+        if (unwrap.matcher(s).matches()) {\n+            return toStringList(s);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NTY2Nw==", "bodyText": "Please no sleeping, you can use verify with a timeout to account for time, while running as quick as possible.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414255667", "createdAt": "2020-04-24T02:57:41Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -191,13 +200,65 @@ public void GIVEN_deployment_job_WHEN_deployment_process_fails_THEN_report_faile\n                     .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n             verify(mockIotJobsHelper, WAIT_FOUR_SECONDS)\n                     .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.FAILED), any());\n+\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_job_with_auto_rollback_not_requested_WHEN_deployment_process_fails_THEN_report_failed_job_status()\n+                throws Exception {\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(\n+                    new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, null));\n+            when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFuture);\n+            startDeploymentServiceInAnotherThread();\n+\n+            //Wait for the enough time after which deployment service would have processed the job from the queue\n+            Thread.sleep(Duration.ofSeconds(2).toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NjA4ODYx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-399608861", "createdAt": "2020-04-24T03:01:56Z", "commit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7baae660204cef828058c2574b7c9a121c22cb6a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7baae660204cef828058c2574b7c9a121c22cb6a", "committedDate": "2020-04-24T03:50:39Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/e3bf18afca668477ee865f261a4bc532c42b921a", "committedDate": "2020-04-24T01:45:58Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}, "afterCommit": {"oid": "7baae660204cef828058c2574b7c9a121c22cb6a", "author": {"user": {"login": "shaguptashaikh", "name": "Shagupta Shaikh"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7baae660204cef828058c2574b7c9a121c22cb6a", "committedDate": "2020-04-24T03:50:39Z", "message": "Autorollback failed deployment when customer has configured it so\nRefactor deployment config merger\nAdd rollback tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDY1ODM4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-400065838", "createdAt": "2020-04-24T15:48:25Z", "commit": {"oid": "7baae660204cef828058c2574b7c9a121c22cb6a"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0ODoyNVrOGLeAJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0ODoyNVrOGLeAJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3OTA3Nw==", "bodyText": "nit\nNew tests should have reasonable names.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414679077", "createdAt": "2020-04-24T15:48:25Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/util/CoerceTest.java", "diffHunk": "@@ -84,5 +92,17 @@ void t(String s, String... expect) {\n         }\n     }\n \n+    @Test\n+    public void T6() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7baae660204cef828058c2574b7c9a121c22cb6a"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTIzNjU3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#pullrequestreview-400123657", "createdAt": "2020-04-24T17:07:10Z", "commit": {"oid": "7baae660204cef828058c2574b7c9a121c22cb6a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2133, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}