{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMjUyMjAy", "number": 133, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDoxNlrODq_Keg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToxMTo0M1rODrZm5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDAxNjU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDoxNlrOF7EunQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDoxNlrOF7EunQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4Nzc3Mw==", "bodyText": "this needs a comment for why it is a global lock", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397487773", "createdAt": "2020-03-24T22:00:16Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -123,7 +124,7 @@ private void updateStateAndBroadcast(State newState) {\n         logger.atInfo().setEventType(\"service-set-state\").addKeyValue(\"currentState\", currentState)\n                 .addKeyValue(\"newState\", newState).log();\n \n-        synchronized (this.state) {\n+        synchronized (State.class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDAxODM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDo1M1rOF7EvqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMDo1M1rOF7EvqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODA0MQ==", "bodyText": "nit\n.equals.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397488041", "createdAt": "2020-03-24T22:00:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDAyMTczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjowMTo1OVrOF7Exkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzoyNjowNlrOF7GzLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODUzMQ==", "bodyText": "We need a way to cancel this: ex if the future that we return is cancelled by the user, this should also be cancelled.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397488531", "createdAt": "2020-03-24T22:01:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(Executor.class).execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwNTI5Mw==", "bodyText": "So far all this large blob() is in UpdateSystemSafelyService.addUpdateAction() . In which UpdateSystemSafelyService queue actions and run them on runOnPublishQueueAndWait(). There isn't a way to cancel the queued actions in UpdateSystemSafelyService now.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397505293", "createdAt": "2020-03-24T22:41:43Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(Executor.class).execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODUzMQ=="}, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyMTcwOA==", "bodyText": "We don't need to cancel it though, we can cancel our own code inside by checking that the future is not canceled before continuing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397521708", "createdAt": "2020-03-24T23:26:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (eg.getState() == State.NEW) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(Executor.class).execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ4ODUzMQ=="}, "originalCommit": {"oid": "2c21f4b35a24bc38617002a25bf106d51765ccab"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDcwODE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMzozNzo0M1rOF7LGrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMzozNzo0M1rOF7LGrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjIzOQ==", "bodyText": "formatting looks off, can you auto-format the whole file please?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397592239", "createdAt": "2020-03-25T03:37:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDcxMTMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMzozOTozMlrOF7LIkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDowOTo0MFrOF7LiUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjcyMA==", "bodyText": "Not too sure what the behavior is of completing a cancelled future. In the case that it is cancelled, the loop exits and we'll fall through to here and complete it which would normally mean that the merge is done, but that's not the case here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397592720", "createdAt": "2020-03-25T03:39:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+                            removeServices(removedServices);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTMxNQ==", "bodyText": "Updated. However totallyCompleteFuture can be cancelled at any point. We might need to revisit the behavior of cancelling a config merge.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397599315", "createdAt": "2020-03-25T04:09:40Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,86 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName: serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+                            removeServices(removedServices);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5MjcyMA=="}, "originalCommit": {"oid": "9b19c3f173135798c0dbc65f14bcd7f75b7ccb85"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDc4NDE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDoyODoyNVrOF7Lyhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo1MDoxN1rOF7MEUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzQ2Mw==", "bodyText": "Since mergeMap is asynchronous, does it mean when line613 is executed the mergeMap might not be done yet? Is that not an issue? Do we need to make mergeMap blocking?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397603463", "createdAt": "2020-03-25T04:28:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODAxOA==", "bodyText": "the setValue() in mergeMap is blocking. the running listeners on topics isn't . L613 will be able to locate new evergreen service.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608018", "createdAt": "2020-03-25T04:50:17Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzQ2Mw=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDc4Njg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDozMDowNVrOF7L0AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMDozNzo0MVrOF7zbOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ==", "bodyText": "Why do we need to run context.runOnPublishQueueAndWait() instead of on the current thread? is it because of mergeMap? Let's try to make this code more readable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397603841", "createdAt": "2020-03-25T04:30:05Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODM3Nw==", "bodyText": "Yes. the topic listeners triggered by mergeMap might not finished at this point. We want the check of reachedDesiredState() happens after topic listeners updates desiredState in every service", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608377", "createdAt": "2020-03-25T04:51:56Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1Mjg1Nw==", "bodyText": "Right now maybe add more comments on explain why we need to run on the publish queue. Let's also try to think how we can improve this in the long run.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398252857", "createdAt": "2020-03-26T00:37:41Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzg0MQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDc5MjY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDozNDowOFrOF7L3UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo1MjowNFrOF7MF3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDY4OA==", "bodyText": "I would log a warn instead.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397604688", "createdAt": "2020-03-25T04:34:08Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODQxNA==", "bodyText": "Sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608414", "createdAt": "2020-03-25T04:52:04Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDY4OA=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDc5MzgxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDozNTowNlrOF7L37w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDozNTowNlrOF7L37w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNDg0Nw==", "bodyText": "This log line should be after removeServices()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397604847", "createdAt": "2020-03-25T04:35:06Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDgwMTcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo0MDo1OVrOF7L8pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo0MDo1OVrOF7L8pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjA1NA==", "bodyText": "Do we need to clean up or revert anything before exiting here? Probably also treat different exception differently. Don't need to address in this PR but I would leave a TODO comment in the code so we don't forget.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397606054", "createdAt": "2020-03-25T04:40:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDgwOTk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo0Njo0N1rOF7MBcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo1MzoxNFrOF7MGzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzI4MQ==", "bodyText": "I understand this part of code is copy and paste from previous commit, but I think we shouldn't block on get() forever. I don't understand close() return a future instead of a synchronous call. It's not like we can cancel a close.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397607281", "createdAt": "2020-03-25T04:46:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODY1NA==", "bodyText": "The reason we make it asynchronous is we don't want to block on each service's close. If services don't have dependency on each other, they can be closed in parallel", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608654", "createdAt": "2020-03-25T04:53:14Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzI4MQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDgxMTg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwNDo0ODoyNVrOF7MCmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMDo0MTo1MFrOF7zf0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ==", "bodyText": "Not sure only logging is sufficient. Not able to remove the topic seems like an error we need to populate up and handle seriously (e.g. rollback).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397607579", "createdAt": "2020-03-25T04:48:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();\n+            } catch (Exception e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Cloud not clean up resources while removing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwODgwNg==", "bodyText": "I haven't look into the code of when this case can happen. Can add a TODO here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r397608806", "createdAt": "2020-03-25T04:53:52Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();\n+            } catch (Exception e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Cloud not clean up resources while removing\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3MTk1Nw==", "bodyText": "I don't think it is possible for it to fail, but let me know if you find that it can.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398171957", "createdAt": "2020-03-25T21:11:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();\n+            } catch (Exception e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Cloud not clean up resources while removing\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1NDAzNQ==", "bodyText": "Then let's remove the try..catch. It doesn't provide any value to wrap all the code in try...catch lol.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398254035", "createdAt": "2020-03-26T00:41:50Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,93 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"All services updated\");\n+\n+                            removeServices(removedServices);\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();\n+            } catch (Exception e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Cloud not clean up resources while removing\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNzU3OQ=="}, "originalCommit": {"oid": "d428e6c49462a68e9aba4dbc931361f884c55ce0"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODM0OTE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToxMTo0M1rOF7ugHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMToxMTo0M1rOF7ugHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3MjE5MQ==", "bodyText": "Use the public static constant for \"services\"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/133#discussion_r398172191", "createdAt": "2020-03-25T21:11:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -603,74 +605,95 @@ public Topics findServiceTopic(String name) {\n         List<String> removedServices = getRemovedServicesNames(serviceConfig);\n         logger.atDebug(\"merge-config\").kv(\"removedServices\", removedServices).log();\n \n-        Map<String, CountDownLatch> servicesRunningLatches = new HashMap<>();\n-        serviceConfig.forEach((key, v) -> servicesRunningLatches.put(key, new CountDownLatch(1)));\n+        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n+            try {\n+                mergeMap(timestamp, newConfig);\n+                for (String serviceName : serviceConfig.keySet()) {\n+                    EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                    if (State.NEW.equals(eg.getState())) {\n+                        eg.requestStart();\n+                    }\n+                    servicesToTrack.add(eg);\n+                }\n \n-        EvergreenService.GlobalStateChangeListener listener = (service, oldState, newState) -> {\n-            if (serviceConfig.containsKey(service.getName()) && newState.equals(State.RUNNING)) {\n-                servicesRunningLatches.get(service.getName()).countDown();\n-            }\n-        };\n+                // wait until topic listeners finished processing mergeMap changes.\n+                context.runOnPublishQueueAndWait(() -> {\n+                    logger.atInfo(\"merge-config\")\n+                            .addKeyValue(\"serviceToTrack\", servicesToTrack)\n+                            .log(\"applied new service config. Waiting for services to complete update\");\n \n-        context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            context.runOnPublishQueueAndWait(() -> {\n-                try {\n-                    mergeMap(timestamp, newConfig);\n-                    context.addGlobalStateChangeListener(listener);\n-                    serviceConfig.keySet().forEach(serviceName -> {\n+                    // polling to wait for all services started.\n+                    context.get(ExecutorService.class).submit(() -> {\n+                        //TODO: Add timeout\n                         try {\n-                            EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                            eg.requestStart();\n-                        } catch (ServiceLoadException e) {\n-                            logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                    .log(\"Could not locate EvergreenService for modified service\");\n+                            while (!totallyCompleteFuture.isCancelled()) {\n+                                if (servicesToTrack.stream().allMatch(service -> {\n+                                    if (!service.reachedDesiredState()) {\n+                                        return false;\n+                                    }\n+                                    State state = service.getState();\n+                                    if (State.RUNNING.equals(state) || State.FINISHED.equals(state)) {\n+                                        return true;\n+                                    }\n+                                    return false;\n+                                })) {\n+                                    break;\n+                                }\n+                                Thread.sleep(1000); // hardcoded\n+                            }\n+                            if (totallyCompleteFuture.isCancelled()) {\n+                                logger.atWarn(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                    .log(\"merge-config-cancelled\");\n+                                return;\n+                            }\n+\n+                            removeServices(removedServices);\n+                            logger.atInfo(\"merge-config\").addKeyValue(\"deploymentId\", deploymentId)\n+                                .log(\"All services updated\");\n+\n+                            totallyCompleteFuture.complete(null);\n+                        } catch (Throwable t) {\n+                            //TODO: handle different throwables. Revert changes if applicable.\n+                            totallyCompleteFuture.completeExceptionally(t);\n                         }\n                     });\n-                } catch (Throwable e) {\n-                    totallyCompleteFuture.completeExceptionally(e);\n-                }\n-            });\n-        });\n-        // execute logic to close and clean up removed services.\n-        context.get(Executor.class).execute(() -> {\n-            try {\n-                for (Map.Entry<String, CountDownLatch> entry : servicesRunningLatches.entrySet()) {\n-                    logger.atDebug(\"merge-config\").log(\"Waiting for service {} to be running\", entry.getKey());\n-                    entry.getValue().await();\n-                }\n-                List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        EvergreenService eg = EvergreenService.locate(context, serviceName);\n-                        serviceClosedFutures.add(eg.close());\n-                    } catch (ServiceLoadException e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Could not locate EvergreenService to close service\");\n-                    }\n-                });\n-                // waiting for removed service to close before removing reference and config entry\n-                for (Future serviceClosedFuture : serviceClosedFutures) {\n-                    serviceClosedFuture.get();\n-                }\n-                removedServices.forEach(serviceName -> {\n-                    try {\n-                        context.remove(serviceName);\n-                        findTopics(\"services\", serviceName).remove();\n-                    } catch (Exception e) {\n-                        logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                                .log(\"Cloud not clean up resources while removing\");\n-                    }\n                 });\n-\n-                totallyCompleteFuture.complete(null);\n             } catch (Throwable e) {\n                 totallyCompleteFuture.completeExceptionally(e);\n             }\n         });\n-        totallyCompleteFuture.thenRun(() -> context.removeGlobalStateChangeListener(listener));\n+\n         return totallyCompleteFuture;\n     }\n \n+    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n+        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                EvergreenService eg = EvergreenService.locate(context, serviceName);\n+                serviceClosedFutures.add(eg.close());\n+            } catch (ServiceLoadException e) {\n+                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n+                        .log(\"Could not locate EvergreenService to close service\");\n+            }\n+        });\n+        // waiting for removed service to close before removing reference and config entry\n+        for (Future serviceClosedFuture : serviceClosedFutures) {\n+            serviceClosedFuture.get();\n+        }\n+        serviceToRemove.forEach(serviceName -> {\n+            try {\n+                context.remove(serviceName);\n+                findTopics(\"services\", serviceName).remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cefed1e995ab6c7c2ef8fa1505d1d91889b7e5b"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4944, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}