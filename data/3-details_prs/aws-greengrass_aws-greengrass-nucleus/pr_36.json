{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDc3MTYx", "number": 36, "title": "Add error recovery", "bodyText": "Start a service only when dependencies are ready\nStop a service when dependency errored.\nRestart a service automatically when dependency is recovered.\nSmall fixes:\nKernel shutdown wait until all tasks being processed before kernel process exit.\nRename Shutdown to Broken.\n\nIssue #, if available:\nDescription of changes:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-01-21T03:24:02Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36", "merged": true, "mergeCommit": {"oid": "6ea627d6e3a1c861957631adc2c9fc9748505f40"}, "closed": true, "closedAt": "2020-01-23T22:44:49Z", "author": {"login": "ShirleyZheng92"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8Y77jABqjI5NjQ3NjIyNTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9RSluAH2gAyMzY1MDc3MTYxOjdiMmUzZjE5NWFmODg3MzNlOTFkODBhNDIyN2YyOTU3ZDUzYTkxNmY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12f469fcecfdc6477cda1bd203192879b4e3b2ae", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/12f469fcecfdc6477cda1bd203192879b4e3b2ae", "committedDate": "2020-01-21T03:19:11Z", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n  1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n  1. Rename Shutdown to Broken."}, "afterCommit": {"oid": "3e82e9b29e950d73e769dd2cdc355a275e0a7050", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3e82e9b29e950d73e769dd2cdc355a275e0a7050", "committedDate": "2020-01-21T03:53:26Z", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n  1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n  1. Rename Shutdown to Broken."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afce75047644ef9b1250bf3366e87c65ca768f9b", "committedDate": "2020-01-21T19:17:35Z", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n    1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n    1. Rename Shutdown to Broken."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e82e9b29e950d73e769dd2cdc355a275e0a7050", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3e82e9b29e950d73e769dd2cdc355a275e0a7050", "committedDate": "2020-01-21T03:53:26Z", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n  1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n  1. Rename Shutdown to Broken."}, "afterCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/afce75047644ef9b1250bf3366e87c65ca768f9b", "committedDate": "2020-01-21T19:17:35Z", "message": "Add error recovery\n\n1. Start a service only when dependencies are ready\n1. Stop a service when dependency errored.\n1. Restart a service automatically when dependency is recovered.\n1. Small fixes:\n    1. Kernel shutdown wait until all tasks being processed before kernel process exit.\n    1. Rename Shutdown to Broken."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzU1ODQ5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-346755849", "createdAt": "2020-01-22T17:08:22Z", "commit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzowODoyM1rOFgkAnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzowODoyM1rOFgkAnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4ODczMg==", "bodyText": "In general, it's best to use the thread pool context.get(ExecutorService.class).submit(r), unless it's a long lived thread whose parameters you want to change (like priority or name).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369688732", "createdAt": "2020-01-22T17:08:23Z", "author": {"login": "JamesGosling"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,42 +46,93 @@ public boolean isRunningInternally() {\n     public boolean isPeriodic() { return periodicityInformation!=null; }\n     private boolean errorHandlerErrored; // cheezy hack to avoid repeating error handlers\n     public void setState(State s) {\n-        State was = (State) state.getOnce();\n+        final State was = (State) state.getOnce();\n+\n+\n         if(s!=was) {\n             context.getLog().note(getName(),was,\"=>\",s);\n-            state.setValue(Long.MAX_VALUE, s);\n-            context.globalNotifyStateChanged(this, was);\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (state) {\n+                state.setValue(Long.MAX_VALUE, s);\n+                context.globalNotifyStateChanged(this, was);\n+            }\n         }\n     }\n     private State activeState = State.New;\n+    CountDownLatch shutdownLatch = new CountDownLatch(0);\n     @Override // for listening to state changes\n     public void published(final WhatHappened what, final Topic topic) {\n         final State newState = (State) topic.getOnce();\n         if(activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n+            shutdownLatch = new CountDownLatch(1);\n+            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until shutdown task complete.\n+            // May consider just merge shutdown() into other state's handling.\n             setBackingTask(() -> {\n                 try {\n                     shutdown();\n                 } catch (Throwable t) {\n-                    errored(\"Failed shutting down\", t);\n+                    if (activeState != State.Errored) {\n+                        errored(\"Failed shutting down\", t);\n+                    } else {\n+                        context.getLog().error(this,\"Failed shutting down\", t);\n+                    }\n+                } finally {\n+                    shutdownLatch.countDown();\n                 }\n+                backingTask = null;\n             }, getName() + \"=>\" + newState);\n+\n+            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch() here.\n+            // However, this caused the global configuration publish queue being blocked.\n         }\n+\n         try {\n             switch(newState) {\n                 case Installing:\n-                    setBackingTask(() -> {\n+                    new Thread(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzY3NzQ4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-346767748", "createdAt": "2020-01-22T17:26:10Z", "commit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoyNjoxMFrOFgkktA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoyNjoxMFrOFgkktA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5Nzk3Mg==", "bodyText": "It would probably be good to add something like:\n// TODO Improve error restarts by collecting statistics on errors.  eg. If it error's often, start adding backoff waits.\n//  Maybe doing a little inspection of exceptions to be smarter.  eg. file system full messages could trigger a disk\n//  cleanup before the restart,  Or network errors could look at the network state and not restart until the network\n//  reconnects.\n\nWhich should end up as backlog SIMs", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369697972", "createdAt": "2020-01-22T17:26:10Z", "author": {"login": "JamesGosling"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -192,11 +246,31 @@ public void startup() {\n     protected void run() {\n         setState(State.Finished);\n     }\n+\n     /**\n      * Called when a running service encounters an error.\n      */\n     protected void handleError() {\n+        if (error != null) {\n+            context.getLog().error(\"Handle error\", error);\n+            error = null;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzY4MDkz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-346768093", "createdAt": "2020-01-22T17:26:41Z", "commit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MjI3OTU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-346227954", "createdAt": "2020-01-21T22:11:39Z", "commit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjoxMTo0MFrOFgKgUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoyODo0N1rOFgkpxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3MDg2Ng==", "bodyText": "why did you change this to final?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369270866", "createdAt": "2020-01-21T22:11:40Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/dependency/Context.java", "diffHunk": "@@ -118,7 +118,7 @@ public synchronized void removeGlobalStateChangeListener(EvergreenService.Global\n             if(listeners.isEmpty()) listeners = null;\n         }\n     }\n-    public void globalNotifyStateChanged(EvergreenService l, State was) {\n+    public void globalNotifyStateChanged(EvergreenService l, final State was) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTA1Mg==", "bodyText": "should waitForDependencyReady() throw InterruptedException instead of swallowing it so that we can move into an errored state if we are interrupted while waiting for dependencies?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699052", "createdAt": "2020-01-22T17:28:20Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,42 +46,93 @@ public boolean isRunningInternally() {\n     public boolean isPeriodic() { return periodicityInformation!=null; }\n     private boolean errorHandlerErrored; // cheezy hack to avoid repeating error handlers\n     public void setState(State s) {\n-        State was = (State) state.getOnce();\n+        final State was = (State) state.getOnce();\n+\n+\n         if(s!=was) {\n             context.getLog().note(getName(),was,\"=>\",s);\n-            state.setValue(Long.MAX_VALUE, s);\n-            context.globalNotifyStateChanged(this, was);\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (state) {\n+                state.setValue(Long.MAX_VALUE, s);\n+                context.globalNotifyStateChanged(this, was);\n+            }\n         }\n     }\n     private State activeState = State.New;\n+    CountDownLatch shutdownLatch = new CountDownLatch(0);\n     @Override // for listening to state changes\n     public void published(final WhatHappened what, final Topic topic) {\n         final State newState = (State) topic.getOnce();\n         if(activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n+            shutdownLatch = new CountDownLatch(1);\n+            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until shutdown task complete.\n+            // May consider just merge shutdown() into other state's handling.\n             setBackingTask(() -> {\n                 try {\n                     shutdown();\n                 } catch (Throwable t) {\n-                    errored(\"Failed shutting down\", t);\n+                    if (activeState != State.Errored) {\n+                        errored(\"Failed shutting down\", t);\n+                    } else {\n+                        context.getLog().error(this,\"Failed shutting down\", t);\n+                    }\n+                } finally {\n+                    shutdownLatch.countDown();\n                 }\n+                backingTask = null;\n             }, getName() + \"=>\" + newState);\n+\n+            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch() here.\n+            // However, this caused the global configuration publish queue being blocked.\n         }\n+\n         try {\n             switch(newState) {\n                 case Installing:\n-                    setBackingTask(() -> {\n+                    new Thread(() -> {\n+                        // wait until shutdown finished.\n+                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n                         try {\n-                            install();\n-                            setState(State.AwaitingStartup);\n-                        } catch (Throwable t) {\n-                            errored(\"Failed installing\", t);\n+                            shutdownLatch.await();\n+                        } catch (InterruptedException e) {\n+                            errored(\"waiting for shutdown complete\", e);\n+                            return;\n                         }\n-                        backingTask = null;\n-                    }, getName()+\" => \"+newState);\n+                        if (!errored() && getState() == State.Installing) {\n+                            setBackingTask(() -> {\n+                                try {\n+                                    install();\n+                                    if (!errored()) {\n+                                        setState(State.AwaitingStartup);\n+                                    }\n+                                } catch (Throwable t) {\n+                                    errored(\"Failed installing\", t);\n+                                }\n+                                backingTask = null;\n+                            }, getName() + \" => \" + newState);\n+                        }\n+                    }).start();\n+\n                     break;\n                 case AwaitingStartup:\n                     awaitingStartup();\n-                    if(!hasDependencies() && !errored()) setState(State.Starting);\n+                    new Thread(() -> {\n+                        // wait until shutdown finished.\n+                        try {\n+                            shutdownLatch.await();\n+                        } catch (InterruptedException e) {\n+                            errored(\"waiting for shutdown complete\", e);\n+                            return;\n+                        }\n+                        if (dependencies != null) {\n+                            waitForDependencyReady();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTI2OA==", "bodyText": "Do we want to print the stack when we are interrupted?\nIf it is interrupted, is that the same as all the dependencies being ready?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699268", "createdAt": "2020-01-22T17:28:47Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();\n+            }\n+        });\n     }\n-    private boolean hasDependencies() {\n-        return dependencies != null\n-                && (dependencies.entrySet().stream().anyMatch(ls -> ls.getKey().getState().preceeds(ls.getValue())));\n+\n+    private boolean dependencyReady() {\n+        if (dependencies == null) {\n+            return true;\n+        }\n+        return dependencies.entrySet().stream().allMatch(ls -> dependencyReady(ls.getKey()));\n     }\n-    public void forAllDependencies(Consumer<? super EvergreenService> f) {\n-        if(dependencies!=null) dependencies.keySet().forEach(f);\n+\n+    private boolean dependencyReady(EvergreenService v) {\n+        State state = v.getState();\n+        State startWhenState = dependencies.get(v);\n+        return (state.isHappy()) && startWhenState.preceedsOrEqual(state);\n     }\n-    private void recheckOthersDependencies() {\n-        if (context != null) {\n-            final AtomicBoolean changed = new AtomicBoolean(true);\n-            while (changed.get()) {\n-                changed.set(false);\n-                context.forEach(v -> {\n-                    Object vv = v.value;\n-                    if(vv instanceof EvergreenService) {\n-                        EvergreenService l = (EvergreenService) vv;\n-                        if (l.inState(State.AwaitingStartup)) {\n-                            if (!l.hasDependencies()) {\n-                                l.setState(State.Starting);\n-                                changed.set(true);\n-                            }\n-                        }\n-                    }\n-                });\n-            }\n+\n+    private void waitForDependencyReady() {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+\n+        try {\n+            dependencyReadyLatch.await();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 273}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzYyMjAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-346762200", "createdAt": "2020-01-22T17:17:46Z", "commit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoxNzo0NlrOFgkTxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNzoyOTozNVrOFgkrQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MzYzNg==", "bodyText": "Why convert to a linked list? Just use the List given by Arrays.asList.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369693636", "createdAt": "2020-01-22T17:17:46Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelTest.java", "diffHunk": "@@ -2,16 +2,102 @@\n  * SPDX-License-Identifier: Apache-2.0 */\n package com.aws.iot.evergreen.kernel;\n \n+import java.util.Arrays;\n+import java.util.LinkedList;\n import java.util.concurrent.*;\n \n+import com.aws.iot.evergreen.dependency.State;\n import org.junit.jupiter.api.Test;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \n public class KernelTest {\n-//    boolean seenDocker, seenShell;\n+//    boolean seenDocker, seenShell\n //    int seenTickTock = 4;\n //    long lastTickTock = 0;\n+    @Test\n+    public void testErrorRetry() throws InterruptedException {\n+            String tdir = System.getProperty(\"user.home\") + \"/kernelTest\";\n+            Kernel kernel = new Kernel();\n+            kernel.parseArgs(\"-r\", tdir,\n+                    \"-log\", \"stdout\",\n+                    \"-i\", Kernel.class.getResource(\"config_broken.yaml\").toString()\n+            );\n+\n+        LinkedList<ExpectedStateTransition> expectedStateTransitionList = new LinkedList<>(Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NjE2Nw==", "bodyText": "Looks like you never check this ok.\nFor these async assertions, I think we may want to try maybe a CompletableFuture which we can wait to complete or error, and then calling .get() on the future will cause it to throw the exception if there was any.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369696167", "createdAt": "2020-01-22T17:22:46Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/kernel/KernelTest.java", "diffHunk": "@@ -2,16 +2,102 @@\n  * SPDX-License-Identifier: Apache-2.0 */\n package com.aws.iot.evergreen.kernel;\n \n+import java.util.Arrays;\n+import java.util.LinkedList;\n import java.util.concurrent.*;\n \n+import com.aws.iot.evergreen.dependency.State;\n import org.junit.jupiter.api.Test;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \n public class KernelTest {\n-//    boolean seenDocker, seenShell;\n+//    boolean seenDocker, seenShell\n //    int seenTickTock = 4;\n //    long lastTickTock = 0;\n+    @Test\n+    public void testErrorRetry() throws InterruptedException {\n+            String tdir = System.getProperty(\"user.home\") + \"/kernelTest\";\n+            Kernel kernel = new Kernel();\n+            kernel.parseArgs(\"-r\", tdir,\n+                    \"-log\", \"stdout\",\n+                    \"-i\", Kernel.class.getResource(\"config_broken.yaml\").toString()\n+            );\n+\n+        LinkedList<ExpectedStateTransition> expectedStateTransitionList = new LinkedList<>(Arrays.asList(\n+                new ExpectedStateTransition(\"installErrorRetry\", State.New, State.Installing),\n+                new ExpectedStateTransition(\"installErrorRetry\", State.Installing, State.Errored),\n+                new ExpectedStateTransition(\"installErrorRetry\", State.Errored, State.Installing),\n+                new ExpectedStateTransition(\"installErrorRetry\", State.Installing, State.AwaitingStartup),\n+\n+                // main service doesn't start until dependency ready\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Starting, State.Running),\n+                new ExpectedStateTransition(\"main\", State.AwaitingStartup, State.Starting),\n+                new ExpectedStateTransition(\"main\", State.Starting, State.Running),\n+\n+                // runErrorRetry restart on error\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Running, State.Errored),\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Errored, State.AwaitingStartup),\n+\n+                // main service restart on dependency error\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Running, State.Errored),\n+                new ExpectedStateTransition(\"main\", State.Running, State.AwaitingStartup),\n+                new ExpectedStateTransition(\"runErrorRetry\", State.Starting, State.Running),\n+                new ExpectedStateTransition(\"main\", State.AwaitingStartup, State.Starting)\n+            ));\n+\n+        CountDownLatch assertionLatch = new CountDownLatch(1);\n+\n+        kernel.context.addGlobalStateChangeListener((EvergreenService service, State was) -> {\n+            if (expectedStateTransitionList.size() == 0) {\n+                return;\n+            }\n+\n+            ExpectedStateTransition expected = expectedStateTransitionList.peek();\n+\n+            if (service.getName().equals(expected.serviceName) &&\n+                was.equals(expected.was) &&\n+                service.getState().equals(expected.current)) {\n+                System.out.println(String.format(\"Just saw state event for service %s: %s=> %s\",\n+                        expected.serviceName,\n+                        expected.was,\n+                        expected.current\n+                        ));\n+\n+                expectedStateTransitionList.pollFirst();\n+                if (expectedStateTransitionList.size() == 0) {\n+                    // all assersion done.\n+                    assertionLatch.countDown();\n+                }\n+            }\n+\n+        });\n+        kernel.launch();\n+        boolean ok = assertionLatch.await(60, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NzIwMQ==", "bodyText": "I'd probably let this throw to the caller instead of trying to handle it in here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369697201", "createdAt": "2020-01-22T17:24:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();\n+            }\n+        });\n     }\n-    private boolean hasDependencies() {\n-        return dependencies != null\n-                && (dependencies.entrySet().stream().anyMatch(ls -> ls.getKey().getState().preceeds(ls.getValue())));\n+\n+    private boolean dependencyReady() {\n+        if (dependencies == null) {\n+            return true;\n+        }\n+        return dependencies.entrySet().stream().allMatch(ls -> dependencyReady(ls.getKey()));\n     }\n-    public void forAllDependencies(Consumer<? super EvergreenService> f) {\n-        if(dependencies!=null) dependencies.keySet().forEach(f);\n+\n+    private boolean dependencyReady(EvergreenService v) {\n+        State state = v.getState();\n+        State startWhenState = dependencies.get(v);\n+        return (state.isHappy()) && startWhenState.preceedsOrEqual(state);\n     }\n-    private void recheckOthersDependencies() {\n-        if (context != null) {\n-            final AtomicBoolean changed = new AtomicBoolean(true);\n-            while (changed.get()) {\n-                changed.set(false);\n-                context.forEach(v -> {\n-                    Object vv = v.value;\n-                    if(vv instanceof EvergreenService) {\n-                        EvergreenService l = (EvergreenService) vv;\n-                        if (l.inState(State.AwaitingStartup)) {\n-                            if (!l.hasDependencies()) {\n-                                l.setState(State.Starting);\n-                                changed.set(true);\n-                            }\n-                        }\n-                    }\n-                });\n-            }\n+\n+    private void waitForDependencyReady() {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+\n+        try {\n+            dependencyReadyLatch.await();\n+        } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5NzYzNA==", "bodyText": "Since you're only using the key, you can use the keySet instead of entries.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369697634", "createdAt": "2020-01-22T17:25:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();\n+            }\n+        });\n     }\n-    private boolean hasDependencies() {\n-        return dependencies != null\n-                && (dependencies.entrySet().stream().anyMatch(ls -> ls.getKey().getState().preceeds(ls.getValue())));\n+\n+    private boolean dependencyReady() {\n+        if (dependencies == null) {\n+            return true;\n+        }\n+        return dependencies.entrySet().stream().allMatch(ls -> dependencyReady(ls.getKey()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTE1Ng==", "bodyText": "This doesn't look threadsafe to me. A different thread could be waiting on a latch which you then set to a different instance of a latch. I'm pretty sure this won't work properly, especially with multiple dependencies that we're waiting for.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699156", "createdAt": "2020-01-22T17:28:33Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5OTY0OA==", "bodyText": "This latch that you're counting down isn't necessarily the same latch that some other thread is waiting for, so the waiting thread might get stuck waiting forever.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369699648", "createdAt": "2020-01-22T17:29:35Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +279,65 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    dependencyReadyLatch = new CountDownLatch(1);\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);\n+                }\n+            } else if (dependencyReady()) {\n+                dependencyReadyLatch.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afce75047644ef9b1250bf3366e87c65ca768f9b"}, "originalPosition": 224}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b83f3c8daa016cb9a6cc52de0699566982782e08", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b83f3c8daa016cb9a6cc52de0699566982782e08", "committedDate": "2020-01-22T19:37:20Z", "message": "remove InstallOnly mode."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/f202bdded7c353543d5138d8e62cb64558ae54e7", "committedDate": "2020-01-22T22:26:30Z", "message": "Use object lock&notify in waitForDependencyReady()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTg0OTI0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-346984924", "createdAt": "2020-01-22T23:55:12Z", "commit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzo1NToxMlrOFgvCuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMzo1NToxMlrOFgvCuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2OTQ5Ng==", "bodyText": "if you are switching to wait/notifyAll, then this doesn't need to be a latch at all. You could just use new Object()\nYou could rename this as final Object dependencyLock = new Object() and use that instead", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r369869496", "createdAt": "2020-01-22T23:55:12Z", "author": {"login": "rbattle"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -287,7 +299,7 @@ public void close() {\n \n     public Context getContext() { return context; }\n \n-    CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n+    final CountDownLatch dependencyReadyLatch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDcyOTU3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-347472957", "createdAt": "2020-01-23T17:20:19Z", "commit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzoyMDoyMFrOFhGUqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNzoyODozNlrOFhGkyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MDkyMg==", "bodyText": "Do you ever reset this value to be false?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370250922", "createdAt": "2020-01-23T17:20:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -113,25 +170,30 @@ public void published(final WhatHappened what, final Topic topic) {\n                     }\n                     break;\n                 case Errored:\n-                    try {\n-                        if(!errorHandlerErrored) handleError();\n-                    } catch (Throwable t) {\n-                        errorHandlerErrored = true;\n-                        errored(\"Error handler failed\", t);\n-                    }\n+                    if (activeState != State.Errored) // already in the process of error handling\n+                        try {\n+                            if(!errorHandlerErrored) handleError();\n+                        } catch (Throwable t) {\n+                            errorHandlerErrored = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1MjA0Mg==", "bodyText": "I thought we were going to have some different behavior here, like a service that can handle its dependencies being down. It's fine not to have right now, but please add a TODO here if I'm remembering correctly.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370252042", "createdAt": "2020-01-23T17:22:32Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -205,47 +291,63 @@ public void shutdown() {\n         Periodicity t = periodicityInformation;\n         if(t!=null) t.shutdown();\n     }\n-    /**\n-     * Sets the state to Shutdown\n-     */\n+\n     @Override\n     public void close() {\n-        setState(State.Shutdown);\n+        setState(State.Finished);\n     }\n+\n     public Context getContext() { return context; }\n+\n+    final CountDownLatch dependencyReadyLatch = new CountDownLatch(1);\n     public void addDependency(EvergreenService v, State when) {\n         if (dependencies == null)\n             dependencies = new ConcurrentHashMap<>();\n         context.get(Kernel.class).clearODcache();\n         dependencies.put(v, when);\n+\n+        v.getStateTopic().subscribe((WhatHappened what, Topic t) -> {\n+            if (this.getState() == State.Starting || this.getState().isRunning()) {\n+                // if dependency is down, restart the service and wait for dependency up\n+                if (!dependencyReady(v)) {\n+                    context.getLog().note(\"Restart service because of dependency error. \", this.getName());\n+                    this.setState(State.AwaitingStartup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1NDYzNQ==", "bodyText": "Since the state machine just runs, maybe this should be renamed. Maybe \"startupAllServices\"? Or anything else really, since installEverything doesn't really cover the whole scope of what will result from calling it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370254635", "createdAt": "2020-01-23T17:27:47Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -224,8 +220,6 @@ public Kernel launch() {\n         writeEffectiveConfig();\n         try {\n             installEverything();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1NTA1MQ==", "bodyText": "May need a timer and then a shutdown(true) to force it to stop.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#discussion_r370255051", "createdAt": "2020-01-23T17:28:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -368,13 +352,23 @@ public void shutdown() {\n         try {\n             log.significant(\"Shutting everything down\", getMain());\n             EvergreenService[] d = orderedDependencies().toArray(new EvergreenService[0]);\n-            for (int i = d.length; --i >= 0;) // shutdown in reverse order\n+            for (int i = d.length; --i >= 0;) { // shutdown in reverse order\n                 if (d[i].inState(State.Running))\n                     try {\n                         d[i].close();\n                     } catch (Throwable t) {\n                         log.error(d[i], \"Failed to shutdown\", t);\n                     }\n+            }\n+\n+            // Wait for tasks in the executor to end.\n+            ExecutorService executorService = context.get(ExecutorService.class);\n+            this.context.runOnPublishQueueAndWait(() -> {\n+                executorService.shutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f202bdded7c353543d5138d8e62cb64558ae54e7"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efbbeefd35425797d037ebeca3997af9c6614695", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/efbbeefd35425797d037ebeca3997af9c6614695", "committedDate": "2020-01-23T20:23:18Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NjAyNjgx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/36#pullrequestreview-347602681", "createdAt": "2020-01-23T20:59:04Z", "commit": {"oid": "efbbeefd35425797d037ebeca3997af9c6614695"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4553af4bef0bad8e819560298fb504d13f39a6da", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4553af4bef0bad8e819560298fb504d13f39a6da", "committedDate": "2020-01-23T20:59:20Z", "message": "Merge branch 'master' into errHandle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b2e3f195af88733e91d80a4227f2957d53a916f", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/7b2e3f195af88733e91d80a4227f2957d53a916f", "committedDate": "2020-01-23T21:33:00Z", "message": "Merge branch 'master' into errHandle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2440, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}