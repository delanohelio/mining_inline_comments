{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMjM2ODM0", "number": 342, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNToyNDoyMlrOEUGQfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoxNDoyNFrOEUIXDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTA5NTAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelLifecycle.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNToyNDoyMlrOG6MjcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzozMDowN1rOG6ZWaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NjI3Mg==", "bodyText": "Should we actually flip these, since that's the behavior when it is running; it reads the config then writes changes to tlog?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463676272", "createdAt": "2020-07-31T15:24:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelLifecycle.java", "diffHunk": "@@ -114,6 +91,42 @@ public void launch() {\n         startupAllServices();\n     }\n \n+    private void initConfigAndTlog() {\n+        Path transactionLogPath = kernel.getConfigPath().resolve(\"config.tlog\");\n+        Path configurationFile = kernel.getConfigPath().resolve(\"config.yaml\");\n+\n+\n+        try {\n+            if (Objects.nonNull(kernelCommandLine.getProvidedConfigPathName())) {\n+                // If a config file is provided, kernel will use the provided file as a new base\n+                // and ignore existing config and tlog files.\n+                // This ideally should only used for testing and not in production\n+                kernel.getConfig().read(kernelCommandLine.getProvidedConfigPathName());\n+            } else {\n+                // if tlog presents, read the tlog first, because the yaml config file may not be up to date\n+                if (Files.exists(transactionLogPath)) {\n+                    kernel.getConfig().read(transactionLogPath);\n+                }\n+\n+                // if configuration file is available, merge it. It will be merged with file's last modified timestamp\n+                if (Files.exists(configurationFile)) {\n+                    kernel.getConfig().read(configurationFile);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NTkyOQ==", "bodyText": "I thought about that as well. But I now think the order here doesn't really matter since we do timestamp merge... The result is going to be the same no matter which one we merge first, right? Maybe I should just update the comment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463885929", "createdAt": "2020-07-31T23:30:07Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelLifecycle.java", "diffHunk": "@@ -114,6 +91,42 @@ public void launch() {\n         startupAllServices();\n     }\n \n+    private void initConfigAndTlog() {\n+        Path transactionLogPath = kernel.getConfigPath().resolve(\"config.tlog\");\n+        Path configurationFile = kernel.getConfigPath().resolve(\"config.yaml\");\n+\n+\n+        try {\n+            if (Objects.nonNull(kernelCommandLine.getProvidedConfigPathName())) {\n+                // If a config file is provided, kernel will use the provided file as a new base\n+                // and ignore existing config and tlog files.\n+                // This ideally should only used for testing and not in production\n+                kernel.getConfig().read(kernelCommandLine.getProvidedConfigPathName());\n+            } else {\n+                // if tlog presents, read the tlog first, because the yaml config file may not be up to date\n+                if (Files.exists(transactionLogPath)) {\n+                    kernel.getConfig().read(transactionLogPath);\n+                }\n+\n+                // if configuration file is available, merge it. It will be merged with file's last modified timestamp\n+                if (Files.exists(configurationFile)) {\n+                    kernel.getConfig().read(configurationFile);\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NjI3Mg=="}, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTA5ODQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNToyNTowNVrOG6MlZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzozMDoxNVrOG6ZWgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3Njc3Mw==", "bodyText": "[nit]\nJust say in-memory", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463676773", "createdAt": "2020-07-31T15:25:05Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "diffHunk": "@@ -0,0 +1,27 @@\n+# Kernel\n+\n+### How kernel reads config.tlog and config.yaml when starting\n+![Alt text](kernelTlog.svg)\n+\n+### Potential issues\n+Ideally right after we create the in-mem config, we should", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NTk1NA==", "bodyText": "Thanks!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463885954", "createdAt": "2020-07-31T23:30:15Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "diffHunk": "@@ -0,0 +1,27 @@\n+# Kernel\n+\n+### How kernel reads config.tlog and config.yaml when starting\n+![Alt text](kernelTlog.svg)\n+\n+### Potential issues\n+Ideally right after we create the in-mem config, we should", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3Njc3Mw=="}, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTA5ODg2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNToyNToxMVrOG6Mlpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzozMDoyMlrOG6ZWmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NjgzOQ==", "bodyText": "provide alt text", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463676839", "createdAt": "2020-07-31T15:25:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "diffHunk": "@@ -0,0 +1,27 @@\n+# Kernel\n+\n+### How kernel reads config.tlog and config.yaml when starting\n+![Alt text](kernelTlog.svg)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NTk3Nw==", "bodyText": "hah will do", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463885977", "createdAt": "2020-07-31T23:30:22Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "diffHunk": "@@ -0,0 +1,27 @@\n+# Kernel\n+\n+### How kernel reads config.tlog and config.yaml when starting\n+![Alt text](kernelTlog.svg)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NjgzOQ=="}, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTEwNDMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelLifecycle.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNToyNjo1MVrOG6MpEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzozMjo1N1rOG6ZYrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NzcxMg==", "bodyText": "get rid of effectiveConfig.evg? Since you're writing it into the main config file?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463677712", "createdAt": "2020-07-31T15:26:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelLifecycle.java", "diffHunk": "@@ -114,6 +91,42 @@ public void launch() {\n         startupAllServices();\n     }\n \n+    private void initConfigAndTlog() {\n+        Path transactionLogPath = kernel.getConfigPath().resolve(\"config.tlog\");\n+        Path configurationFile = kernel.getConfigPath().resolve(\"config.yaml\");\n+\n+\n+        try {\n+            if (Objects.nonNull(kernelCommandLine.getProvidedConfigPathName())) {\n+                // If a config file is provided, kernel will use the provided file as a new base\n+                // and ignore existing config and tlog files.\n+                // This ideally should only used for testing and not in production\n+                kernel.getConfig().read(kernelCommandLine.getProvidedConfigPathName());\n+            } else {\n+                // if tlog presents, read the tlog first, because the yaml config file may not be up to date\n+                if (Files.exists(transactionLogPath)) {\n+                    kernel.getConfig().read(transactionLogPath);\n+                }\n+\n+                // if configuration file is available, merge it. It will be merged with file's last modified timestamp\n+                if (Files.exists(configurationFile)) {\n+                    kernel.getConfig().read(configurationFile);\n+                }\n+            }\n+\n+            // write new tlog and config files\n+            kernel.writeEffectiveConfigAsTransactionLog(transactionLogPath);\n+            kernel.writeEffectiveConfig(configurationFile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjIyMQ==", "bodyText": "Yeah... The effectiveConfig.evg is not really helpful now. Also I want to ask when should we update the main config file? Initially I thought we should always update the config file when in-memory config changes, just like Tlog.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463886221", "createdAt": "2020-07-31T23:31:39Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelLifecycle.java", "diffHunk": "@@ -114,6 +91,42 @@ public void launch() {\n         startupAllServices();\n     }\n \n+    private void initConfigAndTlog() {\n+        Path transactionLogPath = kernel.getConfigPath().resolve(\"config.tlog\");\n+        Path configurationFile = kernel.getConfigPath().resolve(\"config.yaml\");\n+\n+\n+        try {\n+            if (Objects.nonNull(kernelCommandLine.getProvidedConfigPathName())) {\n+                // If a config file is provided, kernel will use the provided file as a new base\n+                // and ignore existing config and tlog files.\n+                // This ideally should only used for testing and not in production\n+                kernel.getConfig().read(kernelCommandLine.getProvidedConfigPathName());\n+            } else {\n+                // if tlog presents, read the tlog first, because the yaml config file may not be up to date\n+                if (Files.exists(transactionLogPath)) {\n+                    kernel.getConfig().read(transactionLogPath);\n+                }\n+\n+                // if configuration file is available, merge it. It will be merged with file's last modified timestamp\n+                if (Files.exists(configurationFile)) {\n+                    kernel.getConfig().read(configurationFile);\n+                }\n+            }\n+\n+            // write new tlog and config files\n+            kernel.writeEffectiveConfigAsTransactionLog(transactionLogPath);\n+            kernel.writeEffectiveConfig(configurationFile);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NzcxMg=="}, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NjUxMQ==", "bodyText": "Definitely not all the time. Leave that for later.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463886511", "createdAt": "2020-07-31T23:32:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/KernelLifecycle.java", "diffHunk": "@@ -114,6 +91,42 @@ public void launch() {\n         startupAllServices();\n     }\n \n+    private void initConfigAndTlog() {\n+        Path transactionLogPath = kernel.getConfigPath().resolve(\"config.tlog\");\n+        Path configurationFile = kernel.getConfigPath().resolve(\"config.yaml\");\n+\n+\n+        try {\n+            if (Objects.nonNull(kernelCommandLine.getProvidedConfigPathName())) {\n+                // If a config file is provided, kernel will use the provided file as a new base\n+                // and ignore existing config and tlog files.\n+                // This ideally should only used for testing and not in production\n+                kernel.getConfig().read(kernelCommandLine.getProvidedConfigPathName());\n+            } else {\n+                // if tlog presents, read the tlog first, because the yaml config file may not be up to date\n+                if (Files.exists(transactionLogPath)) {\n+                    kernel.getConfig().read(transactionLogPath);\n+                }\n+\n+                // if configuration file is available, merge it. It will be merged with file's last modified timestamp\n+                if (Files.exists(configurationFile)) {\n+                    kernel.getConfig().read(configurationFile);\n+                }\n+            }\n+\n+            // write new tlog and config files\n+            kernel.writeEffectiveConfigAsTransactionLog(transactionLogPath);\n+            kernel.writeEffectiveConfig(configurationFile);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY3NzcxMg=="}, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTQzOTQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNzoxNDoyNFrOG6P6Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzozNTowMlrOG6ZajA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMTIyMw==", "bodyText": "I'm not fully understanding this statement but, we do want to be able to update system config or what you're calling provisioning config here via deployments, since those updates go to the tlog file, when restarting next time for whatever reason, that history should not be wiped out", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463731223", "createdAt": "2020-07-31T17:14:24Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "diffHunk": "@@ -0,0 +1,27 @@\n+# Kernel\n+\n+### How kernel reads config.tlog and config.yaml when starting\n+![Alt text](kernelTlog.svg)\n+\n+### Potential issues\n+Ideally right after we create the in-mem config, we should\n+1. decide if kernel needs to merge from existing tlog/config file to restore the history\n+1. hook up the tlog listener so that every update to in-mem config is then captured to tlog automatically.\n+\n+But now both 1 and 2 are done at later stage. This causes two potential issues but neither is a real issue now. It may \n+become real issue if some conditions changes. So we are documenting them below.\n+\n+1. Since the tlog listener only created at very late stage, a potential problem is that the changes to in-mem config \n+before the listener gets hooked up will be only in the memory. \n+\n+   1. We get around this problem by dumping the in-mem to a \n+new tlog file right after we have merged existing tlog/config.\n+\n+2. Since kernel merges from existing tlog/config file after the provision step, and the provision step updates the \n+in-mem config, a potential issue is that the provision step will always update in-mem config, without knowing the \n+histories from existing tlog/config files. \n+\n+   1. This is not a real issue for now because the provision step will only \n+be executed if a user specifies doing so. When a user specifies that he or she wants to do provision, then it's fine\n+to always update in-mem config and ignores the history in tlog. But this condition may change in the future.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4Njk4OA==", "bodyText": "Right. It's very hard to explain (even to myself)... So we can sync offline.\nBut we kinda get round the \"wiped out\" problem because if user doesn't do --provision, then the provision step sets default with timestamp 1 and when it merges previous tlog, the settings will get merged in (with timestamp > 1).\nIf user does --provision, then it is okay to override...", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/342#discussion_r463886988", "createdAt": "2020-07-31T23:35:02Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/README.md", "diffHunk": "@@ -0,0 +1,27 @@\n+# Kernel\n+\n+### How kernel reads config.tlog and config.yaml when starting\n+![Alt text](kernelTlog.svg)\n+\n+### Potential issues\n+Ideally right after we create the in-mem config, we should\n+1. decide if kernel needs to merge from existing tlog/config file to restore the history\n+1. hook up the tlog listener so that every update to in-mem config is then captured to tlog automatically.\n+\n+But now both 1 and 2 are done at later stage. This causes two potential issues but neither is a real issue now. It may \n+become real issue if some conditions changes. So we are documenting them below.\n+\n+1. Since the tlog listener only created at very late stage, a potential problem is that the changes to in-mem config \n+before the listener gets hooked up will be only in the memory. \n+\n+   1. We get around this problem by dumping the in-mem to a \n+new tlog file right after we have merged existing tlog/config.\n+\n+2. Since kernel merges from existing tlog/config file after the provision step, and the provision step updates the \n+in-mem config, a potential issue is that the provision step will always update in-mem config, without knowing the \n+histories from existing tlog/config files. \n+\n+   1. This is not a real issue for now because the provision step will only \n+be executed if a user specifies doing so. When a user specifies that he or she wants to do provision, then it's fine\n+to always update in-mem config and ignores the history in tlog. But this condition may change in the future.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczMTIyMw=="}, "originalCommit": {"oid": "627ef628ee5e2000392be1088e705fe931049c0b"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4491, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}