{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2OTM3Njcx", "number": 64, "title": "State machine refactor", "bodyText": "Issue #, if available:\nPreviously, the state machine doesn't reflect the true state of service. Service set state first before state machine handles the state transition.\nThis commit includes:\n\nUse desiredStateList to record the lifecycle request from external service. every lifecycle request will override desiredStateList\nDesiredState is explicit.\nState machine gets notified whenever a reportState() is invoked, or desiredStateList is updated.\n\nDescription of changes:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-02-19T02:59:32Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64", "merged": true, "mergeCommit": {"oid": "ee67dd5ead5e3ebdcca8625e609d140204d783f9"}, "closed": true, "closedAt": "2020-02-21T20:54:56Z", "author": {"login": "ShirleyZheng92"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFveqaAFqTM2MDg0Njc4MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGlXvngBqjMwNjE3NDcxMDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODQ2Nzgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-360846780", "createdAt": "2020-02-19T05:14:44Z", "commit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODU0Nzc3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-360854777", "createdAt": "2020-02-19T05:45:14Z", "commit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNTo0NToxNFrOFrbxPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNTo0NToxNFrOFrbxPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODA2Mg==", "bodyText": "Use our logger if possible, and if not, this may well be fine to ignore. This is using the actual hostname as a platform (which we may not want to be supporting anyway).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088062", "createdAt": "2020-02-19T05:45:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/PlatformResolver.java", "diffHunk": "@@ -71,6 +71,7 @@\n         try {\n             ranks.put(InetAddress.getLocalHost().getHostName(), 99);\n         } catch (UnknownHostException ex) {\n+            ex.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODU0OTE5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-360854919", "createdAt": "2020-02-19T05:45:42Z", "commit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNTo0NTo0M1rOFrbxpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjoxMjoxOFrOFrcJJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODE2Nw==", "bodyText": "I believe this should be started up in the constructor without needing to be explicitly called.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088167", "createdAt": "2020-02-19T05:45:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -60,8 +59,21 @@ public EvergreenService(Topics topics) {\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODMyMA==", "bodyText": "I think this may need to catch Throwable and have some strong error handling, since if the state machine thread dies, that's a big problem for the service. Probably it should auto-restart the thread.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088320", "createdAt": "2020-02-19T05:46:25Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -60,8 +59,21 @@ public EvergreenService(Topics topics) {\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        }).start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODQ4MA==", "bodyText": "Use your getState function here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088480", "createdAt": "2020-02-19T05:47:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {\n+        final State currentState = (State) this.state.getOnce();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODUyMQ==", "bodyText": "Prefer .equals()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088521", "createdAt": "2020-02-19T05:47:19Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {\n+        final State currentState = (State) this.state.getOnce();\n+\n+        if (newState != currentState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODY1MQ==", "bodyText": "Why long max? Shouldn't it get the current timestamp, since that is the proper time that the change is happening.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088651", "createdAt": "2020-02-19T05:48:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {\n+        final State currentState = (State) this.state.getOnce();\n+\n+        if (newState != currentState) {\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (this.state) {\n+                this.state.setValue(Long.MAX_VALUE, newState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODkzMg==", "bodyText": "Why 100? If we think it can only have up to 2 or 3 entries, let's just force it to that size (at least for now until we find we need more room).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381088932", "createdAt": "2020-02-19T05:49:09Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTI3MQ==", "bodyText": "Rename the input state. I think it has the meaning of currentState or activeState, but I'm unsure, so best to rename it to what it actually is.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381089271", "createdAt": "2020-02-19T05:50:40Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTg4OA==", "bodyText": "These methods seem a little odd since they don't start, stop, restart, or reinstall; they request that that happens. I would expect methods like these to block until the task is completed and then return the success. If you want to keep these methods as-is, which I think would be ok except for the return value, then I would rename them to requestX or something like that.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381089888", "createdAt": "2020-02-19T05:53:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4OTk4MQ==", "bodyText": "I think this should be protected so only subclasses can claim they are in an errored state", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381089981", "createdAt": "2020-02-19T05:53:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MDIwNw==", "bodyText": "There's no way to escape from broken?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381090207", "createdAt": "2020-02-19T05:54:59Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MDg0Ng==", "bodyText": "These should all be break to break the switch, not continue to continue the loop. If we added logic after the switch it would never be executed with these continues.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381090846", "createdAt": "2020-02-19T05:57:36Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTAyOQ==", "bodyText": "Why isn't this running in the backing task too? If we wanted to have timeouts and cancellation, then it would need to be, right? And I think that we do want those abilities.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091029", "createdAt": "2020-02-19T05:58:27Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTMxNA==", "bodyText": "This should be enforced when setting the desired state list. At least the states which are never allowed to be desired should be filtered out at that point.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091314", "createdAt": "2020-02-19T05:59:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);\n+                                } catch (InterruptedException e) {\n+                                    return;\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n-                    break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n+                            synchronized (stateChangeEvent) {\n+                                if (getState() == State.Installed) {\n+                                    stateChangeEvent.wait();\n+                                }\n                             }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n-                        }\n-                    }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTc1OA==", "bodyText": "Why setting it to null is needed? Shouldn't the backing task finish up once startup is done, and then there shouldn't be anything else to do.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091758", "createdAt": "2020-02-19T06:01:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MTk5Ng==", "bodyText": "instead of setting the backing task to null, should we have a function to kill the task and then set it to null? That may be a nicer API. stopBackingTask().", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381091996", "createdAt": "2020-02-19T06:02:50Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjIyOQ==", "bodyText": "Since we're reusing this pattern a lot it should be extractable to a function that just takes the current state.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092229", "createdAt": "2020-02-19T06:03:51Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);\n+                                } catch (InterruptedException e) {\n+                                    return;\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n-                    break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n+                            synchronized (stateChangeEvent) {\n+                                if (getState() == State.Installed) {\n+                                    stateChangeEvent.wait();\n+                                }\n                             }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n-                        }\n-                    }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n+                    continue;\n                 case Running:\n-                    if (!activeState.isRunning()) {\n-                        setBackingTask(() -> {\n-                            try {\n-                                run();\n-                                // subclasses implementing run() should handle state transition;\n-                            } catch (Throwable t) {\n-                                errored(\"Failed starting up\", t);\n-                            }\n-                            backingTask = null;\n-                        }, getName() + \" => \" + newState);\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Running);\n+                    if (desiredState == null || desiredState == State.Running) {\n+                        waitOnStateChangeEvent(State.Running);\n+                        continue;\n                     }\n-                    break;\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    shutdown();\n+                    if (this.getState() != State.Errored) {\n+                        setState(State.Finished);\n+                    }\n+                    continue;\n+                case Finished:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Finished);\n+                    if (desiredState == null || desiredState == State.Finished) {\n+                        waitOnStateChangeEvent(State.Finished);\n+                        continue;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjQ3Nw==", "bodyText": "Right now there's no way for a service to get into the broken state it seems. Am I right in saying that?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092477", "createdAt": "2020-02-19T06:04:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +216,227 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(100);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n+    private State peekOrRemoveFirstDesiredState(State state) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == state) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n+            }\n         }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            synchronized (stateChangeEvent) {\n+                stateChangeEvent.notifyAll();\n+            }\n         }\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean startService() {\n+        setDesiredState(State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean stopService() {\n+        setDesiredState(State.Finished);\n+        return true;\n+    }\n+\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean restartService() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean reInstallService() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n+\n+    /**\n+     * Error out a service.\n+     */\n+    public void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void waitOnStateChangeEvent(State currentState) throws InterruptedException {\n+        synchronized (stateChangeEvent) {\n+            while (desiredStateList.isEmpty() && getState() == currentState) {\n+                stateChangeEvent.wait();\n+            }\n+        }\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (true) {\n+            State desiredState = null;\n+            switch (this.getState()) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.New);\n+                    if (desiredState == null || desiredState == State.New) {\n+                        waitOnStateChangeEvent(State.New);\n+                        continue;\n+                    }\n+                    try {\n+                        install();\n+                    } catch (Throwable t) {\n+                        errored(\"Error in install\", t);\n+                    }\n+                    if (getState() != State.Errored) {\n+                        setState(State.Installed);\n+                    }\n+                    continue;\n+                case Installed:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Installed);\n+                    if (desiredState == null || desiredState == State.Installed) {\n+                        waitOnStateChangeEvent(State.Installed);\n+                        continue;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            setBackingTask(null, null);\n+                            setState(State.Finished);\n+                            break;\n+                        case Running:\n+                            //TODO: use backing task\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n-                                } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    waitForDependencyReady();\n+                                    context.getLog().error(getName(), \"starting\");\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n+                                    setBackingTask(null, null);\n+                                } catch (InterruptedException e) {\n+                                    return;\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n-                    break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n+                            synchronized (stateChangeEvent) {\n+                                if (getState() == State.Installed) {\n+                                    stateChangeEvent.wait();\n+                                }\n                             }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n-                        }\n-                    }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n+                    continue;\n                 case Running:\n-                    if (!activeState.isRunning()) {\n-                        setBackingTask(() -> {\n-                            try {\n-                                run();\n-                                // subclasses implementing run() should handle state transition;\n-                            } catch (Throwable t) {\n-                                errored(\"Failed starting up\", t);\n-                            }\n-                            backingTask = null;\n-                        }, getName() + \" => \" + newState);\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Running);\n+                    if (desiredState == null || desiredState == State.Running) {\n+                        waitOnStateChangeEvent(State.Running);\n+                        continue;\n                     }\n-                    break;\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    shutdown();\n+                    if (this.getState() != State.Errored) {\n+                        setState(State.Finished);\n+                    }\n+                    continue;\n+                case Finished:\n+                    desiredState = peekOrRemoveFirstDesiredState(State.Finished);\n+                    if (desiredState == null || desiredState == State.Finished) {\n+                        waitOnStateChangeEvent(State.Finished);\n+                        continue;\n+                    }\n+                    context.getLog().note(getName(), getState(), \"desiredState\", desiredState);\n+                    switch (desiredState) {\n+                        case New:\n+                        case Installed:\n+                            setState(State.New);\n+                            break;\n+                        case Running:\n+                            setState(State.Installed);\n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed to set desired state to Stopping, Errored, Broken\n+                    }\n+\n+                    continue;\n                 case Errored:\n-                    if (activeState != State.Errored) {\n-                        // already in the process of error handling\n-                        try {\n-                            handleError();\n-                        } catch (Throwable t) {\n-                            // TODO: handle the case where error happens in error recovery.\n-                            errored(\"Error handler failed\", t);\n-                        }\n+                    handleError();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjY4NA==", "bodyText": "Should be made private and then expose only a couple options for the implementing service such as reportRunning(), reportError() and whatever else you think we need.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092684", "createdAt": "2020-02-19T06:05:53Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5Mjg0Nw==", "bodyText": "This won't help checkstyle since you need to provide a comment for the parameter.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381092847", "createdAt": "2020-02-19T06:06:37Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -512,13 +589,20 @@ private boolean dependencyReady(EvergreenService v) {\n     }\n \n     private void waitForDependencyReady() throws InterruptedException {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+        context.getLog().error(getName(), \"waiting for dependency ready\");\n         synchronized (dependencyReadyLock) {\n             while (!dependencyReady()) {\n                 dependencyReadyLock.wait();\n             }\n         }\n     }\n \n+    /**\n+     * @param f", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 612}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzA0MA==", "bodyText": "This seems like it should be replaced with our log, not sure why it is using stderr.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381093040", "createdAt": "2020-02-19T06:07:13Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -552,7 +636,8 @@ public void postInject() {\n         } else if (d == null) {\n             return;\n         } else {\n-            String errMsg = String.format(\"Unrecognized dependency configuration for service %s, config content: %s\", getName(), d.toString());\n+            String errMsg = String.format(\"Unrecognized dependency configuration for service %s, config content: %s\",\n+                    getName(), d.toString());\n             System.err.println(errMsg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 624}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzIyOQ==", "bodyText": "Can you add a comment for what is going on here and why?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381093229", "createdAt": "2020-02-19T06:08:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -39,7 +39,11 @@ public GenericExternalService(Topics c) {\n         c.subscribe((what, child) -> {\n             if (c.parentNeedsToKnow() && !child.childOf(\"shutdown\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MzYwMA==", "bodyText": "Why is the service checking its own state during the running of startup? Nothing should be changing it except for the service itself. Or more importantly, what does it mean if he state isn't installed and how should it be handled?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381093600", "createdAt": "2020-02-19T06:09:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -67,10 +71,37 @@ public void awaitingStartup() {\n \n     @Override\n     public void startup() {\n-        if (run(\"startup\", null) == RunStatus.Errored) {\n+        RunStatus result = run(\"startup\", exit -> {\n+            if (getState() == State.Installed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5NDE4MQ==", "bodyText": "No call to super? This is confusing that some implementations call the super, but others don't.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381094181", "createdAt": "2020-02-19T06:12:18Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -116,7 +117,7 @@ public void run() {\n                 log.note(getName(), \"Back on run Q safe-time update\");\n             }\n         }\n-        super.run();\n+        this.stopService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "committedDate": "2020-02-19T23:10:37Z", "message": "State machine refactor\n\nRefactor the state machine:\n1. Not use published() in EvergreenService. Use state transition thread\ninstead.\n2. Use desiredStateList for external entities to start/stop evergreen\nservice. Every start/stop/restart request will override the\ndesiredStateList.\n3. Remove run() method in EvergreenService. startup() should report\nRunning instead."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNTA2NjA2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-361506606", "createdAt": "2020-02-19T23:09:56Z", "commit": {"oid": "d2cc50fcde78ba82eef97a63f97c79355fc81aa6"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzowOTo1NlrOFr7DcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzoxMToyMlrOFr7FlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMDYyNQ==", "bodyText": "I think we can remove all Service from the requestXxx as we are in the EvergreenService class", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381600625", "createdAt": "2020-02-19T23:09:56Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -116,7 +117,7 @@ public void run() {\n                 log.note(getName(), \"Back on run Q safe-time update\");\n             }\n         }\n-        super.run();\n+        this.requestStopService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2cc50fcde78ba82eef97a63f97c79355fc81aa6"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMTE3Mg==", "bodyText": "+1. If that's what we need to do, then it's fine. I did it in the postInject after it figures out the dependency.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381601172", "createdAt": "2020-02-19T23:11:22Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -60,8 +59,21 @@ public EvergreenService(Topics topics) {\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA4ODE2Nw=="}, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 54}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2cc50fcde78ba82eef97a63f97c79355fc81aa6", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d2cc50fcde78ba82eef97a63f97c79355fc81aa6", "committedDate": "2020-02-19T22:18:34Z", "message": "Address comments"}, "afterCommit": {"oid": "11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/11dc2d4f8e06c9d5366c50a2541d82b742d84ed6", "committedDate": "2020-02-19T23:10:37Z", "message": "State machine refactor\n\nRefactor the state machine:\n1. Not use published() in EvergreenService. Use state transition thread\ninstead.\n2. Use desiredStateList for external entities to start/stop evergreen\nservice. Every start/stop/restart request will override the\ndesiredStateList.\n3. Remove run() method in EvergreenService. startup() should report\nRunning instead."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNTA5MDU2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-361509056", "createdAt": "2020-02-19T23:15:44Z", "commit": {"oid": "d2cc50fcde78ba82eef97a63f97c79355fc81aa6"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzoxNTo0NFrOFr7LVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzoxNjoxNlrOFr7MAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMjY0NA==", "bodyText": "Agree.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381602644", "createdAt": "2020-02-19T23:15:44Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -70,11 +82,32 @@ static void setState(Object o, State state) {\n         }\n     }\n \n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    public void setState(State newState) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA5MjY4NA=="}, "originalCommit": {"oid": "7ee25d34a650229a91879e35befec8209bedcc8d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMjgxOQ==", "bodyText": "move to the top?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381602819", "createdAt": "2020-02-19T23:16:16Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -198,144 +223,229 @@ public Topic getStateTopic() {\n         return state;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n-    }\n-\n     public boolean isPeriodic() {\n         return periodicityInformation != null;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2cc50fcde78ba82eef97a63f97c79355fc81aa6"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNTIwMzQx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-361520341", "createdAt": "2020-02-19T23:44:28Z", "commit": {"oid": "11dc2d4f8e06c9d5366c50a2541d82b742d84ed6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzo0NDoyOFrOFr7wsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzo0NDoyOFrOFr7wsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYxMjIwOQ==", "bodyText": "I guess it is not at error level", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381612209", "createdAt": "2020-02-19T23:44:28Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -512,6 +598,10 @@ private boolean dependencyReady(EvergreenService v) {\n     }\n \n     private void waitForDependencyReady() throws InterruptedException {\n+        if (dependencyReady()) {\n+            return;\n+        }\n+        context.getLog().error(getName(), \"waiting for dependency ready\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11dc2d4f8e06c9d5366c50a2541d82b742d84ed6"}, "originalPosition": 619}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "committedDate": "2020-02-20T01:38:16Z", "message": "Add reportState"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10956d246514cc82af1a4f85460dd4a828683822", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/10956d246514cc82af1a4f85460dd4a828683822", "committedDate": "2020-02-20T00:57:36Z", "message": "Add reportState"}, "afterCommit": {"oid": "c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3b970ebaa816c2c336f2c8ee7784bc091571a7b", "committedDate": "2020-02-20T01:38:16Z", "message": "Add reportState"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c", "committedDate": "2020-02-20T05:59:49Z", "message": "Use blocking queue to ensure state transition events are processed in order."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjUxNTYz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-361651563", "createdAt": "2020-02-20T06:06:25Z", "commit": {"oid": "c3b970ebaa816c2c336f2c8ee7784bc091571a7b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowNjoyNVrOFsGf-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjowNjoyNVrOFsGf-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4ODE1Mw==", "bodyText": "As discussed today at the whiteboard, will you change this so that it never sets the state directly? Instead it should use some signaling mechanism which the state machine can use to set the appropriate state. That way, only the state machine thread ever calls setState.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381788153", "createdAt": "2020-02-20T06:06:25Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +50,75 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    //Used to notify when state has changed Or a desiredState is set.\n+    private final Object stateChangeEvent = new Object();\n+\n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());\n+                startLifecycle();\n+            }\n+        }).start();\n+    }\n+\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    private void setState(State newState) {\n+        final State currentState = getState();\n+\n+        // TODO: Add validation\n+        if (!newState.equals(currentState)) {\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            // Make sure the order of setValue() invocation is same as order of global state notification\n+            synchronized (this.state) {\n+                this.state.setValue(newState);\n+                context.globalNotifyStateChanged(this, currentState);\n+                synchronized (this.stateChangeEvent) {\n+                    stateChangeEvent.notifyAll();\n+                }\n+            }\n+        }\n     }\n \n-    static void setState(Object o, State state) {\n-        if (o instanceof EvergreenService) {\n-            ((EvergreenService) o).setState(state);\n+    public void reportState(State newState) {\n+        if (newState.equals(State.Installed) || newState.equals(State.Broken) || newState.equals(State.Finished)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);\n         }\n+        setState(newState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3b970ebaa816c2c336f2c8ee7784bc091571a7b"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjU3MDQ0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-361657044", "createdAt": "2020-02-20T06:23:53Z", "commit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjoyMzo1NFrOFsHCag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjoyMzo1NFrOFsHCag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5Njk3MA==", "bodyText": "Since you're only using this as a lock right now as far as I can tell, ie you don't do anything with the stored data, maybe it should be a ReentrantLock and you create a Condition from the lock and notify waiters.\nActually you are doing a bit more I guess, so this may be appropriate.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381796970", "createdAt": "2020-02-20T06:23:54Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +52,83 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    // A state event can be a state transition event, or a desired state updated notification.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNjU3NTA3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-361657507", "createdAt": "2020-02-20T06:25:28Z", "commit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjoyNToyOVrOFsHFXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwNjoyNToyOVrOFsHFXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc5NzcyNQ==", "bodyText": "[nit]\nImport as just SuppressFBWarnings, no need to have the whole path.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r381797725", "createdAt": "2020-02-20T06:25:29Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,258 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    // If the event is state transition, the enqueue is blocking on existing state transition event to be processed.\n+    // If the event is desired state changed notification, the enqueue is not blocking.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjYzNjA0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362263604", "createdAt": "2020-02-20T21:57:42Z", "commit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMTo1Nzo0MlrOFskjyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMTo1Nzo0MlrOFskjyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MDY1MQ==", "bodyText": "I like this idea. But I think we should have a better way than using an arbitrary  Object event and sometimes it is a State and sometimes it is a String, or anything.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382280651", "createdAt": "2020-02-20T21:57:42Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,258 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    // If the event is state transition, the enqueue is blocking on existing state transition event to be processed.\n+    // If the event is desired state changed notification, the enqueue is not blocking.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized void enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            if (!(stateEventQueue.peek() instanceof State)) {\n+                stateEventQueue.clear();\n+            }\n+            try {\n+                stateEventQueue.put(event);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        } else {\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjcxODYw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362271860", "createdAt": "2020-02-20T22:11:50Z", "commit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoxMTo1MFrOFsk8ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoxMTo1MFrOFsk8ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njk0OA==", "bodyText": "The comment could be more helpful here. I guess what we are trying to do is: Conditionally update the active state. The state will only get updated if the active state is condition state, and the newState is different from active state.\nHowever, is it correct to say that we don't really need this method to ensure we are actually in the state we thought, if only one thread is updating state?\nAlso this could be a synchronized method?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382286948", "createdAt": "2020-02-20T22:11:50Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +52,83 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    // A state event can be a state transition event, or a desired state updated notification.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());\n+                startLifecycle();\n+            }\n+        }).start();\n+    }\n+\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjczMjQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362273246", "createdAt": "2020-02-20T22:14:20Z", "commit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoxNDoyMFrOFslAlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoxNDoyMFrOFslAlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4ODAyMw==", "bodyText": "is this required now? I thought I discussed we want to even consider not support require with State", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382288023", "createdAt": "2020-02-20T22:14:20Z", "author": {"login": "leaf94"}, "path": "src/test/resources/com/aws/iot/evergreen/kernel/config.yaml", "diffHunk": "@@ -120,7 +120,7 @@\n       install:\n           skipif: true\n           all: echo All installed\n-      requires: jdk11, git, hello-docker, hello-docker-nginx, mqtt, ticktock, hello\n+      requires: jdk11, git, hello-docker, hello-docker-nginx, mqtt, hello, ticktock:Installed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjgwMTAz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362280103", "createdAt": "2020-02-20T22:27:25Z", "commit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyNzoyNlrOFslWdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjoyNzoyNlrOFslWdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MzYyMw==", "bodyText": "This would eventually call the blockingQueue.put() and it means the caller thread (ex. IPCLifeCycleAgent) will hang there. Is that what we expected?\nOne loop hole I see is that at least IPCLifeCycleAgent should not be waiting to report \"Running\" for one service service.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382293623", "createdAt": "2020-02-20T22:27:26Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +52,83 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n \n+    // A state event can be a state transition event, or a desired state updated notification.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());\n+                startLifecycle();\n+            }\n+        }).start();\n+    }\n+\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    /**\n+     * Set the state of the service. Should only be called by service or through IPC.\n+     * @param newState\n+     */\n+    private void conditionalSetState(State condition, State newState) {\n+        synchronized (this.state) {\n+            final State currentState = getState();\n+            if (condition != null && !currentState.equals(condition)) {\n+                return;\n+            }\n+            if (newState.equals(currentState)) {\n+                return;\n+            }\n+\n+            // TODO: Add validation\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            this.state.setValue(newState);\n+            context.globalNotifyStateChanged(this, currentState);\n+\n+            // push to queue\n+            enqueueStateEvent(newState);\n+        }\n+    }\n+\n+    private void setState(State newState) {\n+        conditionalSetState(null, newState);\n     }\n \n-    static void setState(Object o, State state) {\n-        if (o instanceof EvergreenService) {\n-            ((EvergreenService) o).setState(state);\n+    public void reportState(State newState) {\n+        if (newState.equals(State.Installed) || newState.equals(State.Broken) || newState.equals(State.Finished)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);\n         }\n+        // TODO: add more validation. Eg. Not allow to reportState when current state is Errored or Finished.\n+        setState(newState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca1a7ec0a7cc472681bb95524ca6572bb58dd3c"}, "originalPosition": 118}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67b5d8cc15e1d8186306cd64719d1b414c54dd5c", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/67b5d8cc15e1d8186306cd64719d1b414c54dd5c", "committedDate": "2020-02-20T22:26:13Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}, "afterCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/04b19a0888a86938d4f15acb8d8ac907bac87089", "committedDate": "2020-02-20T22:55:38Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjk4NDI1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362298425", "createdAt": "2020-02-20T23:05:14Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzowNToxNFrOFsmQ7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzowNToxNFrOFsmQ7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODU5MA==", "bodyText": "Why introducing this change?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382308590", "createdAt": "2020-02-20T23:05:14Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -334,12 +329,9 @@ void errorService() {\n \n     private void startStateTransition() throws InterruptedException {\n         periodicityInformation = Periodicity.of(this);\n-        while (true) {\n+        while (!closed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMjk4OTM1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362298935", "createdAt": "2020-02-20T23:06:33Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzowNjozM1rOFsmSkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzowNjozM1rOFsmSkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTAxMA==", "bodyText": "As Michael mentioned before, swtich case should always have break, instead of continue", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382309010", "createdAt": "2020-02-20T23:06:33Z", "author": {"login": "leaf94"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -398,35 +410,53 @@ private void startStateTransition() throws InterruptedException {\n                     break;\n                 case Running:\n                     if (desiredState == null) {\n-                        continue;\n+                        break;\n                     }\n \n-                    conditionalSetState(State.Running, State.Stopping);\n-                    break;\n+                    setState(State.Stopping);\n+                    continue;\n                 case Stopping:\n                     // doesn't handle desiredState in Stopping.\n-                    try {\n-                        shutdown();\n-                    } catch (Throwable t) {\n-                        errored(\"Shutting down\", t);\n+                    // Not use setBackingTask because it will cancel the existing task.\n+                    CountDownLatch stopping = new CountDownLatch(1);\n+                    new Thread(() -> {\n+                        try {\n+                            shutdown();\n+                        } catch (Throwable t) {\n+                            getContext().getLog().error(getName(), \"Error in shutting down\", t);\n+                            reportState(State.Errored);\n+                        } finally {\n+                            stopping.countDown();\n+                        }\n+\n+                    }).start();\n+\n+                    boolean stopSucceed = stopping.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n                         continue;\n                     }\n-                    conditionalSetState(State.Stopping, State.Finished);\n-                    break;\n+                    if (!stopSucceed) {\n+                        setState(State.Errored);\n+                    } else {\n+                        setState(State.Finished);\n+                    }\n+                    continue;\n+\n                 case Finished:\n                     if (desiredState == null) {\n-                        continue;\n+                        break;\n                     }\n \n                     context.getLog().note(getName(), getState(), \"desiredState\", desiredState);\n                     switch (desiredState) {\n                         case New:\n                         case Installed:\n                             setState(State.New);\n-                            break;\n+                            continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzA4NTE1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362308515", "createdAt": "2020-02-20T23:30:22Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozMDoyMlrOFsmyUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozMDoyMlrOFsmyUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNzEzNw==", "bodyText": "Should this be using setState and not report?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382317137", "createdAt": "2020-02-20T23:30:22Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 303}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzA5MzE4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362309318", "createdAt": "2020-02-20T23:32:29Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozMjozMFrOFsm1GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozMjozMFrOFsm1GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNzg0OA==", "bodyText": "Just do getReportState().equals(State.Errored) || !ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382317848", "createdAt": "2020-02-20T23:32:30Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 348}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzEwNzY5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362310769", "createdAt": "2020-02-20T23:35:03Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNTowM1rOFsm4IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNTowM1rOFsm4IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODYyNA==", "bodyText": "Return isn't good here I think because then there's no trigger to unlock the loop again.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382318624", "createdAt": "2020-02-20T23:35:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n+                        continue;\n+                    }\n+                    if (ok) {\n+                        setState(State.Installed);\n+                    } else {\n+                        setState(State.Errored);\n+                    }\n+                    continue;\n+                case Installed:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            stopBackingTask();\n+                            setState(State.Finished);\n+                            continue;\n+                        case Running:\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n+                                    waitForDependencyReady();\n+                                    context.getLog().note(getName(), \"starting\");\n+                                } catch (InterruptedException e) {\n+                                    return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 378}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzEyMDg3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362312087", "createdAt": "2020-02-20T23:36:12Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNjoxMlrOFsm6DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNjoxMlrOFsm6DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTExNg==", "bodyText": "Don't we want it to cancel whatever is running? That's the point of shutdown.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382319116", "createdAt": "2020-02-20T23:36:12Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n+                        continue;\n+                    }\n+                    if (ok) {\n+                        setState(State.Installed);\n+                    } else {\n+                        setState(State.Errored);\n+                    }\n+                    continue;\n+                case Installed:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            stopBackingTask();\n+                            setState(State.Finished);\n+                            continue;\n+                        case Running:\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n+                                    waitForDependencyReady();\n+                                    context.getLog().note(getName(), \"starting\");\n+                                } catch (InterruptedException e) {\n+                                    return;\n+                                }\n+\n+                                try {\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n                                 } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    reportState(State.Errored);\n+                                    getContext().getLog().error(getName(), \"Error in running\", t);\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n                     break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n+                case Running:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    // Not use setBackingTask because it will cancel the existing task.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 412}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzEyNjEx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362312611", "createdAt": "2020-02-20T23:37:41Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNzo0MVrOFsm92w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzozNzo0MVrOFsm92w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMDA5MQ==", "bodyText": "Same here, you can check the state and if await in the same line.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382320091", "createdAt": "2020-02-20T23:37:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +218,297 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n+    }\n+\n+    public Topic getStateTopic() {\n+        return state;\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n+            }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    // Enqueue a state event.\n+    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+            value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+    /**\n+     * Error out a service.\n+     */\n+    void errorService() {\n+        setState(State.Errored);\n+    }\n+\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed) {\n+            State desiredState;\n+\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState == current) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {\n+                        setState(State.Errored);\n+                        continue;\n+                    }\n+                    if (ok) {\n+                        setState(State.Installed);\n+                    } else {\n+                        setState(State.Errored);\n+                    }\n+                    continue;\n+                case Installed:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    switch (desiredState) {\n+                        case Finished:\n+                            stopBackingTask();\n+                            setState(State.Finished);\n+                            continue;\n+                        case Running:\n                             setBackingTask(() -> {\n                                 try {\n-                                    install();\n-                                    if (!errored()) {\n-                                        setState(State.AwaitingStartup);\n-                                    }\n+                                    waitForDependencyReady();\n+                                    context.getLog().note(getName(), \"starting\");\n+                                } catch (InterruptedException e) {\n+                                    return;\n+                                }\n+\n+                                try {\n+                                    startup();// TODO: rename to  initiateStartup. Service need to report state to Running.\n                                 } catch (Throwable t) {\n-                                    errored(\"Failed installing\", t);\n+                                    reportState(State.Errored);\n+                                    getContext().getLog().error(getName(), \"Error in running\", t);\n                                 }\n-                                backingTask = null;\n-                            }, getName() + \" => \" + newState);\n-                        }\n-                    }).start();\n+                            }, \"start\");\n \n+                            break;\n+                        default:\n+                            context.getLog().error(\"Unexpected desired state\", desiredState);\n+                            // not allowed for New, Stopping, Errored, Broken\n+                            break;\n+                    }\n                     break;\n-                case AwaitingStartup:\n-                    awaitingStartup();\n+                case Running:\n+                    if (desiredState == null) {\n+                        break;\n+                    }\n+\n+                    setState(State.Stopping);\n+                    continue;\n+                case Stopping:\n+                    // doesn't handle desiredState in Stopping.\n+                    // Not use setBackingTask because it will cancel the existing task.\n+                    CountDownLatch stopping = new CountDownLatch(1);\n                     new Thread(() -> {\n-                        // wait until shutdown finished.\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n-                        }\n-                        if (dependencies != null) {\n-                            try {\n-                                waitForDependencyReady();\n-                            } catch (InterruptedException e) {\n-                                errored(\"waiting for dependency ready\", e);\n-                            }\n-                        }\n-                        // if no other state change happened in between\n-                        if (!errored() && getState() == State.AwaitingStartup) {\n-                            setState(State.Starting);\n+                            shutdown();\n+                        } catch (Throwable t) {\n+                            getContext().getLog().error(getName(), \"Error in shutting down\", t);\n+                            reportState(State.Errored);\n+                        } finally {\n+                            stopping.countDown();\n                         }\n+\n                     }).start();\n \n-                    break;\n-                case Starting:\n-                    setBackingTask(() -> {\n-                        try {\n-                            periodicityInformation = Periodicity.of(this);\n-                            startup();\n-                            if (!errored()) {\n-                                setState(isPeriodic()  // Let timer do the transition to Running==null\n-                                        ? State.Finished : State.Running);\n-                            }\n-                        } catch (Throwable t) {\n-                            errored(\"Failed starting up\", t);\n-                        }\n-                        backingTask = null;\n-                    }, getName() + \" => \" + newState);\n-                    break;\n-                case Running:\n-                    if (!activeState.isRunning()) {\n-                        setBackingTask(() -> {\n-                            try {\n-                                run();\n-                                // subclasses implementing run() should handle state transition;\n-                            } catch (Throwable t) {\n-                                errored(\"Failed starting up\", t);\n-                            }\n-                            backingTask = null;\n-                        }, getName() + \" => \" + newState);\n+                    boolean stopSucceed = stopping.await(30, TimeUnit.SECONDS);\n+                    if (getReportState() == State.Errored) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 470}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzM0OTQ3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362334947", "createdAt": "2020-02-21T00:42:40Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/04b19a0888a86938d4f15acb8d8ac907bac87089", "committedDate": "2020-02-20T22:55:38Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}, "afterCommit": {"oid": "85b254795b5b05259c530d522953c5ac42504108", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85b254795b5b05259c530d522953c5ac42504108", "committedDate": "2020-02-21T00:50:28Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85b254795b5b05259c530d522953c5ac42504108", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85b254795b5b05259c530d522953c5ac42504108", "committedDate": "2020-02-21T00:50:28Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}, "afterCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "committedDate": "2020-02-21T01:01:42Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzQyODQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362342846", "createdAt": "2020-02-21T01:06:42Z", "commit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMTowNjo0MlrOFsolUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMTowNjo0MlrOFsolUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjU3Ng==", "bodyText": "Not needed now, but this doesn't need to be a function, it can be a static member.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382346576", "createdAt": "2020-02-21T01:06:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+    private static final Set<State> validReportState = getValidReportState();\n+\n+    private static Set<State> getValidReportState() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzE0NTg2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362314586", "createdAt": "2020-02-20T23:43:00Z", "commit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzo0MzowMVrOFsnFeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMTowNjoyMVrOFsok_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjA0MQ==", "bodyText": "Why size of 3? Probably don't want to use a magic number.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382322041", "createdAt": "2020-02-20T23:43:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +53,82 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjgzOA==", "bodyText": "Why is there four different log lines?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382322838", "createdAt": "2020-02-20T23:45:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +53,82 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    /**\n+     * Start the Lifecycle in a separate thread.\n+     */\n+    public void startLifecycle() {\n+        new Thread(() -> {\n+            try {\n+                startStateTransition();\n+            } catch (Throwable e) {\n+                context.getLog().error(\"Error in state transition\", e);\n+                System.err.println(\"Error in state transition\");\n+                e.printStackTrace(System.err);\n+                context.getLog().note(\"restarting service\", getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NDk5OQ==", "bodyText": "Why do you print 4 log lines in different way? I would at least leave a comment to explain this odd behavior.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382344999", "createdAt": "2020-02-21T01:00:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {\n+            while (!closed) {\n+                try {\n+                    startStateTransition();\n+                    return;\n+                } catch (Throwable e) {\n+                    context.getLog().error(\"Error in state transition\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85b254795b5b05259c530d522953c5ac42504108"}, "originalPosition": 704}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjQ5Mw==", "bodyText": "Why are we returning null? Can we avoid this? Even using Optional is better than returning null.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382346493", "createdAt": "2020-02-21T01:06:21Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+    private static final Set<State> validReportState = getValidReportState();\n+\n+    private static Set<State> getValidReportState() {\n+        Set<State> result = new HashSet<>();\n+        result.add(State.Running);\n+        result.add(State.Errored);\n+        result.add(State.Finished);\n+        return result;\n+    }\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        synchronized (this.state) {\n+            final State currentState = getState();\n+\n+            if (newState.equals(currentState)) {\n+                return;\n+            }\n+\n+            // TODO: Add validation\n+            context.getLog().note(getName(), currentState, \"=>\", newState);\n+            prevState = currentState;\n+            this.state.setValue(newState);\n+            context.globalNotifyStateChanged(this, currentState);\n+        }\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are Running, Finished, Errored.\n+     * @param newState\n+     * @return\n+     */\n+    public synchronized boolean reportState(State newState) {\n+        context.getLog().note(getName(), \"reporting state\", newState);\n+        if (!validReportState.contains(newState)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);\n+        }\n+        // TODO: Add more validations\n+\n+        if (getState().equals(State.Starting) && newState.equals(State.Finished)) {\n+            // if a service doesn't have any run logic, request stop on service to clean up DesiredStateList\n+            requestStop();\n+        }\n+\n+        return enqueueStateEvent(newState);\n     }\n \n-    static void setState(Object o, State state) {\n-        if (o instanceof EvergreenService) {\n-            ((EvergreenService) o).setState(state);\n+    private State getReportState() {\n+        Object top = stateEventQueue.poll();\n+        if (top instanceof State) {\n+            return (State) top;\n         }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 126}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5", "committedDate": "2020-02-21T01:01:42Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}, "afterCommit": {"oid": "720d173bbaeb883fab9e28d25a066772da573a24", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/720d173bbaeb883fab9e28d25a066772da573a24", "committedDate": "2020-02-21T01:21:01Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzQzODM5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362343839", "createdAt": "2020-02-21T01:10:08Z", "commit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMToxMDowOFrOFsoocw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMTozMDoxOVrOFso8QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzM3OQ==", "bodyText": "Again please don't return null. Use Optional.empty instead.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382347379", "createdAt": "2020-02-21T01:10:08Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +222,286 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0ODk2Mw==", "bodyText": "Why are we using a Thread instead of ExecutorService?  It's much easier to manage the lifecycle the thread using ExecutorService.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382348963", "createdAt": "2020-02-21T01:16:37Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 698}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTQ4Nw==", "bodyText": "Why do you catch Throwable? Normally we don't want to just catch Throwable. There should be layers of error handling.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382349487", "createdAt": "2020-02-21T01:18:45Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {\n+            while (!closed) {\n+                try {\n+                    startStateTransition();\n+                    return;\n+                } catch (Throwable e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 703}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTYyMw==", "bodyText": "How is the service restarted?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382349623", "createdAt": "2020-02-21T01:19:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +682,20 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        new Thread(() -> {\n+            while (!closed) {\n+                try {\n+                    startStateTransition();\n+                    return;\n+                } catch (Throwable e) {\n+                    context.getLog().error(\"Error in state transition\", e);\n+                    System.err.println(\"Error in state transition\");\n+                    e.printStackTrace(System.err);\n+                    context.getLog().note(\"restarting service\", getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 707}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MDU3Ng==", "bodyText": "This should be volatile or use AtomicBoolean if it's intended to synchronize between different threads. Again I prefer we use ExecutorService to spin up the state machine thread.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382350576", "createdAt": "2020-02-21T01:23:14Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MTU0NQ==", "bodyText": "Remove synchronized if setState is private and only called by one thread. synchronized conveys misleading information that this method can be called by different threads.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382351545", "createdAt": "2020-02-21T01:26:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +54,85 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+    private static final Set<State> validReportState = getValidReportState();\n+\n+    private static Set<State> getValidReportState() {\n+        Set<State> result = new HashSet<>();\n+        result.add(State.Running);\n+        result.add(State.Errored);\n+        result.add(State.Finished);\n+        return result;\n+    }\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        synchronized (this.state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MjA2Mg==", "bodyText": "You don't need synchronized here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382352062", "createdAt": "2020-02-21T01:28:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +222,286 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1MjQ0OA==", "bodyText": "It's worth adding a comment that this method expects multi-thread access and is synchronized.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382352448", "createdAt": "2020-02-21T01:30:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +222,286 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private State peekOrRemoveFirstDesiredState(State activeState) {\n+        synchronized (desiredStateList) {\n+            if (desiredStateList.isEmpty()) {\n+                return null;\n+            }\n+            State first = desiredStateList.get(0);\n+            if (first == activeState) {\n+                return desiredStateList.remove(0);\n+            } else {\n+                return first;\n             }\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    private void setDesiredState(State... state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0a05f9aa367e5d29ecfb9172fda0601ce4bf2b5"}, "originalPosition": 192}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1654b3976ebc335497cb39d2c75156ee4c603be6", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1654b3976ebc335497cb39d2c75156ee4c603be6", "committedDate": "2020-02-21T01:48:06Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "720d173bbaeb883fab9e28d25a066772da573a24", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/720d173bbaeb883fab9e28d25a066772da573a24", "committedDate": "2020-02-21T01:21:01Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}, "afterCommit": {"oid": "1654b3976ebc335497cb39d2c75156ee4c603be6", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1654b3976ebc335497cb39d2c75156ee4c603be6", "committedDate": "2020-02-21T01:48:06Z", "message": "Modify stateEventQueue to handle reportState() events. Test not fixed yet.\n\nCompare to previous commit, this one use stateEventQueue to handle\nreportState() events instead of setState() events.\n\nPro is all setState() is called in the same thread.\nCon is state transition validation can only do best-effort.\n\nTest not fixed yet."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fc9177b832b0957ca462a39ea74462a95c327f5e", "committedDate": "2020-02-21T03:43:04Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f832c14cbc3dd212bb17e1f69518413169b62bc", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3f832c14cbc3dd212bb17e1f69518413169b62bc", "committedDate": "2020-02-21T03:14:50Z", "message": "Address comments"}, "afterCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fc9177b832b0957ca462a39ea74462a95c327f5e", "committedDate": "2020-02-21T03:43:04Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzg5NzI3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362389727", "createdAt": "2020-02-21T04:11:24Z", "commit": {"oid": "3f832c14cbc3dd212bb17e1f69518413169b62bc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxMjowN1rOFsrKMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxMjowN1rOFsrKMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4ODc4NQ==", "bodyText": "[nit]\nDon't need the continue here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382388785", "createdAt": "2020-02-21T04:12:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed.get()) {\n+            Optional<State> desiredState;\n \n-        try {\n-            switch (newState) {\n-                case Installing:\n-                    new Thread(() -> {\n-                        // wait until shutdown finished.\n-                        // not using setBackTask() here to avoid cancelling the ongoing shutdown task\n+            State current = getState();\n+            context.getLog().note(\"Processing state\", getName(), getState());\n+\n+            // if already in desired state, remove the head of desired state list.\n+            desiredState = peekOrRemoveFirstDesiredState(current);\n+            while (desiredState.isPresent() && desiredState.get().equals(current)) {\n+                desiredState = peekOrRemoveFirstDesiredState(current);\n+            }\n+\n+            switch (current) {\n+                case Broken:\n+                    context.getLog().significant(getName(), \"Broken\");\n+                    return;\n+                case New:\n+                    // if no desired state is set, don't do anything.\n+                    if (!desiredState.isPresent()) {\n+                        break;\n+                    }\n+                    CountDownLatch installLatch = new CountDownLatch(1);\n+                    setBackingTask(() -> {\n                         try {\n-                            shutdownLatch.await();\n-                        } catch (InterruptedException e) {\n-                            errored(\"waiting for shutdown complete\", e);\n-                            return;\n+                            install();\n+                        } catch (Throwable t) {\n+                            reportState(State.Errored);\n+                            getContext().getLog().error(getName(), \"Error in install\", t);\n+                        } finally {\n+                            installLatch.countDown();\n                         }\n-                        // TODO: wait until all install dependency ready.\n-                        if (!errored() && getState() == State.Installing) {\n+                    }, \"install\");\n+\n+                    // TODO: Configurable timeout logic.\n+                    boolean ok = installLatch.await(120, TimeUnit.SECONDS);\n+                    State reportState = getReportState().orElse(null);\n+                    if (State.Errored.equals(reportState) || !ok) {\n+                        setState(State.Errored);\n+                        continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 342}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzkwNTYw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362390560", "createdAt": "2020-02-21T04:15:07Z", "commit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNTowOFrOFsrMaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNTowOFrOFsrMaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4OTM1Mw==", "bodyText": "Nothing outside of the state machine thread should call setState. This should be converted into reportState.\nSearch EvergreenService for setState() and make sure that only the state machine thread ever calls it.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382389353", "createdAt": "2020-02-21T04:15:08Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -401,59 +568,22 @@ protected void awaitingStartup() {\n     /**\n      * Called when all dependencies are Running. If there are no dependencies,\n      * it is called right after postInject.  The service doesn't transition to Running\n-     * until *after* this state is complete.  The service transitions to Running when\n-     * startup() completes\n+     * until *after* this state is complete.\n      */\n-    public void startup() {\n+    protected void startup() {\n+        setState(State.Running);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 579}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzkwNzU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#pullrequestreview-362390755", "createdAt": "2020-02-21T04:16:12Z", "commit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNDoxNjoxMlrOFsrNRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwNToxNzowMVrOFsr7vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4OTU3NA==", "bodyText": "If this always return true, then we don't need a boolean return type. Just use void. Same for the other request methods.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382389574", "createdAt": "2020-02-21T04:16:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MzQ1OQ==", "bodyText": "Since state variable is shared between two threads (state machine and service thread), it needs to be volatile or use AtomicReference to reduce the the risk of memory consistency errors.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382393459", "createdAt": "2020-02-21T04:37:07Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NTgzNw==", "bodyText": "Preferably this variable shouldn't be a class instance variable of EvergreenService since it's only used in the state machine. I'm fine if we refactor this later.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382395837", "createdAt": "2020-02-21T04:48:31Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;\n     public Context context;\n     protected ConcurrentHashMap<EvergreenService, State> dependencies;\n-    private CountDownLatch shutdownLatch = new CountDownLatch(0);\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzI4OA==", "bodyText": "I am not sure whether throwing an exception (especially RuntimeException) is a sane behavior here. We don't want to crash the program just because some one made a mistake and reported an invalid state here. I think simply logging a warning message and moving on is better.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382397288", "createdAt": "2020-02-21T04:55:47Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;\n     public Context context;\n     protected ConcurrentHashMap<EvergreenService, State> dependencies;\n-    private CountDownLatch shutdownLatch = new CountDownLatch(0);\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    // DesiredStateList is used to set desired path of state transition.\n+    // Eg. Start a service will need DesiredStateList to be <Running>\n+    // Set capacity to 3, since currently the max length of state transition path is reInstall(),\n+    // which is Finished->New->Running\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    private static final Set<State> validReportState = new HashSet<>(Arrays.asList(\n+            State.Running, State.Errored, State.Finished));\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        final State currentState = getState();\n+\n+        if (newState.equals(currentState)) {\n+            return;\n+        }\n+\n+        // TODO: Add validation\n+        context.getLog().note(getName(), currentState, \"=>\", newState);\n+        prevState = currentState;\n+        this.state.setValue(newState);\n+        context.globalNotifyStateChanged(this, currentState);\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are Running, Finished, Errored.\n+     * @param newState\n+     * @return\n+     */\n+    public synchronized boolean reportState(State newState) {\n+        context.getLog().note(getName(), \"reporting state\", newState);\n+        if (!validReportState.contains(newState)) {\n+            throw new IllegalArgumentException(\"Invalid state: \" + newState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODI1MA==", "bodyText": "This method always returns true, I would change return type to void.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382398250", "createdAt": "2020-02-21T05:00:30Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5ODM4OQ==", "bodyText": "It doesn't look like this method ever return false, I would change the return type to void.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382398389", "createdAt": "2020-02-21T05:01:06Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -47,34 +53,84 @@\n     private final Topic state;\n     public Context context;\n     protected ConcurrentHashMap<EvergreenService, State> dependencies;\n-    private CountDownLatch shutdownLatch = new CountDownLatch(0);\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    // DesiredStateList is used to set desired path of state transition.\n+    // Eg. Start a service will need DesiredStateList to be <Running>\n+    // Set capacity to 3, since currently the max length of state transition path is reInstall(),\n+    // which is Finished->New->Running\n+    private final List<State> desiredStateList = new ArrayList<>(3);\n+\n+    private static final Set<State> validReportState = new HashSet<>(Arrays.asList(\n+            State.Running, State.Errored, State.Finished));\n \n     @SuppressWarnings(\"LeakingThisInConstructor\")\n     public EvergreenService(Topics topics) {\n         this.config = topics;\n         this.state = initStateTopic(topics);\n     }\n \n-    public static State getState(EvergreenService evergreenService) {\n-        return evergreenService.getState();\n+    public State getState() {\n+        return (State) state.getOnce();\n+    }\n+\n+    private void setState(State newState) {\n+        final State currentState = getState();\n+\n+        if (newState.equals(currentState)) {\n+            return;\n+        }\n+\n+        // TODO: Add validation\n+        context.getLog().note(getName(), currentState, \"=>\", newState);\n+        prevState = currentState;\n+        this.state.setValue(newState);\n+        context.globalNotifyStateChanged(this, currentState);\n+    }\n+\n+    /**\n+     * public API for service to report state. Allowed state are Running, Finished, Errored.\n+     * @param newState\n+     * @return\n+     */\n+    public synchronized boolean reportState(State newState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMDU0MA==", "bodyText": "Shouldn't desiredStateList be thread-safe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382400540", "createdAt": "2020-02-21T05:12:02Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -51,30 +53,82 @@\n     private Throwable error;\n     private Future backingTask;\n     private Periodicity periodicityInformation;\n-    private State activeState = State.New;\n+    private State prevState = State.New;\n     private String status;\n+    private boolean closed = false;\n+\n+    // A state event can be a state transition event, or a desired state updated notification.\n+    // TODO: make class of StateEvent instead of generic object.\n+    private final BlockingQueue<Object> stateEventQueue = new ArrayBlockingQueue<>(1);\n+\n+    private final List<State> desiredStateList = new ArrayList<>(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjA0MQ=="}, "originalCommit": {"oid": "04b19a0888a86938d4f15acb8d8ac907bac87089"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMTIzOA==", "bodyText": "We shouldn't do busy loop here. But I'm okay to address this in a separate pull request.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382401238", "createdAt": "2020-02-21T05:15:53Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -539,6 +675,19 @@ public String getName() {\n \n     @Override\n     public void postInject() {\n+        //TODO: Use better threadPool mechanism\n+        new Thread(() -> {\n+            while (!closed.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 694}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwMTQ2OQ==", "bodyText": "This is redundant with the caller code of startStateTransition. Why do you need to have two while loops?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/64#discussion_r382401469", "createdAt": "2020-02-21T05:17:01Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -164,178 +220,285 @@ public static EvergreenService errNode(Context context, String name, String mess\n     private Topic initStateTopic(final Topics topics) {\n         Topic state = topics.createLeafChild(STATE_TOPIC_NAME);\n         state.setParentNeedsToKnow(false);\n-        state.setValue(Long.MAX_VALUE, State.New);\n+        state.setValue(State.New);\n         state.validate((newStateObj, oldStateObj) -> {\n             State newState = Coerce.toEnum(State.class, newStateObj);\n             return newState == null ? oldStateObj : newStateObj;\n         });\n-        state.subscribe(this);\n+\n         return state;\n     }\n \n-    public State getState() {\n-        return (State) state.getOnce();\n+    public boolean inState(State s) {\n+        return s == state.getOnce();\n     }\n \n-    public void setState(State newState) {\n-        final State currentState = (State) this.state.getOnce();\n+    public Topic getStateTopic() {\n+        return state;\n+    }\n+\n+    public boolean isPeriodic() {\n+        return periodicityInformation != null;\n+    }\n+\n+    private Optional<State> peekOrRemoveFirstDesiredState(State activeState) {\n+        if (desiredStateList.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        State first = desiredStateList.get(0);\n+        if (first == activeState) {\n+            desiredStateList.remove(first);\n+            // ignore remove() return value as it's possible that desiredStateList update\n+        }\n+        return Optional.ofNullable(first);\n+    }\n \n-        if (newState != currentState) {\n-            context.getLog().note(getName(), currentState, \"=>\", newState);\n-            // Make sure the order of setValue() invocation is same as order of global state notification\n-            synchronized (this.state) {\n-                this.state.setValue(Long.MAX_VALUE, newState);\n-                context.globalNotifyStateChanged(this, currentState);\n+    // Set desiredStateList and override existing desiredStateList.\n+    // Expect to have multi-thread access\n+    private synchronized void setDesiredState(State... state) {\n+        synchronized (desiredStateList) {\n+            List<State> newStateList = Arrays.asList(state);\n+            if (newStateList.equals(desiredStateList)) {\n+                return;\n             }\n+            desiredStateList.clear();\n+            desiredStateList.addAll(newStateList);\n+            // try insert to the queue, if queue full doesn't block.\n+            enqueueStateEvent(\"DesiredStateUpdated\");\n         }\n     }\n \n-    public boolean inState(State s) {\n-        return s == state.getOnce();\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\")\n+    private synchronized boolean enqueueStateEvent(Object event) {\n+        if (event instanceof State) {\n+            // override existing reportState\n+            stateEventQueue.clear();\n+            return stateEventQueue.offer(event);\n+        } else {\n+            stateEventQueue.offer(event);\n+\n+            // Ignore returned value of offer().\n+            // If enqueue isn't successful, the event queue has contents and there is no need to send another\n+            // trigger to process state transition.\n+            return true;\n+        }\n     }\n \n-    public Topic getStateTopic() {\n-        return state;\n+    /**\n+     * Start Service.\n+     * @return successful\n+     */\n+    public boolean requestStart() {\n+        setDesiredState(State.Running);\n+        return true;\n     }\n \n-    public boolean isRunningInternally() {\n-        Future b = backingTask;\n-        return b != null && !b.isDone();\n+    /**\n+     * Stop Service.\n+     * @return successful\n+     */\n+    public boolean requestStop() {\n+        setDesiredState(State.Finished);\n+        return true;\n     }\n \n-    public boolean isPeriodic() {\n-        return periodicityInformation != null;\n+    /**\n+     * Restart Service.\n+     * @return successful\n+     */\n+    public boolean requestRestart() {\n+        setDesiredState(State.Finished, State.Running);\n+        return true;\n     }\n \n-    @Override // for listening to state changes\n-    public void published(final WhatHappened what, final Topic topic) {\n-        final State newState = (State) topic.getOnce();\n-        if (activeState == newState) {\n-            return;\n-        }\n-        if (activeState.isRunning() && !newState.isRunning()) { // transition from running to not running\n-            shutdownLatch = new CountDownLatch(1);\n-            // Assume that shutdown task won't be cancelled. Following states (installing/awaitingStartup) wait until\n-            // shutdown task complete.\n-            // May consider just merge shutdown() into other state's handling.\n-            State oldState = activeState;\n-            setBackingTask(() -> {\n-                try {\n-                    shutdown();\n-                } catch (Throwable t) {\n-                    if (oldState != State.Errored) {\n-                        errored(\"Failed shutting down\", t);\n-                    } else {\n-                        context.getLog().error(this, \"Failed shutting down\", t);\n-                    }\n-                } finally {\n-                    shutdownLatch.countDown();\n-                }\n-                backingTask = null;\n-            }, getName() + \"=>\" + newState);\n+    /**\n+     * ReInstall Service.\n+     * @return successful\n+     */\n+    public boolean requestReinstall() {\n+        setDesiredState(State.Finished, State.New, State.Running);\n+        return true;\n+    }\n \n-            // Since shutdown() is modeled as part of state transition, I initially tried waiting on shutdownLatch()\n-            // here.\n-            // However, this caused the global configuration publish queue being blocked.\n-        }\n+    private void startStateTransition() throws InterruptedException {\n+        periodicityInformation = Periodicity.of(this);\n+        while (!closed.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9177b832b0957ca462a39ea74462a95c327f5e"}, "originalPosition": 292}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5d808687f9403b8110b1342ab60a47bcd8023cc", "author": {"user": {"login": "MikeDombo", "name": "Michael Dombrowski"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d5d808687f9403b8110b1342ab60a47bcd8023cc", "committedDate": "2020-02-21T17:25:32Z", "message": "Merge branch 'master' into PocStateMachine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8524e4c47db3d85f09e34e2521f948f0f791ef88", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8524e4c47db3d85f09e34e2521f948f0f791ef88", "committedDate": "2020-02-21T20:01:50Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dcf6984a8669f5ce971d73c1ffbb1fbc1ef77cf6", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dcf6984a8669f5ce971d73c1ffbb1fbc1ef77cf6", "committedDate": "2020-02-21T19:43:09Z", "message": "Address comments"}, "afterCommit": {"oid": "8524e4c47db3d85f09e34e2521f948f0f791ef88", "author": {"user": {"login": "ShirleyZheng92", "name": "Xueli Zheng "}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8524e4c47db3d85f09e34e2521f948f0f791ef88", "committedDate": "2020-02-21T20:01:50Z", "message": "Address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2492, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}