{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3MDgwMjUz", "number": 111, "title": "Refactor dependency resolution for packages", "bodyText": "Issue #, if available:\nDescription of changes:\nRefactor package resolution to load root packages with pinned versions from job document and use backtracking to find out all package versions in the dependency tree.\nOpen action items:\n\n Add logging\n Add more unit tests\n Optimize the logic to get all possible versions\n Rename for better readability\n Add error message for conflicting package versions (Will address in seperate PR)\n Add readme\n Clean up deployment document (may not be in this PR)\n Add integration test for running dependency resolution for a medium/bigger sized tree and then observe performance statistics for this approach (may not be in this PR)\n\nWhy is this change necessary:\nHow was this change tested:\nAny additional information or context required to review the change:\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-03-12T07:18:47Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111", "merged": true, "mergeCommit": {"oid": "6f61ec17c7235d7a05b1d05dd26665608ac37f1e"}, "closed": true, "closedAt": "2020-03-17T22:23:45Z", "author": {"login": "hui-yang"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcM_3dRAFqTM3Mzc3NDc1NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOqYE8AFqTM3NjQ0NjQ1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzc0NzU1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373774755", "createdAt": "2020-03-12T17:48:59Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNzo0OTowMFrOF1pCjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODoxNjoyMFrOF1p92Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5MTI0Nw==", "bodyText": "Make this final?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391791247", "createdAt": "2020-03-12T17:49:00Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -1,19 +1,47 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.PlatformResolver;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.io.IOException;\n+import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static Logger logger = LogManager.getLogger(DependencyResolver.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzA3Mw==", "bodyText": "typo, find found?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391803073", "createdAt": "2020-03-12T18:10:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzg3MA==", "bodyText": "Even though this is private, it is important and complicated, so please add javadoc to explain inputs and outputs.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391803870", "createdAt": "2020-03-12T18:11:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNDcwMA==", "bodyText": "here too, please add javadoc.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391804700", "createdAt": "2020-03-12T18:13:11Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTMwNw==", "bodyText": "typo: should be semver not semvar", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391805307", "createdAt": "2020-03-12T18:14:21Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjA3Ng==", "bodyText": "Maybe make this an Optional instead?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391806076", "createdAt": "2020-03-12T18:15:44Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjQyNQ==", "bodyText": "Why empty string here instead of null?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391806425", "createdAt": "2020-03-12T18:16:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {\n+        EvergreenService service = null;\n+        try {\n+            service = EvergreenService.locate(context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atWarn().setCause(e).addKeyValue(\"packageName\", packageName).log(\"Fail to load package\");\n+            return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODE0NTgz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373814583", "createdAt": "2020-03-12T18:46:19Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxODo0NjoyMFrOF1q9NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTo1NDowMVrOF1s_HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyMjY0NQ==", "bodyText": "Nit - Semver", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391822645", "createdAt": "2020-03-12T18:46:20Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1NTkwMQ==", "bodyText": "I'm not sure this will do anything since we don't have a way for customers to specify platform specific dependencies in the recipe. The map of String,String here actually stands for packagename,version, there is no platform specification in it, you can leave it as it is if you want though and we can revisit after the recipe has a way to support platform in dependencies as well as artifacts sections", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391855901", "createdAt": "2020-03-12T19:54:01Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {\n+        EvergreenService service = null;\n+        try {\n+            service = EvergreenService.locate(context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atWarn().setCause(e).addKeyValue(\"packageName\", packageName).log(\"Fail to load package\");\n+            return \"\";\n+        }\n+        Object version = service.config.getChild(\"version\");\n+        return version == null ? \"\" : version.toString();\n+    }\n+\n+    private Package getPackage(final String pkgName, final Semver version) throws PackagingException, IOException {\n+        // TODO: handle exceptions with retry\n+        Optional<Package> optionalPackage = store.getPackage(pkgName, version);\n+        if (!optionalPackage.isPresent()) {\n+            throw new UnexpectedPackagingException(\"Unexpected error in job document: package-version doesn't exist \"\n+                    + pkgName + \"-\" + version);\n+        }\n+        return optionalPackage.get();\n+    }\n+\n+    // Get dependency map for the current platform\n+    private Map<String, String> getPackageDependencies(final Package pkg) throws UnexpectedPackagingException {\n+        Object dependencyListForPlatform = PlatformResolver.resolvePlatform((Map) pkg.getDependencies());\n+        if (!(dependencyListForPlatform instanceof Map)) {\n+            throw new UnexpectedPackagingException(\"Unexpected format of dependency map: \" + dependencyListForPlatform);\n+        }\n+        return (Map<String, String>) dependencyListForPlatform;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 244}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODY0OTEy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373864912", "createdAt": "2020-03-12T20:05:53Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDowNTo1M1rOF1thhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDowNTo1M1rOF1thhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDcxMQ==", "bodyText": "why is this method not private?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391864711", "createdAt": "2020-03-12T20:05:53Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Find conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    protected List<Semver> getVersionsToExplore(final List<Semver> allVersions,\n+                                              final Collection<String> packageVersionConstraintList,\n+                                              final String pkgName) {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemvarRequirements(packageVersionConstraintList));\n+\n+        // Add active package version running on the device\n+        String version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (!version.isEmpty() && req.isSatisfiedBy(version)) {\n+            activeVersion = new Semver(version);\n+            versionList.add(0, activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemvarRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(\n+                v -> Requirement.buildNPM(v).toString()).collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected String getPackageVersionIfActive(final String packageName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODY2NTE5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373866519", "createdAt": "2020-03-12T20:08:31Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDowODozMVrOF1tp2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDowODozMVrOF1tp2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2Njg0Mg==", "bodyText": "nit- just do return resolve(resolvedPackages, packageVersionConstraints, packagesToResolve); ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391866842", "createdAt": "2020-03-12T20:08:31Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODYwNTUz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373860553", "createdAt": "2020-03-12T19:58:55Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxOTo1ODo1NVrOF1tLmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMDo0NzoxNVrOF1uxsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1OTA5Ng==", "bodyText": "change name to indicate that it is packageToDependencyToVersionConstraints.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391859096", "createdAt": "2020-03-12T19:58:55Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg1OTU0NQ==", "bodyText": "This does not look right to me. If this is adding an entry for dependencies and then what is ROOT? Do you mean to add an entry for self?\nAs per the comment the nested map should capture version constraints, then why is it storing Resolved version in this case?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391859545", "createdAt": "2020-03-12T19:59:31Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDY4MA==", "bodyText": "Would prefer this method returning the resolvedPackages and throwing the conflict exception, rather than a boolean check here. That would also save an initialization of resolvedPackages in this method, which IMO will make it more readable? (too many similar sounding names of variables)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391864680", "createdAt": "2020-03-12T20:05:51Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MDg2OA==", "bodyText": "The listOfDependenctPackages need to change to List of PackageIdentifier?If we are not using version constraints from the deployment document then remove that?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391870868", "createdAt": "2020-03-12T20:15:54Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentPackageConfiguration.java", "diffHunk": "@@ -17,6 +18,7 @@\n  */\n @JsonInclude(JsonInclude.Include.NON_NULL)\n @Getter\n+@AllArgsConstructor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MTc2MA==", "bodyText": "change name to indicate that these are root packages. Maybe - rootPackagesToResolve", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391871760", "createdAt": "2020-03-12T20:17:53Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3MjI5MA==", "bodyText": "Can this just be Set of PackageIdentifiers? We should use the model which we have to represent a package", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391872290", "createdAt": "2020-03-12T20:19:05Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg3ODcwMw==", "bodyText": "Rename this to indicate everythign this method is doing. As I understand - resolve dependencies and updating the version constraints", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391878703", "createdAt": "2020-03-12T20:33:00Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MjQ5Ng==", "bodyText": "rename to indicate what the map holds", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391882496", "createdAt": "2020-03-12T20:41:12Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MzM5NA==", "bodyText": "At this point I am curious why we do this first? We should be getting list of packages and their resolved version from deployment document. Shouldn't we try to see if those work well? Why explore other versions of a package first?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391883394", "createdAt": "2020-03-12T20:43:15Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NTIzNQ==", "bodyText": "I would think that this method would take in Map root packages and reolved versions for them. That info seems to be going in this method via the packageVersionConstraints, but it is not being used that way inside the method. Read my comment on the methos definition.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391885235", "createdAt": "2020-03-12T20:47:15Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODk4MTkx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373898191", "createdAt": "2020-03-12T21:02:55Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowMjo1NVrOF1vMwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowMjo1NVrOF1vMwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MjE2MQ==", "bodyText": "I would prefer to use iterative approach, this will grow rapidly for large number of packages.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391892161", "createdAt": "2020-03-12T21:02:55Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczODk5MjA3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373899207", "createdAt": "2020-03-12T21:04:43Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowNDo0M1rOF1vQAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTowNDo0M1rOF1vQAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjk5NA==", "bodyText": "If the same package shows up multiple times, all of these steps will get repeated. It would make more sense to get the list of valid versions for each package at the beginning and make it available for all iterations of the same package.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391892994", "createdAt": "2020-03-12T21:04:43Z", "author": {"login": "chaurah"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNzAzNDIz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373703423", "createdAt": "2020-03-12T16:18:23Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNjoyMjoxM1rOF1lt5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMTozMzoxNVrOF1wPYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczNjgwNA==", "bodyText": "Why a list of stores?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391736804", "createdAt": "2020-03-12T16:22:13Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -1,19 +1,47 @@\n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.PlatformResolver;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n \n+import java.io.IOException;\n+import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n \n-    public DependencyResolver(PackageRegistry packageRegistry) {\n-        this.packageRegistry = packageRegistry;\n+    // TODO: Temporary, should be list of stores", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTczODIyMg==", "bodyText": "Shouldn't the key be PackageIdentifier instead of packageName?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391738222", "createdAt": "2020-03-12T16:24:20Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2OTE5Mw==", "bodyText": "Probably want to include the conflict versions", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391769193", "createdAt": "2020-03-12T17:12:40Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NTE3Ng==", "bodyText": "Agree. maybe also add a readme explaining how the algorithm works.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391885176", "createdAt": "2020-03-12T20:47:07Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwMzg3MA=="}, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkwOTIxOA==", "bodyText": "This doesn't seem correct. For example, pkgA-1 have two dependencies pkgB-1, pkgC-1; pkgB-1 goes through the inner for loop and is added to the newDependencyPackagesToResolve(line138), but pkgC-1 is excluded because it doesn't satisfy the constraint (line 134); in this case the for loop breaks, the code gives up on pkgA-1 and try a different version. In this case, pkgB shouldn't need to be added into newDependencyPackagesToResolve, correct? Only the versions of the pkgA that all its dependencies are met need to be added to newDependencyPackagesToResolve. Did I miss something here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391909218", "createdAt": "2020-03-12T21:33:15Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTc4MTY1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373978165", "createdAt": "2020-03-13T00:19:20Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwMDoxOToyMFrOF1z9EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwMDoxOToyMFrOF1z9EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MDA2NQ==", "bodyText": "Can we have more descriptive names so its easy to read", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391970065", "createdAt": "2020-03-13T00:19:20Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 132}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/73a8bec3a4d64c4b1499bded048a6523279dcfaf", "committedDate": "2020-03-12T07:16:49Z", "message": "Refactor dependency resolution for packages"}, "afterCommit": {"oid": "da2f0e981e43d7ca0f3c624898ba034151bdcd72", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/da2f0e981e43d7ca0f3c624898ba034151bdcd72", "committedDate": "2020-03-13T00:20:38Z", "message": "Refactor dependency resolution for packages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTY2MTEx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373966111", "createdAt": "2020-03-12T23:37:24Z", "commit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQyMzozNzoyNFrOF1zUKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwMDozMjo1OFrOF10JAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1OTU5Mw==", "bodyText": "Even if you have version constraints on top level, the preference should be given to the resolved version. The list being returned from getVersionsToExplore does not come in that order, if I understand correctly, it currently only add the active version at 0th index. We should be adding the resolved version as next in the list I think.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391959593", "createdAt": "2020-03-12T23:37:24Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4MzM5NA=="}, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3MzEyMw==", "bodyText": "I think the newDependencyPackagesToResolve will again be set to  a new HashMap with the next version of pkgA (pkgA-2). So it should be ok.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391973123", "createdAt": "2020-03-13T00:32:58Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        // Update resolvedPackagesWithConstraints with resolvedPackages and packageVersionConstraints\n+        for (Map.Entry<String, Semver> entry : resolvedPackages.entrySet()) {\n+            resolvedPackagesWithConstraints.put(new PackageIdentifier(entry.getKey(), entry.getValue()),\n+                    mergeSemvarRequirements(packageVersionConstraints.get(entry.getKey()).values()));\n+        }\n+        return resolvedPackagesWithConstraints;\n+    }\n+\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                            Map<String, Map<String, String>> packageVersionConstraints,\n+                            Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(allVersions,\n+                packageVersionConstraints.get(pkgName).values(), pkgName);\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkwOTIxOA=="}, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 145}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTg0ODQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373984846", "createdAt": "2020-03-13T00:45:33Z", "commit": {"oid": "da2f0e981e43d7ca0f3c624898ba034151bdcd72"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTg2MDA4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373986008", "createdAt": "2020-03-13T00:49:57Z", "commit": {"oid": "da2f0e981e43d7ca0f3c624898ba034151bdcd72"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwMDo0OTo1N1rOF10X1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwMDo1MzoyNVrOF10axA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NjkxNw==", "bodyText": "ok", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391976917", "createdAt": "2020-03-13T00:49:57Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -23,10 +51,189 @@ public DependencyResolver(PackageRegistry packageRegistry) {\n      * @param document deployment document\n      * @return a map of packages to be run on the device to version constraints\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException when the running thread is interrupted\n+     * @throws IOException when a package cannot be retrieved from the package store\n+     * @throws PackagingException for other package errors\n      */\n-    public Map<PackageIdentifier, String> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new HashMap<>();\n+    public Map<PackageIdentifier, String> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Return value of resolved packages\n+        Map<PackageIdentifier, String> resolvedPackagesWithConstraints = new HashMap<>();\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName()).addKeyValue(\"version\",\n+                    dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg2NDY4MA=="}, "originalCommit": {"oid": "73a8bec3a4d64c4b1499bded048a6523279dcfaf"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk3NzY2OA==", "bodyText": "Remove dead code?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r391977668", "createdAt": "2020-03-13T00:53:25Z", "author": {"login": "abanthiy"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,256 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+\n+    @Inject\n+    private Context context;\n+\n+    public DependencyResolver(PackageStore store) {\n+        this.store = store;\n+    }\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackages = new HashMap<>();\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> packagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        // TODO: accept both pinned version and version constraint\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageVersionConstraints.get(dpc.getPackageName()).put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        boolean resolved = resolve(resolvedPackages, packageVersionConstraints, packagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + packagesToResolve);\n+        }\n+\n+        return resolvedPackages.entrySet().stream().map(e -> new PackageIdentifier(e.getKey(), e.getValue()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackages          map of package names to a pinned version, which is resolved\n+     * @param packageVersionConstraints map of package names (A) to a map of depending package names (B) to the version\n+     *                                  requirements (from B to A)\n+     * @param packagesToResolve         set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n+     */\n+    protected boolean resolve(Map<String, Semver> resolvedPackages,\n+                              Map<String, Map<String, String>> packageVersionConstraints,\n+                              Set<String> packagesToResolve) throws PackagingException, IOException {\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageVersionConstraints.get(pkgName).values());\n+\n+        for (Semver version : versionsToExplore) {\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dep = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackages.containsKey(depPkgName)) {\n+                    if (!resolvedPackages.get(entry.getKey()).satisfies(entry.getValue())) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackages.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolve(resolvedPackages, packageVersionConstraints, packagesToResolve)) {\n+                return true;\n+            }\n+\n+            // Found conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackages.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dep.entrySet()) {\n+                packageVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Get a ordered list of possible versions to explore for the given package.\n+     *\n+     * @param pkgName                      name of the package to be explored\n+     * @param packageVersionConstraintList list of version constraints for the package\n+     * @return list of versions as Semver instances\n+     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected List<Semver> getVersionsToExplore(final String pkgName,\n+                                                final Collection<String> packageVersionConstraintList)\n+            throws UnexpectedPackagingException {\n+        // TODO: Consider package version constraints from other groups/fleets on the device\n+        List<Semver> versionList = new LinkedList<>();\n+        Requirement req = Requirement.buildNPM(mergeSemverRequirements(packageVersionConstraintList));\n+\n+        // Find out all available versions in package store\n+        List<Semver> allVersions = store.getPackageVersionsIfExists(pkgName);\n+\n+        // Add active package version running on the device\n+        Optional<String> version = getPackageVersionIfActive(pkgName);\n+        Semver activeVersion = null;\n+        if (version.isPresent() && req.isSatisfiedBy(version.get())) {\n+            activeVersion = new Semver(version.get());\n+            versionList.add(activeVersion);\n+        }\n+\n+        for (Semver v : allVersions) {\n+            if (req.isSatisfiedBy(v) && !v.equals(activeVersion)) {\n+                versionList.add(v);\n+            }\n+        }\n+\n+        return versionList;\n+    }\n+\n+    protected String mergeSemverRequirements(final Collection<String> packageVersionConstraintList) {\n+        // TODO: See if there's a better way to get the union of version constraints\n+        return packageVersionConstraintList.stream().map(v -> Requirement.buildNPM(v).toString())\n+                .collect(Collectors.joining(\" \"));\n+    }\n+\n+    protected Optional<String> getPackageVersionIfActive(final String packageName) {\n+        EvergreenService service = null;\n+        try {\n+            service = EvergreenService.locate(context, packageName);\n+        } catch (ServiceLoadException e) {\n+            logger.atWarn().setCause(e).addKeyValue(\"packageName\", packageName).log(\"Fail to load package\");\n+            return Optional.empty();\n+        }\n+        Object version = service.config.getChild(\"version\");\n+        return version == null ? Optional.empty() : Optional.of(version.toString());\n+    }\n+\n+    private Package getPackage(final String pkgName, final Semver version) throws PackagingException, IOException {\n+        // TODO: handle exceptions with retry\n+        Optional<Package> optionalPackage = store.getPackage(pkgName, version);\n+        if (!optionalPackage.isPresent()) {\n+            throw new UnexpectedPackagingException(\"Unexpected error in job document: package-version doesn't exist \"\n+                    + pkgName + \"-\" + version);\n+        }\n+        return optionalPackage.get();\n+    }\n+\n+    // Get dependency map for the current platform\n+    private Map<String, String> getPackageDependencies(final Package pkg) throws UnexpectedPackagingException {\n+        return pkg.getDependencies();\n+        // TODO: Add platform keyword\n+        //Object dependencyListForPlatform = PlatformResolver.resolvePlatform((Map) pkg.getDependencies());\n+        //if (!(dependencyListForPlatform instanceof Map)) {\n+        //   throw new UnexpectedPackagingException(\"Unexpected format of dependency map: \" +\n+        //   dependencyListForPlatform);\n+        //}\n+        //return (Map<String, String>) dependencyListForPlatform;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da2f0e981e43d7ca0f3c624898ba034151bdcd72"}, "originalPosition": 263}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da2f0e981e43d7ca0f3c624898ba034151bdcd72", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/da2f0e981e43d7ca0f3c624898ba034151bdcd72", "committedDate": "2020-03-13T00:20:38Z", "message": "Refactor dependency resolution for packages"}, "afterCommit": {"oid": "32a4dff3988eb46699cc2cc16a7fdb74cba78adc", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/32a4dff3988eb46699cc2cc16a7fdb74cba78adc", "committedDate": "2020-03-13T01:05:09Z", "message": "Refactor dependency resolution for packages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTkwOTAw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-373990900", "createdAt": "2020-03-13T01:09:26Z", "commit": {"oid": "da2f0e981e43d7ca0f3c624898ba034151bdcd72"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32a4dff3988eb46699cc2cc16a7fdb74cba78adc", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/32a4dff3988eb46699cc2cc16a7fdb74cba78adc", "committedDate": "2020-03-13T01:05:09Z", "message": "Refactor dependency resolution for packages"}, "afterCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/466e7fd163102380396264f408452a9ce8b831ad", "committedDate": "2020-03-16T21:39:43Z", "message": "Refactor dependency resolution for packages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NzQzMzg3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-375743387", "createdAt": "2020-03-17T05:08:22Z", "commit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNTowODoyMlrOF3OITg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNTowODoyMlrOF3OITg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0NzUwMg==", "bodyText": "In this sense, say A is a root as well as a node in D's tree, can we update A's version through D's deployment?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393447502", "createdAt": "2020-03-17T05:08:22Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,\n+                                            Map<String, Map<String, String>> packageNameToVersionConstraints,\n+                                            Set<String> packagesToResolve)\n+            throws PackagingException, IOException, PackageVersionConflictException {\n+\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+        logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(\"packageName\", pkgName).log();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+\n+        for (Semver version : versionsToExplore) {\n+            logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                    \"version\", version).log();\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dependencyNameToVersionConstraints = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackageNameToVersion.containsKey(depPkgName)) {\n+                    Semver resolvedVersion = resolvedPackageNameToVersion.get(entry.getKey());\n+                    if (!Requirement.buildNPM(entry.getValue()).isSatisfiedBy(resolvedVersion)) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        logger.atDebug().addKeyValue(\"packageName\", depPkgName)\n+                                .addKeyValue(\"resolvedVersion\", resolvedVersion)\n+                                .addKeyValue(\"dependingPackage\", pkgName)\n+                                .addKeyValue(\"versionConstraints\", entry.getValue())\n+                                .log(\"Resolved package version does not satisfy new version constraints of the \"\n+                                        + \"depending package\");\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+            logger.atTrace().addKeyValue(\"packageName\", pkgName).addKeyValue(\"packageVersion\", version).addKeyValue(\n+                    \"dependencies\", newDependencyPackagesToResolve).log(\"Found new dependencies to resolve\");\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageNameToVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackageNameToVersion.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                    packagesToResolve)) {\n+                logger.atDebug().setEventType(\"resolve-package-done\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                        \"version\", version).log();\n+                return true;\n+            }\n+\n+            // Found conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackageNameToVersion.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        logger.atDebug().setEventType(\"resolve-package-backtrack\").addKeyValue(\"packageName\", pkgName).log(\n+                \"Exhaust all possible versions of package without a solution. Backtracking...\");\n+        return false;\n+    }\n+\n+    /**\n+     * Get a ordered list of possible versions to explore for the given package.\n+     *\n+     * @param pkgName                      name of the package to be explored\n+     * @param packageToVersionConstraints list of version constraints for the package\n+     * @return list of versions as Semver instances\n+     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n+     */\n+    protected List<Semver> getVersionsToExplore(final String pkgName,\n+                                                final Map<String, String> packageToVersionConstraints)\n+            throws UnexpectedPackagingException, PackageVersionConflictException {\n+\n+        List<Semver> versionList = new LinkedList<>();\n+        logger.atDebug().addKeyValue(\"packageName\", pkgName).addKeyValue(\"versionConstraints\",\n+                packageToVersionConstraints).log(\"Parsing version constraints for dependency package\");\n+        Requirement req = Requirement.buildNPM(mergeSemverRequirements(packageToVersionConstraints.values()));\n+\n+        if (packageToVersionConstraints.containsKey(ROOT_REQUIREMENT_KEY)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 233}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NzQ1ODU0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-375745854", "createdAt": "2020-03-17T05:17:18Z", "commit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNToxNzoxOFrOF3OP0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNToxNzoxOFrOF3OP0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0OTQyNw==", "bodyText": "Why are the method protected? Can they be package private?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393449427", "createdAt": "2020-03-17T05:17:18Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1Nzk3MDMw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-375797030", "createdAt": "2020-03-17T07:40:42Z", "commit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0MDo0MlrOF3QwPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0MDo0MlrOF3QwPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MDQ5Mw==", "bodyText": "It seems the resolved version takes precedence. Shouldn't re-consider the version of dependency if the resolved version doesn't satisfy with the new constraint?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393490493", "createdAt": "2020-03-17T07:40:42Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,\n+                                            Map<String, Map<String, String>> packageNameToVersionConstraints,\n+                                            Set<String> packagesToResolve)\n+            throws PackagingException, IOException, PackageVersionConflictException {\n+\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+        logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(\"packageName\", pkgName).log();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+\n+        for (Semver version : versionsToExplore) {\n+            logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                    \"version\", version).log();\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dependencyNameToVersionConstraints = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackageNameToVersion.containsKey(depPkgName)) {\n+                    Semver resolvedVersion = resolvedPackageNameToVersion.get(entry.getKey());\n+                    if (!Requirement.buildNPM(entry.getValue()).isSatisfiedBy(resolvedVersion)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MjA4MzMw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-376208330", "createdAt": "2020-03-17T16:36:57Z", "commit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozNjo1N1rOF3kiTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNzozNDo1M1rOF3m4gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxNDYwNA==", "bodyText": "NIT: add some comments explaining why this is needed.\nAlso this can be optimized to save memory. Instead of using a map of map, you can use a map: Map<String, String>. The inner map can be resolved a string value.The key is the packageName, the value is the resolved version constraint of all its depending packages. Every time when a depending package is added or removed, the value can be updated according. This can be done in a separate PR.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393814604", "createdAt": "2020-03-17T16:36:57Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTQxOQ==", "bodyText": "Is there a way to include the package versions that are conflicting?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393825419", "createdAt": "2020-03-17T16:52:12Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgyNTg1Mg==", "bodyText": "Why not arraylist?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393825852", "createdAt": "2020-03-17T16:52:48Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;\n \n     /**\n      * Create the full list of packages to be run on the device from a deployment document.\n      * It also resolves the conflicts between the packages specified in the deployment document and the existing\n      * running packages on the device.\n      *\n      * @param document deployment document\n-     * @return a map of packages to be run on the device to version constraints\n+     * @return a list of packages to be run on the device\n      * @throws PackageVersionConflictException when a package version conflict cannot be resolved\n-     * @throws InterruptedException            when the running thread is interrupted\n+     * @throws IOException                     when a package cannot be retrieved from the package store\n+     * @throws PackagingException              for other package errors\n+     */\n+    public List<PackageIdentifier> resolveDependencies(final DeploymentDocument document)\n+            throws PackageVersionConflictException, IOException, PackagingException {\n+\n+        // A map of package version constraints {packageName => {dependingPackageName => versionConstraint}} to be\n+        // maintained and updated\n+        Map<String, Map<String, String>> packageNameToVersionConstraints = new HashMap<>();\n+\n+        // List of root packages to be resolved\n+        Set<String> rootPackagesToResolve = new LinkedHashSet<>(document.getRootPackages());\n+\n+        // Get a list of package configurations with pinned versions\n+        for (DeploymentPackageConfiguration dpc : document.getDeploymentPackageConfigurationList()) {\n+            logger.atDebug().addKeyValue(\"packageName\", dpc.getPackageName())\n+                    .addKeyValue(\"version\", dpc.getResolvedVersion()).log(\"Found package configuration\");\n+            packageNameToVersionConstraints.putIfAbsent(dpc.getPackageName(), new HashMap<>());\n+            packageNameToVersionConstraints.get(dpc.getPackageName())\n+                    .put(ROOT_REQUIREMENT_KEY, dpc.getResolvedVersion());\n+        }\n+\n+        mergeActiveRootPackages(rootPackagesToResolve, packageNameToVersionConstraints);\n+        logger.atInfo().setEventType(\"resolve-dependencies-start\").addKeyValue(\"rootPackages\", rootPackagesToResolve)\n+                .addKeyValue(\"versionConstraints\", packageNameToVersionConstraints).log();\n+\n+        // Map of package name and resolved version\n+        Map<String, Semver> resolvedPackageNameToVersion = new HashMap<>();\n+        boolean resolved = resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                rootPackagesToResolve);\n+        if (!resolved) {\n+            throw new PackageVersionConflictException(\"Unresolved packages: \" + rootPackagesToResolve);\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-dependencies-done\").addKeyValue(\"packages\", resolvedPackageNameToVersion)\n+                .log();\n+        return resolvedPackageNameToVersion.entrySet().stream()\n+                .map(e -> new PackageIdentifier(e.getKey(), e.getValue())).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Implementation of finding one possible solution for package dependency resolution with backtracking.\n+     *\n+     * @param resolvedPackageNameToVersion    map of package names to a pinned version, which is resolved\n+     * @param packageNameToVersionConstraints map of package names (A) to a map of depending package names (B) to the\n+     *                                        version requirements (from B to A)\n+     * @param packagesToResolve               set of package names, which is yet to be resolved\n+     * @return true when one way to resolve the version of all packages is found, false otherwise\n+     * @throws PackagingException for all package errors\n+     * @throws IOException        when a package cannot be retrieved from the package store\n      */\n-    public List<PackageIdentifier> resolveDependencies(DeploymentDocument document)\n-            throws PackageVersionConflictException, InterruptedException {\n-        return new ArrayList<>();\n+    protected boolean resolveDependencyTree(Map<String, Semver> resolvedPackageNameToVersion,\n+                                            Map<String, Map<String, String>> packageNameToVersionConstraints,\n+                                            Set<String> packagesToResolve)\n+            throws PackagingException, IOException, PackageVersionConflictException {\n+\n+        if (packagesToResolve.isEmpty()) {\n+            return true;\n+        }\n+\n+        // Get any one package from the to-be-resolved list\n+        String pkgName = packagesToResolve.iterator().next();\n+        logger.atDebug().setEventType(\"resolve-package-start\").addKeyValue(\"packageName\", pkgName).log();\n+\n+        // Compile a list of versions to explore for this package in order\n+        List<Semver> versionsToExplore = getVersionsToExplore(pkgName, packageNameToVersionConstraints.get(pkgName));\n+\n+        for (Semver version : versionsToExplore) {\n+            logger.atTrace().setEventType(\"resolve-package-attempt\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                    \"version\", version).log();\n+\n+            // Get package recipe\n+            Package pkgRecipe = getPackage(pkgName, version);\n+\n+            // Get dependency map (of package name to version constraints) for the current platform\n+            Map<String, String> dependencyNameToVersionConstraints = getPackageDependencies(pkgRecipe);\n+\n+            // Note: All changes in Step 1 should be revertible in Step 3\n+            // 1.1. Generate additional new packages to resolve, which are discovered from dependencies\n+            Set<String> newDependencyPackagesToResolve = new HashSet<>();\n+\n+            boolean conflictsInDependency = false;\n+            // Go over dependency map to see if any has been resolved\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                String depPkgName = entry.getKey();\n+\n+                if (resolvedPackageNameToVersion.containsKey(depPkgName)) {\n+                    Semver resolvedVersion = resolvedPackageNameToVersion.get(entry.getKey());\n+                    if (!Requirement.buildNPM(entry.getValue()).isSatisfiedBy(resolvedVersion)) {\n+                        // If a dependency package is already resolved, but the version does not satisfy the current\n+                        // version constraints, there is a conflict.\n+                        // Try another package version.\n+                        conflictsInDependency = true;\n+                        logger.atDebug().addKeyValue(\"packageName\", depPkgName)\n+                                .addKeyValue(\"resolvedVersion\", resolvedVersion)\n+                                .addKeyValue(\"dependingPackage\", pkgName)\n+                                .addKeyValue(\"versionConstraints\", entry.getValue())\n+                                .log(\"Resolved package version does not satisfy new version constraints of the \"\n+                                        + \"depending package\");\n+                        break;\n+                    }\n+                } else if (!packagesToResolve.contains(depPkgName)) {\n+                    // Only add if not already added. Make the change revertible later\n+                    newDependencyPackagesToResolve.add(depPkgName);\n+                }\n+            }\n+            if (conflictsInDependency) {\n+                continue;\n+            }\n+            packagesToResolve.addAll(newDependencyPackagesToResolve);\n+            logger.atTrace().addKeyValue(\"packageName\", pkgName).addKeyValue(\"packageVersion\", version).addKeyValue(\n+                    \"dependencies\", newDependencyPackagesToResolve).log(\"Found new dependencies to resolve\");\n+\n+            // 1.2. Update all dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.putIfAbsent(entry.getKey(), new HashMap<>());\n+                packageNameToVersionConstraints.get(entry.getKey()).put(pkgName, entry.getValue());\n+            }\n+\n+            // 1.3. Resolve current package version\n+            resolvedPackageNameToVersion.put(pkgName, version);\n+            packagesToResolve.remove(pkgName);\n+\n+            // 2. Resolve the rest packages recursively\n+            if (resolveDependencyTree(resolvedPackageNameToVersion, packageNameToVersionConstraints,\n+                    packagesToResolve)) {\n+                logger.atDebug().setEventType(\"resolve-package-done\").addKeyValue(\"packageName\", pkgName).addKeyValue(\n+                        \"version\", version).log();\n+                return true;\n+            }\n+\n+            // Found conflicts in step 2, so revert all step 1 changes\n+            // 3.1. Mark current package as unresolved\n+            packagesToResolve.add(pkgName);\n+            resolvedPackageNameToVersion.remove(pkgName);\n+\n+            // 3.2. Remove dependency version constraints of this package\n+            for (Map.Entry<String, String> entry : dependencyNameToVersionConstraints.entrySet()) {\n+                packageNameToVersionConstraints.get(entry.getKey()).remove(pkgName);\n+            }\n+\n+            // 3.3. Remove newly-introduced dependency packages\n+            packagesToResolve.removeAll(newDependencyPackagesToResolve);\n+\n+        }\n+\n+        logger.atDebug().setEventType(\"resolve-package-backtrack\").addKeyValue(\"packageName\", pkgName).log(\n+                \"Exhaust all possible versions of package without a solution. Backtracking...\");\n+        return false;\n+    }\n+\n+    /**\n+     * Get a ordered list of possible versions to explore for the given package.\n+     *\n+     * @param pkgName                      name of the package to be explored\n+     * @param packageToVersionConstraints list of version constraints for the package\n+     * @return list of versions as Semver instances\n+     * @throws UnexpectedPackagingException when a package cannot be retrieved from the package store\n+     */\n+    protected List<Semver> getVersionsToExplore(final String pkgName,\n+                                                final Map<String, String> packageToVersionConstraints)\n+            throws UnexpectedPackagingException, PackageVersionConflictException {\n+\n+        List<Semver> versionList = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1MzA1OQ==", "bodyText": "Can you add a test case that covers backtracking? It can be done in a separate PR.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393853059", "createdAt": "2020-03-17T17:34:53Z", "author": {"login": "fengwang666"}, "path": "src/test/java/com/aws/iot/evergreen/packagemanager/DependencyResolverTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.packagemanager;\n+\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.dependency.State;\n+import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n+import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class DependencyResolverTest {\n+    @Mock\n+    private PackageStore mockPackageStore;\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private Context context;\n+\n+    @Mock\n+    private EvergreenService mainService;\n+\n+    @BeforeAll\n+    public static void Setup() {\n+        System.setProperty(\"log.fmt\", \"TEXT\");\n+        System.setProperty(\"log.store\", \"CONSOLE\");\n+        System.setProperty(\"log.level\", \"TRACE\");\n+    }\n+\n+    @Nested\n+    class MergeSemverRequirementsTest {\n+        @Spy\n+        private DependencyResolver resolver = new DependencyResolver(mockPackageStore, kernel, context);\n+\n+        @Test\n+        public void GIVEN_list_of_version_ranges_WHEN_get_union_THEN_get_version_range() {\n+            List<String> constraints = new LinkedList<>();\n+            constraints.add(\"<3.0\");\n+            constraints.add(\">1.0\");\n+            constraints.add(\">2.0\");\n+            String req = resolver.mergeSemverRequirements(constraints);\n+            assertEquals(\"<3.0 >1.0 >2.0\", req);\n+\n+            Requirement r = Requirement.buildNPM(req);\n+            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n+            assertTrue(r.isSatisfiedBy(\"2.0.1\"));\n+        }\n+\n+        @Test\n+        public void GIVEN_list_of_version_range_and_pinned_version_WHEN_get_union_THEN_get_pinned_version() {\n+            List<String> constraints = new LinkedList<>();\n+            constraints.add(\"<3.0\");\n+            constraints.add(\"1.0.0\");\n+            String req = resolver.mergeSemverRequirements(constraints);\n+            assertEquals(\"<3.0 =1.0.0\", req);\n+\n+            Requirement r = Requirement.buildNPM(req);\n+            assertFalse(r.isSatisfiedBy(\"1.0.1\"));\n+            assertTrue(r.isSatisfiedBy(\"1.0.0\"));\n+        }\n+\n+        @Test\n+        public void GIVEN_list_of_version_range_with_conflicts_WHEN_get_union_THEN_get_no_version_match() {\n+            List<String> constraints = new LinkedList<>();\n+            constraints.add(\">4.0\");\n+            constraints.add(\"<3.0\");\n+            String req = resolver.mergeSemverRequirements(constraints);\n+            assertEquals(\">4.0 <3.0\", req);\n+\n+            Requirement r = Requirement.buildNPM(req);\n+            assertFalse(r.isSatisfiedBy(\"4.0.1\"));\n+            assertFalse(r.isSatisfiedBy(\"2.0.0\"));\n+        }\n+    }\n+\n+    @Nested\n+    class GetVersionsToExploreTest{\n+        @Test\n+        public void GIVEN_package_not_active_WHEN_get_versions_THEN_get_version_within_constraint() throws UnexpectedPackagingException, PackageVersionConflictException {\n+            when(mockPackageStore.getPackageVersionsIfExists(\"testPackage\")).thenReturn(Arrays.asList(new Semver(\"1.2\" +\n+                    \".0\"), new Semver(\"1.1.0\"), new Semver(\"1.0.0\")));\n+            DependencyResolver resolver = spy(new DependencyResolver(mockPackageStore, kernel, context));\n+            doReturn(Optional.empty()).when(resolver).getPackageVersionIfActive(any());\n+\n+            Map<String, String> versionConstraints = new HashMap<>();\n+            versionConstraints.putIfAbsent(\"mock\", \">1.0\");\n+            List<Semver> versions = resolver.getVersionsToExplore(\"testPackage\", versionConstraints);\n+            assertEquals(Arrays.asList(new Semver(\"1.2.0\"), new Semver(\"1.1.0\")), versions);\n+        }\n+\n+        @Test\n+        public void GIVEN_package_active_WHEN_get_versions_THEN_get_active_version_first() throws UnexpectedPackagingException, PackageVersionConflictException {\n+            when(mockPackageStore.getPackageVersionsIfExists(\"testPackage\")).thenReturn(Arrays.asList(new Semver(\"1\" +\n+                    \".2.0\"), new Semver(\"1.1.0\"), new Semver(\"1.0.0\")));\n+            DependencyResolver resolver = spy(new DependencyResolver(mockPackageStore, kernel, context));\n+            doReturn(Optional.of(\"1.1.0\")).when(resolver).getPackageVersionIfActive(any());\n+\n+            Map<String, String> versionConstraints = new HashMap<>();\n+            versionConstraints.putIfAbsent(\"mock\", \">1.0\");\n+            List<Semver> versions = resolver.getVersionsToExplore(\"testPackage\", versionConstraints);\n+            assertEquals(Arrays.asList(new Semver(\"1.1.0\"), new Semver(\"1.2.0\")), versions);\n+        }\n+    }\n+\n+    @Nested\n+    class ResolveDependenciesTest{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2Mjg3NzQx", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-376287741", "createdAt": "2020-03-17T18:13:06Z", "commit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODoxMzowN1rOF3oVLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODoxMzowN1rOF3oVLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg3Njc4Mw==", "bodyText": "Shouldn't kernel be also injected? and could you not use kernel.context instead of having context separately injected here?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393876783", "createdAt": "2020-03-17T18:13:07Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/DependencyResolver.java", "diffHunk": "@@ -3,32 +3,328 @@\n \n package com.aws.iot.evergreen.packagemanager;\n \n+import com.aws.iot.evergreen.config.Node;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.dependency.Context;\n import com.aws.iot.evergreen.deployment.model.DeploymentDocument;\n+import com.aws.iot.evergreen.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n import com.aws.iot.evergreen.packagemanager.exceptions.PackageVersionConflictException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.PackagingException;\n+import com.aws.iot.evergreen.packagemanager.exceptions.UnexpectedPackagingException;\n+import com.aws.iot.evergreen.packagemanager.models.Package;\n import com.aws.iot.evergreen.packagemanager.models.PackageIdentifier;\n+import com.aws.iot.evergreen.packagemanager.plugins.PackageStore;\n+import com.vdurmont.semver4j.Requirement;\n+import com.vdurmont.semver4j.Semver;\n import lombok.AllArgsConstructor;\n \n-import java.util.ArrayList;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n \n @AllArgsConstructor\n public class DependencyResolver {\n-    // TODO: temporarily suppress this warning which will be gone after these fields get used.\n-    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value = \"URF_UNREAD_FIELD\")\n-    private final PackageRegistry packageRegistry;\n+    private static final Logger logger = LogManager.getLogger(DependencyResolver.class);\n+    private static final String ROOT_REQUIREMENT_KEY = \"ROOT\";\n+\n+    private final PackageStore store;\n+    private final Kernel kernel;\n+\n+    @Inject\n+    private Context context;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MzE4MTM0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-376318134", "createdAt": "2020-03-17T18:54:53Z", "commit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODo1NDo1M1rOF3p0kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODo1NDo1M1rOF3p0kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkwMTIwMg==", "bodyText": "Thanks for cleaning this up!", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#discussion_r393901202", "createdAt": "2020-03-17T18:54:53Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/packagemanager/KernelConfigResolver.java", "diffHunk": "@@ -25,8 +25,7 @@\n public class KernelConfigResolver {\n \n     private static final String SERVICE_DEPENDENCIES_CONFIG_KEY = \"dependencies\";\n-    private static final String VERSION_CONFIG_KEY = \"version\";\n-    private static final String VERSION_CONSTRAINT_CONFIG_KEY = \"versionconstraint\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MzE5MzY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-376319364", "createdAt": "2020-03-17T18:56:39Z", "commit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b79403cbb3bc0c9911f61d00c3437e700096797", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b79403cbb3bc0c9911f61d00c3437e700096797", "committedDate": "2020-03-17T22:05:34Z", "message": "Refactor dependency resolution for packages"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "466e7fd163102380396264f408452a9ce8b831ad", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/466e7fd163102380396264f408452a9ce8b831ad", "committedDate": "2020-03-16T21:39:43Z", "message": "Refactor dependency resolution for packages"}, "afterCommit": {"oid": "3b79403cbb3bc0c9911f61d00c3437e700096797", "author": {"user": {"login": "hui-yang", "name": "Hui Yang"}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3b79403cbb3bc0c9911f61d00c3437e700096797", "committedDate": "2020-03-17T22:05:34Z", "message": "Refactor dependency resolution for packages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDQ2NDUz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/111#pullrequestreview-376446453", "createdAt": "2020-03-17T22:23:20Z", "commit": {"oid": "3b79403cbb3bc0c9911f61d00c3437e700096797"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2335, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}