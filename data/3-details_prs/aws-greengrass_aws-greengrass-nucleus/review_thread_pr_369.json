{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5MTIwMTI4", "number": 369, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NTowMFrOEZQllw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzo0NzoxN1rOEbDcxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIxNjIzOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NTowMFrOHB-dDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NTowMFrOHB-dDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzMzg2OA==", "bodyText": "[nit]\nDuration.ofSeconds(3).toMillis()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471833868", "createdAt": "2020-08-17T23:45:00Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIxNzA5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NToyN1rOHB-djg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MjowMlrOHB_Zrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzMzk5OA==", "bodyText": "shouldn't we fail the test on this?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471833998", "createdAt": "2020-08-17T23:45:27Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){\n+                preComponentUpdateCount.getAndIncrement();\n+                //defer update the first time\n+                //no response the second time causes the kernel to move forward after default wait time\n+                if(deferCount.get() < 1){\n+                    try {\n+                        deferCount.getAndIncrement();\n+                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n+                    } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTM5MQ==", "bodyText": "if deferComponentUpdate call fails the test will fail as, the test expects it to be called twice. Moved the count after the function call.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849391", "createdAt": "2020-08-18T00:42:02Z", "author": {"login": "fahadmohammed01"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,49 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){\n+                preComponentUpdateCount.getAndIncrement();\n+                //defer update the first time\n+                //no response the second time causes the kernel to move forward after default wait time\n+                if(deferCount.get() < 1){\n+                    try {\n+                        deferCount.getAndIncrement();\n+                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n+                    } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzMzk5OA=="}, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIxODU5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NjoxOFrOHB-eXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MjowMVrOHB_ZrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDIwNA==", "bodyText": "likewise", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834204", "createdAt": "2020-08-17T23:46:18Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -376,6 +382,20 @@ void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_pr\n                 DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n                 System.currentTimeMillis());\n         resultFuture.get(30, TimeUnit.SECONDS);\n+\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"NonDisruptableService\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+            if (event instanceof PreComponentUpdateEvent) {\n+                try {\n+                    lifecycle.deferComponentUpdate(\"NonDisruptableService\", TimeUnit.SECONDS.toMillis(60));\n+                    ipcClient.disconnect();\n+                } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTM4OA==", "bodyText": "if deferComponentUpdate, the test will fail because the logs wont have \"deferred by NonDisruptableService\" entry", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849388", "createdAt": "2020-08-18T00:42:01Z", "author": {"login": "fahadmohammed01"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -376,6 +382,20 @@ void GIVEN_deployment_in_progress_WHEN_deployment_task_is_cancelled_THEN_stop_pr\n                 DeploymentTaskIntegrationTest.class.getResource(\"AddNewServiceWithSafetyCheck.json\").toURI(),\n                 System.currentTimeMillis());\n         resultFuture.get(30, TimeUnit.SECONDS);\n+\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"NonDisruptableService\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+            if (event instanceof PreComponentUpdateEvent) {\n+                try {\n+                    lifecycle.deferComponentUpdate(\"NonDisruptableService\", TimeUnit.SECONDS.toMillis(60));\n+                    ipcClient.disconnect();\n+                } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDIwNA=="}, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIyMDI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NzowMVrOHB-fQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MTo1OFrOHB_Zow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDQzNQ==", "bodyText": "[nit]\nUse a set", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834435", "createdAt": "2020-08-17T23:47:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -3,74 +3,67 @@\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n-import com.aws.iot.evergreen.ipc.common.FrameReader;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleClientOpCodes;\n+import com.aws.iot.evergreen.ipc.common.ServiceEventHelper;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse.DeferComponentUpdateResponseBuilder;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleGenericResponse;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleImpl;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PostComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PreComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.SubscribeToComponentUpdatesResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.UpdateStateRequest;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n \n-import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.function.BiConsumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode.LIFECYCLE;\n+\n /**\n  * Class to handle business logic for all Lifecycle requests over IPC.\n  */\n public class LifecycleIPCAgent implements InjectionActions {\n-    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n-    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n-            new DefaultConcurrentHashMap<>(ConcurrentHashMap::new);\n-    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final List<ConnectionContext> componentUpdateListeners = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTM3OQ==", "bodyText": "updated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849379", "createdAt": "2020-08-18T00:41:58Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -3,74 +3,67 @@\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n-import com.aws.iot.evergreen.ipc.common.FrameReader;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleClientOpCodes;\n+import com.aws.iot.evergreen.ipc.common.ServiceEventHelper;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse.DeferComponentUpdateResponseBuilder;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleGenericResponse;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleImpl;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PostComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PreComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.SubscribeToComponentUpdatesResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.UpdateStateRequest;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n \n-import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.function.BiConsumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode.LIFECYCLE;\n+\n /**\n  * Class to handle business logic for all Lifecycle requests over IPC.\n  */\n public class LifecycleIPCAgent implements InjectionActions {\n-    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n-    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n-            new DefaultConcurrentHashMap<>(ConcurrentHashMap::new);\n-    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final List<ConnectionContext> componentUpdateListeners = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDQzNQ=="}, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIyMDkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0NzoyNFrOHB-foA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTowNjo0NlrOHCmsnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDUyOA==", "bodyText": "can you add a comment about how this is used?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834528", "createdAt": "2020-08-17T23:47:24Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -3,74 +3,67 @@\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n-import com.aws.iot.evergreen.ipc.common.FrameReader;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleClientOpCodes;\n+import com.aws.iot.evergreen.ipc.common.ServiceEventHelper;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse.DeferComponentUpdateResponseBuilder;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleGenericResponse;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleImpl;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PostComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PreComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.SubscribeToComponentUpdatesResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.UpdateStateRequest;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n \n-import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.function.BiConsumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode.LIFECYCLE;\n+\n /**\n  * Class to handle business logic for all Lifecycle requests over IPC.\n  */\n public class LifecycleIPCAgent implements InjectionActions {\n-    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n-    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n-            new DefaultConcurrentHashMap<>(ConcurrentHashMap::new);\n-    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final List<ConnectionContext> componentUpdateListeners = new CopyOnWriteArrayList<>();\n+\n+    private final Map<ConnectionContext, CompletableFuture<DeferComponentUpdateRequest>> deferUpdateFuturesMap =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MzIxNQ==", "bodyText": "updated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r472493215", "createdAt": "2020-08-18T21:06:46Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -3,74 +3,67 @@\n import com.aws.iot.evergreen.dependency.InjectionActions;\n import com.aws.iot.evergreen.dependency.State;\n import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n-import com.aws.iot.evergreen.ipc.common.FrameReader;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleClientOpCodes;\n+import com.aws.iot.evergreen.ipc.common.ServiceEventHelper;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.DeferComponentUpdateResponse.DeferComponentUpdateResponseBuilder;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleGenericResponse;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleImpl;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleListenRequest;\n import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleResponseStatus;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateChangeRequest;\n-import com.aws.iot.evergreen.ipc.services.lifecycle.StateTransitionEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.LifecycleServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PostComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.PreComponentUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.SubscribeToComponentUpdatesResponse;\n+import com.aws.iot.evergreen.ipc.services.lifecycle.UpdateStateRequest;\n import com.aws.iot.evergreen.kernel.EvergreenService;\n-import com.aws.iot.evergreen.kernel.GlobalStateChangeListener;\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.DefaultConcurrentHashMap;\n \n-import java.io.IOException;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.CopyOnWriteArrayList;\n import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.function.BiConsumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode.LIFECYCLE;\n+\n /**\n  * Class to handle business logic for all Lifecycle requests over IPC.\n  */\n public class LifecycleIPCAgent implements InjectionActions {\n-    // Map from service that is listened to --> Map of connection --> Function to call when service state changes\n-    private static final Map<String, Map<ConnectionContext, BiConsumer<State, State>>> listeners =\n-            new DefaultConcurrentHashMap<>(ConcurrentHashMap::new);\n-    private static final int TIMEOUT_SECONDS = 30;\n+\n+    private final List<ConnectionContext> componentUpdateListeners = new CopyOnWriteArrayList<>();\n+\n+    private final Map<ConnectionContext, CompletableFuture<DeferComponentUpdateRequest>> deferUpdateFuturesMap =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDUyOA=="}, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIyMTUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0Nzo0NVrOHB-f9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTowNzowNFrOHCmtNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDYxNA==", "bodyText": "debug", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834614", "createdAt": "2020-08-17T23:47:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MzM2Nw==", "bodyText": "updated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r472493367", "createdAt": "2020-08-18T21:07:04Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDYxNA=="}, "originalCommit": {"oid": "9f1067033a4841d7525a10aad96adb92c73735e0"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIyMzM1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo0ODo0OFrOHB-hFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTowNjoxMlrOHCmrkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDkwMA==", "bodyText": "use interpolation instead of concatenation", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471834900", "createdAt": "2020-08-17T23:48:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTMzMA==", "bodyText": "#353 (comment) :)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849330", "createdAt": "2020-08-18T00:41:47Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDkwMA=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1MjU0OA==", "bodyText": "I'm not a hypocrite, don't worry. Since this is a log, it is possible that info level isn't enabled, in which case we really want to use interpolation because that is a no-op.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471852548", "createdAt": "2020-08-18T00:54:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDkwMA=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5Mjk0Ng==", "bodyText": "lol I believe you :P, updated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r472492946", "createdAt": "2020-08-18T21:06:12Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNDkwMA=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIyNjIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo1MDowNlrOHB-irg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MTo0NVrOHB_Zaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTMxMA==", "bodyText": "Does this need to be info?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471835310", "createdAt": "2020-08-17T23:50:06Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.info(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTMyMw==", "bodyText": "not really, changed to debug", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849323", "createdAt": "2020-08-18T00:41:45Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.info(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTMxMA=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIyNzk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo1MTowMVrOHB-jrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MTo0MlrOHB_ZYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTU2NA==", "bodyText": "completing the future means that the update should be delayed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471835564", "createdAt": "2020-08-17T23:51:01Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.info(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferComponentUpdateRequest> deferComponentUpdateRequestFuture =\n+                deferUpdateFuturesMap.get(context);\n+        if (deferComponentUpdateRequestFuture == null) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Time limit to respond to PreComponentUpdateEvent exceeded\").build();\n+        }\n+\n+        deferComponentUpdateRequestFuture.complete(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTMxNA==", "bodyText": "completing the future means the component responded. UpdateSystemSafelyService will check the recheckTimeInMs field to determine if update needs to be delayed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849314", "createdAt": "2020-08-18T00:41:42Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +81,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.info(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.info(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferComponentUpdateRequest> deferComponentUpdateRequestFuture =\n+                deferUpdateFuturesMap.get(context);\n+        if (deferComponentUpdateRequestFuture == null) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Time limit to respond to PreComponentUpdateEvent exceeded\").build();\n+        }\n+\n+        deferComponentUpdateRequestFuture.complete(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTU2NA=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIzMDYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo1MjoyM1rOHB-lJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MTo0MFrOHB_ZVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTk0Mw==", "bodyText": "just remove them, why comment it out?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471835943", "createdAt": "2020-08-17T23:52:23Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -313,7 +304,7 @@ public long whenIsDisruptionOK() {\n         // By default, if anything goes wrong we will assume it is not safe to update right now\n         return Instant.now().plusSeconds(recheckSeconds).toEpochMilli();\n     }\n-\n+    /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTMwMg==", "bodyText": "my bad, removed.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849302", "createdAt": "2020-08-18T00:41:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/GenericExternalService.java", "diffHunk": "@@ -313,7 +304,7 @@ public long whenIsDisruptionOK() {\n         // By default, if anything goes wrong we will assume it is not safe to update right now\n         return Instant.now().plusSeconds(recheckSeconds).toEpochMilli();\n     }\n-\n+    /*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNTk0Mw=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIzMzAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo1Mzo0OVrOHB-mjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MTozOFrOHB_ZQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNjMwMw==", "bodyText": "log?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471836303", "createdAt": "2020-08-17T23:53:49Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());\n+                            }\n+                        } catch (ExecutionException e) {\n+                            //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTI4MQ==", "bodyText": "updated", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849281", "createdAt": "2020-08-18T00:41:38Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());\n+                            }\n+                        } catch (ExecutionException e) {\n+                            //", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNjMwMw=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTIzNDAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMzo1NDoyOVrOHB-nNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwMDo0MTozNVrOHB_ZMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNjQ2OQ==", "bodyText": "can it not be public if it is only for testing?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471836469", "createdAt": "2020-08-17T23:54:29Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -154,4 +185,10 @@ protected void startup() throws InterruptedException {\n             }\n         }\n     }\n+\n+    //only for testing\n+    public void setDefaultTimeOutInMs(long defaultTimeOutInMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0OTI2NQ==", "bodyText": "Its used in deployment package, hence public", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r471849265", "createdAt": "2020-08-18T00:41:35Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -154,4 +185,10 @@ protected void startup() throws InterruptedException {\n             }\n         }\n     }\n+\n+    //only for testing\n+    public void setDefaultTimeOutInMs(long defaultTimeOutInMs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzNjQ2OQ=="}, "originalCommit": {"oid": "5ac90da363f3b1e2a3bf00c9f2838cdc45369096"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NDIxNzE0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMjo0OTozMlrOHCuNVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzowNjozM1rOHEWJOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYxNjI3OQ==", "bodyText": "Nit - formatting here and a few places below", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r472616279", "createdAt": "2020-08-19T02:49:32Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbf3ac5a238c20ef20274cdb0f2d8844acd08e24"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxOTE2Mw==", "bodyText": "Fixed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474319163", "createdAt": "2020-08-20T23:06:33Z", "author": {"login": "fahadmohammed01"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYxNjI3OQ=="}, "originalCommit": {"oid": "bbf3ac5a238c20ef20274cdb0f2d8844acd08e24"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDcxNTI0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzowODowNlrOHDu5FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzowNjozMFrOHEWJLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY3NjA1Mg==", "bodyText": "Why not add this to throws ? If I understand correctly this is a checked exception but it indicates a failure if the client does get this exception right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473676052", "createdAt": "2020-08-20T07:08:06Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){\n+                preComponentUpdateCount.getAndIncrement();\n+                //defer update the first time\n+                //no response the second time causes the kernel to move forward after default wait time\n+                if(deferCount.get() < 1){\n+                    try {\n+                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n+                        deferCount.getAndIncrement();\n+                    } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxOTE0OA==", "bodyText": "Not throwing because its inside a consumer. If the deferComponentUpdate failed the test will not pass as the test verifies that PreComponentUpdateEvent was pushed twice", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474319148", "createdAt": "2020-08-20T23:06:30Z", "author": {"login": "fahadmohammed01"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -444,45 +454,48 @@ void GIVEN_a_running_service_is_not_disruptable_WHEN_deployed_THEN_deployment_wa\n                 mainFinished.countDown();\n             }\n         });\n-\n         // wait for main to finish\n         assertTrue(mainFinished.await(10, TimeUnit.SECONDS));\n \n-        Map<Object, Object> currentConfig = new HashMap<>(kernel.getConfig().toPOJO());\n+        KernelIPCClientConfig nonDisruptable = getIPCConfigForService(\"nondisruptable\", kernel);\n+        IPCClientImpl ipcClient = new IPCClientImpl(nonDisruptable);\n+        Lifecycle lifecycle = new LifecycleImpl(ipcClient);\n+\n+        UpdateSystemSafelyService updateSystemSafelyService = kernel.getContext().get(UpdateSystemSafelyService.class);\n+        updateSystemSafelyService.setDefaultTimeOutInMs(TimeUnit.SECONDS.toMillis(3));\n+\n+        AtomicInteger deferCount = new AtomicInteger(0);\n+        AtomicInteger preComponentUpdateCount = new AtomicInteger(0);\n+        CountDownLatch postComponentUpdateRecieved = new CountDownLatch(1);\n+        lifecycle.subscribeToComponentUpdate((event) -> {\n+\n+            if(event instanceof PreComponentUpdateEvent){\n+                preComponentUpdateCount.getAndIncrement();\n+                //defer update the first time\n+                //no response the second time causes the kernel to move forward after default wait time\n+                if(deferCount.get() < 1){\n+                    try {\n+                        lifecycle.deferComponentUpdate(\"nondisruptable\", TimeUnit.SECONDS.toMillis(5));\n+                        deferCount.getAndIncrement();\n+                    } catch (LifecycleIPCException e) { }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY3NjA1Mg=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDc1Njc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzoxNjoxNFrOHDvTKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzoxNjo0OVrOHEWVSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MjczMQ==", "bodyText": "This doesn't read very well I think - (System.currentTimeMillis() - now) Might want to change the name from now to something more appropriate", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473682731", "createdAt": "2020-08-20T07:16:14Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjI1MQ==", "bodyText": "renamed now to currentTimeMillis", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474322251", "createdAt": "2020-08-20T23:16:49Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MjczMQ=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDc3OTM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzoyMDo0M1rOHDvhhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzozNDoxMVrOHEWpRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4NjQwNg==", "bodyText": "why is this needed?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473686406", "createdAt": "2020-08-20T07:20:43Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());\n+                            }\n+                        } catch (ExecutionException e) {\n+                            logger.error(\"Failed to process component update request\", e);\n+                        }\n+                        iterator.remove();\n+                    }\n                 }\n+                Thread.sleep(TimeUnit.SECONDS.toMillis(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNzM2Ng==", "bodyText": "Poll every second to check if all components responded. If not wait till max timeout.  Without this it will be a busy wait", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474327366", "createdAt": "2020-08-20T23:34:11Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());\n+                            }\n+                        } catch (ExecutionException e) {\n+                            logger.error(\"Failed to process component update request\", e);\n+                        }\n+                        iterator.remove();\n+                    }\n                 }\n+                Thread.sleep(TimeUnit.SECONDS.toMillis(1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4NjQwNg=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDgwMjQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzoyNToyNlrOHDvw4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzoxNjozMFrOHEWU5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5MDMzNg==", "bodyText": "When one of the services defers update, this will cause a fresh set of PreComponentUpdateEvents to be sent to all services who have subscribed right? Do you not need to discard futures from previous batch in that case? Or alternately, manage that inside lifecycleIPCAgent.sendPreComponentUpdateEvent ? It doesn't seem to clear the set of futures on each sendPreComponentUpdateEvent call?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473690336", "createdAt": "2020-08-20T07:25:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMjE0OA==", "bodyText": "Updated to clear the future explicitly before sending next set of events", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474322148", "createdAt": "2020-08-20T23:16:30Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -123,23 +130,47 @@ protected void startup() throws InterruptedException {\n                 }\n             }\n             logger.atInfo().setEventType(\"get-available-service-update\").log();\n+            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n+                    .log();\n+\n+            //TODO: set isGgcRestarting to true if the updates involves kernel restart\n+            PreComponentUpdateEvent preComponentUpdateEvent = PreComponentUpdateEvent.builder()\n+                    .isGgcRestarting(false).build();\n+            List<Future<DeferComponentUpdateRequest>> deferRequestFutures = new ArrayList<>();\n+            lifecycleIPCAgent.sendPreComponentUpdateEvent(preComponentUpdateEvent, deferRequestFutures);\n+\n             // TODO: should really use an injected clock to support simulation-time\n             //      it's a big project and would affect many parts of the system.\n             final long now = System.currentTimeMillis();\n             long maxt = now;\n-\n-            logger.atDebug().setEventType(\"service-update-pending\").addKeyValue(\"numOfUpdates\", pendingActions.size())\n-                    .log();\n-            for (EvergreenService s : kernel.orderedDependencies()) {\n-                long ct = s.whenIsDisruptionOK();\n-                if (ct > maxt) {\n-                    maxt = ct;\n+            while ((System.currentTimeMillis() - now) < defaultTimeOutInMs && !deferRequestFutures.isEmpty()) {\n+                Iterator<Future<DeferComponentUpdateRequest>> iterator = deferRequestFutures.iterator();\n+                while (iterator.hasNext()) {\n+                    Future<DeferComponentUpdateRequest> fut = iterator.next();\n+                    if (fut.isDone()) {\n+                        try {\n+                            DeferComponentUpdateRequest deferRequest = fut.get();\n+                            long timeToRecheck = now + deferRequest.getRecheckTimeInMs();\n+                            if (timeToRecheck > maxt) {\n+                                maxt = timeToRecheck;\n+                                logger.atInfo().setEventType(\"service-update-deferred\")\n+                                        .log(\"deferred by {} for {} millis\", deferRequest.getComponentName(),\n+                                                deferRequest.getRecheckTimeInMs());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5MDMzNg=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDgzOTM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozMjozMVrOHDwIGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzowNjoxNFrOHEWIyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NjI4Mw==", "bodyText": "There's no way for the component's process to report an error if it encounters one while evaluating the condition to defer update right? If there's a problem with that piece of code in customer's component, do we expect that customers should write it in a way that it always manages to make a defer update request? What happens if they can't make a defer request because of a bug/error and kernel takes that as it being okay with the update? What if that component happens to be performing critical tasks which are not safe to disrupt?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473696283", "createdAt": "2020-08-20T07:32:31Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxOTA1MQ==", "bodyText": "The contract the component agrees to when subscribing to component updates is that it will respond with a deferComponentUpdate event within the timeout period (which can be configured by the customer).", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474319051", "createdAt": "2020-08-20T23:06:14Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5NjI4Mw=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDg5MTg5OnYy", "diffSide": "LEFT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzozOToyN1rOHDwqww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzowNjoyNVrOHEWJCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcwNTE1NQ==", "bodyText": "So all of the lifecycle APIs are being tested in the deployment workflow integ tests now? Do we need more tests? How is UpdateState API tested for instance?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473705155", "createdAt": "2020-08-20T07:39:27Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -155,25 +151,7 @@ void registerResourcePermissionTest() throws Exception {\n \n         assertThrows(ResourceNotOwnedException.class, () -> c.registerResource(req));\n     }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxOTExMw==", "bodyText": "I couldnt find any integ test, added one.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474319113", "createdAt": "2020-08-20T23:06:25Z", "author": {"login": "fahadmohammed01"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -155,25 +151,7 @@ void registerResourcePermissionTest() throws Exception {\n \n         assertThrows(ResourceNotOwnedException.class, () -> c.registerResource(req));\n     }\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcwNTE1NQ=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDk0NjU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNzo0Njo0NlrOHDxPww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNToyOTozOFrOHEcF2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxNDYyNw==", "bodyText": "Following up on my comment on the sdk PR, there's componentname in the defer request https://github.com/aws/aws-greengrass-sdk-java/pull/50/files#r472616090, if it's only for logging which I see being the case in UpdateSystemSafelyService.java, should we validate that no components are making requests with some other component's name?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r473714627", "createdAt": "2020-08-20T07:46:46Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferComponentUpdateRequest> deferComponentUpdateRequestFuture =\n+                deferUpdateFuturesMap.get(context);\n+        if (deferComponentUpdateRequestFuture == null) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Time limit to respond to PreComponentUpdateEvent exceeded\").build();\n+        }\n+\n+        deferComponentUpdateRequestFuture.complete(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxOTAzMw==", "bodyText": "We also need to support the use case that there would be one component who would be monitoring the whole system and defers the update if any other component cannot be disrupted.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474319033", "createdAt": "2020-08-20T23:06:10Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferComponentUpdateRequest> deferComponentUpdateRequestFuture =\n+                deferUpdateFuturesMap.get(context);\n+        if (deferComponentUpdateRequestFuture == null) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Time limit to respond to PreComponentUpdateEvent exceeded\").build();\n+        }\n+\n+        deferComponentUpdateRequestFuture.complete(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxNDYyNw=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxNjYwMg==", "bodyText": "removed component name and added an optional message field to the deferUpdateRequest object.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474416602", "createdAt": "2020-08-21T05:29:38Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,84 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferComponentUpdateRequest>> deferUpdateFutures) {\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferComponentUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferComponentUpdateRequest> deferComponentUpdateRequestFuture =\n+                deferUpdateFuturesMap.get(context);\n+        if (deferComponentUpdateRequestFuture == null) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Time limit to respond to PreComponentUpdateEvent exceeded\").build();\n+        }\n+\n+        deferComponentUpdateRequestFuture.complete(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxNDYyNw=="}, "originalCommit": {"oid": "e240d6c1d17f76591020b278e890c02cece8d357"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzYzMjQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNTozOTozN1rOHEyFXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMDo1NzoyMFrOHE9jrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjkyNQ==", "bodyText": "Can it be immutable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474776925", "createdAt": "2020-08-21T15:39:37Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class DeferUpdateRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0MDQ5OA==", "bodyText": "No, doesn't work with Jackson.\nAlso, this needs @NoArgsConstructor", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474840498", "createdAt": "2020-08-21T17:47:15Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class DeferUpdateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjkyNQ=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1Nzk1MA==", "bodyText": "This is not used by Jackson, it s pojo created by the LifeCycleAPIAgent and passed to who ever is calling sendPreComponentUpdateEvent", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474857950", "createdAt": "2020-08-21T18:25:16Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class DeferUpdateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjkyNQ=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4MDc4MQ==", "bodyText": "Even it's used by Jackson, it still can be immutable. It's better to be immutable.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474880781", "createdAt": "2020-08-21T19:13:56Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class DeferUpdateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjkyNQ=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4MTgwMA==", "bodyText": "No, using @Value doesn't work with Jackson AFAIK", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474881800", "createdAt": "2020-08-21T19:15:10Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class DeferUpdateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjkyNQ=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk2NDkwOA==", "bodyText": "Made DeferUpdateRequest immutable", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474964908", "createdAt": "2020-08-21T20:57:20Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/DeferUpdateRequest.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.aws.iot.evergreen.builtin.services.lifecycle;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+\n+@Data\n+@AllArgsConstructor\n+public class DeferUpdateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc3NjkyNQ=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzc2NjE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjoyMDoyNVrOHEzYdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMTo1MzoxNFrOHE-1Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5ODE5Ng==", "bodyText": "If timeouts are to be made configurable, they will need to be added as service/system config that can change in deployment, when we do that this will not be needed since we should be able to use the config for testing as well, can you add a TODO for that here and have it say that this should be removed when that happens?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474798196", "createdAt": "2020-08-21T16:20:25Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -154,4 +188,10 @@ protected void startup() throws InterruptedException {\n             }\n         }\n     }\n+\n+    //only for testing\n+    public void setDefaultTimeOutInMs(long defaultTimeOutInMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1MzE2NQ==", "bodyText": "we need this for integ test where we do not do a full deployment but use mergeInNewConfig", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474853165", "createdAt": "2020-08-21T18:14:32Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -154,4 +188,10 @@ protected void startup() throws InterruptedException {\n             }\n         }\n     }\n+\n+    //only for testing\n+    public void setDefaultTimeOutInMs(long defaultTimeOutInMs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5ODE5Ng=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk4NTgxOA==", "bodyText": "Well, there are still two ways to do that through tests, 1) mergeInNewConfig takes deployment document as argument and 2) UpdateSystemSafelyService could read it from system config directly, depending on how the timeout setting through deployment is implemented and I would really prefer that, not blocking this PR on it though", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474985818", "createdAt": "2020-08-21T21:53:14Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/UpdateSystemSafelyService.java", "diffHunk": "@@ -154,4 +188,10 @@ protected void startup() throws InterruptedException {\n             }\n         }\n     }\n+\n+    //only for testing\n+    public void setDefaultTimeOutInMs(long defaultTimeOutInMs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc5ODE5Ng=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzg3NjI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo1NToxNFrOHE0cPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoxMjo0OFrOHE2sPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNTU0OA==", "bodyText": "Is 'beforeComponentUpdate' more accurate on what this API is doing?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474815548", "createdAt": "2020-08-21T16:55:14Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1MjQxMw==", "bodyText": "The API is pushing PreComponentUpdateEvent to component via IPC", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474852413", "createdAt": "2020-08-21T18:12:48Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNTU0OA=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzg4NzI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo1ODo1M1rOHE0jKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMDo1Nzo1NVrOHE9lvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNzMyMg==", "bodyText": "Why does it need to alter pass in parameter? Are we sure the list passed in is mutable?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474817322", "createdAt": "2020-08-21T16:58:53Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk2NTQzNg==", "bodyText": "Are we sure the list passed in is mutable -> yes", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474965436", "createdAt": "2020-08-21T20:57:55Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNzMyMg=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzkyOTA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoxMjoyNFrOHE08Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoxMjowOFrOHE2rFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyMzczNA==", "bodyText": "If we clear the map, are we giving up to update the previous futures? Are we expecting caller to abandon them as well?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474823734", "createdAt": "2020-08-21T17:12:24Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1MjExOQ==", "bodyText": "LifecycleIPCAgent will discard them. The caller will get an error \"Time limit to respond to PreComponentUpdateEvent exceeded\"", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474852119", "createdAt": "2020-08-21T18:12:08Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyMzczNA=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODAxMjQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzozOTozNVrOHE1vpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODowNDowNVrOHE2dhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzNjkwMw==", "bodyText": "Do we have separate thread to monitor the expiration of future?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474836903", "createdAt": "2020-08-21T17:39:35Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0ODY0NQ==", "bodyText": "We do not monitor the expiration of future, the futures are discarded by kernel LifeIPCAgent when it sends out a new set of preComponentUpdateEvent or postComponentUpdateEvent.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474848645", "createdAt": "2020-08-21T18:04:05Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/lifecycle/LifecycleIPCAgent.java", "diffHunk": "@@ -88,57 +86,86 @@ public LifecycleGenericResponse reportState(StateChangeRequest stateChangeReques\n     }\n \n     /**\n-     * Set up a listener for state changes for a requested service. (Currently any service can listen to any other\n-     * service's lifecycle changes).\n+     * handle component request to subscribe to component update events.\n      *\n-     * @param lifecycleListenRequest incoming listen request\n-     * @param context                caller context\n-     * @return response\n+     * @param context client context\n      */\n-    public LifecycleGenericResponse listenToStateChanges(LifecycleListenRequest lifecycleListenRequest,\n-                                                         ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.get(lifecycleListenRequest.getServiceName())\n-                .put(context, sendStateUpdateToListener(lifecycleListenRequest, context));\n-        context.onDisconnect(() -> listeners.values().forEach(map -> map.remove(context)));\n+    public SubscribeToComponentUpdatesResponse subscribeToComponentUpdate(ConnectionContext context) {\n+        log.debug(\"{} subscribed to component update\", context.getServiceName());\n+        componentUpdateListeners.add(context);\n+        context.onDisconnect(() -> componentUpdateListeners.remove(context));\n+        return SubscribeToComponentUpdatesResponse.builder().responseStatus(LifecycleResponseStatus.Success).build();\n+    }\n+\n+    /**\n+     * Signal components about pending component updates.\n+     *\n+     * @param preComponentUpdateEvent event sent to subscribed components\n+     * @param deferUpdateFutures      futures tracking the response to preComponentUpdateEvent\n+     */\n+    public void sendPreComponentUpdateEvent(PreComponentUpdateEvent preComponentUpdateEvent,\n+                                            List<Future<DeferUpdateRequest>> deferUpdateFutures) {\n+        discardDeferComponentUpdateFutures();\n+        componentUpdateListeners.forEach((context) -> {\n+            //TODO: error handling if sendServiceEvent fails\n+            log.info(\"Sending preComponentUpdate event to {}\", context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, preComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.PRE_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+            CompletableFuture<DeferUpdateRequest> deferUpdateFuture = new CompletableFuture<>();\n+            deferUpdateFutures.add(deferUpdateFuture);\n+            deferUpdateFuturesMap.put(context, deferUpdateFuture);\n+        });\n \n-        return LifecycleGenericResponse.builder().status(LifecycleResponseStatus.Success).build();\n     }\n \n-    private BiConsumer<State, State> sendStateUpdateToListener(LifecycleListenRequest listenRequest,\n-                                                               ConnectionContext context) {\n-        return (oldState, newState) -> {\n-            StateTransitionEvent stateTransitionEvent =\n-                    StateTransitionEvent.builder().newState(newState.toString()).oldState(oldState.toString())\n-                            .service(listenRequest.getServiceName()).build();\n-\n-            log.info(\"Pushing state change notification to {} from {} to {}\", listenRequest.getServiceName(), oldState,\n-                    newState);\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(LifecycleImpl.API_VERSION)\n-                        .opCode(LifecycleClientOpCodes.STATE_TRANSITION.ordinal())\n-                        .payload(IPCUtil.encode(stateTransitionEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = context.serverPush(BuiltInServiceDestinationCode.LIFECYCLE.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                                .log(\"Error sending lifecycle update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-lifecycle-update\").kv(\"context\", context)\n-                        .log(\"Error sending lifecycle update to client\", e);\n-            }\n-        };\n+    /**\n+     * Signal component that updates are complete.\n+     *\n+     * @param postComponentUpdateEvent event sent to subscribed components\n+     */\n+    public void sendPostComponentUpdateEvent(PostComponentUpdateEvent postComponentUpdateEvent) {\n+        componentUpdateListeners.forEach((context) -> {\n+            log.info(\"Sending postComponentUpdate event to \" + context.getServiceName());\n+            serviceEventHelper.sendServiceEvent(context, postComponentUpdateEvent, LIFECYCLE,\n+                    LifecycleServiceOpCodes.POST_COMPONENT_UPDATE_EVENT.ordinal(), LifecycleImpl.API_VERSION);\n+        });\n+    }\n+\n+    /**\n+     * Discard the futures used to track components responding to PreComponentUpdateEvent. This is invoked when\n+     * the max time limit to respond to PreComponentUpdateEvent is reached.\n+     */\n+    public void discardDeferComponentUpdateFutures() {\n+        log.debug(\"Discarding {} DeferComponentUpdateRequest futures\", deferUpdateFuturesMap.size());\n+        deferUpdateFuturesMap.clear();\n+    }\n+\n+    /**\n+     * Accepts defer updates requests and sets the corresponding future with the information.\n+     *\n+     * @param request response for PreComponentUpdateEvent\n+     * @param context client context\n+     * @return response to the request\n+     */\n+    public DeferComponentUpdateResponse handleDeferComponentUpdateRequest(DeferComponentUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        DeferComponentUpdateResponseBuilder responseBuilder = DeferComponentUpdateResponse.builder();\n+        if (!componentUpdateListeners.contains(context)) {\n+            return responseBuilder.responseStatus(LifecycleResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Component is not subscribed to component update events\").build();\n+        }\n+\n+        CompletableFuture<DeferUpdateRequest> deferComponentUpdateRequestFuture =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzNjkwMw=="}, "originalCommit": {"oid": "70b8a604279cdd98a4b1599fa48cdff4a070c54e"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODAzNTI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/LifecycleIPCService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzo0NzoxN1rOHE19zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODowNDozOFrOHE2eeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0MDUyNg==", "bodyText": "Are we using enum indices as opCode? Is opCode visible to client?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474840526", "createdAt": "2020-08-21T17:47:17Z", "author": {"login": "wikimonkey"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/LifecycleIPCService.java", "diffHunk": "@@ -68,36 +68,39 @@ public void postInject() {\n         ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n         try {\n             //TODO: add version compatibility check\n-            LifecycleServiceOpCodes lifecycleServiceOpCodes =\n-                    LifecycleServiceOpCodes.values()[applicationMessage.getOpCode()];\n-            LifecycleGenericResponse lifecycleGenericResponse = new LifecycleGenericResponse();\n-            switch (lifecycleServiceOpCodes) {\n-                case REGISTER_LISTENER:\n-                    LifecycleListenRequest listenRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), LifecycleListenRequest.class);\n-                    lifecycleGenericResponse = agent.listenToStateChanges(listenRequest, context);\n-                    break;\n-                case REPORT_STATE:\n-                    StateChangeRequest stateChangeRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), StateChangeRequest.class);\n-                    lifecycleGenericResponse = agent.reportState(stateChangeRequest, context);\n-                    break;\n-                default:\n-                    lifecycleGenericResponse.setStatus(LifecycleResponseStatus.InvalidRequest);\n-                    lifecycleGenericResponse\n-                            .setErrorMessage(\"Unknown request type \" + lifecycleServiceOpCodes.toString());\n-                    break;\n+            LifecycleGenericResponse lifecycleGenericResponse = new LifecycleGenericResponse(\n+                    LifecycleResponseStatus.InvalidRequest, \"Unknown request type\");\n+            if (LifecycleClientOpCodes.values().length > applicationMessage.getOpCode()) {\n+                LifecycleClientOpCodes lifecycleClientOpCodes =\n+                        LifecycleClientOpCodes.values()[applicationMessage.getOpCode()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba1a59374bf6dfcfba39a114795dd829446e6b63"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0ODg4OQ==", "bodyText": "Yes, the customer is not exposed to this.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/369#discussion_r474848889", "createdAt": "2020-08-21T18:04:38Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/LifecycleIPCService.java", "diffHunk": "@@ -68,36 +68,39 @@ public void postInject() {\n         ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n         try {\n             //TODO: add version compatibility check\n-            LifecycleServiceOpCodes lifecycleServiceOpCodes =\n-                    LifecycleServiceOpCodes.values()[applicationMessage.getOpCode()];\n-            LifecycleGenericResponse lifecycleGenericResponse = new LifecycleGenericResponse();\n-            switch (lifecycleServiceOpCodes) {\n-                case REGISTER_LISTENER:\n-                    LifecycleListenRequest listenRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), LifecycleListenRequest.class);\n-                    lifecycleGenericResponse = agent.listenToStateChanges(listenRequest, context);\n-                    break;\n-                case REPORT_STATE:\n-                    StateChangeRequest stateChangeRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), StateChangeRequest.class);\n-                    lifecycleGenericResponse = agent.reportState(stateChangeRequest, context);\n-                    break;\n-                default:\n-                    lifecycleGenericResponse.setStatus(LifecycleResponseStatus.InvalidRequest);\n-                    lifecycleGenericResponse\n-                            .setErrorMessage(\"Unknown request type \" + lifecycleServiceOpCodes.toString());\n-                    break;\n+            LifecycleGenericResponse lifecycleGenericResponse = new LifecycleGenericResponse(\n+                    LifecycleResponseStatus.InvalidRequest, \"Unknown request type\");\n+            if (LifecycleClientOpCodes.values().length > applicationMessage.getOpCode()) {\n+                LifecycleClientOpCodes lifecycleClientOpCodes =\n+                        LifecycleClientOpCodes.values()[applicationMessage.getOpCode()];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0MDUyNg=="}, "originalCommit": {"oid": "ba1a59374bf6dfcfba39a114795dd829446e6b63"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4551, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}