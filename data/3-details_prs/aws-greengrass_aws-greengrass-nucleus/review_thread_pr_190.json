{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0ODY1OTA3", "number": 190, "reviewThreads": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToxMDoyN1rODyusaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0ODoyNVrOD11ujQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIwNDI0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToxMDoyN1rOGG8fSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToyOTo0OFrOGG80Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTY5MA==", "bodyText": "Please clean up this cutnpaste which doesn't do anything.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409935690", "createdAt": "2020-04-17T01:10:27Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "diffHunk": "@@ -0,0 +1,32 @@\n+---\n+services:\n+  plain:\n+    lifecycle:\n+      startup:\n+        all: \"{platform.invoke} {args}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MTAzMQ==", "bodyText": "Sure, didn't look at the code at all, just moved stuff around, will change", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409941031", "createdAt": "2020-04-17T01:29:48Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "diffHunk": "@@ -0,0 +1,32 @@\n+---\n+services:\n+  plain:\n+    lifecycle:\n+      startup:\n+        all: \"{platform.invoke} {args}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTY5MA=="}, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIwNDg5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToxMDo0NVrOGG8fqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToyOTo1NFrOGG80Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTc4Nw==", "bodyText": "let's stop doing this as it just pollutes our logs.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409935787", "createdAt": "2020-04-17T01:10:45Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "diffHunk": "@@ -0,0 +1,32 @@\n+---\n+services:\n+  plain:\n+    lifecycle:\n+      startup:\n+        all: \"{platform.invoke} {args}\"\n+\n+  sleeperB:\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo sleeperB_running; sleep 5\n+        done\n+\n+  sleeperA:\n+    dependencies:\n+      - sleeperB\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo sleeperA_running; sleep 5\n+        done\n+\n+  main:\n+    dependencies:\n+      - sleeperA\n+      - sleeperB\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo main_running; sleep 5\n+        done", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MTA0Ng==", "bodyText": "Will do", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409941046", "createdAt": "2020-04-17T01:29:54Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/long_running_services.yaml", "diffHunk": "@@ -0,0 +1,32 @@\n+---\n+services:\n+  plain:\n+    lifecycle:\n+      startup:\n+        all: \"{platform.invoke} {args}\"\n+\n+  sleeperB:\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo sleeperB_running; sleep 5\n+        done\n+\n+  sleeperA:\n+    dependencies:\n+      - sleeperB\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo sleeperA_running; sleep 5\n+        done\n+\n+  main:\n+    dependencies:\n+      - sleeperA\n+      - sleeperB\n+    lifecycle:\n+      run: |-\n+        while true; do\n+        date; echo main_running; sleep 5\n+        done", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTc4Nw=="}, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIwNjA4OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/KernelTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToxMTozMVrOGG8gYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDozNzowNVrOGItWxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTk3MQ==", "bodyText": "The main purpose of those tests was to show that the service's config can be updated, ie setting new envvars. Has this case been replaced?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409935971", "createdAt": "2020-04-17T01:11:31Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/KernelTest.java", "diffHunk": "@@ -35,9 +32,7 @@\n                     new ExpectedStdoutPattern(0, \"EVERGREEN_UID=\", \"generated unique token\"),\n                     new ExpectedStdoutPattern(0, \"version: 0.12.1\", \"moquette mqtt server\"),\n                     new ExpectedStdoutPattern(0, \"JUSTME=fancy a spot of tea?\", \"local setenv in main service\"),\n-                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\"),\n-                    new ExpectedStdoutPattern(2, \"JUSTME=fancy a spot of coffee?\", \"merge yaml\"),\n-                    new ExpectedStdoutPattern(2, \"I'm Frodo\", \"merge adding dependency\")};\n+                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\")};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MDg4MQ==", "bodyText": "Previously mergeConfig was part of Kernel and this was a really old case testing that, I was trying to clean it up since it has evolved so much now. And the merge code has been moved to its own class in the deployment bundle. There's no need for this anymore. I'm not sure if I cleaned up all of the code related to it though. I'll do that, will also check if a test needs to be added to the merge integ tests", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409940881", "createdAt": "2020-04-17T01:29:17Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/KernelTest.java", "diffHunk": "@@ -35,9 +32,7 @@\n                     new ExpectedStdoutPattern(0, \"EVERGREEN_UID=\", \"generated unique token\"),\n                     new ExpectedStdoutPattern(0, \"version: 0.12.1\", \"moquette mqtt server\"),\n                     new ExpectedStdoutPattern(0, \"JUSTME=fancy a spot of tea?\", \"local setenv in main service\"),\n-                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\"),\n-                    new ExpectedStdoutPattern(2, \"JUSTME=fancy a spot of coffee?\", \"merge yaml\"),\n-                    new ExpectedStdoutPattern(2, \"I'm Frodo\", \"merge adding dependency\")};\n+                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\")};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTk3MQ=="}, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4NDkwMw==", "bodyText": "The service merge integ tests were pretty much testing all of it except new config deserialized from a yaml file, I added a basic test for that in DeploymentConfigMergingTest for that", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411784903", "createdAt": "2020-04-21T00:37:05Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/kernel/KernelTest.java", "diffHunk": "@@ -35,9 +32,7 @@\n                     new ExpectedStdoutPattern(0, \"EVERGREEN_UID=\", \"generated unique token\"),\n                     new ExpectedStdoutPattern(0, \"version: 0.12.1\", \"moquette mqtt server\"),\n                     new ExpectedStdoutPattern(0, \"JUSTME=fancy a spot of tea?\", \"local setenv in main service\"),\n-                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\"),\n-                    new ExpectedStdoutPattern(2, \"JUSTME=fancy a spot of coffee?\", \"merge yaml\"),\n-                    new ExpectedStdoutPattern(2, \"I'm Frodo\", \"merge adding dependency\")};\n+                    new ExpectedStdoutPattern(1, \"NEWMAIN\", \"Assignment to 'run' script'\")};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNTk3MQ=="}, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIwODIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToxMjo0OFrOGG8hpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMTozMjo1OVrOGG83cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNjI5Mw==", "bodyText": "prefer .equals()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409936293", "createdAt": "2020-04-17T01:12:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -222,8 +221,20 @@ private void finishCurrentDeployment() throws InterruptedException {\n             //No timeout is set here. Detection of error is delegated to downstream components like\n             // dependency resolver, package downloader, kernel which will have more visibility\n             // if something is going wrong\n-            currentProcessStatus.get();\n-            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+            DeploymentResult result = currentProcessStatus.get();\n+            if (result != null) {\n+                DeploymentResult.DeploymentStatus deploymentStatus = result.getDeploymentStatus();\n+                Map<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"detailed-deployment-status\", deploymentStatus.name());\n+                if (deploymentStatus == DeploymentResult.DeploymentStatus.SUCCESSFUL) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MTg3Mg==", "bodyText": "Sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409941872", "createdAt": "2020-04-17T01:32:59Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -222,8 +221,20 @@ private void finishCurrentDeployment() throws InterruptedException {\n             //No timeout is set here. Detection of error is delegated to downstream components like\n             // dependency resolver, package downloader, kernel which will have more visibility\n             // if something is going wrong\n-            currentProcessStatus.get();\n-            storeDeploymentStatusInConfig(currentJobId, JobStatus.SUCCEEDED, new HashMap<>());\n+            DeploymentResult result = currentProcessStatus.get();\n+            if (result != null) {\n+                DeploymentResult.DeploymentStatus deploymentStatus = result.getDeploymentStatus();\n+                Map<String, String> statusDetails = new HashMap<>();\n+                statusDetails.put(\"detailed-deployment-status\", deploymentStatus.name());\n+                if (deploymentStatus == DeploymentResult.DeploymentStatus.SUCCESSFUL) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNjI5Mw=="}, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIwOTUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToxMzoyOFrOGG8iTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMTozMzoxN1rOGG83rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNjQ2Mw==", "bodyText": "I believe this suppression may be removed by your change.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409936463", "createdAt": "2020-04-17T01:13:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -370,7 +380,7 @@ public int compare(Topic o1, Topic o2) {\n     }\n \n     @SuppressWarnings({\"PMD.LooseCoupling\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MTkzNQ==", "bodyText": "yeah, this and a couple others, will remove", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409941935", "createdAt": "2020-04-17T01:33:17Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentService.java", "diffHunk": "@@ -370,7 +380,7 @@ public int compare(Topic o1, Topic o2) {\n     }\n \n     @SuppressWarnings({\"PMD.LooseCoupling\"})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzNjQ2Mw=="}, "originalCommit": {"oid": "49183f26e8334fff19beb9f69fa2a335d4230cbf"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIyMzI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToyMDo0NVrOGG8qRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMTozMToxNlrOGG81lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODUwMg==", "bodyText": "Of course I understand why you set this to the current time, but I don't think this is technically correct moving forward. When it rolls back, it should be in exactly the same state as before; timestamps and all. So that new deployments can update the values correctly.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409938502", "createdAt": "2020-04-17T01:20:45Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +48,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     AutoRollbackConfig autoRollbackConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        DesiredServicesStateManager servicesStateManager = new DesiredServicesStateManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesStateManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesStateManager.servicesToTrackForDeployment();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesStateManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesStateManager);\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture,\n+                          Throwable failureCause, DesiredServicesStateManager servicesStateManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+            kernel.config.read(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)),\n+                    System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MTM5OQ==", "bodyText": "Kernel read will simply reject the update as it is if the timestamp is old, since the newest timestamps on config keys will be the one from the original merge for the deployment, which is supposed to be reverted. But we can explore managing this better", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409941399", "createdAt": "2020-04-17T01:31:16Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +48,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     AutoRollbackConfig autoRollbackConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        DesiredServicesStateManager servicesStateManager = new DesiredServicesStateManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesStateManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesStateManager.servicesToTrackForDeployment();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesStateManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesStateManager);\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture,\n+                          Throwable failureCause, DesiredServicesStateManager servicesStateManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+            kernel.config.read(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)),\n+                    System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODUwMg=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIyNDY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToyMTo0MlrOGG8rKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjoxNDozM1rOGJauxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ==", "bodyText": "not that it really matter, but why tlog instead of yaml?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409938729", "createdAt": "2020-04-17T01:21:42Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MTcwNg==", "bodyText": "Didn't look too much at it, James already has nicely working code for snapshots in the form of tlog so I didn't try to reinvent it, if there's value in it, I'm open to exploring it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409941706", "createdAt": "2020-04-17T01:32:25Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3NDUxNw==", "bodyText": "Why do we need to take snapshot here? Don't we already take snapshot in KernelLifecycle class?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410374517", "createdAt": "2020-04-17T17:43:07Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwMjgwMA==", "bodyText": "KernelLifecycle takes the snapshot only on launch as of today, and even if we did take periodic snapshots in it, it is the most accurate to take snapshot right before the merge is about to happen in a safe to disrupt window so that we ensure the kernel in not in a stale state after rollback. Folks also emphasized this at the time we were having config merge discussions", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410402800", "createdAt": "2020-04-17T18:37:40Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3MzM4Ng==", "bodyText": "Would like to correct my comment above - Yes, KernelLifecycle takes a snapshot by attaching a config writer to itself during launch, and it immediately updates the tlog file as soon as any config key is modified. Deployment merge will also be recoded in this same tlog file and at the time of rollback that file will have all the logs i.e. before deployment and afterdeployment. They'll either need to be removed from the file or not written to file until deployment success(I think this is what you mean by 'committing config only after deployment success is confirmed'). But since there are listeners attached to each config key that automatically write to the file, doing that is more complex. It's much easier to take a new snapshot and delete it as soon as done.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411773386", "createdAt": "2020-04-21T00:02:48Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4Njk4OA==", "bodyText": "Also, for the original question of why tlog and not plain config, please see the description and the latest changes around merging the snapshot", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411786988", "createdAt": "2020-04-21T00:43:24Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MzQ4NQ==", "bodyText": "Would like to correct my comment above - Yes, KernelLifecycle takes a snapshot by attaching a config writer to itself during launch, and it immediately updates the tlog file as soon as any config key is modified. Deployment merge will also be recoded in this same tlog file and at the time of rollback that file will have all the logs i.e. before deployment and afterdeployment. They'll either need to be removed from the file or not written to file until deployment success(I think this is what you mean by 'committing config only after deployment success is confirmed'). But since there are listeners attached to each config key that automatically write to the file, doing that is more complex. It's much easier to take a new snapshot and delete it as soon as done.\n\nAren't you doing the same thing here -- attach a config writer? This config writer will also record the deployment update to the deployment tlog file (snapshot). How is it different? Why not just copy and rename the original tlog before applying the merge?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412483485", "createdAt": "2020-04-21T20:52:54Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyODMyNg==", "bodyText": "For taking the snapshot we use the configwriter.dump method that writes the current config's state only once. It does not keep on logging the updates from deployment merge. It's more efficient from the original tlog file since that has logs for all historical updates for each config which we don't need to replay for rollback(and they will be logged again redundantly to original tlog file as we replay those logs), we only need to rollback to the last known state of any config with its last working timestamp", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412528326", "createdAt": "2020-04-21T22:14:33Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODcyOQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIyNjU0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToyMjoyOFrOGG8sJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDowMzowNlrOGIsqaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODk4MA==", "bodyText": "This is the same as L229, right? Shouldn't this be deleting the file?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409938980", "createdAt": "2020-04-17T01:22:28Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\n+                    \"Failed to record snapshot that's needed in case of \" + \"rollback\", e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3MzU0NA==", "bodyText": "Yes that was a miss, I updated it", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411773544", "createdAt": "2020-04-21T00:03:06Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\n+                    \"Failed to record snapshot that's needed in case of \" + \"rollback\", e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzODk4MA=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 288}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTIyOTk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMToyMzo0MVrOGG8t-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMTozMjo1MFrOGG83PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzOTQ1MQ==", "bodyText": "Why restart and not just start?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409939451", "createdAt": "2020-04-17T01:23:41Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\n+                    \"Failed to record snapshot that's needed in case of \" + \"rollback\", e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                    .log(\"Error cleaning up kernel snapshot\");\n+        }\n+    }\n+\n+    private boolean isAutoRollbackRequested(AutoRollbackConfig autoRollbackConfig) {\n+        return autoRollbackConfig == AutoRollbackConfig.AUTO_ROLLBACK_REQUESTED;\n+    }\n+\n+    @Getter\n+    // TODO : Use better name, state is too ambiguous for Evergreen\n+    //  and clean up this code\n+    class DesiredServicesStateManager {\n+        private Set<String> servicesToAdd;\n+        private Set<String> servicesToUpdate;\n+        private Set<String> servicesToRemove;\n+\n+        public DesiredServicesStateManager(Kernel kernel, Map<String, Object> newServiceConfig) {\n+            Set<String> runningUserServices = kernel.orderedDependencies().stream()\n+                    .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                    .map(EvergreenService::getName).collect(Collectors.toSet());\n+\n+            this.servicesToAdd =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> !runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());\n+\n+            this.servicesToUpdate =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());\n+\n+            // TODO: handle removing services that are running within the JVM but defined via config\n+            this.servicesToRemove =\n+                    runningUserServices.stream().filter(serviceName -> !newServiceConfig.containsKey(serviceName))\n+                            .collect(Collectors.toSet());\n+        }\n+\n+        public void startNewServices() throws ServiceLoadException {\n+            startServices(servicesToAdd);\n+        }\n+\n+        public void startRemovedServicesForRollback() throws ServiceLoadException {\n+            startServices(servicesToRemove);\n+        }\n+\n+        private void startServices(Set<String> serviceNames) throws ServiceLoadException {\n+            for (String serviceName : serviceNames) {\n+                EvergreenService service = kernel.locate(serviceName);\n+                service.requestRestart();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0MTgyMQ==", "bodyText": "This is a mistake, needs to be start, will change", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r409941821", "createdAt": "2020-04-17T01:32:50Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +220,128 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\n+                    \"Failed to record snapshot that's needed in case of \" + \"rollback\", e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                    .log(\"Error cleaning up kernel snapshot\");\n+        }\n+    }\n+\n+    private boolean isAutoRollbackRequested(AutoRollbackConfig autoRollbackConfig) {\n+        return autoRollbackConfig == AutoRollbackConfig.AUTO_ROLLBACK_REQUESTED;\n+    }\n+\n+    @Getter\n+    // TODO : Use better name, state is too ambiguous for Evergreen\n+    //  and clean up this code\n+    class DesiredServicesStateManager {\n+        private Set<String> servicesToAdd;\n+        private Set<String> servicesToUpdate;\n+        private Set<String> servicesToRemove;\n+\n+        public DesiredServicesStateManager(Kernel kernel, Map<String, Object> newServiceConfig) {\n+            Set<String> runningUserServices = kernel.orderedDependencies().stream()\n+                    .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                    .map(EvergreenService::getName).collect(Collectors.toSet());\n+\n+            this.servicesToAdd =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> !runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());\n+\n+            this.servicesToUpdate =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());\n+\n+            // TODO: handle removing services that are running within the JVM but defined via config\n+            this.servicesToRemove =\n+                    runningUserServices.stream().filter(serviceName -> !newServiceConfig.containsKey(serviceName))\n+                            .collect(Collectors.toSet());\n+        }\n+\n+        public void startNewServices() throws ServiceLoadException {\n+            startServices(servicesToAdd);\n+        }\n+\n+        public void startRemovedServicesForRollback() throws ServiceLoadException {\n+            startServices(servicesToRemove);\n+        }\n+\n+        private void startServices(Set<String> serviceNames) throws ServiceLoadException {\n+            for (String serviceName : serviceNames) {\n+                EvergreenService service = kernel.locate(serviceName);\n+                service.requestRestart();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzOTQ1MQ=="}, "originalCommit": {"oid": "52e13ac6c77df6422fca4c7424fc71e6f5adb55b"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzg5ODA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentResult.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozMjo1OVrOGHW9fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo0ODoxOVrOGHZUXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTQwNw==", "bodyText": "Why do we need to have different enums for FAILED? Don't we already include the detail failure message in the statusDetail field?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410369407", "createdAt": "2020-04-17T17:32:59Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentResult.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@ToString\n+@Builder\n+@Getter\n+public class DeploymentResult {\n+\n+    DeploymentStatus deploymentStatus;\n+    Throwable failureCause;\n+\n+    public enum DeploymentStatus {\n+        SUCCESSFUL,\n+        FAILED_NO_STATE_CHANGE,\n+        FAILED_ROLLBACK_NOT_REQUESTED,\n+        FAILED_ROLLBACK_COMPLETE,\n+        FAILED_UNABLE_TO_ROLLBACK", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwODAzMA==", "bodyText": "I originally tried to do that, but I could see it quickly become complex and inadequate even. Deployment fails with a certain error and conveying that message to the customer should be the most important. Then if you perform rollback there can still be errors in that step, and the same types of errors too e.g. some service failing to update etc. I'm attempting to convey what failed originally so customers can fix it and what happened at the device after that failure, if the rollback succeeded, if not should they do something to revive the device? It is also good to be explicit in the response than nest errors inside errors and try to manage the flow based on that. (no matter on the device or the cloud side).\nThat was my thought process, let me know what you think", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410408030", "createdAt": "2020-04-17T18:48:19Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/DeploymentResult.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.ToString;\n+\n+@ToString\n+@Builder\n+@Getter\n+public class DeploymentResult {\n+\n+    DeploymentStatus deploymentStatus;\n+    Throwable failureCause;\n+\n+    public enum DeploymentStatus {\n+        SUCCESSFUL,\n+        FAILED_NO_STATE_CHANGE,\n+        FAILED_ROLLBACK_NOT_REQUESTED,\n+        FAILED_ROLLBACK_COMPLETE,\n+        FAILED_UNABLE_TO_ROLLBACK", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2OTQwNw=="}, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NzkwNTI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/model/AutoRollbackConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzozNToyMlrOGHXCSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODozMjozNVrOGHY2ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDYzNA==", "bodyText": "I would rename the enum to FailureHandlingPolicy with values:\nROLLBACK and DO_NOTHING.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410370634", "createdAt": "2020-04-17T17:35:22Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/AutoRollbackConfig.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+public enum AutoRollbackConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwMDM5NA==", "bodyText": "Sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410400394", "createdAt": "2020-04-17T18:32:35Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/model/AutoRollbackConfig.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.aws.iot.evergreen.deployment.model;\n+\n+public enum AutoRollbackConfig {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MDYzNA=="}, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM0OTkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowNTowMlrOGHbfMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDo0MToyOVrOGItciQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MzU3MA==", "bodyText": "If we handle the auto rollback one level up in deployment task, would it be simpler? Deployment task will snapshot the current config and call mergeInconfig the the new config. If that fails, deployment tasks call mergeInConfig with the snapshoted config. The benefit is we do not have any special logic to rollback services. The mergeinconfig already handles adding/updating/removing services.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410443570", "createdAt": "2020-04-17T20:05:02Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4ODIwOA==", "bodyText": "Snapshot needs to be taken inside the update action that we pass to the UpdateSystemSafelyService because otherwise there can be hours between the time snapshot was taken and when merge executed and that's not ideal", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410488208", "createdAt": "2020-04-17T21:53:56Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MzU3MA=="}, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NjM0Mg==", "bodyText": "The config will be updated when services shutdown (like invalidate/clean during service shutdown).  Would it be ideal to start the services using the config provided in the package recipe?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411756342", "createdAt": "2020-04-20T23:22:22Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MzU3MA=="}, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4NjM3Nw==", "bodyText": "Could you explain a little more what you mean? mergeInNewConfig does take config from recipes so we don't have his problem. On rollback yes, it will take it from what has been updated in kernel, but that is supposed to be the source of truth when we want to revert kernel to its previously working state, no?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411786377", "createdAt": "2020-04-21T00:41:29Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MzU3MA=="}, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQ0NjUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0MToxNFrOGHccfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDowOTowOFrOGIsyuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTI2MA==", "bodyText": "I feel L146-151 is very similar to logic in mergeInConfig. can we void this duplication?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410459260", "createdAt": "2020-04-17T20:41:14Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     AutoRollbackConfig autoRollbackConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        DesiredServicesStateManager servicesStateManager = new DesiredServicesStateManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesStateManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesStateManager.servicesToTrackForDeployment();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesStateManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesStateManager);\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture,\n+                          Throwable failureCause, DesiredServicesStateManager servicesStateManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+            kernel.config.read(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)),\n+                    System.currentTimeMillis());\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.context.runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.context.get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesStateManager.startRemovedServicesForRollback();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4ODQ1Mg==", "bodyText": "Yep I agree, I'll reduce duplication if I can", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r410488452", "createdAt": "2020-04-17T21:54:32Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     AutoRollbackConfig autoRollbackConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        DesiredServicesStateManager servicesStateManager = new DesiredServicesStateManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesStateManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesStateManager.servicesToTrackForDeployment();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesStateManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesStateManager);\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture,\n+                          Throwable failureCause, DesiredServicesStateManager servicesStateManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+            kernel.config.read(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)),\n+                    System.currentTimeMillis());\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.context.runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.context.get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesStateManager.startRemovedServicesForRollback();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTI2MA=="}, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NTY3Mg==", "bodyText": "I tried to do this, but the two methods are not completely different, and it's hard to break it down, trying to reduce duplication will likely make this code unreadable since I don't think of any other way than using functional interfaces", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411775672", "createdAt": "2020-04-21T00:09:08Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +49,150 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId       give an ID to the task to run\n+     * @param timestamp          timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig          the map of new configuration\n+     * @param autoRollbackConfig auto rollback configuration for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n     @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     AutoRollbackConfig autoRollbackConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        DesiredServicesStateManager servicesStateManager = new DesiredServicesStateManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesStateManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesStateManager.servicesToTrackForDeployment();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesStateManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(autoRollbackConfig)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesStateManager);\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture,\n+                          Throwable failureCause, DesiredServicesStateManager servicesStateManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+            kernel.config.read(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)),\n+                    System.currentTimeMillis());\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.context.runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.context.get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesStateManager.startRemovedServicesForRollback();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTI2MA=="}, "originalCommit": {"oid": "7d5fade4e164dfc2ff8ddc81745897079e82fdfa"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzg2NzcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo0NTo0MlrOGIpA9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDowNzowNVrOGIsvvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMzc4Mw==", "bodyText": "Do you need to filter GenericExternalService same as L276?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411713783", "createdAt": "2020-04-20T21:45:42Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +224,142 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\"Failed to record snapshot that's needed in case of rollback\",\n+                    e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            Files.delete(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                    .log(\"Error cleaning up kernel snapshot\");\n+        }\n+    }\n+\n+    /*\n+     * Evaluate if the customer specified failure handling policy is to auto-rollback\n+     */\n+    private boolean isAutoRollbackRequested(FailureHandlingPolicy failureHandlingPolicy) {\n+        return FailureHandlingPolicy.ROLLBACK.equals(failureHandlingPolicy);\n+    }\n+\n+    @Getter\n+    @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+    private class AggregateServicesChangeManager {\n+        private Kernel kernel;\n+        private Set<String> servicesToAdd;\n+        private Set<String> servicesToUpdate;\n+        private Set<String> servicesToRemove;\n+\n+        /**\n+         * Constructs an object based on the current Kernel state and the config to be merged.\n+         *\n+         * @param kernel           evergreen kernel\n+         * @param newServiceConfig new config to be merged for deployment\n+         */\n+        public AggregateServicesChangeManager(Kernel kernel, Map<String, Object> newServiceConfig) {\n+            Set<String> runningUserServices = kernel.orderedDependencies().stream()\n+                    .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                    .map(EvergreenService::getName).collect(Collectors.toSet());\n+\n+            this.kernel = kernel;\n+\n+            this.servicesToAdd =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> !runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NDkxMA==", "bodyText": "No, this is operating on the list of services the deployment is trying to add, so it will only have user defined services, and which are in the form of raw config map, not updated in kernel yet", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411774910", "createdAt": "2020-04-21T00:07:05Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -155,34 +224,142 @@ public static void waitForServicesToStart(Set<EvergreenService> servicesToTrack,\n         }\n     }\n \n-    private void removeServices(List<String> serviceToRemove) throws InterruptedException, ExecutionException {\n-        List<Future<Void>> serviceClosedFutures = new ArrayList<>();\n-        serviceToRemove.forEach(serviceName -> {\n-            try {\n-                EvergreenService eg = kernel.locate(serviceName);\n-                serviceClosedFutures.add(eg.close());\n-            } catch (ServiceLoadException e) {\n-                logger.atError().setCause(e).addKeyValue(\"serviceName\", serviceName)\n-                        .log(\"Could not locate EvergreenService to close service\");\n-                // No need to handle the error when trying to stop a non-existing service.\n-            }\n-        });\n-        // waiting for removed service to close before removing reference and config entry\n-        for (Future<?> serviceClosedFuture : serviceClosedFutures) {\n-            serviceClosedFuture.get();\n+    /*\n+     * Take a snapshot in a transaction log file before rollback if rollback is applicable for deployment\n+     */\n+    private void takeSnapshotForRollback(String deploymentId) throws SnapshotRecordingFailureException {\n+        // record kernel snapshot\n+        try {\n+            kernel.writeEffectiveConfigAsTransactionLog(\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            throw new SnapshotRecordingFailureException(\"Failed to record snapshot that's needed in case of rollback\",\n+                    e);\n         }\n-        serviceToRemove.forEach(serviceName -> {\n-            kernel.context.remove(serviceName);\n-            kernel.findServiceTopic(serviceName).remove();\n-        });\n     }\n \n-    //TODO: handle removing services that are running within in the JVM but defined via config\n-    private List<String> getRemovedServicesNames(Map<String, Object> serviceConfig) {\n-        return kernel.orderedDependencies().stream()\n-                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n-                .map(EvergreenService::getName).filter(serviceName -> !serviceConfig.containsKey(serviceName))\n-                .collect(Collectors.toList());\n+    /*\n+     * Clean up snapshot file\n+     */\n+    private void cleanUpSnapshot(String deploymentId) {\n+        try {\n+            Files.delete(kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+        } catch (IOException e) {\n+            logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                    .log(\"Error cleaning up kernel snapshot\");\n+        }\n+    }\n+\n+    /*\n+     * Evaluate if the customer specified failure handling policy is to auto-rollback\n+     */\n+    private boolean isAutoRollbackRequested(FailureHandlingPolicy failureHandlingPolicy) {\n+        return FailureHandlingPolicy.ROLLBACK.equals(failureHandlingPolicy);\n+    }\n+\n+    @Getter\n+    @AllArgsConstructor(access = AccessLevel.PRIVATE)\n+    private class AggregateServicesChangeManager {\n+        private Kernel kernel;\n+        private Set<String> servicesToAdd;\n+        private Set<String> servicesToUpdate;\n+        private Set<String> servicesToRemove;\n+\n+        /**\n+         * Constructs an object based on the current Kernel state and the config to be merged.\n+         *\n+         * @param kernel           evergreen kernel\n+         * @param newServiceConfig new config to be merged for deployment\n+         */\n+        public AggregateServicesChangeManager(Kernel kernel, Map<String, Object> newServiceConfig) {\n+            Set<String> runningUserServices = kernel.orderedDependencies().stream()\n+                    .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                    .map(EvergreenService::getName).collect(Collectors.toSet());\n+\n+            this.kernel = kernel;\n+\n+            this.servicesToAdd =\n+                    newServiceConfig.keySet().stream().filter(serviceName -> !runningUserServices.contains(serviceName))\n+                            .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMzc4Mw=="}, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzk2NTgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjoxNToyMFrOGIp5DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxODowOVrOGJUdAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyODE0MQ==", "bodyText": "the mergeTime should be before calling mergeConfigForceTimestamps(), not system.currentMillisecond", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411728141", "createdAt": "2020-04-20T22:15:20Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,151 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture, Throwable failureCause,\n+                          AggregateServicesChangeManager servicesChangeManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+\n+            ConfigurationReader.mergeConfigForceTimestamps(kernel.config,\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.context.runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.context.get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        Set<EvergreenService> servicesToTrackForRollback = servicesChangeManager.servicesToTrack();\n+                        waitForServicesToStart(servicesToTrackForRollback, totallyCompleteFuture,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNTQ3Mw==", "bodyText": "Changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412425473", "createdAt": "2020-04-21T19:18:09Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,151 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(DeploymentResult.builder().deploymentStatus(\n+                                        DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED).failureCause(e)\n+                                        .build());\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException s) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(s);\n+                totallyCompleteFuture.complete(DeploymentResult.builder()\n+                        .deploymentStatus(DeploymentResult.DeploymentStatus.FAILED_NO_STATE_CHANGE).failureCause(s)\n+                        .build());\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture, Throwable failureCause,\n+                          AggregateServicesChangeManager servicesChangeManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+\n+            ConfigurationReader.mergeConfigForceTimestamps(kernel.config,\n+                    kernel.configPath.resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.context.runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.context.get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+                        Set<EvergreenService> servicesToTrackForRollback = servicesChangeManager.servicesToTrack();\n+                        waitForServicesToStart(servicesToTrackForRollback, totallyCompleteFuture,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyODE0MQ=="}, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzk3NDgyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMjoxODoxN1rOGIp-Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDowNTozNFrOGIsttw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyOTQ5MA==", "bodyText": "Add check here\n// if the update is cancelled, don't perform merge\nif totallyCompleteFuture.isCancelled() {\n  return;\n}", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411729490", "createdAt": "2020-04-20T22:18:17Z", "author": {"login": "ShirleyZheng92"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,151 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NDM5MQ==", "bodyText": "Added", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411774391", "createdAt": "2020-04-21T00:05:34Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,151 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyOTQ5MA=="}, "originalCommit": {"oid": "0e2dacb8d75329e2c6522f8dae3c9af447f5fd02"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODQzNDYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowNTo1NVrOGIt8SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxNzo0N1rOGJUcGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NDUwNA==", "bodyText": "This should not be here. This needs to be fixed by tlog parsing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411794504", "createdAt": "2020-04-21T01:05:55Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -136,6 +141,22 @@ private synchronized void initDependenciesTopic() {\n         }\n     }\n \n+    private Iterable<String> getDependencyNames(Object dependenciesNode) {\n+        if (dependenciesNode instanceof String) {\n+            // Dependencies topic is directly deserialized as a list into formats\n+            // such as tlog files, parse such specifications accordingly\n+            String depNodeStr = (String) dependenciesNode;\n+            depNodeStr = depNodeStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxMzg1Mw==", "bodyText": "I thought about it but couldn't find a better place for it, I'll try to move it if possible", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411813853", "createdAt": "2020-04-21T02:03:28Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -136,6 +141,22 @@ private synchronized void initDependenciesTopic() {\n         }\n     }\n \n+    private Iterable<String> getDependencyNames(Object dependenciesNode) {\n+        if (dependenciesNode instanceof String) {\n+            // Dependencies topic is directly deserialized as a list into formats\n+            // such as tlog files, parse such specifications accordingly\n+            String depNodeStr = (String) dependenciesNode;\n+            depNodeStr = depNodeStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NDUwNA=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTI0Nw==", "bodyText": "Thanks for looking. The thing is, this isn't just about the dependencies, this would be a big problem for anything which is an array instead of map/string. So I do think this needs a better solution so we don't run into issues like this in the future.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411815247", "createdAt": "2020-04-21T02:08:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -136,6 +141,22 @@ private synchronized void initDependenciesTopic() {\n         }\n     }\n \n+    private Iterable<String> getDependencyNames(Object dependenciesNode) {\n+        if (dependenciesNode instanceof String) {\n+            // Dependencies topic is directly deserialized as a list into formats\n+            // such as tlog files, parse such specifications accordingly\n+            String depNodeStr = (String) dependenciesNode;\n+            depNodeStr = depNodeStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NDUwNA=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2MTkzMA==", "bodyText": "I think I found the place, I'll update the PR once I have this fixed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412361930", "createdAt": "2020-04-21T17:44:17Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -136,6 +141,22 @@ private synchronized void initDependenciesTopic() {\n         }\n     }\n \n+    private Iterable<String> getDependencyNames(Object dependenciesNode) {\n+        if (dependenciesNode instanceof String) {\n+            // Dependencies topic is directly deserialized as a list into formats\n+            // such as tlog files, parse such specifications accordingly\n+            String depNodeStr = (String) dependenciesNode;\n+            depNodeStr = depNodeStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NDUwNA=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNTI0MA==", "bodyText": "Changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412425240", "createdAt": "2020-04-21T19:17:47Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/EvergreenService.java", "diffHunk": "@@ -136,6 +141,22 @@ private synchronized void initDependenciesTopic() {\n         }\n     }\n \n+    private Iterable<String> getDependencyNames(Object dependenciesNode) {\n+        if (dependenciesNode instanceof String) {\n+            // Dependencies topic is directly deserialized as a list into formats\n+            // such as tlog files, parse such specifications accordingly\n+            String depNodeStr = (String) dependenciesNode;\n+            depNodeStr = depNodeStr.replaceAll(\"\\\\[\", \"\").replaceAll(\"\\\\]\", \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NDUwNA=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODQzOTc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowODowM1rOGIt_EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxNzozMVrOGJUbjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTIxNg==", "bodyText": "builders aren't efficient. When it is something simple like this, let's just use a constructor.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411795216", "createdAt": "2020-04-21T01:08:03Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNDc0Mw==", "bodyText": "I know we've been trying to avoid them, but in this case builder suits better because I want to be able to build a response with only some members or with all members as needed, we would need multiple constructors in that case. Is that still preferred over a builder?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411814743", "createdAt": "2020-04-21T02:06:16Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTIxNg=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNDk4Mw==", "bodyText": "I think so, or you just pass nulls since that is what the builder would be doing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411814983", "createdAt": "2020-04-21T02:07:07Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTIxNg=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNTEwMA==", "bodyText": "Changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412425100", "createdAt": "2020-04-21T19:17:31Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTIxNg=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODQ0MTU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowODo0M1rOGIt__w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxNzoxOFrOGJUa-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTQ1NQ==", "bodyText": "I think that even if they don't request it, it would be a good idea to snapshot anyway, just don't do the rollback.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411795455", "createdAt": "2020-04-21T01:08:43Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTQyMg==", "bodyText": "Is there any benefit in doing that? we would simply be deleting it after the merge, why even have the kernel do the extra work to serialize another file and store it?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411815422", "createdAt": "2020-04-21T02:08:31Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTQ1NQ=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyMDc3NQ==", "bodyText": "Not for us to do anything, no, but I can think that some customers may want it. For example, if they want to determine why it failed, they may want to look back at the snapshot to see the before state.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411820775", "createdAt": "2020-04-21T02:23:48Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTQ1NQ=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNDk1NQ==", "bodyText": "It may be helpful for them to debug but not much more helpful than the logs and the tlog inside the initial and forever updating tlog file attached with kernel config. I'm a little reluctant to make retaining deployment snapshots the default behavior without a clean up strategy for the files, if we later find out that it will be helpful it is easy to change this behavior", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412424955", "createdAt": "2020-04-21T19:17:18Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTQ1NQ=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODQ0Mzc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTowOTozNFrOGIuBLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxNzoyNFrOGJUbQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTc1OQ==", "bodyText": "Log the exception.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r411795759", "createdAt": "2020-04-21T01:09:34Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNTAyNQ==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412425025", "createdAt": "2020-04-21T19:17:24Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +51,159 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentId          give an ID to the task to run\n+     * @param timestamp             timestamp for all configuration values to use when merging (newer timestamps win)\n+     * @param newConfig             the map of new configuration\n+     * @param failureHandlingPolicy failure handling policy for the deployment\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig,\n+                                                     FailureHandlingPolicy failureHandlingPolicy) {\n+\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.config.mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(\n+                    DeploymentResult.builder().deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n         kernel.context.get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.config.mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.context.runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.context.get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(DeploymentResult.builder()\n+                                    .deploymentStatus(DeploymentResult.DeploymentStatus.SUCCESSFUL).build());\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5NTc1OQ=="}, "originalCommit": {"oid": "c74077e12dbf8b5dfa2276694e445ffd6ab32947"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjMyNjY0OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODowMTowM1rOGJRUIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxODoxOTo1NlrOGJSHLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NDA1MQ==", "bodyText": "Moving top level discussion here so we can have proper comments and replies.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412374051", "createdAt": "2020-04-21T18:01:03Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -1,17 +1,23 @@\n /* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n  * SPDX-License-Identifier: Apache-2.0 */\n \n-package com.aws.iot.evergreen.integrationtests.kernel;\n+package com.aws.iot.evergreen.integrationtests.deployment;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ff4f6e2ec58781c9d630db258e65d51f792a45e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NDkyMA==", "bodyText": "@fengwa-aws I think a snapshot is better because we actually do want to rollback the timestamps, otherwise newer deployments may not be able update due to older timestamps.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412374920", "createdAt": "2020-04-21T18:02:12Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -1,17 +1,23 @@\n /* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n  * SPDX-License-Identifier: Apache-2.0 */\n \n-package com.aws.iot.evergreen.integrationtests.kernel;\n+package com.aws.iot.evergreen.integrationtests.deployment;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NDA1MQ=="}, "originalCommit": {"oid": "5ff4f6e2ec58781c9d630db258e65d51f792a45e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4NzExNg==", "bodyText": "Yeah, but truncating the tlog also removes the entries from the failed deployment.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412387116", "createdAt": "2020-04-21T18:19:56Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -1,17 +1,23 @@\n /* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n  * SPDX-License-Identifier: Apache-2.0 */\n \n-package com.aws.iot.evergreen.integrationtests.kernel;\n+package com.aws.iot.evergreen.integrationtests.deployment;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3NDA1MQ=="}, "originalCommit": {"oid": "5ff4f6e2ec58781c9d630db258e65d51f792a45e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjc0MDczOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTozNTo1MVrOGJVIog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNzozNjozN1rOGJn5Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNjY0Mg==", "bodyText": "This method name can be more clear. How about\nmergeTlogToConfig(Path tlogPath, Configuration cfg, boolean ignoreTimestamp)", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412436642", "createdAt": "2020-04-21T19:35:51Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMjM3MQ==", "bodyText": "sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412522371", "createdAt": "2020-04-21T22:02:23Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNjY0Mg=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc0Mzk5NQ==", "bodyText": "I changed this but decided to still call the boolean forceTimestamp, ignoreTimestamp in my opinion is ambiguous since it doesn't say what timestamp is to be ignored - the current one on the config or the one coming from tlog. forceTimestamp is also consistent with the arg to the withValue function being called", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412743995", "createdAt": "2020-04-22T07:36:37Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNjY0Mg=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjkxNTk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoxOTowM1rOGJWwYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNzoyODo1OFrOGJnmHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2MzIwMA==", "bodyText": "readLine() throws IOException. How do we handle partial failure here when readLine() throws in the middle of while loop?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412463200", "createdAt": "2020-04-21T20:19:03Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {\n+        try (BufferedReader in = Files.newBufferedReader(p)) {\n+            String l = in.readLine();\n+            while (l != null) {\n+                java.util.regex.Matcher m = logLine.matcher(l);\n+                if (m.matches()) {\n+                    c.lookup(seperator.split(m.group(2))).withValue(parseLong(m.group(1)), toObject(m.group(3)), true);\n+                }\n+                l = in.readLine();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMzYwMA==", "bodyText": "The rollback will fail in that case and customer will be notified, although I can try to improve this bit and separate reading from initializing topics", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412523600", "createdAt": "2020-04-21T22:04:50Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {\n+        try (BufferedReader in = Files.newBufferedReader(p)) {\n+            String l = in.readLine();\n+            while (l != null) {\n+                java.util.regex.Matcher m = logLine.matcher(l);\n+                if (m.matches()) {\n+                    c.lookup(seperator.split(m.group(2))).withValue(parseLong(m.group(1)), toObject(m.group(3)), true);\n+                }\n+                l = in.readLine();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2MzIwMA=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjczOTEwMw==", "bodyText": "Changed this to first read all input and merge config only if reading was successful", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412739103", "createdAt": "2020-04-22T07:28:58Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +59,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param c configuration to merge into\n+     * @param p path of the tlog file to read to-be-merged config from\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeConfigForceTimestamps(Configuration c, Path p) throws IOException {\n+        try (BufferedReader in = Files.newBufferedReader(p)) {\n+            String l = in.readLine();\n+            while (l != null) {\n+                java.util.regex.Matcher m = logLine.matcher(l);\n+                if (m.matches()) {\n+                    c.lookup(seperator.split(m.group(2))).withValue(parseLong(m.group(1)), toObject(m.group(3)), true);\n+                }\n+                l = in.readLine();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2MzIwMA=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjkzMzU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyMzoyNVrOGJW6lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNzozMjoxMlrOGJnuaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NTgxNA==", "bodyText": "withValue is not an ideal name here. It doesn't convey the information that only if the value is newer, then use the new value. It was okay previously because that is the only logic, but now we have withValue(long proposedModtime, final Object proposed, boolean forceTimestamp), it can cause confusion. Maybe name it withNewerValue()?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412465814", "createdAt": "2020-04-21T20:23:25Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -93,10 +93,22 @@ public Topic withValue(Object nv) {\n      * @param proposed        new value.\n      * @return this.\n      */\n-    public synchronized Topic withValue(long proposedModtime, final Object proposed) {\n+    public Topic withValue(long proposedModtime, final Object proposed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMzYzOQ==", "bodyText": "Sure", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412523639", "createdAt": "2020-04-21T22:04:56Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -93,10 +93,22 @@ public Topic withValue(Object nv) {\n      * @param proposed        new value.\n      * @return this.\n      */\n-    public synchronized Topic withValue(long proposedModtime, final Object proposed) {\n+    public Topic withValue(long proposedModtime, final Object proposed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NTgxNA=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc0MTIyNQ==", "bodyText": "Changed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412741225", "createdAt": "2020-04-22T07:32:12Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -93,10 +93,22 @@ public Topic withValue(Object nv) {\n      * @param proposed        new value.\n      * @return this.\n      */\n-    public synchronized Topic withValue(long proposedModtime, final Object proposed) {\n+    public Topic withValue(long proposedModtime, final Object proposed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NTgxNA=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjk0NTM1OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/local_store_content/recipe/BreakingService-1.0.0.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNjoyMlrOGJXBiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNjoyMlrOGJXBiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NzU5Mw==", "bodyText": "Please remove sleep, we want all our tests to be super quick", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412467593", "createdAt": "2020-04-21T20:26:22Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/resources/com/aws/iot/evergreen/integrationtests/deployment/local_store_content/recipe/BreakingService-1.0.0.yaml", "diffHunk": "@@ -0,0 +1,13 @@\n+---\n+RecipeTemplateVersion: '2020-01-25'\n+PackageName: BreakingService\n+Description: A service that just can't run\n+Publisher: Me\n+Version: '1.0.0'\n+Lifecycle:\n+  startup: |-\n+    sleep 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzEyMDE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTowOTo1NVrOGJYm6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNzozNDowMFrOGJnypA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzU0NQ==", "bodyText": "This is really far from where the exception is thrown. Can we make this try...catch loop smaller?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412493545", "createdAt": "2020-04-21T21:09:55Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMzcxMw==", "bodyText": "Okay", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412523713", "createdAt": "2020-04-21T22:05:02Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzU0NQ=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc0MjMwOA==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412742308", "createdAt": "2020-04-22T07:34:00Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzU0NQ=="}, "originalCommit": {"oid": "89023db247961020b44e44f23726ca1446ab47d7"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzE0NzQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMToxNjoxOVrOGJY13w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNzozNDowOVrOGJnzCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NzM3NQ==", "bodyText": "Same here. The try...catch block can be smaller.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412497375", "createdAt": "2020-04-21T21:16:19Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture, Throwable failureCause,\n+                          AggregateServicesChangeManager servicesChangeManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+\n+            // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n+            long mergeTime = System.currentTimeMillis();\n+            ConfigurationReader.mergeConfigForceTimestamps(kernel.getConfig(),\n+                    kernel.getConfigPath().resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.getContext().runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.getContext().get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+\n+                        Set<EvergreenService> servicesToTrackForRollback = servicesChangeManager.servicesToTrack();\n+\n+                        waitForServicesToStart(servicesToTrackForRollback, totallyCompleteFuture, mergeTime);\n+\n+                        servicesChangeManager.removeObsoleteServices();\n+                        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                                .log(\"All services rolled back\");\n+\n+                        cleanUpSnapshot(deploymentId);\n+\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n+                    } catch (InterruptedException | ServiceUpdateException | ExecutionException\n+                            | ServiceLoadException e) {\n+                        // Rollback execution failed\n+                        logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                                .log(\"Failed to rollback deployment\");\n+                        // TODO : Run user provided script to reach user defined safe state and\n+                        //  set deployment status based on the success of the script run\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n+                    }\n+                });\n+            });\n+        } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffdf052f02e008191104d1cd78384ae2250c1340"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMzc1NQ==", "bodyText": "Okay", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412523755", "createdAt": "2020-04-21T22:05:09Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture, Throwable failureCause,\n+                          AggregateServicesChangeManager servicesChangeManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+\n+            // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n+            long mergeTime = System.currentTimeMillis();\n+            ConfigurationReader.mergeConfigForceTimestamps(kernel.getConfig(),\n+                    kernel.getConfigPath().resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.getContext().runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.getContext().get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+\n+                        Set<EvergreenService> servicesToTrackForRollback = servicesChangeManager.servicesToTrack();\n+\n+                        waitForServicesToStart(servicesToTrackForRollback, totallyCompleteFuture, mergeTime);\n+\n+                        servicesChangeManager.removeObsoleteServices();\n+                        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                                .log(\"All services rolled back\");\n+\n+                        cleanUpSnapshot(deploymentId);\n+\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n+                    } catch (InterruptedException | ServiceUpdateException | ExecutionException\n+                            | ServiceLoadException e) {\n+                        // Rollback execution failed\n+                        logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                                .log(\"Failed to rollback deployment\");\n+                        // TODO : Run user provided script to reach user defined safe state and\n+                        //  set deployment status based on the success of the script run\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n+                    }\n+                });\n+            });\n+        } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NzM3NQ=="}, "originalCommit": {"oid": "ffdf052f02e008191104d1cd78384ae2250c1340"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc0MjQxMA==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r412742410", "createdAt": "2020-04-22T07:34:09Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +53,154 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n             try {\n+                // if the update is cancelled, don't perform merge\n+                if (totallyCompleteFuture.isCancelled()) {\n+                    return;\n+                }\n+\n+                FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+                if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                    takeSnapshotForRollback(deploymentId);\n+                }\n                 // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n                 long mergeTime = System.currentTimeMillis();\n \n                 kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n-                }\n-\n                 // wait until topic listeners finished processing mergeMap changes.\n                 kernel.getContext().runOnPublishQueueAndWait(() -> {\n-                    logger.atInfo(MERGE_CONFIG_EVENT_KEY)\n-                            .kv(\"serviceToTrack\", servicesToTrack)\n-                            .log(\"applied new service config. Waiting for services to complete update\");\n-\n-                    // polling to wait for all services started.\n+                    // polling to wait for all services to be started.\n                     kernel.getContext().get(ExecutorService.class).execute(() -> {\n                         //TODO: Add timeout\n                         try {\n+                            servicesChangeManager.startNewServices();\n+\n+                            Set<EvergreenService> servicesToTrack = servicesChangeManager.servicesToTrack();\n+                            logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"serviceToTrack\", servicesToTrack)\n+                                    .log(\"Applied new service config. Waiting for services to complete update\");\n+\n                             waitForServicesToStart(servicesToTrack, totallyCompleteFuture, mergeTime);\n-                            if (totallyCompleteFuture.isCompletedExceptionally()) {\n-                                return;\n-                            }\n                             if (totallyCompleteFuture.isCancelled()) {\n-                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                                // TODO : Does this need rolling back to old config?\n+                                logger.atWarn(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                         .log(\"merge-config-cancelled\");\n                                 return;\n                             }\n-\n-                            removeServices(removedServices);\n-                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(\"deploymentId\", deploymentId)\n+                            servicesChangeManager.removeObsoleteServices();\n+                            logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n                                     .log(\"All services updated\");\n-\n-                            totallyCompleteFuture.complete(null);\n-                        } catch (Throwable t) {\n-                            //TODO: handle different throwables. Revert changes if applicable.\n-                            totallyCompleteFuture.completeExceptionally(t);\n+                            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n+                        } catch (ServiceLoadException | InterruptedException | ServiceUpdateException\n+                                | ExecutionException e) {\n+                            logger.atError(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).setCause(e)\n+                                    .log(\"Deployment failed\");\n+                            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                                rollback(deploymentId, totallyCompleteFuture, e, servicesChangeManager.toRollback());\n+                            } else {\n+                                totallyCompleteFuture.complete(\n+                                        new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, e));\n+                            }\n+                            return;\n                         }\n                     });\n                 });\n-            } catch (Throwable e) {\n-                totallyCompleteFuture.completeExceptionally(e);\n+            } catch (SnapshotRecordingFailureException e) {\n+                // Failed to record snapshot hence did not execute merge, no rollback needed\n+                logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);\n+                totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.FAILED_NO_STATE_CHANGE, e));\n             }\n         });\n-\n         return totallyCompleteFuture;\n     }\n \n+    /*\n+     * Rollback kernel to the state recorded before merging deployment config\n+     */\n+    private void rollback(String deploymentId, CompletableFuture totallyCompleteFuture, Throwable failureCause,\n+                          AggregateServicesChangeManager servicesChangeManager) {\n+        try {\n+            logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Rolling back failed deployment\");\n+\n+            // Get the timestamp before merging snapshot. It will be used to check whether services have started.\n+            long mergeTime = System.currentTimeMillis();\n+            ConfigurationReader.mergeConfigForceTimestamps(kernel.getConfig(),\n+                    kernel.getConfigPath().resolve(String.format(ROLLBACK_SNAPSHOT_PATH_FORMAT, deploymentId)));\n+\n+            // wait until topic listeners finished processing read changes.\n+            kernel.getContext().runOnPublishQueueAndWait(() -> {\n+                // polling to wait for all services to be started.\n+                kernel.getContext().get(ExecutorService.class).execute(() -> {\n+                    // TODO: Add timeout\n+                    try {\n+                        servicesChangeManager.startNewServices();\n+\n+                        Set<EvergreenService> servicesToTrackForRollback = servicesChangeManager.servicesToTrack();\n+\n+                        waitForServicesToStart(servicesToTrackForRollback, totallyCompleteFuture, mergeTime);\n+\n+                        servicesChangeManager.removeObsoleteServices();\n+                        logger.atInfo(MERGE_CONFIG_EVENT_KEY).kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                                .log(\"All services rolled back\");\n+\n+                        cleanUpSnapshot(deploymentId);\n+\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_COMPLETE, failureCause));\n+                    } catch (InterruptedException | ServiceUpdateException | ExecutionException\n+                            | ServiceLoadException e) {\n+                        // Rollback execution failed\n+                        logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e)\n+                                .log(\"Failed to rollback deployment\");\n+                        // TODO : Run user provided script to reach user defined safe state and\n+                        //  set deployment status based on the success of the script run\n+                        totallyCompleteFuture.complete(\n+                                new DeploymentResult(DeploymentStatus.FAILED_UNABLE_TO_ROLLBACK, failureCause));\n+                    }\n+                });\n+            });\n+        } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NzM3NQ=="}, "originalCommit": {"oid": "ffdf052f02e008191104d1cd78384ae2250c1340"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTQ1MTUzOnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToxMjoyM1rOGKSOxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMTo0Njo1NVrOGKS7fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzNzYzOA==", "bodyText": "use hamcrest matcher for ContainsInAnyOrder.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413437638", "createdAt": "2020-04-23T01:12:23Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0OTA4NA==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413449084", "createdAt": "2020-04-23T01:46:55Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzNzYzOA=="}, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTQ1NTU4OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToxNDoxMVrOGKSRDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMTo0Njo1MlrOGKS7aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODIyMQ==", "bodyText": "Likewise down here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413438221", "createdAt": "2020-04-23T01:14:11Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+        assertTrue(services.contains(\"BreakingService\"));\n+        assertTrue(services.contains(\"Mosquitto\"));\n+        assertTrue(services.contains(\"GreenSignal\"));\n+        assertEquals(State.BROKEN, kernel.locate(\"BreakingService\").getState());\n+        assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, result.getDeploymentStatus());\n+\n+    }\n+\n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service and the failure handling policy is to rollback\n+     * As a result, kernel should be reverted to the state before deployment\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(5)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_rollback_THEN_services_are_rolled_back(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureRollbackDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal, RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0OTA2Nw==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413449067", "createdAt": "2020-04-23T01:46:52Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+        assertTrue(services.contains(\"BreakingService\"));\n+        assertTrue(services.contains(\"Mosquitto\"));\n+        assertTrue(services.contains(\"GreenSignal\"));\n+        assertEquals(State.BROKEN, kernel.locate(\"BreakingService\").getState());\n+        assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, result.getDeploymentStatus());\n+\n+    }\n+\n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service and the failure handling policy is to rollback\n+     * As a result, kernel should be reverted to the state before deployment\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(5)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_rollback_THEN_services_are_rolled_back(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureRollbackDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal, RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODIyMQ=="}, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTQ1NTk4OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToxNDoyMlrOGKSRRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMTo0Njo0OVrOGKS7VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODI3Nw==", "bodyText": "Same here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413438277", "createdAt": "2020-04-23T01:14:22Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+        assertTrue(services.contains(\"BreakingService\"));\n+        assertTrue(services.contains(\"Mosquitto\"));\n+        assertTrue(services.contains(\"GreenSignal\"));\n+        assertEquals(State.BROKEN, kernel.locate(\"BreakingService\").getState());\n+        assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, result.getDeploymentStatus());\n+\n+    }\n+\n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service and the failure handling policy is to rollback\n+     * As a result, kernel should be reverted to the state before deployment\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(5)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_rollback_THEN_services_are_rolled_back(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0OTA0NQ==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413449045", "createdAt": "2020-04-23T01:46:49Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"YellowSignal\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+\n+        ignoreExceptionUltimateCauseOfType(context, ServiceUpdateException.class);\n+        resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"FailureDoNothingDeployment.json\").toURI(),\n+                System.currentTimeMillis());\n+        DeploymentResult result = resultFuture.get(30, TimeUnit.SECONDS);\n+        services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, RedSignal, BreakingService, Mosquitto and GreenSignal\n+        assertEquals(5, services.size());\n+        assertTrue(services.contains(\"main\"));\n+        assertTrue(services.contains(\"RedSignal\"));\n+        assertTrue(services.contains(\"BreakingService\"));\n+        assertTrue(services.contains(\"Mosquitto\"));\n+        assertTrue(services.contains(\"GreenSignal\"));\n+        assertEquals(State.BROKEN, kernel.locate(\"BreakingService\").getState());\n+        assertEquals(DeploymentResult.DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, result.getDeploymentStatus());\n+\n+    }\n+\n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service and the failure handling policy is to rollback\n+     * As a result, kernel should be reverted to the state before deployment\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(5)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_rollback_THEN_services_are_rolled_back(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODI3Nw=="}, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTQ1NjI5OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToxNDozNFrOGKSReA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMTo0Njo0NlrOGKS7SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODMyOA==", "bodyText": "And here.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413438328", "createdAt": "2020-04-23T01:14:34Z", "author": {"login": "MikeDombo"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0OTAzMw==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413449033", "createdAt": "2020-04-23T01:46:46Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentTaskIntegrationTest.java", "diffHunk": "@@ -221,13 +227,104 @@ void GIVEN_services_running_WHEN_service_added_and_deleted_THEN_add_remove_servi\n         assertThrows(ServiceLoadException.class, () -> kernel.locate(\"GreenSignal\"));\n     }\n \n+    /**\n+     * First deployment starts some services. Second deployment tries to add a service that breaks\n+     * and removes an existing service but the failure handling policy is to do nothing\n+     * As a result, no corrective action will be taken on failure\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Order(4)\n+    void GIVEN_services_running_WHEN_new_service_breaks_failure_handling_policy_do_nothing_THEN_service_stays_broken(\n+            ExtensionContext context) throws Exception {\n+        Future<DeploymentResult> resultFuture = submitSampleJobDocument(\n+                DeploymentTaskIntegrationTest.class.getResource(\"YellowAndRedSignal.json\").toURI(),\n+                System.currentTimeMillis());\n+        resultFuture.get(30, TimeUnit.SECONDS);\n+        List<String> services = kernel.orderedDependencies().stream()\n+                .filter(evergreenService -> evergreenService instanceof GenericExternalService)\n+                .map(evergreenService -> evergreenService.getName()).collect(Collectors.toList());\n+\n+        // should contain main, YellowSignal and RedSignal\n+        assertEquals(3, services.size());\n+        assertTrue(services.contains(\"main\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzODMyOA=="}, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTQ2NDc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToxNzo1OFrOGKSWJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMTozMjozMVrOGKSo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzOTUyNQ==", "bodyText": "Shouldn't this still be withValue? It isn't forcing the timestamp.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413439525", "createdAt": "2020-04-23T01:17:58Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -93,10 +93,23 @@ public Topic withValue(Object nv) {\n      * @param proposed        new value.\n      * @return this.\n      */\n-    public synchronized Topic withValue(long proposedModtime, final Object proposed) {\n+    public Topic withNewerValue(long proposedModtime, final Object proposed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0NDMxNg==", "bodyText": "That's how I had it earlier, with simple function overloading, the change was a result of Feng's comment about both this method and the new one named the same can create confusion, withNewerValue is being a bit more accurate in that it will prefer the newer value, i.e. the one with the latest timestamp. I personally think it's still slightly ambiguous either way so I don't have a strong opinion, I would rely on the javadoc in this case", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413444316", "createdAt": "2020-04-23T01:32:31Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/Topic.java", "diffHunk": "@@ -93,10 +93,23 @@ public Topic withValue(Object nv) {\n      * @param proposed        new value.\n      * @return this.\n      */\n-    public synchronized Topic withValue(long proposedModtime, final Object proposed) {\n+    public Topic withNewerValue(long proposedModtime, final Object proposed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQzOTUyNQ=="}, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTQ3MjkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMToyMToyMFrOGKSadw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMTo0NjozOVrOGKS7Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0MDYzMQ==", "bodyText": "this is missing a .log().", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413440631", "createdAt": "2020-04-23T01:21:20Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +52,158 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            try {\n-                // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n-                long mergeTime = System.currentTimeMillis();\n \n-                kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n+            // if the update is cancelled, don't perform merge\n+            if (totallyCompleteFuture.isCancelled()) {\n+                return;\n+            }\n+\n+            FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                try {\n+                    takeSnapshotForRollback(deploymentId);\n+                } catch (IOException e) {\n+                    // Failed to record snapshot hence did not execute merge, no rollback needed\n+                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0ODk5OA==", "bodyText": "done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413448998", "createdAt": "2020-04-23T01:46:39Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentConfigMerger.java", "diffHunk": "@@ -42,90 +52,158 @@\n     /**\n      * Merge in new configuration values and new services.\n      *\n-     * @param deploymentId give an ID to the task to run\n-     * @param timestamp    timestamp for all configuration values to use when merging (newer timestamps win)\n-     * @param newConfig    the map of new configuration\n+     * @param deploymentDocument deployment document\n+     * @param newConfig          the map of new configuration\n      * @return future which completes only once the config is merged and all the services in the config are running\n      */\n-    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n-    public Future<Void> mergeInNewConfig(String deploymentId, long timestamp, Map<Object, Object> newConfig) {\n-        CompletableFuture<Void> totallyCompleteFuture = new CompletableFuture<>();\n+    public Future<DeploymentResult> mergeInNewConfig(DeploymentDocument deploymentDocument,\n+                                                     Map<Object, Object> newConfig) {\n+        CompletableFuture<DeploymentResult> totallyCompleteFuture = new CompletableFuture<>();\n+        long timestamp = deploymentDocument.getTimestamp();\n \n         if (newConfig.get(SERVICES_NAMESPACE_TOPIC) == null) {\n             kernel.getConfig().mergeMap(timestamp, newConfig);\n-            totallyCompleteFuture.complete(null);\n+            totallyCompleteFuture.complete(new DeploymentResult(DeploymentStatus.SUCCESSFUL, null));\n             return totallyCompleteFuture;\n         }\n \n         Map<String, Object> serviceConfig = (Map<String, Object>) newConfig.get(SERVICES_NAMESPACE_TOPIC);\n-        List<String> removedServices = getRemovedServicesNames(serviceConfig);\n-        logger.atDebug(MERGE_CONFIG_EVENT_KEY).kv(\"removedServices\", removedServices).log();\n+        AggregateServicesChangeManager servicesChangeManager =\n+                new AggregateServicesChangeManager(kernel, serviceConfig);\n \n-        Set<EvergreenService> servicesToTrack = new HashSet<>();\n+        String deploymentId = deploymentDocument.getDeploymentId();\n         kernel.getContext().get(UpdateSystemSafelyService.class).addUpdateAction(deploymentId, () -> {\n-            try {\n-                // Get the timestamp before mergeMap(). It will be used to check whether services have started.\n-                long mergeTime = System.currentTimeMillis();\n \n-                kernel.getConfig().mergeMap(timestamp, newConfig);\n-                for (String serviceName : serviceConfig.keySet()) {\n-                    EvergreenService eg = kernel.locate(serviceName);\n-                    if (State.NEW.equals(eg.getState())) {\n-                        eg.requestStart();\n-                    }\n-                    servicesToTrack.add(eg);\n+            // if the update is cancelled, don't perform merge\n+            if (totallyCompleteFuture.isCancelled()) {\n+                return;\n+            }\n+\n+            FailureHandlingPolicy failureHandlingPolicy = deploymentDocument.getFailureHandlingPolicy();\n+            if (isAutoRollbackRequested(failureHandlingPolicy)) {\n+                try {\n+                    takeSnapshotForRollback(deploymentId);\n+                } catch (IOException e) {\n+                    // Failed to record snapshot hence did not execute merge, no rollback needed\n+                    logger.atError().setEventType(MERGE_ERROR_LOG_EVENT_KEY).setCause(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0MDYzMQ=="}, "originalCommit": {"oid": "dc8a5d02f1fb18be16983826378fc2055d672553"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MzAzNDQ3OnYy", "diffSide": "RIGHT", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzoxMjozMVrOGKzEig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxOTo0MTozM1rOGK5B4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3NTY5MA==", "bodyText": "What's difference between this test case and the one below (GIVEN_kernel_running_single_service_WHEN_merge_changes_service_THEN_service_restarts_with_new_config)?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413975690", "createdAt": "2020-04-23T17:12:31Z", "author": {"login": "fengwang666"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -54,7 +62,38 @@ void after() {\n     }\n \n     @Test\n-    void GIVEN_kernel_running_single_service_WHEN_merge_change_to_service_THEN_service_restarts_with_new_config()\n+    void GIVEN_kernel_running_with_some_config_WHEN_merge_simple_yaml_file_THEN_config_is_updated() throws Throwable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MzMxMw==", "bodyText": "They're functionally the same, this new test is a replacement of a test that exited in KernelTest before, it was simply testing if we can parse a yaml file and merge that delta successfully in config. Now the merge code has been moved out of kernel so I moved that test here", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414073313", "createdAt": "2020-04-23T19:41:33Z", "author": {"login": "shaguptashaikh"}, "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/deployment/DeploymentConfigMergingTest.java", "diffHunk": "@@ -54,7 +62,38 @@ void after() {\n     }\n \n     @Test\n-    void GIVEN_kernel_running_single_service_WHEN_merge_change_to_service_THEN_service_restarts_with_new_config()\n+    void GIVEN_kernel_running_with_some_config_WHEN_merge_simple_yaml_file_THEN_config_is_updated() throws Throwable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3NTY5MA=="}, "originalCommit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MzEzNjEzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzozNTozNFrOGK0CzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxOTo0MDoxM1rOGK4-hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MTYyOQ==", "bodyText": "Might want to add a comment here that this potentially have memory issue if the transaction log is large.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r413991629", "createdAt": "2020-04-23T17:35:34Z", "author": {"login": "fengwang666"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +60,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param config         configuration to merge into\n+     * @param tlogPath       path of the tlog file to read to-be-merged config from\n+     * @param forceTimestamp should ignore if the proposed timestamp is older than current\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeTlogIntoConfig(Configuration config, Path tlogPath, boolean forceTimestamp)\n+            throws IOException {\n+        Iterator<String> logLines = Files.readAllLines(tlogPath).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MjQ1NQ==", "bodyText": "Added", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414072455", "createdAt": "2020-04-23T19:40:13Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/config/ConfigurationReader.java", "diffHunk": "@@ -59,4 +60,24 @@ public static Configuration createFromTLog(Context context, Path p) throws IOExc\n         ConfigurationReader.mergeTLogInto(c, p);\n         return c;\n     }\n+\n+    /**\n+     * Merge the given transaction log into the given configuration.\n+     *\n+     * @param config         configuration to merge into\n+     * @param tlogPath       path of the tlog file to read to-be-merged config from\n+     * @param forceTimestamp should ignore if the proposed timestamp is older than current\n+     * @throws IOException if reading fails\n+     */\n+    public static void mergeTlogIntoConfig(Configuration config, Path tlogPath, boolean forceTimestamp)\n+            throws IOException {\n+        Iterator<String> logLines = Files.readAllLines(tlogPath).iterator();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MTYyOQ=="}, "originalCommit": {"oid": "bf2c5c930486e880f758ce241303bea3694c2cbb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDkyNjM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMjo1NDo1N1rOGLEG9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMzo1ODozMFrOGLFS8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NDgzOA==", "bodyText": "These are not the sane, right? Before it kept a running log, but now it is a 1 time thing.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414254838", "createdAt": "2020-04-24T02:54:57Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -191,7 +190,7 @@ public void writeEffectiveConfig(Path p) {\n      * @throws IOException if writing fails\n      */\n     public void writeEffectiveConfigAsTransactionLog(Path transactionLogPath) throws IOException {\n-        ConfigurationWriter.logTransactionsTo(config, transactionLogPath).flushImmediately(true);\n+        ConfigurationWriter.dump(config, transactionLogPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MjQyOQ==", "bodyText": "Correct", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414272429", "createdAt": "2020-04-24T03:52:09Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -191,7 +190,7 @@ public void writeEffectiveConfig(Path p) {\n      * @throws IOException if writing fails\n      */\n     public void writeEffectiveConfigAsTransactionLog(Path transactionLogPath) throws IOException {\n-        ConfigurationWriter.logTransactionsTo(config, transactionLogPath).flushImmediately(true);\n+        ConfigurationWriter.dump(config, transactionLogPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NDgzOA=="}, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MzI1Ng==", "bodyText": "Don't we want to keep a running tlog though? In addition to the snapshot of course. I definitely may be wrong, but I thought this method was used during launch to setup the tlog.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414273256", "createdAt": "2020-04-24T03:55:02Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -191,7 +190,7 @@ public void writeEffectiveConfig(Path p) {\n      * @throws IOException if writing fails\n      */\n     public void writeEffectiveConfigAsTransactionLog(Path transactionLogPath) throws IOException {\n-        ConfigurationWriter.logTransactionsTo(config, transactionLogPath).flushImmediately(true);\n+        ConfigurationWriter.dump(config, transactionLogPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NDgzOA=="}, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NDI5MQ==", "bodyText": "No it isn't used for launching, and for deployment snapshot we don't want a running tlog, there's definitely scope refactor and bring consistency though, while also doing the right thing in the two different scenarios", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414274291", "createdAt": "2020-04-24T03:58:30Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/kernel/Kernel.java", "diffHunk": "@@ -191,7 +190,7 @@ public void writeEffectiveConfig(Path p) {\n      * @throws IOException if writing fails\n      */\n     public void writeEffectiveConfigAsTransactionLog(Path transactionLogPath) throws IOException {\n-        ConfigurationWriter.logTransactionsTo(config, transactionLogPath).flushImmediately(true);\n+        ConfigurationWriter.dump(config, transactionLogPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NDgzOA=="}, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDkyOTE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/aws/iot/evergreen/util/Coerce.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMjo1NjoxNFrOGLEIdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMzo1MTo1N1rOGLFLdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NTIyMg==", "bodyText": "Let's add testing for this in the utils or coerce unit test.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414255222", "createdAt": "2020-04-24T02:56:14Z", "author": {"login": "MikeDombo"}, "path": "src/main/java/com/aws/iot/evergreen/util/Coerce.java", "diffHunk": "@@ -318,6 +330,9 @@ public static Object toObject(String s) {\n         if (\"null\".equals(s)) {\n             return null;\n         }\n+        if (unwrap.matcher(s).matches()) {\n+            return toStringList(s);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MjM3NQ==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414272375", "createdAt": "2020-04-24T03:51:57Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/util/Coerce.java", "diffHunk": "@@ -318,6 +330,9 @@ public static Object toObject(String s) {\n         if (\"null\".equals(s)) {\n             return null;\n         }\n+        if (unwrap.matcher(s).matches()) {\n+            return toStringList(s);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NTIyMg=="}, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NDkzMjQ1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMjo1Nzo0MVrOGLEKMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwMzo1MTo1M1rOGLFLZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NTY2Nw==", "bodyText": "Please no sleeping, you can use verify with a timeout to account for time, while running as quick as possible.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414255667", "createdAt": "2020-04-24T02:57:41Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -191,13 +200,65 @@ public void GIVEN_deployment_job_WHEN_deployment_process_fails_THEN_report_faile\n                     .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n             verify(mockIotJobsHelper, WAIT_FOUR_SECONDS)\n                     .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.FAILED), any());\n+\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_job_with_auto_rollback_not_requested_WHEN_deployment_process_fails_THEN_report_failed_job_status()\n+                throws Exception {\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(\n+                    new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, null));\n+            when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFuture);\n+            startDeploymentServiceInAnotherThread();\n+\n+            //Wait for the enough time after which deployment service would have processed the job from the queue\n+            Thread.sleep(Duration.ofSeconds(2).toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MjM1Nw==", "bodyText": "Done", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414272357", "createdAt": "2020-04-24T03:51:53Z", "author": {"login": "shaguptashaikh"}, "path": "src/test/java/com/aws/iot/evergreen/deployment/DeploymentServiceTest.java", "diffHunk": "@@ -191,13 +200,65 @@ public void GIVEN_deployment_job_WHEN_deployment_process_fails_THEN_report_faile\n                     .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.IN_PROGRESS), any());\n             verify(mockIotJobsHelper, WAIT_FOUR_SECONDS)\n                     .updateJobStatus(eq(TEST_JOB_ID_1), eq(JobStatus.FAILED), any());\n+\n+            deploymentService.shutdown();\n+        }\n+\n+        @Test\n+        public void GIVEN_deployment_job_with_auto_rollback_not_requested_WHEN_deployment_process_fails_THEN_report_failed_job_status()\n+                throws Exception {\n+            CompletableFuture<DeploymentResult> mockFuture = new CompletableFuture<>();\n+            mockFuture.complete(\n+                    new DeploymentResult(DeploymentStatus.FAILED_ROLLBACK_NOT_REQUESTED, null));\n+            when(mockExecutorService.submit(any(DeploymentTask.class))).thenReturn(mockFuture);\n+            startDeploymentServiceInAnotherThread();\n+\n+            //Wait for the enough time after which deployment service would have processed the job from the queue\n+            Thread.sleep(Duration.ofSeconds(2).toMillis());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI1NTY2Nw=="}, "originalCommit": {"oid": "e3bf18afca668477ee865f261a4bc532c42b921a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NzgxMzg5OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/aws/iot/evergreen/util/CoerceTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0ODoyNVrOGLeAJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTo0ODoyNVrOGLeAJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY3OTA3Nw==", "bodyText": "nit\nNew tests should have reasonable names.", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/190#discussion_r414679077", "createdAt": "2020-04-24T15:48:25Z", "author": {"login": "MikeDombo"}, "path": "src/test/java/com/aws/iot/evergreen/util/CoerceTest.java", "diffHunk": "@@ -84,5 +92,17 @@ void t(String s, String... expect) {\n         }\n     }\n \n+    @Test\n+    public void T6() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7baae660204cef828058c2574b7c9a121c22cb6a"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4613, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}