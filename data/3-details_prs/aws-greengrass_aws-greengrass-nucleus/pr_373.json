{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5ODU3OTAy", "number": 373, "title": "Cli APIs over IPC", "bodyText": "Issue #, if available:\nAdding CLI APIs defined in the Smithy model - https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/mainline/--/model/main.smithy\nDescription of changes:\nCLI API implementation. Working on adding more tests for all APIs.\nWhy is this change necessary:\nHow was this change tested:\nFew integration tests by using the changes in SDK locally.\nAny additional information or context required to review the change:\nChecklist:\n\n Updated the README if applicable\n Updated or added new unit tests\n Updated or added new integration tests\n Updated or added new end-to-end tests\n\nBy submitting this pull request, I confirm that you can use, modify, copy, and redistribute this contribution, under the terms of your choice.", "createdAt": "2020-08-19T00:41:26Z", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373", "merged": true, "mergeCommit": {"oid": "966e3667ca7ba100253f9bbed791c4182d355e1b"}, "closed": true, "closedAt": "2020-09-04T17:34:17Z", "author": {"login": "abanthiy"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdAjpWugFqTQ3MTAxNjE3NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFoZPrAFqTQ4MjgyMzc5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDE2MTc1", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-471016175", "createdAt": "2020-08-19T22:49:04Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjo0OTowNVrOHDePlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMjo0OTowNVrOHDePlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQwMzI4NQ==", "bodyText": "this would not build, updating the version as 0.0.0-clioveripc-SNAPSHOT will allow github action to pick the corresponding sdk build", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473403285", "createdAt": "2020-08-19T22:49:05Z", "author": {"login": "fahadmohammed01"}, "path": "pom.xml", "diffHunk": "@@ -11,7 +11,8 @@\n             <id>evergreen-ipc-java-sdk</id>\n             <name>Evergreen Ipc Java Sdk</name>\n             <!-- cloud front url fronting the Evergreen Ipc Java Sdk artifact in S3-->\n-            <url>https://d10d248laylpoq.cloudfront.net/</url>\n+<!--            <url>https://d10d248laylpoq.cloudfront.net/</url>-->\n+            <url>file:///Users/abanthiy/workspace/evergreen/aws-greengrass-sdk-java/target</url>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDI3NDEz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-471027413", "createdAt": "2020-08-19T23:19:35Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoxOTozNlrOHDfkyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoxOTozNlrOHDfkyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQyNTA5OA==", "bodyText": "Use PackageStore.RECIPE_DIRECTORY", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473425098", "createdAt": "2020-08-19T23:19:36Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDI3NjI5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-471027629", "createdAt": "2020-08-19T23:20:15Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoyMDoxNVrOHDfmpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzoyMDoxNVrOHDfmpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQyNTU3Mg==", "bodyText": "Use PackageStore.ARTIFACT_DIRECTORY", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473425572", "createdAt": "2020-08-19T23:20:15Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDMxNjE4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-471031618", "createdAt": "2020-08-19T23:30:36Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzozMDozNlrOHDgDhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzozMDozNlrOHDgDhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMjk2Ng==", "bodyText": "why not use Utils.copyFolderRecursively()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473432966", "createdAt": "2020-08-19T23:30:36Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {\n+        Topics localDeployments = serviceConfig.lookupTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        String deploymentId = (String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID);\n+        Topic localDeploymentDetails = localDeployments.lookup(deploymentId);\n+        localDeploymentDetails.withValue(deploymentDetails);\n+        DeploymentStatus status = (DeploymentStatus) deploymentDetails.get(\n+                PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+        // TODO: Remove the succeeded deployments if the number of deployments have exceeded max limit\n+    }\n+\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    private void validateGetLocalDeploymentStatusRequest(GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError {\n+        try {\n+            UUID.fromString(request.getDeploymentId());\n+        } catch (IllegalArgumentException e) {\n+            throw new InvalidArgumentsError(\"Invalid deploymentId format received. DeploymentId is a UUID\");\n+        }\n+    }\n+\n+    private static void copyFolderRecursively(Path src, Path des) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 318}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDMxNzM3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-471031737", "createdAt": "2020-08-19T23:30:55Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzozMDo1NVrOHDgEcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMzozMDo1NVrOHDgEcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQzMzIwMA==", "bodyText": "Does this need to be public?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r473433200", "createdAt": "2020-08-19T23:30:55Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest\n+                .toString(), Deployment.DeploymentType.LOCAL, deploymentId);\n+        if (deploymentsQueue == null) {\n+            logger.atError().log(\"Deployments queue not initialized\");\n+            throw new ServiceError(DEPLOYMENTS_QUEUE_NOT_INITIALIZED);\n+        } else {\n+            if (deploymentsQueue.offer(deployment)) {\n+                logger.atInfo().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId).log(\"Submitted local deployment request.\");\n+                return CreateLocalDeploymentResponse.builder().deploymentId(deploymentId).build();\n+            } else {\n+                logger.atError().kv(DEPLOYMENT_ID_LOG_KEY, deploymentId)\n+                        .log(\"Failed to submit local deployment request because deployment queue is full\");\n+                throw new ServiceError(DEPLOYMENTS_QUEUE_FULL);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get status of local deployment with the given deploymentId.\n+     * @param request {@link GetLocalDeploymentStatusRequest}\n+     * @param serviceConfig Cli service configuration\n+     * @return {@link GetLocalDeploymentStatusResponse}\n+     * @throws InvalidArgumentsError thrown when invalid deploymentId format is received\n+     * @throws ResourceNotFoundError thrown when deployment with given Id not found\n+     */\n+    public GetLocalDeploymentStatusResponse getLocalDeploymentStatus(Topics serviceConfig,\n+                                                                     GetLocalDeploymentStatusRequest request)\n+            throws InvalidArgumentsError, ResourceNotFoundError {\n+        validateGetLocalDeploymentStatusRequest(request);\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        if (localDeployments.find(request.getDeploymentId()) == null) {\n+            throw new ResourceNotFoundError(\"Cannot find deployment\",\n+                    \"Deployment\", request.getDeploymentId());\n+        } else {\n+            Topic deployment = localDeployments.find(request.getDeploymentId());\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) deployment.getOnce();\n+            DeploymentStatus status =\n+                    (DeploymentStatus) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS);\n+            return GetLocalDeploymentStatusResponse.builder()\n+                    .deployment(LocalDeployment.builder().deploymentId(request.getDeploymentId())\n+                            .status(status).build()).build();\n+        }\n+    }\n+\n+    /**\n+     * Lists last 5 local deployments.\n+     * @param serviceConfig CLI service configuration\n+     * @return {@link ListLocalDeploymentResponse}\n+     */\n+    public ListLocalDeploymentResponse listLocalDeployments(Topics serviceConfig) {\n+        List<LocalDeployment> persistedDeployments = new ArrayList<>();\n+        Topics localDeployments = serviceConfig.findTopics(PERSISTENT_LOCAL_DEPLOYMENTS);\n+        localDeployments.deepForEachTopic(topic -> {\n+            Map<String, Object> deploymentDetails = (Map<String, Object>) topic.getOnce();\n+            persistedDeployments.add(LocalDeployment.builder()\n+                    .deploymentId((String) deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID))\n+                    .status((DeploymentStatus) deploymentDetails.get(\n+                            PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS))\n+                    .build());\n+        });\n+        return ListLocalDeploymentResponse.builder().localDeployments(persistedDeployments).build();\n+    }\n+\n+    /**\n+     * Persists the local deployment details in the config.\n+     * @param serviceConfig CLI service configuration\n+     * @param deploymentDetails Details of the local deployment to save\n+     */\n+    public void persistLocalDeployment(Topics serviceConfig, Map<String, Object> deploymentDetails) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 298}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjU4NTY0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-472658564", "createdAt": "2020-08-21T17:16:26Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoxNjoyNlrOHE1EFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoxNjoyNlrOHE1EFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTc1MQ==", "bodyText": "Does orderedDependencies also have main? do we need to filter it since it's not a component? Also internal services?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474825751", "createdAt": "2020-08-21T17:16:26Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjYwNDg5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-472660489", "createdAt": "2020-08-21T17:19:30Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoxOTozMFrOHE1JxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoxOTozMFrOHE1JxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNzIwNQ==", "bodyText": "Should this wait and check if the state transition actually happens before returning success?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474827205", "createdAt": "2020-08-21T17:19:30Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjYxNzcz", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-472661773", "createdAt": "2020-08-21T17:21:34Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoyMTozNFrOHE1Nyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzoyMTozNFrOHE1Nyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyODIzNQ==", "bodyText": "Same here, do we need to wait and validate if the request actually went through?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474828235", "createdAt": "2020-08-21T17:21:34Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjY3NDg5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-472667489", "createdAt": "2020-08-21T17:30:47Z", "commit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzozMDo0N1rOHE1fWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzozMDo0N1rOHE1fWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzMjcyOQ==", "bodyText": "Since this agent is directly interacting with deployments queue now, we should not need LocalDeploymentListener.java anymore right?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r474832729", "createdAt": "2020-08-21T17:30:47Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.util.Coerce;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+\n+public class CLIServiceAgent {\n+\n+    private static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(componentName)\n+                .state(LifecycleState.valueOf(service.getState().toString()))\n+                .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+        return GetComponentDetailsResponse.builder().componentDetails(componentDetails).build();\n+    }\n+\n+    /**\n+     * Returns the list of all the components running in the Greengrass.\n+     * @return {@link ListComponentsResponse}\n+     */\n+    public ListComponentsResponse listComponents() {\n+        Collection<EvergreenService> services = kernel.orderedDependencies();\n+        List<ComponentDetails> listOfComponents = new ArrayList<>();\n+        services.stream().forEach(service -> {\n+            ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())\n+                    .state(LifecycleState.valueOf(service.getState().toString()))\n+                    .version(Coerce.toString(service.getServiceConfig().find(VERSION_CONFIG_KEY))).build();\n+            listOfComponents.add(componentDetails);\n+        });\n+        return ListComponentsResponse.builder().components(listOfComponents).build();\n+    }\n+\n+    /**\n+     * Restart a component with the given name.\n+     * @param request {@link RestartComponentRequest}\n+     * @return {@link RestartComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public RestartComponentResponse restartComponent(RestartComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateRestartComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a restart. Right now they do not exist.\n+            // Success of this request means restart was triggered successfully\n+            service.requestRestart();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return RestartComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Stop a component with the given name.\n+     * @param request {@link StopComponentRequest}\n+     * @return {@link StopComponentResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError thrown when component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public StopComponentResponse stopComponent(StopComponentRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateStopComponentRequest(request);\n+        String componentName = request.getComponentName();\n+        try {\n+            EvergreenService service = kernel.locate(componentName);\n+            // TODO: Add any checks that can prevent triggering a stop. Right now they do not exist.\n+            // Success of this request means stop was triggered successfully\n+            service.requestStop();\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        return StopComponentResponse.builder().requestStatus(RequestStatus.SUCCEEDED).build();\n+    }\n+\n+    /**\n+     * Copy the recipes and artifacts from given directory path to the kernel package store.\n+     * @param request {@link UpdateRecipesAndArtifactsRequest}\n+     * @throws InvalidArgumentsError thrown when both arguments are empty\n+     * @throws InvalidRecipesDirectoryPathError thrown when the recipe directory path is invalid or kernel does not\n+     *         have permissions to access it.\n+     * @throws InvalidArtifactsDirectoryPathError thrown when the artifacts directory path is invalid or kernel does\n+     *         not have permissions to access it.\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public void updateRecipesAndArtifacts(UpdateRecipesAndArtifactsRequest request)\n+            throws InvalidArgumentsError, InvalidRecipesDirectoryPathError, InvalidArtifactsDirectoryPathError {\n+        validateUpdateRecipesAndArtifactsRequest(request);\n+        Path recipeDirectoryPath = Paths.get(request.getRecipeDirectoryPath());\n+        Path kernelPackageStorePath = kernel.getPackageStorePath();\n+        Path kernelRecipeDirectoryPath = kernelPackageStorePath.resolve(\"recipes\");\n+        try {\n+            copyFolderRecursively(recipeDirectoryPath, kernelRecipeDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidRecipesDirectoryPathError(e.getMessage());\n+        }\n+\n+        Path artifactsDirectoryPath = Paths.get(request.getArtifactDirectoryPath());\n+        Path kernelArtifactsDirectoryPath = kernelPackageStorePath.resolve(\"artifacts\");\n+        try {\n+            copyFolderRecursively(artifactsDirectoryPath, kernelArtifactsDirectoryPath);\n+        } catch (IOException e) {\n+            logger.atError().setCause(e).kv(\"Recipe Directory path\", recipeDirectoryPath)\n+                    .log(\"Caught exception while updating the recipes\");\n+            throw new InvalidArtifactsDirectoryPathError(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Creates a local deployment.\n+     * @param request {@link CreateLocalDeploymentRequest}\n+     * @return {@link CreateLocalDeploymentResponse}\n+     * @throws ServiceError thrown when deployment cannot be queued\n+     */\n+    public CreateLocalDeploymentResponse createLocalDeployment(CreateLocalDeploymentRequest request)\n+            throws ServiceError {\n+        //All inputs are valid. If all inputs are empty, then user might just want to retrigger the deployment with new\n+        // recipes set using the updateRecipesAndArtifacts API.\n+        String deploymentId = UUID.randomUUID().toString();\n+\n+        // TODO: Change the deployment service to directly handle the CreateLocalDeploymentRequest\n+        LocalOverrideRequest localOverrideRequest = LocalOverrideRequest.builder().requestId(deploymentId)\n+                .componentsToMerge(request.getRootComponentVersionsToAdd())\n+                .componentsToRemove(request.getRootComponentsToRemove())\n+                .groupName(request.getGroupName() == null || request.getGroupName()\n+                        .isEmpty() ? DEFAULT_GROUP_NAME : request.getGroupName())\n+                .componentNameToConfig(request.getComponentToConfiguration()).build();\n+        Deployment deployment = new Deployment(localOverrideRequest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56"}, "originalPosition": 230}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1cf3548202fe08dab86f4584506cc11088b02b56", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1cf3548202fe08dab86f4584506cc11088b02b56", "committedDate": "2020-08-19T00:27:29Z", "message": "Cli APIs over IPC"}, "afterCommit": {"oid": "645f879244d34ae21681b30d3694573ba0bdf8e8", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/645f879244d34ae21681b30d3694573ba0bdf8e8", "committedDate": "2020-08-26T01:37:42Z", "message": "Cli APIs over IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "645f879244d34ae21681b30d3694573ba0bdf8e8", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/645f879244d34ae21681b30d3694573ba0bdf8e8", "committedDate": "2020-08-26T01:37:42Z", "message": "Cli APIs over IPC"}, "afterCommit": {"oid": "cdbf6a377525d6e4cfa6b54841af9eada6f88929", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cdbf6a377525d6e4cfa6b54841af9eada6f88929", "committedDate": "2020-08-26T01:45:54Z", "message": "Cli APIs over IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cdbf6a377525d6e4cfa6b54841af9eada6f88929", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/cdbf6a377525d6e4cfa6b54841af9eada6f88929", "committedDate": "2020-08-26T01:45:54Z", "message": "Cli APIs over IPC"}, "afterCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1875a06a41948ece5b6e60f04c2c1497597582d2", "committedDate": "2020-08-26T02:15:42Z", "message": "Cli APIs over IPC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDA4OTQ2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-477008946", "createdAt": "2020-08-27T19:14:50Z", "commit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToxNDo1MFrOHId0CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToxNDo1MFrOHId0CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzOTExMg==", "bodyText": "Remove commented code?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478639112", "createdAt": "2020-08-27T19:14:50Z", "author": {"login": "shaguptashaikh"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -279,8 +280,12 @@ public IotJobsClient getIotJobsClient(MqttClientConnection connection) {\n     }\n \n     private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n-        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n-        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        DeploymentDetailsIotJobs deploymentDetailsIotJobs = OBJECT_MAPPER.convertValue(deploymentDetails,\n+                DeploymentDetailsIotJobs.class);\n+        //        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDExNjY4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-477011668", "createdAt": "2020-08-27T19:18:53Z", "commit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTIxMjQ0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-477121244", "createdAt": "2020-08-27T22:15:30Z", "commit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNTozMFrOHIjGLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNTozMFrOHIjGLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNTY3Ng==", "bodyText": "This can result in index out of bound exception if the client has an opcode > the CliClientOpCodes.values()", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478725676", "createdAt": "2020-08-27T22:15:30Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/CLIService.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package com.aws.iot.evergreen.ipc.modules;\n+\n+import com.aws.iot.evergreen.builtin.services.cli.CLIServiceAgent;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.ImplementsService;\n+import com.aws.iot.evergreen.deployment.DeploymentStatusKeeper;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.IPCRouter;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.exceptions.IPCException;\n+import com.aws.iot.evergreen.ipc.services.cli.CliClientOpCodes;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.GenericCliIpcServerException;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CliGenericResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;\n+import lombok.Data;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import javax.inject.Inject;\n+\n+@ImplementsService(name = CLIService.CLI_SERVICE, autostart = true)\n+public class CLIService extends EvergreenService {\n+\n+    private static final ObjectMapper CBOR_MAPPER = new CBORMapper();\n+\n+    public static final String CLI_SERVICE = \"aws.greengrass.ipc.cli\";\n+    protected static final ObjectMapper OBJECT_MAPPER =\n+            new ObjectMapper().configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+                    .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+\n+    @Inject\n+    CLIServiceAgent agent;\n+\n+    @Inject\n+    private IPCRouter router;\n+\n+    @Inject\n+    private DeploymentStatusKeeper deploymentStatusKeeper;\n+\n+    public CLIService(Topics topics) {\n+        super(topics);\n+    }\n+\n+    /**\n+     * Constructor for unit testing.\n+     * @param topics Service config\n+     * @param router {@link IPCRouter}\n+     * @param agent {@link CLIServiceAgent}\n+     * @param deploymentStatusKeeper {@link DeploymentStatusKeeper}\n+     */\n+    public CLIService(Topics topics, IPCRouter router, CLIServiceAgent agent,\n+                      DeploymentStatusKeeper deploymentStatusKeeper) {\n+        super(topics);\n+        this.router = router;\n+        this.agent = agent;\n+        this.deploymentStatusKeeper = deploymentStatusKeeper;\n+    }\n+\n+    @Override\n+    public void postInject() {\n+        BuiltInServiceDestinationCode destination = BuiltInServiceDestinationCode.CLI;\n+        super.postInject();\n+        try {\n+            router.registerServiceCallback(destination.getValue(), this::handleMessage);\n+            logger.atInfo().setEventType(\"ipc-register-request-handler\").addKeyValue(\"destination\", destination.name())\n+                    .log();\n+            deploymentStatusKeeper.registerDeploymentStatusConsumer(Deployment.DeploymentType.LOCAL,\n+                    this::deploymentStatusChanged, CLIService.class.getName());\n+        } catch (IPCException e) {\n+            logger.atError().setEventType(\"ipc-register-request-handler-error\").setCause(e)\n+                    .addKeyValue(\"destination\", destination.name())\n+                    .log(\"Failed to register service callback to destination\");\n+        }\n+    }\n+\n+    @Data\n+    public static class LocalDeploymentDetails {\n+        String deploymentId;\n+        DeploymentStatus status;\n+    }\n+\n+    @SuppressWarnings(\"PMD.EmptyIfStmt\")\n+    protected Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n+        agent.persistLocalDeployment(config, deploymentDetails);\n+        return true;\n+    }\n+\n+    /**\n+     * Handle all requests for CLI from the CLI client.\n+     *\n+     * @param message incoming request\n+     * @param context Context identifying the client and the channel\n+     */\n+    @SuppressWarnings(\"PMD.AvoidCatchingThrowable\")\n+    public Future<FrameReader.Message> handleMessage(FrameReader.Message message, ConnectionContext context) {\n+        CompletableFuture<FrameReader.Message> fut = new CompletableFuture<>();\n+\n+        ApplicationMessage applicationMessage = ApplicationMessage.fromBytes(message.getPayload());\n+        try {\n+            //TODO: add version compatibility check\n+            CliClientOpCodes opCode = CliClientOpCodes.values()[applicationMessage.getOpCode()];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTIxOTgw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-477121980", "createdAt": "2020-08-27T22:17:12Z", "commit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNzoxMlrOHIjIbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNzoxMlrOHIjIbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNjI1NA==", "bodyText": "Didn't we agree to have component configuration in the getComponentDetails or is that covered by another API", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r478726254", "createdAt": "2020-08-27T22:17:12Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/builtin/services/cli/CLIServiceAgent.java", "diffHunk": "@@ -0,0 +1,376 @@\n+package com.aws.iot.evergreen.builtin.services.cli;\n+\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.deployment.model.Deployment;\n+import com.aws.iot.evergreen.deployment.model.LocalOverrideRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ComponentNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArgumentsError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidArtifactsDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.InvalidRecipesDirectoryPathError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ResourceNotFoundError;\n+import com.aws.iot.evergreen.ipc.services.cli.exceptions.ServiceError;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ComponentDetails;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.CreateLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.DeploymentStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetComponentDetailsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.GetLocalDeploymentStatusResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LifecycleState;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListComponentsResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.ListLocalDeploymentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.LocalDeployment;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RequestStatus;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.RestartComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentRequest;\n+import com.aws.iot.evergreen.ipc.services.cli.models.StopComponentResponse;\n+import com.aws.iot.evergreen.ipc.services.cli.models.UpdateRecipesAndArtifactsRequest;\n+import com.aws.iot.evergreen.kernel.EvergreenService;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.kernel.exceptions.ServiceLoadException;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import com.aws.iot.evergreen.packagemanager.PackageStore;\n+import com.aws.iot.evergreen.util.Coerce;\n+import com.aws.iot.evergreen.util.Utils;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import static com.aws.iot.evergreen.deployment.DeploymentConfigMerger.DEPLOYMENT_ID_LOG_KEY;\n+import static com.aws.iot.evergreen.deployment.DeploymentService.DEPLOYMENTS_QUEUE;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_ID;\n+import static com.aws.iot.evergreen.deployment.DeploymentStatusKeeper.PERSISTED_DEPLOYMENT_STATUS_KEY_LOCAL_DEPLOYMENT_STATUS;\n+import static com.aws.iot.evergreen.deployment.converter.DeploymentDocumentConverter.DEFAULT_GROUP_NAME;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_FULL;\n+import static com.aws.iot.evergreen.ipc.common.IPCErrorStrings.DEPLOYMENTS_QUEUE_NOT_INITIALIZED;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.VERSION_CONFIG_KEY;\n+\n+public class CLIServiceAgent {\n+\n+    public static final String PERSISTENT_LOCAL_DEPLOYMENTS = \"LocalDeployments\";\n+    public static final String LOCAL_DEPLOYMENT_RESOURCE = \"LocalDeployment\";\n+    private static ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n+            .configure(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE, false)\n+            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    private final Kernel kernel;\n+\n+    private final LinkedBlockingQueue<Deployment> deploymentsQueue;\n+\n+    private static Logger logger = LogManager.getLogger(CLIServiceAgent.class);\n+\n+    @Inject\n+    public CLIServiceAgent(Kernel kernel, @Named(DEPLOYMENTS_QUEUE) LinkedBlockingQueue<Deployment> deploymentsQueue) {\n+        this.kernel = kernel;\n+        this.deploymentsQueue = deploymentsQueue;\n+    }\n+\n+    /**\n+     * Get the details of a component with the given name.\n+     * @param request {@link GetComponentDetailsRequest}\n+     * @return {@link GetComponentDetailsResponse}\n+     * @throws InvalidArgumentsError thrown when empty component name is received\n+     * @throws ComponentNotFoundError Thrown when given component does not exist\n+     */\n+    @SuppressWarnings(\"PMD.PreserveStackTrace\")\n+    public GetComponentDetailsResponse getComponentDetails(GetComponentDetailsRequest request)\n+            throws InvalidArgumentsError, ComponentNotFoundError {\n+        validateGetComponentDetailsRequest(request);\n+        String componentName = request.getComponentName();\n+        EvergreenService service;\n+        try {\n+            service = kernel.locate(componentName);\n+        } catch (ServiceLoadException e) {\n+            logger.atError().kv(\"ComponentName\", componentName)\n+                    .setCause(e)\n+                    .log(\"Did not find the component with the given name in Greengrass\");\n+            throw new ComponentNotFoundError(\"Component with name \" + componentName + \" not found in Greengrass\");\n+        }\n+        ComponentDetails componentDetails = ComponentDetails.builder().componentName(service.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2"}, "originalPosition": 109}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1875a06a41948ece5b6e60f04c2c1497597582d2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1875a06a41948ece5b6e60f04c2c1497597582d2", "committedDate": "2020-08-26T02:15:42Z", "message": "Cli APIs over IPC"}, "afterCommit": {"oid": "a4ab07a528bb00d94e96081457e0be6bbe8fb2af", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a4ab07a528bb00d94e96081457e0be6bbe8fb2af", "committedDate": "2020-08-29T01:18:23Z", "message": "Cli APIs over IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4ab07a528bb00d94e96081457e0be6bbe8fb2af", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a4ab07a528bb00d94e96081457e0be6bbe8fb2af", "committedDate": "2020-08-29T01:18:23Z", "message": "Cli APIs over IPC"}, "afterCommit": {"oid": "b4452930db935c86f220fa45409181ca1ee4dbb0", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b4452930db935c86f220fa45409181ca1ee4dbb0", "committedDate": "2020-08-29T01:30:34Z", "message": "Cli APIs over IPC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b4452930db935c86f220fa45409181ca1ee4dbb0", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b4452930db935c86f220fa45409181ca1ee4dbb0", "committedDate": "2020-08-29T01:30:34Z", "message": "Cli APIs over IPC"}, "afterCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4b8114e9e230173401d1d0767c6a3b57072e1739", "committedDate": "2020-08-31T20:23:17Z", "message": "Changing test recipes format as per new format"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NDU4MTIw", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-479458120", "createdAt": "2020-09-01T07:11:40Z", "commit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMTo0MFrOHKoEMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMTo0MFrOHKoEMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDI0Mw==", "bodyText": "This feels weird, creating an object and then storing as a map. Can we just store it as the object and change the call back functions?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r480904243", "createdAt": "2020-09-01T07:11:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/DeploymentStatusKeeper.java", "diffHunk": "@@ -44,44 +49,52 @@\n      * @param serviceName subscribing service name\n      * @return true if call back is registered.\n      */\n-    public boolean registerDeploymentStatusConsumer(DeploymentType type, Function<Map<String, Object>,\n-            Boolean> consumer, String serviceName) {\n-        Map<String, Function<Map<String, Object>, Boolean>> map =\n-                deploymentStatusConsumerMap.getOrDefault(type, new ConcurrentHashMap<>());\n+    public boolean registerDeploymentStatusConsumer(DeploymentType type,\n+                                                    Function<Map<String, Object>, Boolean> consumer,\n+                                                    String serviceName) {\n+        Map<String, Function<Map<String, Object>, Boolean>> map = deploymentStatusConsumerMap\n+                .getOrDefault(type, new ConcurrentHashMap<>());\n         map.putIfAbsent(serviceName, consumer);\n         return deploymentStatusConsumerMap.put(type, map) == null;\n     }\n \n     /**\n      * Persist deployment status in kernel config.\n      *\n-     * @param jobId          id for the deployment.\n+     * @param deploymentId   id for the deployment.\n      * @param deploymentType type of deployment.\n      * @param status         status of deployment.\n      * @param statusDetails  other details of deployment status.\n      */\n-    public void persistAndPublishDeploymentStatus(String jobId, DeploymentType deploymentType,\n-                                                  JobStatus status, Map<String, String> statusDetails) {\n-        // no need to persist status for local deployment\n-        if (deploymentType.equals(DeploymentType.LOCAL)) {\n-            return;\n-        }\n+    public void persistAndPublishDeploymentStatus(String deploymentId, DeploymentType deploymentType, String status,\n+                                                  Map<String, String> statusDetails) {\n \n         //While this method is being run, another thread could be running the publishPersistedStatusUpdates\n         // method which consumes the data in config from the same topics. These two thread needs to be synchronized\n         synchronized (deploymentType) {\n-            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, jobId).kv(\"JobStatus\", status).log(\"Storing job status\");\n-            Map<String, Object> deploymentDetails = new HashMap<>();\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID, jobId);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS, status);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_STATUS_DETAILS, statusDetails);\n-            deploymentDetails.put(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_TYPE, deploymentType);\n+            logger.atDebug().kv(JOB_ID_LOG_KEY_NAME, deploymentId).kv(\"JobStatus\", status).log(\"Storing job status\");\n+            Map<String, Object> deploymentDetails = null;\n+            if (deploymentType == DeploymentType.IOT_JOBS) {\n+                IotJobsHelper.DeploymentDetailsIotJobs deploymentDetailsIotJobs =\n+                        new IotJobsHelper.DeploymentDetailsIotJobs();\n+                deploymentDetailsIotJobs.setJobId(deploymentId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NDU4Nzc2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-479458776", "createdAt": "2020-09-01T07:12:40Z", "commit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMjo0MFrOHKoHDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMjo0MFrOHKoHDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwNDk3NA==", "bodyText": "same as above, can we avoid the serialization and de-serialization ?", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#discussion_r480904974", "createdAt": "2020-09-01T07:12:40Z", "author": {"login": "fahadmohammed01"}, "path": "src/main/java/com/aws/iot/evergreen/deployment/IotJobsHelper.java", "diffHunk": "@@ -279,15 +282,15 @@ public IotJobsClient getIotJobsClient(MqttClientConnection connection) {\n     }\n \n     private Boolean deploymentStatusChanged(Map<String, Object> deploymentDetails) {\n-        String jobId = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_ID).toString();\n-        String status = deploymentDetails.get(PERSISTED_DEPLOYMENT_STATUS_KEY_JOB_STATUS).toString();\n+        DeploymentDetailsIotJobs deploymentDetailsIotJobs = OBJECT_MAPPER.convertValue(deploymentDetails,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTk0MDQy", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-480194042", "createdAt": "2020-09-02T00:00:14Z", "commit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMDA0ODY3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-481004867", "createdAt": "2020-09-02T16:40:19Z", "commit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b8114e9e230173401d1d0767c6a3b57072e1739", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4b8114e9e230173401d1d0767c6a3b57072e1739", "committedDate": "2020-08-31T20:23:17Z", "message": "Changing test recipes format as per new format"}, "afterCommit": {"oid": "a2ac3d72f374ca77b404f7652801a38c73bb275e", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2ac3d72f374ca77b404f7652801a38c73bb275e", "committedDate": "2020-09-03T01:17:08Z", "message": "Changing test recipes format as per new format"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2ac3d72f374ca77b404f7652801a38c73bb275e", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a2ac3d72f374ca77b404f7652801a38c73bb275e", "committedDate": "2020-09-03T01:17:08Z", "message": "Changing test recipes format as per new format"}, "afterCommit": {"oid": "65bc91608224ac7d7b2c202a6eee43bfa03cd515", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65bc91608224ac7d7b2c202a6eee43bfa03cd515", "committedDate": "2020-09-03T19:44:28Z", "message": "Fixing directory path in intergration tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65bc91608224ac7d7b2c202a6eee43bfa03cd515", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/65bc91608224ac7d7b2c202a6eee43bfa03cd515", "committedDate": "2020-09-03T19:44:28Z", "message": "Fixing directory path in intergration tests"}, "afterCommit": {"oid": "c3f4a3ae12fcdd92201c206af5f690d7c0c44a55", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3f4a3ae12fcdd92201c206af5f690d7c0c44a55", "committedDate": "2020-09-03T23:30:44Z", "message": "Fixing directory path in intergration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdd81bb37ef1483bdb1a1b40d9ecf8428ae3a2a3", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/fdd81bb37ef1483bdb1a1b40d9ecf8428ae3a2a3", "committedDate": "2020-09-04T00:34:35Z", "message": "Cli APIs over IPC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6b7b3064124d3d049cacfd3830eb96494607c88", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b6b7b3064124d3d049cacfd3830eb96494607c88", "committedDate": "2020-09-04T00:34:35Z", "message": "Changing test recipes format as per new format"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c3f4a3ae12fcdd92201c206af5f690d7c0c44a55", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c3f4a3ae12fcdd92201c206af5f690d7c0c44a55", "committedDate": "2020-09-03T23:30:44Z", "message": "Fixing directory path in intergration tests"}, "afterCommit": {"oid": "0f57ab1fde9668fdb4b02a45e19bb371bd8a5eb1", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0f57ab1fde9668fdb4b02a45e19bb371bd8a5eb1", "committedDate": "2020-09-04T00:35:22Z", "message": "Fixing directory path in intergration tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f57ab1fde9668fdb4b02a45e19bb371bd8a5eb1", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0f57ab1fde9668fdb4b02a45e19bb371bd8a5eb1", "committedDate": "2020-09-04T00:35:22Z", "message": "Fixing directory path in intergration tests"}, "afterCommit": {"oid": "ad2d9f6336aa6ee50433f469f913bb2e4849d4d2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ad2d9f6336aa6ee50433f469f913bb2e4849d4d2", "committedDate": "2020-09-04T00:36:50Z", "message": "Fixing directory path in intergration tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad2d9f6336aa6ee50433f469f913bb2e4849d4d2", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ad2d9f6336aa6ee50433f469f913bb2e4849d4d2", "committedDate": "2020-09-04T00:36:50Z", "message": "Fixing directory path in intergration tests"}, "afterCommit": {"oid": "4082074183275c50caeae7b01c3573073d331de7", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4082074183275c50caeae7b01c3573073d331de7", "committedDate": "2020-09-04T01:20:13Z", "message": "Fixing directory path in intergration tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNTE4MjI3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-482518227", "createdAt": "2020-09-04T09:51:48Z", "commit": {"oid": "4082074183275c50caeae7b01c3573073d331de7"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec7d54e263cf34b441c4f0ab895d2801a8a84706", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec7d54e263cf34b441c4f0ab895d2801a8a84706", "committedDate": "2020-09-04T16:11:51Z", "message": "Fixing directory path in intergration tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4082074183275c50caeae7b01c3573073d331de7", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/4082074183275c50caeae7b01c3573073d331de7", "committedDate": "2020-09-04T01:20:13Z", "message": "Fixing directory path in intergration tests"}, "afterCommit": {"oid": "ec7d54e263cf34b441c4f0ab895d2801a8a84706", "author": {"user": {"login": "abanthiy", "name": null}}, "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ec7d54e263cf34b441c4f0ab895d2801a8a84706", "committedDate": "2020-09-04T16:11:51Z", "message": "Fixing directory path in intergration tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyODA3ODY5", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-482807869", "createdAt": "2020-09-04T16:42:37Z", "commit": {"oid": "ec7d54e263cf34b441c4f0ab895d2801a8a84706"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyODIzNzk0", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/373#pullrequestreview-482823794", "createdAt": "2020-09-04T17:10:38Z", "commit": {"oid": "ec7d54e263cf34b441c4f0ab895d2801a8a84706"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2092, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}