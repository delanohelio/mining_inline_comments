{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NzM2MjY5", "number": 505, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjozNzozM1rODf8wug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDoxOTowMFrODgo1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODI3OTYyOnYy", "diffSide": "RIGHT", "path": "common-service-core/src/test/java/org/zowe/apiml/util/MapUtilsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjozNzozM1rOFp8p-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMzowMTozOVrOFqjpkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTcyMg==", "bodyText": "No need to assign variable that is not used, just mapUtils.flattenMap(null, testMap); will throw the exception. Same in tests below.", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r379529722", "createdAt": "2020-02-14T16:37:33Z", "author": {"login": "cZikos"}, "path": "common-service-core/src/test/java/org/zowe/apiml/util/MapUtilsTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.junit.Assert.assertThat;\n+\n+public class MapUtilsTest {\n+\n+    private MapUtils mapUtils = new MapUtils();\n+\n+    @Test\n+    public void givenMap_whenFlattenedWithRootKey_shouldReturnMapKeysWithRootKey() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key\", null);\n+        Map<String, String> resultMap = mapUtils.flattenMap(\"apiml\", testMap);\n+        assertThat(resultMap, hasEntry(\"apiml.key\", \"\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithNullValue_whenFlattened_shouldReturnValueEmptyString() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key\", null);\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"key\", \"\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithPrimitiveValues_whenFlattened_shouldReturnCorrectValues() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key1\", true);\n+        testMap.put(\"key2\", 23);\n+        testMap.put(\"key3\", 23.0d);\n+        testMap.put(\"key4\", 23.0f);\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"key1\", \"true\"));\n+        assertThat(resultMap, hasEntry(\"key2\", \"23\"));\n+        assertThat(resultMap, hasEntry(\"key3\", \"23.0\"));\n+        assertThat(resultMap, hasEntry(\"key4\", \"23.0\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithNestedMap_whenFlattened_shouldReturnFlattened() {\n+        Map<String, Object> nestedLvl2 = new HashMap<>();\n+        nestedLvl2.put(\"keyzzz\", \"valuezzz\");\n+\n+        Map<String, Object> nested = new HashMap<>();\n+        nested.put(\"key1\", \"value1\");\n+        nested.put(\"key2\", \"value2\");\n+        nested.put(\"key3\", nestedLvl2);\n+\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"masterKey\", nested);\n+\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"masterKey.key1\", \"value1\"));\n+        assertThat(resultMap, hasEntry(\"masterKey.key2\", \"value2\"));\n+        assertThat(resultMap, hasEntry(\"masterKey.key3.keyzzz\", \"valuezzz\"));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void givenMapWithNestedList_whenFlattened_shouldReturnException() {\n+        List<Object> nested = new ArrayList<>();\n+        nested.add(\"value1\");\n+        nested.add(\"value2\");\n+\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"masterKey\", nested);\n+\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e1a4f3ea0a22a6fafd5f96224093939d9fe3fc5"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE2ODU5Mw==", "bodyText": "Thank you!", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380168593", "createdAt": "2020-02-17T13:01:39Z", "author": {"login": "jandadav"}, "path": "common-service-core/src/test/java/org/zowe/apiml/util/MapUtilsTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.junit.Assert.assertThat;\n+\n+public class MapUtilsTest {\n+\n+    private MapUtils mapUtils = new MapUtils();\n+\n+    @Test\n+    public void givenMap_whenFlattenedWithRootKey_shouldReturnMapKeysWithRootKey() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key\", null);\n+        Map<String, String> resultMap = mapUtils.flattenMap(\"apiml\", testMap);\n+        assertThat(resultMap, hasEntry(\"apiml.key\", \"\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithNullValue_whenFlattened_shouldReturnValueEmptyString() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key\", null);\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"key\", \"\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithPrimitiveValues_whenFlattened_shouldReturnCorrectValues() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key1\", true);\n+        testMap.put(\"key2\", 23);\n+        testMap.put(\"key3\", 23.0d);\n+        testMap.put(\"key4\", 23.0f);\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"key1\", \"true\"));\n+        assertThat(resultMap, hasEntry(\"key2\", \"23\"));\n+        assertThat(resultMap, hasEntry(\"key3\", \"23.0\"));\n+        assertThat(resultMap, hasEntry(\"key4\", \"23.0\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithNestedMap_whenFlattened_shouldReturnFlattened() {\n+        Map<String, Object> nestedLvl2 = new HashMap<>();\n+        nestedLvl2.put(\"keyzzz\", \"valuezzz\");\n+\n+        Map<String, Object> nested = new HashMap<>();\n+        nested.put(\"key1\", \"value1\");\n+        nested.put(\"key2\", \"value2\");\n+        nested.put(\"key3\", nestedLvl2);\n+\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"masterKey\", nested);\n+\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"masterKey.key1\", \"value1\"));\n+        assertThat(resultMap, hasEntry(\"masterKey.key2\", \"value2\"));\n+        assertThat(resultMap, hasEntry(\"masterKey.key3.keyzzz\", \"valuezzz\"));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void givenMapWithNestedList_whenFlattened_shouldReturnException() {\n+        List<Object> nested = new ArrayList<>();\n+        nested.add(\"value1\");\n+        nested.add(\"value2\");\n+\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"masterKey\", nested);\n+\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTcyMg=="}, "originalCommit": {"oid": "5e1a4f3ea0a22a6fafd5f96224093939d9fe3fc5"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTQ0Njg5OnYy", "diffSide": "RIGHT", "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDowMzo1MlrOFq8Oew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjo1ODowNFrOFrc5BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MTI1OQ==", "bodyText": "What about make this mapping in static part. For rootKey of course use BiFunction. In this case the map is constructed all times.", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380571259", "createdAt": "2020-02-18T10:03:52Z", "author": {"login": "pj892031"}, "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {\n+\n+    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+        if (collection == null || collection.isEmpty()) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<String, String> result = new HashMap<>();\n+\n+        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjQzNg==", "bodyText": "check out the latest impl, I've modified the code to do this", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106436", "createdAt": "2020-02-19T06:58:04Z", "author": {"login": "jandadav"}, "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {\n+\n+    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+        if (collection == null || collection.isEmpty()) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<String, String> result = new HashMap<>();\n+\n+        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MTI1OQ=="}, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTQ1NjQwOnYy", "diffSide": "RIGHT", "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDowNjoyOFrOFq8UPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjo1ODoyN1rOFrc5cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MjczMg==", "bodyText": "There is possible to test in first step with current class. If it is not found, then make this iteration and then store new type in the class. It could be helpfull (like cache), but I am not sure how often it is run.\nMap<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\nMap<Class, Consumer<Map.Entry<String, Object>>> cache = new HashMap<>();\nstatic {\ninit(actionMap);\ncache.putAll(actionMap)\n}\n....\nConsumer c = cache.get(...);\nif (c != null) return c....;\nfor (Entry e : actionMap) {\nif (instanceof...) {\ncache.put(class, e.getValue);\nreturn e.getValue....\n}", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380572732", "createdAt": "2020-02-18T10:06:28Z", "author": {"login": "pj892031"}, "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {\n+\n+    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+        if (collection == null || collection.isEmpty()) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<String, String> result = new HashMap<>();\n+\n+        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\n+        actionMap.put(Map.class, entry -> result.putAll(flattenMap(mergeKey(rootKey, entry.getKey()), (Map<String, Object>)entry.getValue())));\n+        actionMap.put(String.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Boolean.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Integer.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Double.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Float.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(List.class, entry -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n+        actionMap.put(Object[].class, entry -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n+        actionMap.put(Object.class, entry -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", entry.getKey(), entry.getValue().toString())); } );\n+\n+        for (Map.Entry<String, Object> entry : collection.entrySet()) {\n+            if (entry.getValue() == null) {\n+                result.put( mergeKey(rootKey, entry.getKey()), \"\");\n+                continue;\n+            }\n+            executeAction(entry,actionMap);\n+        }\n+        return result;\n+    }\n+\n+    private void executeAction(Map.Entry<String, Object> switchSubject, Map<Class, Consumer<Map.Entry<String, Object>>> actionMap) {\n+        for (Map.Entry<Class, Consumer<Map.Entry<String, Object>>> action : actionMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjU0NQ==", "bodyText": "check out the latest impl", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106545", "createdAt": "2020-02-19T06:58:27Z", "author": {"login": "jandadav"}, "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {\n+\n+    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+        if (collection == null || collection.isEmpty()) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<String, String> result = new HashMap<>();\n+\n+        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\n+        actionMap.put(Map.class, entry -> result.putAll(flattenMap(mergeKey(rootKey, entry.getKey()), (Map<String, Object>)entry.getValue())));\n+        actionMap.put(String.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Boolean.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Integer.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Double.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Float.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(List.class, entry -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n+        actionMap.put(Object[].class, entry -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n+        actionMap.put(Object.class, entry -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", entry.getKey(), entry.getValue().toString())); } );\n+\n+        for (Map.Entry<String, Object> entry : collection.entrySet()) {\n+            if (entry.getValue() == null) {\n+                result.put( mergeKey(rootKey, entry.getKey()), \"\");\n+                continue;\n+            }\n+            executeAction(entry,actionMap);\n+        }\n+        return result;\n+    }\n+\n+    private void executeAction(Map.Entry<String, Object> switchSubject, Map<Class, Consumer<Map.Entry<String, Object>>> actionMap) {\n+        for (Map.Entry<Class, Consumer<Map.Entry<String, Object>>> action : actionMap.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MjczMg=="}, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTQ4Nzg3OnYy", "diffSide": "RIGHT", "path": "onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDoxNToyNVrOFq8nyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjo1OTowNVrOFrc6Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzczOA==", "bodyText": "empty (null) values should not be set", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380577738", "createdAt": "2020-02-18T10:15:25Z", "author": {"login": "pj892031"}, "path": "onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.eurekaservice.client.util;\n+\n+import com.netflix.appinfo.EurekaInstanceConfig;\n+import org.zowe.apiml.config.ApiInfo;\n+import org.zowe.apiml.eurekaservice.client.config.*;\n+import org.zowe.apiml.exception.MetadataValidationException;\n+import org.zowe.apiml.exception.ServiceDefinitionException;\n+import org.zowe.apiml.util.MapUtils;\n+import org.zowe.apiml.util.UrlUtils;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.zowe.apiml.constants.EurekaMetadataDefinition.*;\n+\n+public class EurekaInstanceConfigCreator {\n+\n+    private final MapUtils mapUtils;\n+\n+    public EurekaInstanceConfigCreator(MapUtils mapUtils) {\n+        this.mapUtils = mapUtils;\n+    }\n+\n+    public EurekaInstanceConfig createEurekaInstanceConfig(ApiMediationServiceConfig config) throws ServiceDefinitionException {\n+        ApimlEurekaInstanceConfig result = new ApimlEurekaInstanceConfig();\n+\n+        String hostname;\n+        int port;\n+        URL baseUrl;\n+\n+        try {\n+            baseUrl = new URL(config.getBaseUrl());\n+            hostname = baseUrl.getHost();\n+            port = baseUrl.getPort();\n+        } catch (MalformedURLException e) {\n+            String message = String.format(\"baseUrl: [%s] is not valid URL\", config.getBaseUrl());\n+            throw new ServiceDefinitionException(message, e);\n+        }\n+\n+        result.setInstanceId(String.format(\"%s:%s:%s\", hostname, config.getServiceId(), port));\n+        result.setAppname(config.getServiceId());\n+        result.setAppGroupName(config.getServiceId());\n+        result.setHostName(hostname);\n+        result.setIpAddress(config.getServiceIpAddress());\n+        result.setInstanceEnabledOnit(true);\n+        result.setSecureVirtualHostName(config.getServiceId());\n+        result.setVirtualHostName(config.getServiceId());\n+        result.setStatusPageUrl(config.getBaseUrl() + config.getStatusPageRelativeUrl());\n+\n+        if ((config.getHomePageRelativeUrl() != null) && !config.getHomePageRelativeUrl().isEmpty()) {\n+            result.setHomePageUrl(config.getBaseUrl() + config.getHomePageRelativeUrl());\n+        }\n+\n+        String protocol = baseUrl.getProtocol();\n+        result.setNonSecurePort(port);\n+        result.setSecurePort(port);\n+\n+        switch (protocol) {\n+            case \"http\":\n+                result.setNonSecurePortEnabled(true);\n+                result.setHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            case \"https\":\n+                result.setSecurePortEnabled(true);\n+                result.setSecureHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            default:\n+                throw new ServiceDefinitionException(String.format(\"'%s' is not valid protocol for baseUrl property\", protocol));\n+        }\n+\n+        try {\n+            result.setMetadataMap(createMetadata(config));\n+        } catch (MetadataValidationException | IllegalArgumentException e) {\n+            throw new ServiceDefinitionException(\"Service configuration failed to create service metadata: \", e);\n+        }\n+\n+        return result;\n+    }\n+\n+    private Map<String, String> createMetadata(ApiMediationServiceConfig config) {\n+        Map<String, String> metadata = new HashMap<>();\n+\n+        // fill authentication metadata\n+        Authentication authentication = config.getAuthentication();\n+        if (authentication != null) {\n+            metadata.put(AUTHENTICATION_SCHEME, authentication.getScheme());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NzYwNw==", "bodyText": "It's just moved code from your PR", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380597607", "createdAt": "2020-02-18T10:51:52Z", "author": {"login": "jandadav"}, "path": "onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.eurekaservice.client.util;\n+\n+import com.netflix.appinfo.EurekaInstanceConfig;\n+import org.zowe.apiml.config.ApiInfo;\n+import org.zowe.apiml.eurekaservice.client.config.*;\n+import org.zowe.apiml.exception.MetadataValidationException;\n+import org.zowe.apiml.exception.ServiceDefinitionException;\n+import org.zowe.apiml.util.MapUtils;\n+import org.zowe.apiml.util.UrlUtils;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.zowe.apiml.constants.EurekaMetadataDefinition.*;\n+\n+public class EurekaInstanceConfigCreator {\n+\n+    private final MapUtils mapUtils;\n+\n+    public EurekaInstanceConfigCreator(MapUtils mapUtils) {\n+        this.mapUtils = mapUtils;\n+    }\n+\n+    public EurekaInstanceConfig createEurekaInstanceConfig(ApiMediationServiceConfig config) throws ServiceDefinitionException {\n+        ApimlEurekaInstanceConfig result = new ApimlEurekaInstanceConfig();\n+\n+        String hostname;\n+        int port;\n+        URL baseUrl;\n+\n+        try {\n+            baseUrl = new URL(config.getBaseUrl());\n+            hostname = baseUrl.getHost();\n+            port = baseUrl.getPort();\n+        } catch (MalformedURLException e) {\n+            String message = String.format(\"baseUrl: [%s] is not valid URL\", config.getBaseUrl());\n+            throw new ServiceDefinitionException(message, e);\n+        }\n+\n+        result.setInstanceId(String.format(\"%s:%s:%s\", hostname, config.getServiceId(), port));\n+        result.setAppname(config.getServiceId());\n+        result.setAppGroupName(config.getServiceId());\n+        result.setHostName(hostname);\n+        result.setIpAddress(config.getServiceIpAddress());\n+        result.setInstanceEnabledOnit(true);\n+        result.setSecureVirtualHostName(config.getServiceId());\n+        result.setVirtualHostName(config.getServiceId());\n+        result.setStatusPageUrl(config.getBaseUrl() + config.getStatusPageRelativeUrl());\n+\n+        if ((config.getHomePageRelativeUrl() != null) && !config.getHomePageRelativeUrl().isEmpty()) {\n+            result.setHomePageUrl(config.getBaseUrl() + config.getHomePageRelativeUrl());\n+        }\n+\n+        String protocol = baseUrl.getProtocol();\n+        result.setNonSecurePort(port);\n+        result.setSecurePort(port);\n+\n+        switch (protocol) {\n+            case \"http\":\n+                result.setNonSecurePortEnabled(true);\n+                result.setHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            case \"https\":\n+                result.setSecurePortEnabled(true);\n+                result.setSecureHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            default:\n+                throw new ServiceDefinitionException(String.format(\"'%s' is not valid protocol for baseUrl property\", protocol));\n+        }\n+\n+        try {\n+            result.setMetadataMap(createMetadata(config));\n+        } catch (MetadataValidationException | IllegalArgumentException e) {\n+            throw new ServiceDefinitionException(\"Service configuration failed to create service metadata: \", e);\n+        }\n+\n+        return result;\n+    }\n+\n+    private Map<String, String> createMetadata(ApiMediationServiceConfig config) {\n+        Map<String, String> metadata = new HashMap<>();\n+\n+        // fill authentication metadata\n+        Authentication authentication = config.getAuthentication();\n+        if (authentication != null) {\n+            metadata.put(AUTHENTICATION_SCHEME, authentication.getScheme());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzczOA=="}, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjcxNQ==", "bodyText": "as we debated yesterday, i'll leave this part be as is", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106715", "createdAt": "2020-02-19T06:59:05Z", "author": {"login": "jandadav"}, "path": "onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.eurekaservice.client.util;\n+\n+import com.netflix.appinfo.EurekaInstanceConfig;\n+import org.zowe.apiml.config.ApiInfo;\n+import org.zowe.apiml.eurekaservice.client.config.*;\n+import org.zowe.apiml.exception.MetadataValidationException;\n+import org.zowe.apiml.exception.ServiceDefinitionException;\n+import org.zowe.apiml.util.MapUtils;\n+import org.zowe.apiml.util.UrlUtils;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.zowe.apiml.constants.EurekaMetadataDefinition.*;\n+\n+public class EurekaInstanceConfigCreator {\n+\n+    private final MapUtils mapUtils;\n+\n+    public EurekaInstanceConfigCreator(MapUtils mapUtils) {\n+        this.mapUtils = mapUtils;\n+    }\n+\n+    public EurekaInstanceConfig createEurekaInstanceConfig(ApiMediationServiceConfig config) throws ServiceDefinitionException {\n+        ApimlEurekaInstanceConfig result = new ApimlEurekaInstanceConfig();\n+\n+        String hostname;\n+        int port;\n+        URL baseUrl;\n+\n+        try {\n+            baseUrl = new URL(config.getBaseUrl());\n+            hostname = baseUrl.getHost();\n+            port = baseUrl.getPort();\n+        } catch (MalformedURLException e) {\n+            String message = String.format(\"baseUrl: [%s] is not valid URL\", config.getBaseUrl());\n+            throw new ServiceDefinitionException(message, e);\n+        }\n+\n+        result.setInstanceId(String.format(\"%s:%s:%s\", hostname, config.getServiceId(), port));\n+        result.setAppname(config.getServiceId());\n+        result.setAppGroupName(config.getServiceId());\n+        result.setHostName(hostname);\n+        result.setIpAddress(config.getServiceIpAddress());\n+        result.setInstanceEnabledOnit(true);\n+        result.setSecureVirtualHostName(config.getServiceId());\n+        result.setVirtualHostName(config.getServiceId());\n+        result.setStatusPageUrl(config.getBaseUrl() + config.getStatusPageRelativeUrl());\n+\n+        if ((config.getHomePageRelativeUrl() != null) && !config.getHomePageRelativeUrl().isEmpty()) {\n+            result.setHomePageUrl(config.getBaseUrl() + config.getHomePageRelativeUrl());\n+        }\n+\n+        String protocol = baseUrl.getProtocol();\n+        result.setNonSecurePort(port);\n+        result.setSecurePort(port);\n+\n+        switch (protocol) {\n+            case \"http\":\n+                result.setNonSecurePortEnabled(true);\n+                result.setHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            case \"https\":\n+                result.setSecurePortEnabled(true);\n+                result.setSecureHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            default:\n+                throw new ServiceDefinitionException(String.format(\"'%s' is not valid protocol for baseUrl property\", protocol));\n+        }\n+\n+        try {\n+            result.setMetadataMap(createMetadata(config));\n+        } catch (MetadataValidationException | IllegalArgumentException e) {\n+            throw new ServiceDefinitionException(\"Service configuration failed to create service metadata: \", e);\n+        }\n+\n+        return result;\n+    }\n+\n+    private Map<String, String> createMetadata(ApiMediationServiceConfig config) {\n+        Map<String, String> metadata = new HashMap<>();\n+\n+        // fill authentication metadata\n+        Authentication authentication = config.getAuthentication();\n+        if (authentication != null) {\n+            metadata.put(AUTHENTICATION_SCHEME, authentication.getScheme());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzczOA=="}, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTQ5NDc0OnYy", "diffSide": "RIGHT", "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDoxNzozMVrOFq8r9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwNjo1OToxNFrOFrc6Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3ODgwNg==", "bodyText": "What about write it like class library (not as \"helper\")?\npublic final class MapUtils {\nprivate MapUtils() {}\npublic static final Map<String, String> flattenMap....\n}", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380578806", "createdAt": "2020-02-18T10:17:31Z", "author": {"login": "pj892031"}, "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NjI3NA==", "bodyText": "I intended to preserve the class so it can be mocked and it's methods can be mocked or spied on to help with testing.", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380596274", "createdAt": "2020-02-18T10:49:35Z", "author": {"login": "jandadav"}, "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3ODgwNg=="}, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjc1OQ==", "bodyText": "check out the latest impl, I've modified the code to do this", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106759", "createdAt": "2020-02-19T06:59:14Z", "author": {"login": "jandadav"}, "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3ODgwNg=="}, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NTUwMDM2OnYy", "diffSide": "LEFT", "path": "config/local/discoverable-client.yml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDoxOTowMFrOFq8vSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxMDo0ODoxM1rOFq9tYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3OTY1Ng==", "bodyText": "Why use serviceId under service? Just id is not enought?", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380579656", "createdAt": "2020-02-18T10:19:00Z", "author": {"login": "pj892031"}, "path": "config/local/discoverable-client.yml", "diffHunk": "@@ -5,18 +5,14 @@ spring:\n         ansi:\n             enabled: always\n \n+# The `apiml` node contains API Mediation Layer specific configuration\n apiml:\n-    security:\n-        ssl:\n-            ciphers: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\n-    # The `apiml` node contains API Mediation Layer specific configuration\n     service:\n         # The `apiml.service` node contains information required by any APIML service\n-        id: discoverableclient  # Service ID of this service", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NTU1NQ==", "bodyText": "The config is deserialized into ApiMediationServiceConfig class. It has serviceId attribute, not id. There is no need to have serviceId: ${apiml.service.id} in internal file (which matters for config) and then apiml.service.id=.... in externalized. It is just confusing", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380595555", "createdAt": "2020-02-18T10:48:13Z", "author": {"login": "jandadav"}, "path": "config/local/discoverable-client.yml", "diffHunk": "@@ -5,18 +5,14 @@ spring:\n         ansi:\n             enabled: always\n \n+# The `apiml` node contains API Mediation Layer specific configuration\n apiml:\n-    security:\n-        ssl:\n-            ciphers: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\n-    # The `apiml` node contains API Mediation Layer specific configuration\n     service:\n         # The `apiml.service` node contains information required by any APIML service\n-        id: discoverableclient  # Service ID of this service", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3OTY1Ng=="}, "originalCommit": {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 443, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}