{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MTgxMTAw", "number": 3251, "title": "STORM-3623 executors should only report their metrics for V2 metric tick", "bodyText": "Saving a mapping of registered metrics to taskId and using this to pass metrics back to an Executor.", "createdAt": "2020-04-17T14:55:17Z", "url": "https://github.com/apache/storm/pull/3251", "merged": true, "mergeCommit": {"oid": "38d714bf37ecd69dc2d2a16e8f6f6317dfe4f846"}, "closed": true, "closedAt": "2020-04-28T18:47:06Z", "author": {"login": "agresch"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZpjY2gFqTM5NjkzMDAzOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcb2ZGyABqjMyNzc3MzEzOTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTMwMDM4", "url": "https://github.com/apache/storm/pull/3251#pullrequestreview-396930038", "createdAt": "2020-04-21T01:38:57Z", "commit": {"oid": "2de00549174c6fd206277e1f38fd71d8de481144"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTozODo1N1rOGIuoIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTozODo1N1rOGIuoIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNTcyOA==", "bodyText": "This is way cleaner.", "url": "https://github.com/apache/storm/pull/3251#discussion_r411805728", "createdAt": "2020-04-21T01:38:57Z", "author": {"login": "kishorvpatil"}, "path": "storm-client/src/jvm/org/apache/storm/executor/Executor.java", "diffHunk": "@@ -339,47 +342,106 @@ private void addV2Metrics(List<IMetricsConsumer.DataPoint> dataPoints) {\n             return;\n         }\n         StormMetricRegistry stormMetricRegistry = workerData.getMetricRegistry();\n-        for (Map.Entry<String, Gauge> entry : stormMetricRegistry.registry().getGauges().entrySet()) {\n-            String name = entry.getKey();\n-            Object v = entry.getValue().getValue();\n-            if (v instanceof Number) {\n-                IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(name, v);\n-                dataPoints.add(dataPoint);\n-            } else {\n-                LOG.warn(\"Cannot report {}, its value is not a Number {}\", name, v);\n+        Map<String, Metric> metrics = stormMetricRegistry.getExecutorMetrics(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de00549174c6fd206277e1f38fd71d8de481144"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTMxOTQ1", "url": "https://github.com/apache/storm/pull/3251#pullrequestreview-396931945", "createdAt": "2020-04-21T01:45:29Z", "commit": {"oid": "2de00549174c6fd206277e1f38fd71d8de481144"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTo0NTozMFrOGIuwtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMTo0NTozMFrOGIuwtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNzkyNQ==", "bodyText": "should StormMetricRegistry expose getGauges(), getCounters(), getMeters(), getHistograms and getTimers. i.e similar to com.codahale.metrics.MetricRegistry\nI would actually recommend, StormMetricRegistry extending com.codahale.metrics.MetricRegistry", "url": "https://github.com/apache/storm/pull/3251#discussion_r411807925", "createdAt": "2020-04-21T01:45:30Z", "author": {"login": "kishorvpatil"}, "path": "storm-client/src/jvm/org/apache/storm/executor/Executor.java", "diffHunk": "@@ -339,47 +342,106 @@ private void addV2Metrics(List<IMetricsConsumer.DataPoint> dataPoints) {\n             return;\n         }\n         StormMetricRegistry stormMetricRegistry = workerData.getMetricRegistry();\n-        for (Map.Entry<String, Gauge> entry : stormMetricRegistry.registry().getGauges().entrySet()) {\n-            String name = entry.getKey();\n-            Object v = entry.getValue().getValue();\n-            if (v instanceof Number) {\n-                IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(name, v);\n-                dataPoints.add(dataPoint);\n-            } else {\n-                LOG.warn(\"Cannot report {}, its value is not a Number {}\", name, v);\n+        Map<String, Metric> metrics = stormMetricRegistry.getExecutorMetrics(this);\n+        processGauges(metrics, dataPoints);\n+        processCounters(metrics, dataPoints);\n+        processHistograms(metrics, dataPoints);\n+        processMeters(metrics, dataPoints);\n+        processTimers(metrics, dataPoints);\n+\n+        // at this point, we should have no metrics left to process\n+        if (!metrics.isEmpty()) {\n+            for (Map.Entry<String, Metric> entry : metrics.entrySet()) {\n+                LOG.warn(\"Unable to process metric {} {}\", entry.getKey(), entry.getValue());\n             }\n         }\n-        for (Map.Entry<String, Counter> entry : stormMetricRegistry.registry().getCounters().entrySet()) {\n-            Object value = entry.getValue().getCount();\n-            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey(), value);\n-            dataPoints.add(dataPoint);\n+    }\n+\n+    private void processGauges(Map<String, Metric> metrics, List<IMetricsConsumer.DataPoint> dataPoints) {\n+        Set<String> processedMetrics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de00549174c6fd206277e1f38fd71d8de481144"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MTE1MDgx", "url": "https://github.com/apache/storm/pull/3251#pullrequestreview-399115081", "createdAt": "2020-04-23T13:50:33Z", "commit": {"oid": "d52872844735bac3d14b5aada74ffbbdc042bf24"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo1MDozNFrOGKpDFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo1MDozNFrOGKpDFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxMTQ3Nw==", "bodyText": "instead of going through every metric and check if it's a gauge, I think we probably just need separate maps for different metric types.", "url": "https://github.com/apache/storm/pull/3251#discussion_r413811477", "createdAt": "2020-04-23T13:50:34Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/metrics2/StormMetricRegistry.java", "diffHunk": "@@ -35,38 +45,154 @@\n     \n     private final MetricRegistry registry = new MetricRegistry();\n     private final List<StormReporter> reporters = new ArrayList<>();\n+    private final ConcurrentMap<Integer, Map<String, Metric>> taskIdMetrics = new ConcurrentHashMap<>();\n     private String hostName = null;\n \n     public <T> SimpleGauge<T> gauge(\n         T initialValue, String name, String topologyId, String componentId, Integer taskId, Integer port) {\n         String metricName = metricName(name, topologyId, componentId, taskId, port);\n-        return (SimpleGauge<T>) registry.gauge(metricName, () -> new SimpleGauge<>(initialValue));\n+        SimpleGauge<T> gauge = (SimpleGauge<T>) registry.gauge(metricName, () -> new SimpleGauge<>(initialValue));\n+        saveMetricTaskIdMapping(taskId, metricName, gauge);\n+        return gauge;\n+    }\n+\n+    public <T> Gauge<T> gauge(String name, Gauge<T> gauge, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        gauge = registry.register(metricName, gauge);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, gauge);\n+        return gauge;\n     }\n \n     public JcMetrics jcMetrics(String name, String topologyId, String componentId, Integer taskId, Integer port) {\n-        return new JcMetrics(\n-            gauge(0L, name + \"-capacity\", topologyId, componentId, taskId, port),\n-            gauge(0L, name + \"-population\", topologyId, componentId, taskId, port)\n-        );\n+        SimpleGauge<Long> capacityGauge = gauge(0L, name + \"-capacity\", topologyId, componentId, taskId, port);\n+        SimpleGauge<Long> populationGauge = gauge(0L, name + \"-population\", topologyId, componentId, taskId, port);\n+        return new JcMetrics(capacityGauge, populationGauge);\n     }\n \n     public Meter meter(String name, WorkerTopologyContext context, String componentId, Integer taskId, String streamId) {\n         String metricName = metricName(name, context.getStormId(), componentId, streamId, taskId, context.getThisWorkerPort());\n-        return registry.meter(metricName);\n+        Meter meter = registry.meter(metricName);\n+        saveMetricTaskIdMapping(taskId, metricName, meter);\n+        return meter;\n+    }\n+\n+    public Meter meter(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Meter meter = registry.meter(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, meter);\n+        return meter;\n     }\n \n     public Counter counter(String name, WorkerTopologyContext context, String componentId, Integer taskId, String streamId) {\n         String metricName = metricName(name, context.getStormId(), componentId, streamId, taskId, context.getThisWorkerPort());\n-        return registry.counter(metricName);\n+        Counter counter = registry.counter(metricName);\n+        saveMetricTaskIdMapping(taskId, metricName, counter);\n+        return counter;\n     }\n \n     public Counter counter(String name, String topologyId, String componentId, Integer taskId, Integer workerPort, String streamId) {\n         String metricName = metricName(name, topologyId, componentId, streamId, taskId, workerPort);\n-        return registry.counter(metricName);\n+        Counter counter = registry.counter(metricName);\n+        saveMetricTaskIdMapping(taskId, metricName, counter);\n+        return counter;\n     }\n-    \n-    public MetricRegistry registry() {\n-        return registry;\n+\n+    public Counter counter(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Counter counter = registry.counter(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, counter);\n+        return counter;\n+    }\n+\n+    public void metricSet(String prefix, MetricSet set, TopologyContext context) {\n+        String baseName = metricName(prefix, context);\n+        // Instead of registering the metrics as a set, register them individually.\n+        // This allows fetching the individual metrics by type (getTaskGauges())\n+        // to work as expected.\n+        for (Map.Entry<String, Metric> entry : set.getMetrics().entrySet()) {\n+            String metricName = baseName + \".\" + entry.getKey();\n+            Metric metric = registry.register(metricName, entry.getValue());\n+            saveMetricTaskIdMapping(context.getThisTaskId(), metricName, metric);\n+        }\n+    }\n+\n+    public Timer timer(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Timer timer = registry.timer(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, timer);\n+        return timer;\n+    }\n+\n+    public Histogram histogram(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Histogram histogram = registry.histogram(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, histogram);\n+        return histogram;\n+    }\n+\n+    private void saveMetricTaskIdMapping(Integer taskId, String name, Metric metric) {\n+        Map<String, Metric> metrics = taskIdMetrics.computeIfAbsent(taskId, (tid) -> new HashMap<>());\n+        metrics.put(name, metric);\n+    }\n+\n+    public Map<String, Gauge> getTaskGauges(int taskId) {\n+        Map<String, Gauge> taskGaugeMap = new HashMap<>();\n+        Collection<Gauge> gauges = registry.getGauges().values();\n+        Map<String, Metric> taskMetrics = taskIdMetrics.getOrDefault(taskId, Collections.emptyMap());\n+        for (Map.Entry<String, Metric> entry : taskMetrics.entrySet()) {\n+            if (gauges.contains(entry.getValue())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52872844735bac3d14b5aada74ffbbdc042bf24"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzExODI4", "url": "https://github.com/apache/storm/pull/3251#pullrequestreview-401311828", "createdAt": "2020-04-27T20:44:48Z", "commit": {"oid": "09a237afced08702a43e99038c89f3a2070a561d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "committedDate": "2020-04-27T21:43:41Z", "message": "STORM-3623 executors should only report their metrics for V2 metric tick"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09a237afced08702a43e99038c89f3a2070a561d", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/09a237afced08702a43e99038c89f3a2070a561d", "committedDate": "2020-04-27T20:32:29Z", "message": "STORM-3623 save individual metric task mappings"}, "afterCommit": {"oid": "6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "committedDate": "2020-04-27T21:43:41Z", "message": "STORM-3623 executors should only report their metrics for V2 metric tick"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4558, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}