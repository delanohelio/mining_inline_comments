{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NDk0MTQ2", "number": 3213, "reviewThreads": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOToyNzoxMVrODjNU-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMToxODoxOVrODxZGfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjQ1MTE0OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOToyNzoxMVrOFu4_WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1OTozMlrOGCqBtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMjUzNg==", "bodyText": "better to add VisibleForTesting and comments to make it clear that this is only used by unit test", "url": "https://github.com/apache/storm/pull/3213#discussion_r384712536", "createdAt": "2020-02-26T19:27:11Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -239,6 +246,10 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n         markFailedTopology(topologySubmitter, cluster, td, \"Failed to schedule within \" + maxSchedulingAttempts + \" attempts\");\n     }\n \n+    public Set<String> getEvictedTopologies() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIzMDE0OQ==", "bodyText": "I am seeing a possible race condition here. Since the evictedTopologies will be kept updated during scheduling, any function call to getEvictedTopologies doesn't guarantee to return a useful result.  This evictedTopologies includes every topology that is evicted during the scheduling process until the point when getEvictedTopologies is called.  It doesn't seem useful.\nTo know what topologies are being evicted, we already have\nLOG.debug(\"Evicting Topology {} with workers: {} from user {}\", topologyEvict.getName(), workersToEvict,\n                                    topologyEvict.getTopologySubmitter());\n\ncode in place. We can change it to warn if we want it to show up in the regular logs.\n@kishorvpatil  what do you think?", "url": "https://github.com/apache/storm/pull/3213#discussion_r405230149", "createdAt": "2020-04-08T02:58:34Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -239,6 +246,10 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n         markFailedTopology(topologySubmitter, cluster, td, \"Failed to schedule within \" + maxSchedulingAttempts + \" attempts\");\n     }\n \n+    public Set<String> getEvictedTopologies() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMjUzNg=="}, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI0NzM5Mw==", "bodyText": "In that case this method should return a copy \"return new HashSet<>(this.evictedTopologies);\"", "url": "https://github.com/apache/storm/pull/3213#discussion_r405247393", "createdAt": "2020-04-08T04:11:47Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -239,6 +246,10 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n         markFailedTopology(topologySubmitter, cluster, td, \"Failed to schedule within \" + maxSchedulingAttempts + \" attempts\");\n     }\n \n+    public Set<String> getEvictedTopologies() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMjUzNg=="}, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1NTIxOQ==", "bodyText": "Yes that's right. We should return a unmodifiableCollection to solve the race condition. I think my question is mostly on how do we want to use this evictedTopologies information in regular code except unit test since it's only a snapshot of all the evictedTopologies  at the moment we call getEvictedTopologies.  And it could be evictedTopologies after scheduling multiple topologies. And this information is not very useful.\nIf we want to log what are evicted when scheduling a certain topology, we can change the above line to LOG.info and it works better than having a evictedTopologies list.", "url": "https://github.com/apache/storm/pull/3213#discussion_r405255219", "createdAt": "2020-04-08T04:45:08Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -239,6 +246,10 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n         markFailedTopology(topologySubmitter, cluster, td, \"Failed to schedule within \" + maxSchedulingAttempts + \" attempts\");\n     }\n \n+    public Set<String> getEvictedTopologies() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMjUzNg=="}, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzODkwMw==", "bodyText": "As a member of SchedulingResult this information can be more useful.\nBut looks like the intent is to keep track of topologies evicted as part of each topo scheduled, in which case we need a map i.e. topoId -> toposEvicted", "url": "https://github.com/apache/storm/pull/3213#discussion_r405438903", "createdAt": "2020-04-08T10:59:32Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -239,6 +246,10 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n         markFailedTopology(topologySubmitter, cluster, td, \"Failed to schedule within \" + maxSchedulingAttempts + \" attempts\");\n     }\n \n+    public Set<String> getEvictedTopologies() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMjUzNg=="}, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjg2OTYyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/TestUtilsForResourceAwareScheduler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToyODoxMVrOFu86Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMToyODoxMVrOFu86Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Njc5NA==", "bodyText": "We could pass Set<String> evictedTopologies instead of a scheduler since that's the only thing we really need from the scheduler", "url": "https://github.com/apache/storm/pull/3213#discussion_r384776794", "createdAt": "2020-02-26T21:28:11Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/TestUtilsForResourceAwareScheduler.java", "diffHunk": "@@ -451,6 +460,32 @@ public static void assertTopologiesFullyScheduled(Cluster cluster, String... top\n         }\n     }\n \n+    public static void assertTopologiesBeenEvicted(Cluster cluster, ResourceAwareScheduler scheduler, String... topoNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjg5MzM3OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTozNTozN1rOFu9JNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTozNTozN1rOFu9JNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MDU5OQ==", "bodyText": "This should be TestGenericResourceAwareSchedulingPriorityStrategy", "url": "https://github.com/apache/storm/pull/3213#discussion_r384780599", "createdAt": "2020-02-26T21:35:37Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.scheduler.resource.strategies.eviction.TestDefaultEvictionStrategy;\n+import org.apache.storm.utils.Time;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.addTopologies;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.createGrasClusterConfig;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genSupervisors;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genTopology;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userRes;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userResourcePool;\n+\n+public class TestGenericResourceAwareSchedulingPriorityStrategy {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TestDefaultEvictionStrategy.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjg5NTgwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTozNjoxOFrOFu9Kxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTozNjoxOFrOFu9Kxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MDk5OQ==", "bodyText": "heave -> heavy", "url": "https://github.com/apache/storm/pull/3213#discussion_r384780999", "createdAt": "2020-02-26T21:36:18Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.scheduler.resource.strategies.eviction.TestDefaultEvictionStrategy;\n+import org.apache.storm.utils.Time;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.addTopologies;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.createGrasClusterConfig;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genSupervisors;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genTopology;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userRes;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userResourcePool;\n+\n+public class TestGenericResourceAwareSchedulingPriorityStrategy {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TestDefaultEvictionStrategy.class);\n+    private static int currentTime = Time.currentTimeSecs();\n+    private static IScheduler scheduler = null;\n+\n+    @After\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /*\n+     * DefaultSchedulingPriorityStrategy will not evict topo as long as the resources request can be met\n+     *\n+     *  Ethan asks for heavy cpu and memory while Rui asks for little cpu and memory but heave generic resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjg5NjgyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTozNjozNlrOFu9LYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTozNjozNlrOFu9LYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MTE1Mw==", "bodyText": "happend -> 'happen`", "url": "https://github.com/apache/storm/pull/3213#discussion_r384781153", "createdAt": "2020-02-26T21:36:36Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.scheduler.resource.strategies.eviction.TestDefaultEvictionStrategy;\n+import org.apache.storm.utils.Time;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.addTopologies;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.createGrasClusterConfig;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genSupervisors;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genTopology;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userRes;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userResourcePool;\n+\n+public class TestGenericResourceAwareSchedulingPriorityStrategy {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TestDefaultEvictionStrategy.class);\n+    private static int currentTime = Time.currentTimeSecs();\n+    private static IScheduler scheduler = null;\n+\n+    @After\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /*\n+     * DefaultSchedulingPriorityStrategy will not evict topo as long as the resources request can be met\n+     *\n+     *  Ethan asks for heavy cpu and memory while Rui asks for little cpu and memory but heave generic resource\n+     *  Since Rui's all types of resources request can be met, no eviction will happend", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjkxNTE2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0Mjo0NFrOFu9W6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0Mjo0NFrOFu9W6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NDEwNg==", "bodyText": "heave -> heavy", "url": "https://github.com/apache/storm/pull/3213#discussion_r384784106", "createdAt": "2020-02-26T21:42:44Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.scheduler.resource.strategies.eviction.TestDefaultEvictionStrategy;\n+import org.apache.storm.utils.Time;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.addTopologies;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.createGrasClusterConfig;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genSupervisors;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genTopology;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userRes;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userResourcePool;\n+\n+public class TestGenericResourceAwareSchedulingPriorityStrategy {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TestDefaultEvictionStrategy.class);\n+    private static int currentTime = Time.currentTimeSecs();\n+    private static IScheduler scheduler = null;\n+\n+    @After\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /*\n+     * DefaultSchedulingPriorityStrategy will not evict topo as long as the resources request can be met\n+     *\n+     *  Ethan asks for heavy cpu and memory while Rui asks for little cpu and memory but heave generic resource\n+     *  Since Rui's all types of resources request can be met, no eviction will happend\n+    */\n+    @Test\n+    public void testDefaultSchedulingPriorityStrategyNotEvicting() {\n+        Map<String, Double> requestedgenericResourcesMap = new HashMap<>();\n+        requestedgenericResourcesMap.put(\"generic.resource.1\", 40.0);\n+        // Use full memory and cpu of the cluster capacity\n+        Config ruiConf = createGrasClusterConfig(20, 50, 50, null, requestedgenericResourcesMap);\n+        Config ethanConf = createGrasClusterConfig(80, 400, 500, null, Collections.emptyMap());\n+        Topologies topologies = new Topologies(\n+            genTopology(\"ethan-topo-1\", ethanConf, 1, 0, 1, 0, currentTime - 2, 10, \"ethan\"),\n+            genTopology(\"ethan-topo-2\", ethanConf, 1, 0, 1, 0, currentTime - 2, 20, \"ethan\"),\n+            genTopology(\"ethan-topo-3\", ethanConf, 1, 0, 1, 0, currentTime - 2, 28, \"ethan\"),\n+            genTopology(\"ethan-topo-4\", ethanConf, 1, 0, 1, 0, currentTime - 2, 29, \"ethan\"));\n+\n+        Topologies withNewTopo = addTopologies(topologies,\n+            genTopology(\"rui-topo-1\", ruiConf, 1, 0, 4, 0, currentTime - 2, 10, \"rui\"));\n+\n+        Config config = mkClusterConfig(DefaultSchedulingPriorityStrategy.class.getName());\n+        Cluster cluster = mkTestCluster(topologies, config);\n+        scheduler = new ResourceAwareScheduler();\n+        scheduler.prepare(config);\n+        scheduler.schedule(topologies, cluster);\n+\n+        assertTopologiesFullyScheduled(cluster, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+\n+\n+        cluster = new Cluster(cluster, withNewTopo);\n+        scheduler.schedule(withNewTopo, cluster);\n+\n+        assertTopologiesFullyScheduled(cluster, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+        assertTopologiesNotBeenEvicted(cluster, (ResourceAwareScheduler) scheduler, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+        assertTopologiesFullyScheduled(cluster, \"rui-topo-1\");\n+    }\n+\n+    /*\n+     * DefaultSchedulingPriorityStrategy does not take generic resources into account when calculating score\n+     * So even if a user is requesting a lot of generic resources other than CPU and memory, scheduler will still score it very low and kick out other topologies\n+     *\n+     *  Ethan asks for medium cpu and memory while Rui asks for little cpu and memory but heave generic resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjkyNTM1OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0NTo0MlrOFu9dCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo0NTo0MlrOFu9dCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NTY3Mw==", "bodyText": "For as the above test , maybe it's better to refer to the test case directly. If anyone moves the order of these unit tests, this comment can be confusing", "url": "https://github.com/apache/storm/pull/3213#discussion_r384785673", "createdAt": "2020-02-26T21:45:42Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import org.apache.storm.Config;\n+import org.apache.storm.DaemonConfig;\n+import org.apache.storm.metric.StormMetricsRegistry;\n+import org.apache.storm.scheduler.Cluster;\n+import org.apache.storm.scheduler.INimbus;\n+import org.apache.storm.scheduler.IScheduler;\n+import org.apache.storm.scheduler.SupervisorDetails;\n+import org.apache.storm.scheduler.Topologies;\n+import org.apache.storm.scheduler.resource.ResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler;\n+import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n+import org.apache.storm.scheduler.resource.strategies.eviction.TestDefaultEvictionStrategy;\n+import org.apache.storm.utils.Time;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.addTopologies;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesFullyScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotBeenEvicted;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.assertTopologiesNotScheduled;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.createGrasClusterConfig;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genSupervisors;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.genTopology;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userRes;\n+import static org.apache.storm.scheduler.resource.TestUtilsForResourceAwareScheduler.userResourcePool;\n+\n+public class TestGenericResourceAwareSchedulingPriorityStrategy {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TestDefaultEvictionStrategy.class);\n+    private static int currentTime = Time.currentTimeSecs();\n+    private static IScheduler scheduler = null;\n+\n+    @After\n+    public void cleanup() {\n+        if (scheduler != null) {\n+            scheduler.cleanup();\n+            scheduler = null;\n+        }\n+    }\n+\n+    /*\n+     * DefaultSchedulingPriorityStrategy will not evict topo as long as the resources request can be met\n+     *\n+     *  Ethan asks for heavy cpu and memory while Rui asks for little cpu and memory but heave generic resource\n+     *  Since Rui's all types of resources request can be met, no eviction will happend\n+    */\n+    @Test\n+    public void testDefaultSchedulingPriorityStrategyNotEvicting() {\n+        Map<String, Double> requestedgenericResourcesMap = new HashMap<>();\n+        requestedgenericResourcesMap.put(\"generic.resource.1\", 40.0);\n+        // Use full memory and cpu of the cluster capacity\n+        Config ruiConf = createGrasClusterConfig(20, 50, 50, null, requestedgenericResourcesMap);\n+        Config ethanConf = createGrasClusterConfig(80, 400, 500, null, Collections.emptyMap());\n+        Topologies topologies = new Topologies(\n+            genTopology(\"ethan-topo-1\", ethanConf, 1, 0, 1, 0, currentTime - 2, 10, \"ethan\"),\n+            genTopology(\"ethan-topo-2\", ethanConf, 1, 0, 1, 0, currentTime - 2, 20, \"ethan\"),\n+            genTopology(\"ethan-topo-3\", ethanConf, 1, 0, 1, 0, currentTime - 2, 28, \"ethan\"),\n+            genTopology(\"ethan-topo-4\", ethanConf, 1, 0, 1, 0, currentTime - 2, 29, \"ethan\"));\n+\n+        Topologies withNewTopo = addTopologies(topologies,\n+            genTopology(\"rui-topo-1\", ruiConf, 1, 0, 4, 0, currentTime - 2, 10, \"rui\"));\n+\n+        Config config = mkClusterConfig(DefaultSchedulingPriorityStrategy.class.getName());\n+        Cluster cluster = mkTestCluster(topologies, config);\n+        scheduler = new ResourceAwareScheduler();\n+        scheduler.prepare(config);\n+        scheduler.schedule(topologies, cluster);\n+\n+        assertTopologiesFullyScheduled(cluster, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+\n+\n+        cluster = new Cluster(cluster, withNewTopo);\n+        scheduler.schedule(withNewTopo, cluster);\n+\n+        assertTopologiesFullyScheduled(cluster, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+        assertTopologiesNotBeenEvicted(cluster, (ResourceAwareScheduler) scheduler, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+        assertTopologiesFullyScheduled(cluster, \"rui-topo-1\");\n+    }\n+\n+    /*\n+     * DefaultSchedulingPriorityStrategy does not take generic resources into account when calculating score\n+     * So even if a user is requesting a lot of generic resources other than CPU and memory, scheduler will still score it very low and kick out other topologies\n+     *\n+     *  Ethan asks for medium cpu and memory while Rui asks for little cpu and memory but heave generic resource\n+     *  However, Rui's generic request can not be met and default scoring system is not taking generic resources into account,\n+     *  so the score of Rui's new topo will be much lower than all Ethan's topos'.\n+     *  Then all Ethan's topo will be evicted in trying to make rooms for Rui.\n+     */\n+    @Test\n+    public void testDefaultSchedulingPriorityStrategyEvicting() {\n+        Map<String, Double> requestedgenericResourcesMap = new HashMap<>();\n+        requestedgenericResourcesMap.put(\"generic.resource.1\", 40.0);\n+        Config ruiConf = createGrasClusterConfig(10, 10, 10, null, requestedgenericResourcesMap);\n+        Config ethanConf = createGrasClusterConfig(60, 200, 300, null, Collections.emptyMap());\n+        Topologies topologies = new Topologies(\n+            genTopology(\"ethan-topo-1\", ethanConf, 1, 0, 1, 0, currentTime - 2, 10, \"ethan\"),\n+            genTopology(\"ethan-topo-2\", ethanConf, 1, 0, 1, 0, currentTime - 2, 20, \"ethan\"),\n+            genTopology(\"ethan-topo-3\", ethanConf, 1, 0, 1, 0, currentTime - 2, 28, \"ethan\"),\n+            genTopology(\"ethan-topo-4\", ethanConf, 1, 0, 1, 0, currentTime - 2, 29, \"ethan\"));\n+\n+        Topologies withNewTopo = addTopologies(topologies,\n+            genTopology(\"rui-topo-1\", ruiConf, 1, 0, 5, 0, currentTime - 2, 10, \"rui\"));\n+\n+        Config config = mkClusterConfig(DefaultSchedulingPriorityStrategy.class.getName());\n+        Cluster cluster = mkTestCluster(topologies, config);\n+        scheduler = new ResourceAwareScheduler();\n+        scheduler.prepare(config);\n+        scheduler.schedule(topologies, cluster);\n+\n+        assertTopologiesFullyScheduled(cluster, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+\n+\n+        cluster = new Cluster(cluster, withNewTopo);\n+        scheduler.schedule(withNewTopo, cluster);\n+\n+        assertTopologiesFullyScheduled(cluster, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+        assertTopologiesBeenEvicted(cluster, (ResourceAwareScheduler) scheduler, \"ethan-topo-1\", \"ethan-topo-2\", \"ethan-topo-3\", \"ethan-topo-4\");\n+        assertTopologiesNotScheduled(cluster, \"rui-topo-1\");\n+    }\n+\n+    /*\n+     * GenericResourceAwareSchedulingPriorityStrategy extend scoring formula to accommodate generic resources\n+     *\n+     *   Same setting as the above test, but this time, new scoring system is taking generic resources into account,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjk2NDYwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo1NzoxNlrOFu90tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo1NzoxNlrOFu90tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MTczNA==", "bodyText": "nit: too many new lines", "url": "https://github.com/apache/storm/pull/3213#discussion_r384791734", "createdAt": "2020-02-26T21:57:16Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResource();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjk2ODM4OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo1ODoyNFrOFu93Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMTo1ODoyNFrOFu93Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MjMzOA==", "bodyText": "should be GenericResourceAwareSchedulingPriorityStrategy", "url": "https://github.com/apache/storm/pull/3213#discussion_r384792338", "createdAt": "2020-02-26T21:58:24Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultSchedulingPriorityStrategy.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjk3NDg4OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/DefaultSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjowMDozMFrOFu97Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjowMDozMFrOFu97Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MzM4Mg==", "bodyText": "This can be private since it's not used elsewhere ?", "url": "https://github.com/apache/storm/pull/3213#discussion_r384793382", "createdAt": "2020-02-26T22:00:30Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/DefaultSchedulingPriorityStrategy.java", "diffHunk": "@@ -140,7 +140,7 @@ public int compare(SimulatedUser o1, SimulatedUser o2) {\n      * Comparator that sorts topologies by priority and then by submission time.\n      * First sort by Topology Priority, if there is a tie for topology priority, topology uptime is used to sort.\n      */\n-    private static class TopologyByPriorityAndSubmissionTimeComparator implements Comparator<TopologyDetails> {\n+    protected static class TopologyByPriorityAndSubmissionTimeComparator implements Comparator<TopologyDetails> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mjk5OTM2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjowOTowMFrOFu-Ktw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjowOTowMFrOFu-Ktw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5NzM2Nw==", "bodyText": "We could reply on super.simScheduleNextHighest(); so everything in GrasSimulatedUser is gras specific, like what you did elsewhere", "url": "https://github.com/apache/storm/pull/3213#discussion_r384797367", "createdAt": "2020-02-26T22:09:00Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResource();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            Map<String, Double> availGenericResources = cluster.getClusterTotalGenericResource();   // generic resources that are offered\n+            for (Map.Entry<String, Double> entry : availGenericResources.entrySet()) {\n+                String resource = entry.getKey();\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resource, 0.0);\n+                guaranteedGenericResources.put(resource, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = tds.pop();\n+            assignedCpu += td.getTotalRequestedCpu();\n+            assignedMemory += td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzAxOTUwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoxNTozMVrOFu-WzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoxNTozMVrOFu-WzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMDQ2MA==", "bodyText": "Nice javadoc!\nnit: Available -> clusterAvailable", "url": "https://github.com/apache/storm/pull/3213#discussion_r384800460", "createdAt": "2020-02-26T22:15:31Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResource();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            Map<String, Double> availGenericResources = cluster.getClusterTotalGenericResource();   // generic resources that are offered\n+            for (Map.Entry<String, Double> entry : availGenericResources.entrySet()) {\n+                String resource = entry.getKey();\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resource, 0.0);\n+                guaranteedGenericResources.put(resource, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = tds.pop();\n+            assignedCpu += td.getTotalRequestedCpu();\n+            assignedMemory += td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }\n+            return td;\n+        }\n+\n+        /**\n+         * Get a score for the simulated user.  This is used to sort the users, by their highest priority topology.\n+         * Only give user guarantees that will not exceed cluster capacity.\n+         * Score of each resource type is calculated as: (Requested + Assigned - Guaranteed)/Available", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzAzOTA4OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/TestUtilsForResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMjoyMjowMFrOFu-ifQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDo0MTo0MFrOFvUp0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMzQ1Mw==", "bodyText": "This reminds me that we don't have a unit test to test the case where users have the generic resource guarantee. But this can be a follow up work", "url": "https://github.com/apache/storm/pull/3213#discussion_r384803453", "createdAt": "2020-02-26T22:22:00Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/TestUtilsForResourceAwareScheduler.java", "diffHunk": "@@ -83,6 +88,10 @@ public void addSelfTo(Map<String, Map<String, Number>> fullPool) {\n         }\n     }\n \n+    public static TestUserResources userRes(String name, Map<String, Double> resources) {\n+        return new TestUserResources(name, resources);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkwMDM3MQ==", "bodyText": "Addressed all comments, thanks for the prompt review. As for this, yes we should have some tests on User class. Currently we only have a testResourcePoolUtilization. When I was coding I also extended the usage of pool utilization related functions to include generic resources as well. But after I realized that there is nowhere we are using it. I will filed another PR for removing them.", "url": "https://github.com/apache/storm/pull/3213#discussion_r384900371", "createdAt": "2020-02-27T03:52:04Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/TestUtilsForResourceAwareScheduler.java", "diffHunk": "@@ -83,6 +88,10 @@ public void addSelfTo(Map<String, Map<String, Number>> fullPool) {\n         }\n     }\n \n+    public static TestUserResources userRes(String name, Map<String, Double> resources) {\n+        return new TestUserResources(name, resources);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMzQ1Mw=="}, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2NTc3OQ==", "bodyText": "Right. But what I meant is unit tests for GenericResourceAwareSchedulingPriorityStrategy when users do have the generic resource guarantee", "url": "https://github.com/apache/storm/pull/3213#discussion_r385165779", "createdAt": "2020-02-27T14:41:40Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/TestUtilsForResourceAwareScheduler.java", "diffHunk": "@@ -83,6 +88,10 @@ public void addSelfTo(Map<String, Map<String, Number>> fullPool) {\n         }\n     }\n \n+    public static TestUserResources userRes(String name, Map<String, Double> resources) {\n+        return new TestUserResources(name, resources);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMzQ1Mw=="}, "originalCommit": {"oid": "008f2e6d54cdd0501723de82a3281b031e2846de"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTM4NzUwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNDo1Mzo0MlrOFvUr_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTo0NzoxMlrOFwAyDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2NjMzMw==", "bodyText": "One last thing, we can have a boolean like forTests, which by default to false and we can set it to true from unit tests. This is to avoid unnecessary computation/operations. And make it clear that this is only for tests.\nAs for getEvictedTopologies, we can throw exceptions if forTests is false.", "url": "https://github.com/apache/storm/pull/3213#discussion_r385166333", "createdAt": "2020-02-27T14:53:42Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -202,7 +210,7 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                             if (evictAssignemnt != null && !evictAssignemnt.getSlots().isEmpty()) {\n                                 Collection<WorkerSlot> workersToEvict = workingState.getUsedSlotsByTopologyId(topologyEvict.getId());\n                                 topologySchedulingResources.adjustResourcesForEvictedTopology(toSchedule, topologyEvict);\n-\n+                                evictedTopologies.add(topologyEvict.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09bc3b8e1a452a1b02b90aa876093b62e9d52133"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg4ODc4MQ==", "bodyText": "Addressed.", "url": "https://github.com/apache/storm/pull/3213#discussion_r385888781", "createdAt": "2020-02-28T19:47:12Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -202,7 +210,7 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                             if (evictAssignemnt != null && !evictAssignemnt.getSlots().isEmpty()) {\n                                 Collection<WorkerSlot> workersToEvict = workingState.getUsedSlotsByTopologyId(topologyEvict.getId());\n                                 topologySchedulingResources.adjustResourcesForEvictedTopology(toSchedule, topologyEvict);\n-\n+                                evictedTopologies.add(topologyEvict.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2NjMzMw=="}, "originalCommit": {"oid": "09bc3b8e1a452a1b02b90aa876093b62e9d52133"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTA5OTM0OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQxNzoxOTo1N1rOFwKIiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNDo1ODozOVrOFwilCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA0MTk5Mg==", "bodyText": "This can be UnsupportedOperationException", "url": "https://github.com/apache/storm/pull/3213#discussion_r386041992", "createdAt": "2020-02-29T17:19:57Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -248,8 +252,17 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n     }\n \n     @VisibleForTesting\n-    public Set<String> getEvictedTopologies() {\n-        return this.evictedTopologies;\n+    public Set<String> getEvictedTopologies() throws Exception {\n+        if (forTest) {\n+            return this.evictedTopologies;\n+        } else {\n+            throw new Exception(\"Topology eviction check is only provided for test purposes\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30bbfd313340475a16a9ba45951999a33b55f4e1"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0MjUwNA==", "bodyText": "Fixed. Thank you.", "url": "https://github.com/apache/storm/pull/3213#discussion_r386442504", "createdAt": "2020-03-02T14:58:39Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -248,8 +252,17 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n     }\n \n     @VisibleForTesting\n-    public Set<String> getEvictedTopologies() {\n-        return this.evictedTopologies;\n+    public Set<String> getEvictedTopologies() throws Exception {\n+        if (forTest) {\n+            return this.evictedTopologies;\n+        } else {\n+            throw new Exception(\"Topology eviction check is only provided for test purposes\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA0MTk5Mg=="}, "originalCommit": {"oid": "30bbfd313340475a16a9ba45951999a33b55f4e1"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mzk0NzkwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNToxNjoyOVrOFwjQqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTo0MzoyOFrOFwkVdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1MzY3NA==", "bodyText": "UnsupportedOperationException is a runtime exception. throws Exception is not needed in the signature. So is in the unit tests like testDefaultSchedulingPriorityStrategyNotEvicting", "url": "https://github.com/apache/storm/pull/3213#discussion_r386453674", "createdAt": "2020-03-02T15:16:29Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -256,7 +256,8 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n         if (forTest) {\n             return this.evictedTopologies;\n         } else {\n-            throw new Exception(\"Topology eviction check is only provided for test purposes\");\n+            throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0a06e74e824a81b4544c97dc7b85cdc7ed86c4c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3MTI4NQ==", "bodyText": "Thanks for catching.", "url": "https://github.com/apache/storm/pull/3213#discussion_r386471285", "createdAt": "2020-03-02T15:43:28Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -256,7 +256,8 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n         if (forTest) {\n             return this.evictedTopologies;\n         } else {\n-            throw new Exception(\"Topology eviction check is only provided for test purposes\");\n+            throw new UnsupportedOperationException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1MzY3NA=="}, "originalCommit": {"oid": "d0a06e74e824a81b4544c97dc7b85cdc7ed86c4c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTQ2NzM5OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoxODoxNlrOFxrBtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzoyMjo0NFrOFx2cqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyOTQ5Mw==", "bodyText": "A stream API could make it simpler to represent aggregation of maps:.\nreturn supervisors.values().stream().flatMap(m -> m.getTotalGenericResources().entrySet().stream()).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, Double::sum));", "url": "https://github.com/apache/storm/pull/3213#discussion_r387629493", "createdAt": "2020-03-04T12:18:16Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -889,6 +889,20 @@ public double getClusterTotalMemoryResource() {\n         return sum;\n     }\n \n+    @Override\n+    public Map<String, Double> getClusterTotalGenericResource() {\n+        Map<String, Double> ret = new HashMap<>();\n+        for (SupervisorDetails sup : supervisors.values()) {\n+            Map<String, Double> supGenericResources = sup.getTotalGenericResources();\n+            for (Map.Entry<String, Double> entry : supGenericResources.entrySet()) {\n+                String resourceName = entry.getKey();\n+                Double amount = entry.getValue();\n+                ret.put(resourceName, ret.getOrDefault(resourceName, 0.0) + amount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxNjYxOA==", "bodyText": "Very good suggestions. Thank you and addressed.", "url": "https://github.com/apache/storm/pull/3213#discussion_r387816618", "createdAt": "2020-03-04T17:22:44Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -889,6 +889,20 @@ public double getClusterTotalMemoryResource() {\n         return sum;\n     }\n \n+    @Override\n+    public Map<String, Double> getClusterTotalGenericResource() {\n+        Map<String, Double> ret = new HashMap<>();\n+        for (SupervisorDetails sup : supervisors.values()) {\n+            Map<String, Double> supGenericResources = sup.getTotalGenericResources();\n+            for (Map.Entry<String, Double> entry : supGenericResources.entrySet()) {\n+                String resourceName = entry.getKey();\n+                Double amount = entry.getValue();\n+                ret.put(resourceName, ret.getOrDefault(resourceName, 0.0) + amount);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyOTQ5Mw=="}, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTQ3MDg1OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/ISchedulingState.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoxOTozMVrOFxrD8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzozNToxMFrOFx23sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMDA2NA==", "bodyText": "Method name should probably be getClusterTotalGenericResources  with s", "url": "https://github.com/apache/storm/pull/3213#discussion_r387630064", "createdAt": "2020-03-04T12:19:31Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/ISchedulingState.java", "diffHunk": "@@ -271,6 +273,13 @@ boolean wouldFit(\n      */\n     double getClusterTotalMemoryResource();\n \n+    /**\n+     * Get the total amount of generic resources (excluding CPU and memory) in cluster.\n+     */\n+    default Map<String, Double> getClusterTotalGenericResource() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMjY0Mw==", "bodyText": "Cluster should have a private variable that avoids recalculating this often.\nSimilarly, it should have Set genericResourceTypes.\nAnd method getClusterGenericResourceTypes", "url": "https://github.com/apache/storm/pull/3213#discussion_r387632643", "createdAt": "2020-03-04T12:25:06Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/ISchedulingState.java", "diffHunk": "@@ -271,6 +273,13 @@ boolean wouldFit(\n      */\n     double getClusterTotalMemoryResource();\n \n+    /**\n+     * Get the total amount of generic resources (excluding CPU and memory) in cluster.\n+     */\n+    default Map<String, Double> getClusterTotalGenericResource() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMDA2NA=="}, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyMzUzNg==", "bodyText": "Addressed", "url": "https://github.com/apache/storm/pull/3213#discussion_r387823536", "createdAt": "2020-03-04T17:35:10Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/ISchedulingState.java", "diffHunk": "@@ -271,6 +273,13 @@ boolean wouldFit(\n      */\n     double getClusterTotalMemoryResource();\n \n+    /**\n+     * Get the total amount of generic resources (excluding CPU and memory) in cluster.\n+     */\n+    default Map<String, Double> getClusterTotalGenericResource() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMDA2NA=="}, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTQ3MTczOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoxOTo0OVrOFxrEfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzozNToyMVrOFx24Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMDIwNg==", "bodyText": "Method name should include s at the end.", "url": "https://github.com/apache/storm/pull/3213#discussion_r387630206", "createdAt": "2020-03-04T12:19:49Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -889,6 +889,20 @@ public double getClusterTotalMemoryResource() {\n         return sum;\n     }\n \n+    @Override\n+    public Map<String, Double> getClusterTotalGenericResource() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyMzYzMQ==", "bodyText": "Yes, addressed", "url": "https://github.com/apache/storm/pull/3213#discussion_r387823631", "createdAt": "2020-03-04T17:35:21Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -889,6 +889,20 @@ public double getClusterTotalMemoryResource() {\n         return sum;\n     }\n \n+    @Override\n+    public Map<String, Double> getClusterTotalGenericResource() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMDIwNg=="}, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMTQ3NzE5OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjoyMTozMFrOFxrHnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNzozNToyN1rOFx24RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMTAwNw==", "bodyText": "Instead of using getClusterTotalGenericResource here, probably adding below getClusterTotalGenericResourceType to cluster would help avoid calculations..\nIt would looks something like:\n    public Set<String> getClusterGenericResourceTypes() {\n        Set<String> resourceTypes =\n            supervisors.values().parallelStream().map(sup -> sup.getTotalGenericResources().keySet()).flatMap(Set::stream).collect(Collectors.toSet());\n        return resourceTypes;\n    }```", "url": "https://github.com/apache/storm/pull/3213#discussion_r387631007", "createdAt": "2020-03-04T12:21:30Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResource();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            Map<String, Double> availGenericResources = cluster.getClusterTotalGenericResource();   // generic resources that are offered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyMzY4NA==", "bodyText": "Added", "url": "https://github.com/apache/storm/pull/3213#discussion_r387823684", "createdAt": "2020-03-04T17:35:27Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResource();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            Map<String, Double> availGenericResources = cluster.getClusterTotalGenericResource();   // generic resources that are offered", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMTAwNw=="}, "originalCommit": {"oid": "8f76cc79cb0c28581259d5eb392ba8b8bdbae9d4"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNjk4MDY3OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjoyOToxMFrOF28GZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwMzowMDo0MVrOF4eg2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE1MjEwMA==", "bodyText": "These three variables nee to be part if copying from src in copy constructor and  public Cluster(Cluster src, Topologies topologies)", "url": "https://github.com/apache/storm/pull/3213#discussion_r393152100", "createdAt": "2020-03-16T16:29:10Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -80,6 +80,13 @@\n     private final Map<String, Map<String, Double>> nodeToScheduledOffHeapNodeMemoryCache;   // node -> topologyId -> double\n     private final Map<String, Set<WorkerSlot>> nodeToUsedSlotsCache;\n     private final Map<String, NormalizedResourceRequest> totalResourcesPerNodeCache = new HashMap<>();\n+    /**\n+     * Snapshot of cluster total resources (cpu, memory, generic).\n+     */\n+    private final double totalCpuResource;\n+    private final double totalMemoryResource;\n+    private final Map<String, Double> totalGenericResources;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26f4054347cca6787362755210b8e634c55ad89"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4ODg2NQ==", "bodyText": "Fixed", "url": "https://github.com/apache/storm/pull/3213#discussion_r393988865", "createdAt": "2020-03-17T21:45:20Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -80,6 +80,13 @@\n     private final Map<String, Map<String, Double>> nodeToScheduledOffHeapNodeMemoryCache;   // node -> topologyId -> double\n     private final Map<String, Set<WorkerSlot>> nodeToUsedSlotsCache;\n     private final Map<String, NormalizedResourceRequest> totalResourcesPerNodeCache = new HashMap<>();\n+    /**\n+     * Snapshot of cluster total resources (cpu, memory, generic).\n+     */\n+    private final double totalCpuResource;\n+    private final double totalMemoryResource;\n+    private final Map<String, Double> totalGenericResources;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE1MjEwMA=="}, "originalCommit": {"oid": "d26f4054347cca6787362755210b8e634c55ad89"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc2NDUwNw==", "bodyText": "If these variables are being used to keep running totals, should these be called \" cacheTotalCpuResource\" and so on. And the totals be incrementally updated in assign and unassign? If not running cache, then maybe just getTotalResouceCpu() == computeClusterCpuResource()?", "url": "https://github.com/apache/storm/pull/3213#discussion_r394764507", "createdAt": "2020-03-19T03:00:41Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -80,6 +80,13 @@\n     private final Map<String, Map<String, Double>> nodeToScheduledOffHeapNodeMemoryCache;   // node -> topologyId -> double\n     private final Map<String, Set<WorkerSlot>> nodeToUsedSlotsCache;\n     private final Map<String, NormalizedResourceRequest> totalResourcesPerNodeCache = new HashMap<>();\n+    /**\n+     * Snapshot of cluster total resources (cpu, memory, generic).\n+     */\n+    private final double totalCpuResource;\n+    private final double totalMemoryResource;\n+    private final Map<String, Double> totalGenericResources;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE1MjEwMA=="}, "originalCommit": {"oid": "d26f4054347cca6787362755210b8e634c55ad89"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzE3NTI3OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzoxMjoxMVrOF2-Clw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMTo0NTowOVrOF3vKqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4Mzg5NQ==", "bodyText": "should we not adjust cpu and memory as well? Very similar to how SimulatedUser.simScheduleNextHighest()\n                assignedMemory += td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap();\n\nEven better would be generally refactor this whole class to minimize the duplicate code...", "url": "https://github.com/apache/storm/pull/3213#discussion_r393183895", "createdAt": "2020-03-16T17:12:11Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResources();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            // generic resource types that are offered\n+            Set<String> availGenericResourceTypes = cluster.getClusterTotalGenericResources().keySet();\n+            for (String resourceType : availGenericResourceTypes) {\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resourceType, 0.0);\n+                guaranteedGenericResources.put(resourceType, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = super.simScheduleNextHighest();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d26f4054347cca6787362755210b8e634c55ad89"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4ODc3Nw==", "bodyText": "cpu and mem are adjusted by its overrided method on line 105:\nTopologyDetails td = super.simScheduleNextHighest();\nNot sure if this is what you are looking for.", "url": "https://github.com/apache/storm/pull/3213#discussion_r393988777", "createdAt": "2020-03-17T21:45:09Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResources();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            // generic resource types that are offered\n+            Set<String> availGenericResourceTypes = cluster.getClusterTotalGenericResources().keySet();\n+            for (String resourceType : availGenericResourceTypes) {\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resourceType, 0.0);\n+                guaranteedGenericResources.put(resourceType, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = super.simScheduleNextHighest();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4Mzg5NQ=="}, "originalCommit": {"oid": "d26f4054347cca6787362755210b8e634c55ad89"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NjkyNTE0OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwMzozMDoxN1rOF4e6Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxNjo0N1rOF460bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc3MTA0Nw==", "bodyText": "Is this comparator supposed to compare GrasSimulatedUser for use in a sort? Then it should compare o1 to o2. But it \"seems\" to be comparing  \"distance\" from some fixed point to o1 and o2. Is this intentional?", "url": "https://github.com/apache/storm/pull/3213#discussion_r394771047", "createdAt": "2020-03-19T03:30:17Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResources();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            // generic resource types that are offered\n+            Set<String> availGenericResourceTypes = cluster.getClusterTotalGenericResources().keySet();\n+            for (String resourceType : availGenericResourceTypes) {\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resourceType, 0.0);\n+                guaranteedGenericResources.put(resourceType, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = super.simScheduleNextHighest();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }\n+            return td;\n+        }\n+\n+        /**\n+         * Get a score for the simulated user.  This is used to sort the users, by their highest priority topology.\n+         * Only give user guarantees that will not exceed cluster capacity.\n+         * Score of each resource type is calculated as: (Requested + Assigned - Guaranteed)/clusterAvailable\n+         * The final score is a max over all resource types.\n+         * Topology score will fall into the following intervals if:\n+         *      User is under quota (guarantee):                    [(-guarantee)/available : 0]\n+         *      User is over quota:                                 (0, infinity)\n+         * Unfortunately, score below 0 does not guarantee that the topology will be scheduled due to resources fragmentation.\n+         * @param availableCpu available CPU on the cluster.\n+         * @param availableMemory available memory on the cluster.\n+         * @param availableGenericResources available generic resources (other that cpu and memory) in cluster\n+         * @param td the topology we are looking at.\n+         * @return the score.\n+         */\n+        protected double getScore(double availableCpu, double availableMemory,\n+                                  Map<String, Double> availableGenericResources, TopologyDetails td) {\n+            // calculate scores for cpu and memory first\n+            double ret = super.getScore(availableCpu, availableMemory, td);\n+            if (ret == Double.MAX_VALUE) {\n+                return ret;\n+            }\n+            Map<String, Double> tdTotalRequestedGeneric = td.getTotalRequestedGenericResources();\n+            if (tdTotalRequestedGeneric == null) {\n+                tdTotalRequestedGeneric = Collections.emptyMap();\n+            }\n+            for (Map.Entry<String, Double> entry : availableGenericResources.entrySet()) {\n+                String resource = entry.getKey();\n+                Double available = entry.getValue();\n+                if (available <= 0) {\n+                    return Double.MAX_VALUE;\n+                }\n+                Double wouldBeResource = assignedGenericResources.getOrDefault(resource, 0.0)\n+                    + tdTotalRequestedGeneric.getOrDefault(resource, 0.0);\n+                double thisScore = (wouldBeResource -  guaranteedGenericResources.getOrDefault(resource, 0.0)) / available;\n+                ret = Math.max(ret, thisScore);\n+            }\n+\n+            return ret;\n+        }\n+\n+        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {\n+            TopologyDetails td = getNextHighest();\n+            return getScore(availableCpu, availableMemory, availableGenericResources, td);\n+        }\n+    }\n+\n+    private static class GrasSimulatedUserComparator implements Comparator<GrasSimulatedUser> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ba7f9ea112c2733b2d45959b9000d66eba0c93d"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyODI3MQ==", "bodyText": "It is comparing GrasSimulatedUser  for sorting at line 58. And it is comparing o1 and o2 based on their scores, please refer to the overriding compare method at line 175.", "url": "https://github.com/apache/storm/pull/3213#discussion_r395228271", "createdAt": "2020-03-19T18:16:47Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResources();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            // generic resource types that are offered\n+            Set<String> availGenericResourceTypes = cluster.getClusterTotalGenericResources().keySet();\n+            for (String resourceType : availGenericResourceTypes) {\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resourceType, 0.0);\n+                guaranteedGenericResources.put(resourceType, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = super.simScheduleNextHighest();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }\n+            return td;\n+        }\n+\n+        /**\n+         * Get a score for the simulated user.  This is used to sort the users, by their highest priority topology.\n+         * Only give user guarantees that will not exceed cluster capacity.\n+         * Score of each resource type is calculated as: (Requested + Assigned - Guaranteed)/clusterAvailable\n+         * The final score is a max over all resource types.\n+         * Topology score will fall into the following intervals if:\n+         *      User is under quota (guarantee):                    [(-guarantee)/available : 0]\n+         *      User is over quota:                                 (0, infinity)\n+         * Unfortunately, score below 0 does not guarantee that the topology will be scheduled due to resources fragmentation.\n+         * @param availableCpu available CPU on the cluster.\n+         * @param availableMemory available memory on the cluster.\n+         * @param availableGenericResources available generic resources (other that cpu and memory) in cluster\n+         * @param td the topology we are looking at.\n+         * @return the score.\n+         */\n+        protected double getScore(double availableCpu, double availableMemory,\n+                                  Map<String, Double> availableGenericResources, TopologyDetails td) {\n+            // calculate scores for cpu and memory first\n+            double ret = super.getScore(availableCpu, availableMemory, td);\n+            if (ret == Double.MAX_VALUE) {\n+                return ret;\n+            }\n+            Map<String, Double> tdTotalRequestedGeneric = td.getTotalRequestedGenericResources();\n+            if (tdTotalRequestedGeneric == null) {\n+                tdTotalRequestedGeneric = Collections.emptyMap();\n+            }\n+            for (Map.Entry<String, Double> entry : availableGenericResources.entrySet()) {\n+                String resource = entry.getKey();\n+                Double available = entry.getValue();\n+                if (available <= 0) {\n+                    return Double.MAX_VALUE;\n+                }\n+                Double wouldBeResource = assignedGenericResources.getOrDefault(resource, 0.0)\n+                    + tdTotalRequestedGeneric.getOrDefault(resource, 0.0);\n+                double thisScore = (wouldBeResource -  guaranteedGenericResources.getOrDefault(resource, 0.0)) / available;\n+                ret = Math.max(ret, thisScore);\n+            }\n+\n+            return ret;\n+        }\n+\n+        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {\n+            TopologyDetails td = getNextHighest();\n+            return getScore(availableCpu, availableMemory, availableGenericResources, td);\n+        }\n+    }\n+\n+    private static class GrasSimulatedUserComparator implements Comparator<GrasSimulatedUser> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc3MTA0Nw=="}, "originalCommit": {"oid": "0ba7f9ea112c2733b2d45959b9000d66eba0c93d"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Njk5MDg5OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwNDoxMTo1NVrOF4fhxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxODoxODowOVrOF463eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc4MTEyNw==", "bodyText": "Can this be removed. Use TestUtilsForResourceAwareScheduler#assertTopologiesNotScheduled.", "url": "https://github.com/apache/storm/pull/3213#discussion_r394781127", "createdAt": "2020-03-19T04:11:55Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -56,6 +59,10 @@\n     private int schedulingTimeoutSeconds;\n     private ExecutorService backgroundScheduling;\n \n+    // record evicted topologies on each scheduling round, only used in test purpose now\n+    private boolean forTest = false;\n+    private Set<String> evictedTopologies = new HashSet<>();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ba7f9ea112c2733b2d45959b9000d66eba0c93d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyOTA0OQ==", "bodyText": "Unfortunately no, I have to add this to check whether topo has been evicted since in some scenarios, evicted topo would be put back in the same round of scheduling.", "url": "https://github.com/apache/storm/pull/3213#discussion_r395229049", "createdAt": "2020-03-19T18:18:09Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -56,6 +59,10 @@\n     private int schedulingTimeoutSeconds;\n     private ExecutorService backgroundScheduling;\n \n+    // record evicted topologies on each scheduling round, only used in test purpose now\n+    private boolean forTest = false;\n+    private Set<String> evictedTopologies = new HashSet<>();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc4MTEyNw=="}, "originalCommit": {"oid": "0ba7f9ea112c2733b2d45959b9000d66eba0c93d"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjEyMDQ0OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzo1ODo0MFrOGCE5rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzo1ODo0MFrOGCE5rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgzMDYzOA==", "bodyText": "evictedTopologies is cumulated during scheduling all the topologies since it only clears evictedTopologies at Line 111. So evictedTopologies here include all the evictedTopologies not only evicted by scheduling this topology td.getId()", "url": "https://github.com/apache/storm/pull/3213#discussion_r404830638", "createdAt": "2020-04-07T13:58:40Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -113,6 +119,9 @@ public void schedule(Topologies topologies, Cluster cluster) {\n             } else {\n                 User submitter = userMap.get(td.getTopologySubmitter());\n                 scheduleTopology(td, cluster, submitter, orderedTopologies);\n+                if (!evictedTopologies.isEmpty()) {\n+                    LOG.warn(\"Evicted Topologies {} when scheduling topology: {}\", evictedTopologies, td.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec28f7a20dbfca7a175fdd7329230d2550a9ca5a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDg0MTQ2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjowMjoxNVrOGD-ieQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozMzowMFrOGEA21w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyMzU0NQ==", "bodyText": "This looks overly complicated.  Maybe\n        Set<String> set = new HashSet<>();\n        map.values().forEach((s) -> set.addAll(s));\n        return set;", "url": "https://github.com/apache/storm/pull/3213#discussion_r406823545", "createdAt": "2020-04-10T16:02:15Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -210,4 +216,11 @@ private Cluster mkTestCluster(Topologies topologies, Config config) {\n \n         return new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supMap, new HashMap<>(), topologies, config);\n     }\n+\n+    private Set<String> collectMapValues(Map<String, Set<String>> map) {\n+        return map.values()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2MTUyNw==", "bodyText": "Fixed.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406861527", "createdAt": "2020-04-10T17:33:00Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/priority/TestGenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -210,4 +216,11 @@ private Cluster mkTestCluster(Topologies topologies, Config config) {\n \n         return new Cluster(iNimbus, new ResourceMetrics(new StormMetricsRegistry()), supMap, new HashMap<>(), topologies, config);\n     }\n+\n+    private Set<String> collectMapValues(Map<String, Set<String>> map) {\n+        return map.values()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyMzU0NQ=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDg2NDIzOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoxMDoyNFrOGD-v-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzozNToxNlrOGEA7Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzAwMQ==", "bodyText": "tmpEvictedTopos is a set of evictedTopologies in every attempt.\nIt might evict multiple topologies in maxSchedulingAttempts.\nSo the current evictedTopologiesMap is just a subset.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406827001", "createdAt": "2020-04-10T16:10:24Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -196,21 +204,18 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     } else if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {\n                         LOG.debug(\"Not enough resources to schedule {}\", td.getName());\n                         List<TopologyDetails> reversedList = ImmutableList.copyOf(orderedTopologies).reverse();\n-                        boolean evictedSomething = false;\n-                        LOG.debug(\"attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n+                        LOG.debug(\"Attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n                         int tdIndex = reversedList.indexOf(td);\n                         topologySchedulingResources.setRemainingRequiredResources(toSchedule, td);\n \n+                        Set<String> tmpEvictedTopos = new HashSet<>();\n                         for (int index = 0; index < tdIndex; index++) {\n                             TopologyDetails topologyEvict = reversedList.get(index);\n                             SchedulerAssignment evictAssignemnt = workingState.getAssignmentById(topologyEvict.getId());\n                             if (evictAssignemnt != null && !evictAssignemnt.getSlots().isEmpty()) {\n-                                Collection<WorkerSlot> workersToEvict = workingState.getUsedSlotsByTopologyId(topologyEvict.getId());\n                                 topologySchedulingResources.adjustResourcesForEvictedTopology(toSchedule, topologyEvict);\n-\n-                                LOG.debug(\"Evicting Topology {} with workers: {} from user {}\", topologyEvict.getName(), workersToEvict,\n-                                    topologyEvict.getTopologySubmitter());\n-                                evictedSomething = true;\n+                                tmpEvictedTopos.add(topologyEvict.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2MjYxNA==", "bodyText": "Thanks for catching. This is my mistake. Made changes that\n\nnew a hashmap for tmpEvictedTopos  at every round of scheduling.\ncombine evicted topologies at each attempt into tmpEvictedTopologiesMap", "url": "https://github.com/apache/storm/pull/3213#discussion_r406862614", "createdAt": "2020-04-10T17:35:16Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -196,21 +204,18 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     } else if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {\n                         LOG.debug(\"Not enough resources to schedule {}\", td.getName());\n                         List<TopologyDetails> reversedList = ImmutableList.copyOf(orderedTopologies).reverse();\n-                        boolean evictedSomething = false;\n-                        LOG.debug(\"attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n+                        LOG.debug(\"Attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n                         int tdIndex = reversedList.indexOf(td);\n                         topologySchedulingResources.setRemainingRequiredResources(toSchedule, td);\n \n+                        Set<String> tmpEvictedTopos = new HashSet<>();\n                         for (int index = 0; index < tdIndex; index++) {\n                             TopologyDetails topologyEvict = reversedList.get(index);\n                             SchedulerAssignment evictAssignemnt = workingState.getAssignmentById(topologyEvict.getId());\n                             if (evictAssignemnt != null && !evictAssignemnt.getSlots().isEmpty()) {\n-                                Collection<WorkerSlot> workersToEvict = workingState.getUsedSlotsByTopologyId(topologyEvict.getId());\n                                 topologySchedulingResources.adjustResourcesForEvictedTopology(toSchedule, topologyEvict);\n-\n-                                LOG.debug(\"Evicting Topology {} with workers: {} from user {}\", topologyEvict.getName(), workersToEvict,\n-                                    topologyEvict.getTopologySubmitter());\n-                                evictedSomething = true;\n+                                tmpEvictedTopos.add(topologyEvict.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzAwMQ=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDg2ODAwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoxMTo1MVrOGD-yMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoyMDo1OFrOGEt56A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzU3MA==", "bodyText": "The idea of making evictedTopologiesMap a result after a complete schedule round is a good idea.\nBut the code here makes evictedTopologiesMap and tmpEvictedTopologiesMap the same object.\nSo tmpEvictedTopologiesMap.clear == evictedTopologiesMap.clear. This won't achieve the goal here.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406827570", "createdAt": "2020-04-10T16:11:51Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -115,6 +122,7 @@ public void schedule(Topologies topologies, Cluster cluster) {\n                 scheduleTopology(td, cluster, submitter, orderedTopologies);\n             }\n         }\n+        evictedTopologiesMap = tmpEvictedTopologiesMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2Mjc5OQ==", "bodyText": "Fixed on above comments.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406862799", "createdAt": "2020-04-10T17:35:41Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -115,6 +122,7 @@ public void schedule(Topologies topologies, Cluster cluster) {\n                 scheduleTopology(td, cluster, submitter, orderedTopologies);\n             }\n         }\n+        evictedTopologiesMap = tmpEvictedTopologiesMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzU3MA=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5OTU5Mg==", "bodyText": "I'm trying to clarify why we don't pass in evictedTopologiesMap - is it because there could be an exception in scheduleTopology and you want to be able to get the previously evicted topologies?", "url": "https://github.com/apache/storm/pull/3213#discussion_r407599592", "createdAt": "2020-04-13T17:20:58Z", "author": {"login": "govind-menon"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -115,6 +122,7 @@ public void schedule(Topologies topologies, Cluster cluster) {\n                 scheduleTopology(td, cluster, submitter, orderedTopologies);\n             }\n         }\n+        evictedTopologiesMap = tmpEvictedTopologiesMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNzU3MA=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDg5MjMwOnYy", "diffSide": "LEFT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoyMDo1NlrOGD_BJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowNzoxNFrOGEEfmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTM5Ng==", "bodyText": "We can change this to WARN and add the current topologyId since this also includes the workers being evicted.\nThen delete Line228.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406831396", "createdAt": "2020-04-10T16:20:56Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -196,21 +204,18 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     } else if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {\n                         LOG.debug(\"Not enough resources to schedule {}\", td.getName());\n                         List<TopologyDetails> reversedList = ImmutableList.copyOf(orderedTopologies).reverse();\n-                        boolean evictedSomething = false;\n-                        LOG.debug(\"attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n+                        LOG.debug(\"Attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n                         int tdIndex = reversedList.indexOf(td);\n                         topologySchedulingResources.setRemainingRequiredResources(toSchedule, td);\n \n+                        Set<String> tmpEvictedTopos = new HashSet<>();\n                         for (int index = 0; index < tdIndex; index++) {\n                             TopologyDetails topologyEvict = reversedList.get(index);\n                             SchedulerAssignment evictAssignemnt = workingState.getAssignmentById(topologyEvict.getId());\n                             if (evictAssignemnt != null && !evictAssignemnt.getSlots().isEmpty()) {\n-                                Collection<WorkerSlot> workersToEvict = workingState.getUsedSlotsByTopologyId(topologyEvict.getId());\n                                 topologySchedulingResources.adjustResourcesForEvictedTopology(toSchedule, topologyEvict);\n-\n-                                LOG.debug(\"Evicting Topology {} with workers: {} from user {}\", topologyEvict.getName(), workersToEvict,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2NDE0OQ==", "bodyText": "As for log info. I feel the worker and user information is not useful here since all workers will be evicted when evicting topologies. We are more concerned about for what topology the evictions happen. And we can easily know user info from topology info.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406864149", "createdAt": "2020-04-10T17:38:37Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -196,21 +204,18 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     } else if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {\n                         LOG.debug(\"Not enough resources to schedule {}\", td.getName());\n                         List<TopologyDetails> reversedList = ImmutableList.copyOf(orderedTopologies).reverse();\n-                        boolean evictedSomething = false;\n-                        LOG.debug(\"attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n+                        LOG.debug(\"Attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n                         int tdIndex = reversedList.indexOf(td);\n                         topologySchedulingResources.setRemainingRequiredResources(toSchedule, td);\n \n+                        Set<String> tmpEvictedTopos = new HashSet<>();\n                         for (int index = 0; index < tdIndex; index++) {\n                             TopologyDetails topologyEvict = reversedList.get(index);\n                             SchedulerAssignment evictAssignemnt = workingState.getAssignmentById(topologyEvict.getId());\n                             if (evictAssignemnt != null && !evictAssignemnt.getSlots().isEmpty()) {\n-                                Collection<WorkerSlot> workersToEvict = workingState.getUsedSlotsByTopologyId(topologyEvict.getId());\n                                 topologySchedulingResources.adjustResourcesForEvictedTopology(toSchedule, topologyEvict);\n-\n-                                LOG.debug(\"Evicting Topology {} with workers: {} from user {}\", topologyEvict.getName(), workersToEvict,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTM5Ng=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMTExNQ==", "bodyText": "Makes sense", "url": "https://github.com/apache/storm/pull/3213#discussion_r406921115", "createdAt": "2020-04-10T20:07:14Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -196,21 +204,18 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     } else if (result.getStatus() == SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES) {\n                         LOG.debug(\"Not enough resources to schedule {}\", td.getName());\n                         List<TopologyDetails> reversedList = ImmutableList.copyOf(orderedTopologies).reverse();\n-                        boolean evictedSomething = false;\n-                        LOG.debug(\"attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n+                        LOG.debug(\"Attempting to make space for topo {} from user {}\", td.getName(), td.getTopologySubmitter());\n                         int tdIndex = reversedList.indexOf(td);\n                         topologySchedulingResources.setRemainingRequiredResources(toSchedule, td);\n \n+                        Set<String> tmpEvictedTopos = new HashSet<>();\n                         for (int index = 0; index < tdIndex; index++) {\n                             TopologyDetails topologyEvict = reversedList.get(index);\n                             SchedulerAssignment evictAssignemnt = workingState.getAssignmentById(topologyEvict.getId());\n                             if (evictAssignemnt != null && !evictAssignemnt.getSlots().isEmpty()) {\n-                                Collection<WorkerSlot> workersToEvict = workingState.getUsedSlotsByTopologyId(topologyEvict.getId());\n                                 topologySchedulingResources.adjustResourcesForEvictedTopology(toSchedule, topologyEvict);\n-\n-                                LOG.debug(\"Evicting Topology {} with workers: {} from user {}\", topologyEvict.getName(), workersToEvict,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTM5Ng=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDg5NTg2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoyMjoxOVrOGD_DVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoyNDowNVrOGEuAwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTk1OA==", "bodyText": "I would add a comment like This method is not stable. It's subject to change since we don't really use it elsewhere besides unit test currently. It might change depending on how we want to use the evictedTopologies information. As @bipinprasad  said, we might want to put the evictedTopologies information into the scheduleResult in the future.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406831958", "createdAt": "2020-04-10T16:22:19Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -248,6 +255,11 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     + topologySchedulingResources.getRemainingRequiredResourcesMessage());\n     }\n \n+    public Map<String, Set<String>> getEvictedTopologiesMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2NTA1NQ==", "bodyText": "Added.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406865055", "createdAt": "2020-04-10T17:40:31Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -248,6 +255,11 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     + topologySchedulingResources.getRemainingRequiredResourcesMessage());\n     }\n \n+    public Map<String, Set<String>> getEvictedTopologiesMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTk1OA=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMzY4OA==", "bodyText": "Good comment", "url": "https://github.com/apache/storm/pull/3213#discussion_r406923688", "createdAt": "2020-04-10T20:14:49Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -248,6 +255,11 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     + topologySchedulingResources.getRemainingRequiredResourcesMessage());\n     }\n \n+    public Map<String, Set<String>> getEvictedTopologiesMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTk1OA=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwMTM0Ng==", "bodyText": "Regarding my previous question - in this case it makes sense because there are multiple scheduling attempts and you need the final result to keep it consistent but that is not the case with evictedTopologiesMap  and tmpEvictedTopologiesMap  - unless I'm missing something about my previous question?", "url": "https://github.com/apache/storm/pull/3213#discussion_r407601346", "createdAt": "2020-04-13T17:24:05Z", "author": {"login": "govind-menon"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -248,6 +255,11 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                     + topologySchedulingResources.getRemainingRequiredResourcesMessage());\n     }\n \n+    public Map<String, Set<String>> getEvictedTopologiesMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTk1OA=="}, "originalCommit": {"oid": "95fdb64745865bf402d76aa84655a2ed23f94f1b"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ2NTYzOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDowNzo1NlrOGEEglA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTowOToxNVrOGEF_Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMTM2NA==", "bodyText": "This doesn't have to be a attribute since it's only used inside schedule method", "url": "https://github.com/apache/storm/pull/3213#discussion_r406921364", "createdAt": "2020-04-10T20:07:56Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -57,6 +59,8 @@\n     private int maxSchedulingAttempts;\n     private int schedulingTimeoutSeconds;\n     private ExecutorService backgroundScheduling;\n+    private Map<String, Set<String>> evictedTopologiesMap = new HashMap<>();   // topoId : topoEvicted\n+    private Map<String, Set<String>> tmpEvictedTopologiesMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db992e84a02bb3f2e8eb1684d1e9626f99b7e3b7"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0NTU3OQ==", "bodyText": "I was thinking not to add more parameters to he private scheduleTopology function, but I think this makes sense and fixed.", "url": "https://github.com/apache/storm/pull/3213#discussion_r406945579", "createdAt": "2020-04-10T21:09:15Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -57,6 +59,8 @@\n     private int maxSchedulingAttempts;\n     private int schedulingTimeoutSeconds;\n     private ExecutorService backgroundScheduling;\n+    private Map<String, Set<String>> evictedTopologiesMap = new HashMap<>();   // topoId : topoEvicted\n+    private Map<String, Set<String>> tmpEvictedTopologiesMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMTM2NA=="}, "originalCommit": {"oid": "db992e84a02bb3f2e8eb1684d1e9626f99b7e3b7"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTQ3NzQ2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMDoxMzoxOVrOGEEnkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTowOToyMVrOGEF_Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMzE1NA==", "bodyText": "Can simplify this with\ntmpEvictedTopologiesMap.computeIfAbsent(topoId, k -> new HashSet<>()).addAll(tmpEvictedTopos);", "url": "https://github.com/apache/storm/pull/3213#discussion_r406923154", "createdAt": "2020-04-10T20:13:19Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -219,8 +224,14 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                                 }\n                             }\n                         }\n-\n-                        if (!evictedSomething) {\n+                        if (!tmpEvictedTopos.isEmpty()) {\n+                            LOG.warn(\"Evicted Topologies {} when scheduling topology: {}\", tmpEvictedTopos, td.getId());\n+                            String topoId = td.getId();\n+                            if (!tmpEvictedTopologiesMap.containsKey(topoId)) {\n+                                tmpEvictedTopologiesMap.put(topoId, new HashSet<>());\n+                            }\n+                            tmpEvictedTopologiesMap.get(topoId).addAll(tmpEvictedTopos);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db992e84a02bb3f2e8eb1684d1e9626f99b7e3b7"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0NTYxNA==", "bodyText": "Fixed", "url": "https://github.com/apache/storm/pull/3213#discussion_r406945614", "createdAt": "2020-04-10T21:09:21Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/ResourceAwareScheduler.java", "diffHunk": "@@ -219,8 +224,14 @@ private void scheduleTopology(TopologyDetails td, Cluster cluster, final User to\n                                 }\n                             }\n                         }\n-\n-                        if (!evictedSomething) {\n+                        if (!tmpEvictedTopos.isEmpty()) {\n+                            LOG.warn(\"Evicted Topologies {} when scheduling topology: {}\", tmpEvictedTopos, td.getId());\n+                            String topoId = td.getId();\n+                            if (!tmpEvictedTopologiesMap.containsKey(topoId)) {\n+                                tmpEvictedTopologiesMap.put(topoId, new HashSet<>());\n+                            }\n+                            tmpEvictedTopologiesMap.get(topoId).addAll(tmpEvictedTopos);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkyMzE1NA=="}, "originalCommit": {"oid": "db992e84a02bb3f2e8eb1684d1e9626f99b7e3b7"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDMyNTcyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzowNDoyMVrOGEtW1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMTo0NzozMlrOGGMwYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MDYxMg==", "bodyText": "Nit: Possibly use https://www.baeldung.com/java-merge-maps#of to simplify this a little.", "url": "https://github.com/apache/storm/pull/3213#discussion_r407590612", "createdAt": "2020-04-13T17:04:21Z", "author": {"login": "govind-menon"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -873,20 +897,38 @@ public NormalizedResourceOffer getNonBlacklistedClusterAvailableResources(Collec\n \n     @Override\n     public double getClusterTotalCpuResource() {\n-        double sum = 0.0;\n-        for (SupervisorDetails sup : supervisors.values()) {\n-            sum += sup.getTotalCpu();\n-        }\n-        return sum;\n+        return this.totalCpuResource;\n+    }\n+\n+    private double computeClusterCpuResource() {\n+        return supervisors.values().stream()\n+            .mapToDouble(SupervisorDetails::getTotalCpu)\n+            .sum();\n+\n     }\n \n     @Override\n     public double getClusterTotalMemoryResource() {\n-        double sum = 0.0;\n-        for (SupervisorDetails sup : supervisors.values()) {\n-            sum += sup.getTotalMemory();\n-        }\n-        return sum;\n+        return this.totalMemoryResource;\n+    }\n+\n+\n+    private double computeClusterMemoryResource() {\n+        return supervisors.values().stream()\n+            .mapToDouble(SupervisorDetails::getTotalMemory)\n+            .sum();\n+    }\n+\n+    @Override\n+    public Map<String, Double> getClusterTotalGenericResources() {\n+        return this.totalGenericResources;\n+    }\n+\n+    private Map<String, Double> computeClusterGenericResources() {\n+        return supervisors.values().stream()\n+            .map(sup -> sup.getTotalGenericResources().entrySet())\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, Double::sum));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1NDY5Nw==", "bodyText": "Sorry I didn't think of a way to further simplify, could you elaborate? supervisors.values().stream() will create Stream. I don't how Stream.of can help here.", "url": "https://github.com/apache/storm/pull/3213#discussion_r407854697", "createdAt": "2020-04-14T04:08:37Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -873,20 +897,38 @@ public NormalizedResourceOffer getNonBlacklistedClusterAvailableResources(Collec\n \n     @Override\n     public double getClusterTotalCpuResource() {\n-        double sum = 0.0;\n-        for (SupervisorDetails sup : supervisors.values()) {\n-            sum += sup.getTotalCpu();\n-        }\n-        return sum;\n+        return this.totalCpuResource;\n+    }\n+\n+    private double computeClusterCpuResource() {\n+        return supervisors.values().stream()\n+            .mapToDouble(SupervisorDetails::getTotalCpu)\n+            .sum();\n+\n     }\n \n     @Override\n     public double getClusterTotalMemoryResource() {\n-        double sum = 0.0;\n-        for (SupervisorDetails sup : supervisors.values()) {\n-            sum += sup.getTotalMemory();\n-        }\n-        return sum;\n+        return this.totalMemoryResource;\n+    }\n+\n+\n+    private double computeClusterMemoryResource() {\n+        return supervisors.values().stream()\n+            .mapToDouble(SupervisorDetails::getTotalMemory)\n+            .sum();\n+    }\n+\n+    @Override\n+    public Map<String, Double> getClusterTotalGenericResources() {\n+        return this.totalGenericResources;\n+    }\n+\n+    private Map<String, Double> computeClusterGenericResources() {\n+        return supervisors.values().stream()\n+            .map(sup -> sup.getTotalGenericResources().entrySet())\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, Double::sum));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MDYxMg=="}, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MzYzNA==", "bodyText": "If you see the example in the link it's a slightly different way to add the key, value pairs of a Map but it's not an issue. You can keep this as is.", "url": "https://github.com/apache/storm/pull/3213#discussion_r409153634", "createdAt": "2020-04-15T21:47:32Z", "author": {"login": "govind-menon"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/Cluster.java", "diffHunk": "@@ -873,20 +897,38 @@ public NormalizedResourceOffer getNonBlacklistedClusterAvailableResources(Collec\n \n     @Override\n     public double getClusterTotalCpuResource() {\n-        double sum = 0.0;\n-        for (SupervisorDetails sup : supervisors.values()) {\n-            sum += sup.getTotalCpu();\n-        }\n-        return sum;\n+        return this.totalCpuResource;\n+    }\n+\n+    private double computeClusterCpuResource() {\n+        return supervisors.values().stream()\n+            .mapToDouble(SupervisorDetails::getTotalCpu)\n+            .sum();\n+\n     }\n \n     @Override\n     public double getClusterTotalMemoryResource() {\n-        double sum = 0.0;\n-        for (SupervisorDetails sup : supervisors.values()) {\n-            sum += sup.getTotalMemory();\n-        }\n-        return sum;\n+        return this.totalMemoryResource;\n+    }\n+\n+\n+    private double computeClusterMemoryResource() {\n+        return supervisors.values().stream()\n+            .mapToDouble(SupervisorDetails::getTotalMemory)\n+            .sum();\n+    }\n+\n+    @Override\n+    public Map<String, Double> getClusterTotalGenericResources() {\n+        return this.totalGenericResources;\n+    }\n+\n+    private Map<String, Double> computeClusterGenericResources() {\n+        return supervisors.values().stream()\n+            .map(sup -> sup.getTotalGenericResources().entrySet())\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, Double::sum));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MDYxMg=="}, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMDM0NTI5OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/ISchedulingState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzoxMDoxMVrOGEti5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNDowNTozN1rOGE9b3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MzcwMg==", "bodyText": "Do we need to define a default?", "url": "https://github.com/apache/storm/pull/3213#discussion_r407593702", "createdAt": "2020-04-13T17:10:11Z", "author": {"login": "govind-menon"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/ISchedulingState.java", "diffHunk": "@@ -271,6 +273,13 @@ boolean wouldFit(\n      */\n     double getClusterTotalMemoryResource();\n \n+    /**\n+     * Get the total amount of generic resources (excluding CPU and memory) in cluster.\n+     */\n+    default Map<String, Double> getClusterTotalGenericResources() {\n+        return Collections.emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1NDA0NQ==", "bodyText": "No we don't. Only cluster class implement this interface and cluster will have the implementation in this PR. Good catch.", "url": "https://github.com/apache/storm/pull/3213#discussion_r407854045", "createdAt": "2020-04-14T04:05:37Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/ISchedulingState.java", "diffHunk": "@@ -271,6 +273,13 @@ boolean wouldFit(\n      */\n     double getClusterTotalMemoryResource();\n \n+    /**\n+     * Get the total amount of generic resources (excluding CPU and memory) in cluster.\n+     */\n+    default Map<String, Double> getClusterTotalGenericResources() {\n+        return Collections.emptyMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MzcwMg=="}, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTE4MDc2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMToxODoxOVrOGE1sxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMTo0ODowOVrOGGMxjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzMwMA==", "bodyText": "Nit: could we inline this to avoid unnecessary object creation", "url": "https://github.com/apache/storm/pull/3213#discussion_r407727300", "createdAt": "2020-04-13T21:18:19Z", "author": {"login": "govind-menon"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResources();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            // generic resource types that are offered\n+            Set<String> availGenericResourceTypes = cluster.getClusterTotalGenericResources().keySet();\n+            for (String resourceType : availGenericResourceTypes) {\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resourceType, 0.0);\n+                guaranteedGenericResources.put(resourceType, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = super.simScheduleNextHighest();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }\n+            return td;\n+        }\n+\n+        /**\n+         * Get a score for the simulated user.  This is used to sort the users, by their highest priority topology.\n+         * Only give user guarantees that will not exceed cluster capacity.\n+         * Score of each resource type is calculated as: (Requested + Assigned - Guaranteed)/clusterAvailable\n+         * The final score is a max over all resource types.\n+         * Topology score will fall into the following intervals if:\n+         *      User is under quota (guarantee):                    [(-guarantee)/available : 0]\n+         *      User is over quota:                                 (0, infinity)\n+         * Unfortunately, score below 0 does not guarantee that the topology will be scheduled due to resources fragmentation.\n+         * @param availableCpu available CPU on the cluster.\n+         * @param availableMemory available memory on the cluster.\n+         * @param availableGenericResources available generic resources (other that cpu and memory) in cluster\n+         * @param td the topology we are looking at.\n+         * @return the score.\n+         */\n+        protected double getScore(double availableCpu, double availableMemory,\n+                                  Map<String, Double> availableGenericResources, TopologyDetails td) {\n+            // calculate scores for cpu and memory first\n+            double ret = super.getScore(availableCpu, availableMemory, td);\n+            if (ret == Double.MAX_VALUE) {\n+                return ret;\n+            }\n+            Map<String, Double> tdTotalRequestedGeneric = td.getTotalRequestedGenericResources();\n+            if (tdTotalRequestedGeneric == null) {\n+                tdTotalRequestedGeneric = Collections.emptyMap();\n+            }\n+            for (Map.Entry<String, Double> entry : availableGenericResources.entrySet()) {\n+                String resource = entry.getKey();\n+                Double available = entry.getValue();\n+                if (available <= 0) {\n+                    return Double.MAX_VALUE;\n+                }\n+                Double wouldBeResource = assignedGenericResources.getOrDefault(resource, 0.0)\n+                    + tdTotalRequestedGeneric.getOrDefault(resource, 0.0);\n+                double thisScore = (wouldBeResource -  guaranteedGenericResources.getOrDefault(resource, 0.0)) / available;\n+                ret = Math.max(ret, thisScore);\n+            }\n+\n+            return ret;\n+        }\n+\n+        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {\n+            TopologyDetails td = getNextHighest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1NTc5MA==", "bodyText": "Fixed the inline.\nAs for tmpEvictedTopologiesMap, my concern is that in the the scheduleTopology() method, we have a lot of return/break points since we have a pretty complex nested if else structure. Passing the tmpEvictedTopologiesMap can make sure the snapshot will be passed to the evictedTopologiesMap after this round scheduling finished for whatever reason.\nSo we create a new tmpEvictedTopologiesMap object before each round of scheduleTopology() and passed it over afterward.", "url": "https://github.com/apache/storm/pull/3213#discussion_r407855790", "createdAt": "2020-04-14T04:12:47Z", "author": {"login": "RuiLi8080"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResources();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            // generic resource types that are offered\n+            Set<String> availGenericResourceTypes = cluster.getClusterTotalGenericResources().keySet();\n+            for (String resourceType : availGenericResourceTypes) {\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resourceType, 0.0);\n+                guaranteedGenericResources.put(resourceType, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = super.simScheduleNextHighest();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }\n+            return td;\n+        }\n+\n+        /**\n+         * Get a score for the simulated user.  This is used to sort the users, by their highest priority topology.\n+         * Only give user guarantees that will not exceed cluster capacity.\n+         * Score of each resource type is calculated as: (Requested + Assigned - Guaranteed)/clusterAvailable\n+         * The final score is a max over all resource types.\n+         * Topology score will fall into the following intervals if:\n+         *      User is under quota (guarantee):                    [(-guarantee)/available : 0]\n+         *      User is over quota:                                 (0, infinity)\n+         * Unfortunately, score below 0 does not guarantee that the topology will be scheduled due to resources fragmentation.\n+         * @param availableCpu available CPU on the cluster.\n+         * @param availableMemory available memory on the cluster.\n+         * @param availableGenericResources available generic resources (other that cpu and memory) in cluster\n+         * @param td the topology we are looking at.\n+         * @return the score.\n+         */\n+        protected double getScore(double availableCpu, double availableMemory,\n+                                  Map<String, Double> availableGenericResources, TopologyDetails td) {\n+            // calculate scores for cpu and memory first\n+            double ret = super.getScore(availableCpu, availableMemory, td);\n+            if (ret == Double.MAX_VALUE) {\n+                return ret;\n+            }\n+            Map<String, Double> tdTotalRequestedGeneric = td.getTotalRequestedGenericResources();\n+            if (tdTotalRequestedGeneric == null) {\n+                tdTotalRequestedGeneric = Collections.emptyMap();\n+            }\n+            for (Map.Entry<String, Double> entry : availableGenericResources.entrySet()) {\n+                String resource = entry.getKey();\n+                Double available = entry.getValue();\n+                if (available <= 0) {\n+                    return Double.MAX_VALUE;\n+                }\n+                Double wouldBeResource = assignedGenericResources.getOrDefault(resource, 0.0)\n+                    + tdTotalRequestedGeneric.getOrDefault(resource, 0.0);\n+                double thisScore = (wouldBeResource -  guaranteedGenericResources.getOrDefault(resource, 0.0)) / available;\n+                ret = Math.max(ret, thisScore);\n+            }\n+\n+            return ret;\n+        }\n+\n+        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {\n+            TopologyDetails td = getNextHighest();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzMwMA=="}, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE1MzkzMg==", "bodyText": "Thank you - I figured that was why - just wanted to be sure I wasn't missing anything", "url": "https://github.com/apache/storm/pull/3213#discussion_r409153932", "createdAt": "2020-04-15T21:48:09Z", "author": {"login": "govind-menon"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/priority/GenericResourceAwareSchedulingPriorityStrategy.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.storm.scheduler.resource.strategies.priority;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.storm.scheduler.ISchedulingState;\n+import org.apache.storm.scheduler.TopologyDetails;\n+import org.apache.storm.scheduler.resource.User;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GenericResourceAwareSchedulingPriorityStrategy extends DefaultSchedulingPriorityStrategy {\n+    private static final Logger LOG = LoggerFactory.getLogger(GenericResourceAwareSchedulingPriorityStrategy.class);\n+\n+    @Override\n+    protected GrasSimulatedUser getSimulatedUserFor(User u, ISchedulingState cluster) {\n+        return new GrasSimulatedUser(u, cluster);\n+    }\n+\n+    @Override\n+    public List<TopologyDetails> getOrderedTopologies(ISchedulingState cluster, Map<String, User> userMap) {\n+        double cpuAvail = cluster.getClusterTotalCpuResource();\n+        double memAvail = cluster.getClusterTotalMemoryResource();\n+        Map<String, Double> genericAvail = cluster.getClusterTotalGenericResources();\n+\n+        List<TopologyDetails> allUserTopologies = new ArrayList<>();\n+        List<GrasSimulatedUser> users = new ArrayList<>();\n+\n+        for (User u : userMap.values()) {\n+            users.add(getSimulatedUserFor(u, cluster));\n+        }\n+\n+        while (!users.isEmpty()) {\n+            Collections.sort(users, new GrasSimulatedUserComparator(cpuAvail, memAvail, genericAvail));\n+            GrasSimulatedUser u = users.get(0);\n+            TopologyDetails td = u.getNextHighest();\n+            if (td == null) {\n+                users.remove(0);\n+            } else {\n+                double score = u.getScore(cpuAvail, memAvail, genericAvail);\n+                td = u.simScheduleNextHighest();\n+                LOG.info(\"GRAS SIM Scheduling {} with score of {}\", td.getId(), score);\n+                cpuAvail -= td.getTotalRequestedCpu();\n+                memAvail -= (td.getTotalRequestedMemOffHeap() + td.getTotalRequestedMemOnHeap());\n+                for (Map.Entry<String, Double> entry : td.getTotalRequestedGenericResources().entrySet()) {\n+                    String resource = entry.getKey();\n+                    Double requestedAmount = entry.getValue();\n+                    if (!genericAvail.containsKey(resource)) {\n+                        LOG.warn(\"Resource: {} is not supported in this cluster. Ignoring this request.\", resource);\n+                    } else {\n+                        genericAvail.put(resource, genericAvail.get(resource) - requestedAmount);\n+                    }\n+                }\n+                allUserTopologies.add(td);\n+            }\n+        }\n+        return allUserTopologies;\n+    }\n+\n+    protected static class GrasSimulatedUser extends SimulatedUser {\n+\n+        // Extend support for Generic Resources in addition to CPU and Memory\n+        public final Map<String, Double> guaranteedGenericResources;                // resource name : guaranteed amount\n+        private Map<String, Double> assignedGenericResources = new HashMap<>();     // resource name : assigned amount\n+\n+        public GrasSimulatedUser(User other, ISchedulingState cluster) {\n+            super(other, cluster);\n+\n+            Map<String, Double> guaranteedGenericResources = new HashMap<>();\n+            // generic resource types that are offered\n+            Set<String> availGenericResourceTypes = cluster.getClusterTotalGenericResources().keySet();\n+            for (String resourceType : availGenericResourceTypes) {\n+                Double guaranteedAmount = other.getGenericGuaranteed().getOrDefault(resourceType, 0.0);\n+                guaranteedGenericResources.put(resourceType, guaranteedAmount);\n+            }\n+            this.guaranteedGenericResources = guaranteedGenericResources;\n+        }\n+\n+        @Override\n+        public TopologyDetails simScheduleNextHighest() {\n+            TopologyDetails td = super.simScheduleNextHighest();\n+            Map<String, Double> tdRequestedGenericResource = td.getTotalRequestedGenericResources();\n+            for (Map.Entry<String, Double> entry : tdRequestedGenericResource.entrySet()) {\n+                String resource = entry.getKey();\n+                Double requestedAmount = entry.getValue();\n+                assignedGenericResources.put(resource, assignedGenericResources.getOrDefault(resource, 0.0) + requestedAmount);\n+            }\n+            return td;\n+        }\n+\n+        /**\n+         * Get a score for the simulated user.  This is used to sort the users, by their highest priority topology.\n+         * Only give user guarantees that will not exceed cluster capacity.\n+         * Score of each resource type is calculated as: (Requested + Assigned - Guaranteed)/clusterAvailable\n+         * The final score is a max over all resource types.\n+         * Topology score will fall into the following intervals if:\n+         *      User is under quota (guarantee):                    [(-guarantee)/available : 0]\n+         *      User is over quota:                                 (0, infinity)\n+         * Unfortunately, score below 0 does not guarantee that the topology will be scheduled due to resources fragmentation.\n+         * @param availableCpu available CPU on the cluster.\n+         * @param availableMemory available memory on the cluster.\n+         * @param availableGenericResources available generic resources (other that cpu and memory) in cluster\n+         * @param td the topology we are looking at.\n+         * @return the score.\n+         */\n+        protected double getScore(double availableCpu, double availableMemory,\n+                                  Map<String, Double> availableGenericResources, TopologyDetails td) {\n+            // calculate scores for cpu and memory first\n+            double ret = super.getScore(availableCpu, availableMemory, td);\n+            if (ret == Double.MAX_VALUE) {\n+                return ret;\n+            }\n+            Map<String, Double> tdTotalRequestedGeneric = td.getTotalRequestedGenericResources();\n+            if (tdTotalRequestedGeneric == null) {\n+                tdTotalRequestedGeneric = Collections.emptyMap();\n+            }\n+            for (Map.Entry<String, Double> entry : availableGenericResources.entrySet()) {\n+                String resource = entry.getKey();\n+                Double available = entry.getValue();\n+                if (available <= 0) {\n+                    return Double.MAX_VALUE;\n+                }\n+                Double wouldBeResource = assignedGenericResources.getOrDefault(resource, 0.0)\n+                    + tdTotalRequestedGeneric.getOrDefault(resource, 0.0);\n+                double thisScore = (wouldBeResource -  guaranteedGenericResources.getOrDefault(resource, 0.0)) / available;\n+                ret = Math.max(ret, thisScore);\n+            }\n+\n+            return ret;\n+        }\n+\n+        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {\n+            TopologyDetails td = getNextHighest();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNzMwMA=="}, "originalCommit": {"oid": "b300f1314f818bb283b1c6e33437689b8e1c8f65"}, "originalPosition": 157}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4367, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}