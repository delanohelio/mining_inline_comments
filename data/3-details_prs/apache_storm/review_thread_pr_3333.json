{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMDQyNjE5", "number": 3333, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMToxNzo0NVrOEo1ecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMToxNzo0NVrOEo1ecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjU0NjQyOnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/stats/BoltExecutorStats.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMToxNzo0NVrOHaKHsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDozNzo0NlrOHag0Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MDgzMg==", "bodyText": "TEN_MIN_IN_SECONDS_STR can be a constant in this class itself.  But this is not important.", "url": "https://github.com/apache/storm/pull/3333#discussion_r497190832", "createdAt": "2020-09-30T01:17:45Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/stats/BoltExecutorStats.java", "diffHunk": "@@ -53,10 +58,53 @@ public void cleanupStats() {\n         super.cleanupStats();\n     }\n \n-    public void boltExecuteTuple(String component, String stream, long latencyMs) {\n+    public void boltExecuteTuple(String component, String stream, long latencyMs, long workerUptimeSecs,\n+                                 Task firstExecutorTask) {\n         List key = Lists.newArrayList(component, stream);\n         this.getExecuted().incBy(key, this.rate);\n         this.getExecuteLatencies().record(key, latencyMs);\n+\n+        // Calculate capacity:  This is really for the whole executor, but we will use the executor's first task\n+        // for reporting the metric.\n+        double capacity = calculateCapacity(workerUptimeSecs);\n+        firstExecutorTask.getTaskMetrics().setCapacity(capacity);\n+    }\n+\n+    private double calculateCapacity(long workerUptimeSecs) {\n+        if (workerUptimeSecs > 0) {\n+            Map<String, Double> execAvg = valueStat(this.getExecuteLatencies()).get(MultiCountStat.TEN_MIN_IN_SECONDS_STR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80a4939d75bb7cb3bd7efda6f9cf38ca2211f5de"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyNTI3Nw==", "bodyText": "I was going to use MultiCountStat.TEN_MIN_IN_SECONDS_STR to replace the one in StatsUtil, which is in storm-server for more general usage, but didn't replace the other usages to keep a smaller review.", "url": "https://github.com/apache/storm/pull/3333#discussion_r497525277", "createdAt": "2020-09-30T13:50:04Z", "author": {"login": "agresch"}, "path": "storm-client/src/jvm/org/apache/storm/stats/BoltExecutorStats.java", "diffHunk": "@@ -53,10 +58,53 @@ public void cleanupStats() {\n         super.cleanupStats();\n     }\n \n-    public void boltExecuteTuple(String component, String stream, long latencyMs) {\n+    public void boltExecuteTuple(String component, String stream, long latencyMs, long workerUptimeSecs,\n+                                 Task firstExecutorTask) {\n         List key = Lists.newArrayList(component, stream);\n         this.getExecuted().incBy(key, this.rate);\n         this.getExecuteLatencies().record(key, latencyMs);\n+\n+        // Calculate capacity:  This is really for the whole executor, but we will use the executor's first task\n+        // for reporting the metric.\n+        double capacity = calculateCapacity(workerUptimeSecs);\n+        firstExecutorTask.getTaskMetrics().setCapacity(capacity);\n+    }\n+\n+    private double calculateCapacity(long workerUptimeSecs) {\n+        if (workerUptimeSecs > 0) {\n+            Map<String, Double> execAvg = valueStat(this.getExecuteLatencies()).get(MultiCountStat.TEN_MIN_IN_SECONDS_STR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MDgzMg=="}, "originalCommit": {"oid": "80a4939d75bb7cb3bd7efda6f9cf38ca2211f5de"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MjcxNQ==", "bodyText": "There is another similar class MultiLatencyStat. It doesn't feel right to use MultiCountStat.TEN_MIN_IN_SECONDS_STR for MultiLatencyStat. But this is just personal preference and we can leave this to the future. I am okay with current change.", "url": "https://github.com/apache/storm/pull/3333#discussion_r497562715", "createdAt": "2020-09-30T14:37:46Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/stats/BoltExecutorStats.java", "diffHunk": "@@ -53,10 +58,53 @@ public void cleanupStats() {\n         super.cleanupStats();\n     }\n \n-    public void boltExecuteTuple(String component, String stream, long latencyMs) {\n+    public void boltExecuteTuple(String component, String stream, long latencyMs, long workerUptimeSecs,\n+                                 Task firstExecutorTask) {\n         List key = Lists.newArrayList(component, stream);\n         this.getExecuted().incBy(key, this.rate);\n         this.getExecuteLatencies().record(key, latencyMs);\n+\n+        // Calculate capacity:  This is really for the whole executor, but we will use the executor's first task\n+        // for reporting the metric.\n+        double capacity = calculateCapacity(workerUptimeSecs);\n+        firstExecutorTask.getTaskMetrics().setCapacity(capacity);\n+    }\n+\n+    private double calculateCapacity(long workerUptimeSecs) {\n+        if (workerUptimeSecs > 0) {\n+            Map<String, Double> execAvg = valueStat(this.getExecuteLatencies()).get(MultiCountStat.TEN_MIN_IN_SECONDS_STR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MDgzMg=="}, "originalCommit": {"oid": "80a4939d75bb7cb3bd7efda6f9cf38ca2211f5de"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4204, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}