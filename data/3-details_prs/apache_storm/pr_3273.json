{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNjM0Mzcw", "number": 3273, "title": "[STORM-3638] Add fast process liveness check", "bodyText": "What is the purpose of the change\nWhen checking if all processes are dead, each process is checked by issuing a \"ps\" or \"tasklist\" command. This command uses LDAP integration in Linux to determine user. When LDAP is slow, this\nprocess overall response time is slow.\n(Explain why we should have this change)\nThis change checks all processes in a single command, and thus avoid expensive subprocess invocations. For POSIX systems, and additional speedup is achieved using cached mapping of USER to UID mapping and using uid to determine liveness. The latter avoid LDAP hits altogether and avoid LDAP timeouts.\nHow was the change tested\nA new test ContainerTest.testIsAnyProcessAlive() was written to test both the positive and negative cases. Additional test testGetUserId() checks correctness of getUserId. One more test ContainerTest.testIsProcessAlive() also tests prior functions which have been modified and did not have any tests. This uncovered problems in those methods when executing on Mac.\n(Explain what tests did you do to verify the code change)\n(1) Randomly generate a 12 character user which should not own any process. The method isAnyProcessProcessAlive() should return false when supplied the list of running PIDs.\n(2) Call isAnyProcessAlive() with all the currently running PIDs and supply the current user. Since the current user owns one process (the test itself), this should return true.", "createdAt": "2020-05-21T23:18:03Z", "url": "https://github.com/apache/storm/pull/3273", "merged": true, "mergeCommit": {"oid": "5c8d2fb85d7a1e86b0f1f31246d6376f835f9e86"}, "closed": true, "closedAt": "2020-06-08T14:16:53Z", "author": {"login": "bipinprasad"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjmCRFAH2gAyNDIxNjM0MzcwOjA0YjY5MGQ4NjFjMjJkMWE5NWFmOGI1YWRkMmUxNzRiODU5MGFiZjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcn-9DqAFqTQyNDUwOTgxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/04b690d861c22d1a95af8b5add2e174b8590abf7", "committedDate": "2020-05-21T23:12:18Z", "message": "[STORM-3638] Add fast process checking."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTYyNzY5", "url": "https://github.com/apache/storm/pull/3273#pullrequestreview-422962769", "createdAt": "2020-06-02T18:46:32Z", "commit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxODo0NjozMlrOGd_frw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTozNjozNVrOGeBNgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwMjE5MQ==", "bodyText": "This doesn't seem needed", "url": "https://github.com/apache/storm/pull/3273#discussion_r434102191", "createdAt": "2020-06-02T18:46:32Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -62,12 +67,14 @@\n  * Represents a container that a worker will run in.\n  */\n public abstract class Container implements Killable {\n+    public static final boolean IS_ON_WINDOWS = \"Windows_NT\".equals(System.getenv(\"OS\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTA0MQ==", "bodyText": "can be simplified with StringUtils.join(pids, ',');", "url": "https://github.com/apache/storm/pull/3273#discussion_r434109041", "createdAt": "2020-06-02T18:59:00Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTE2Mw==", "bodyText": "here too", "url": "https://github.com/apache/storm/pull/3273#discussion_r434109163", "createdAt": "2020-06-02T18:59:12Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTIyNw==", "bodyText": "here too", "url": "https://github.com/apache/storm/pull/3273#discussion_r434109227", "createdAt": "2020-06-02T18:59:19Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o user -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified UID.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDk2OA==", "bodyText": "processed --> processes", "url": "https://github.com/apache/storm/pull/3273#discussion_r434124968", "createdAt": "2020-06-02T19:26:34Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o user -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified UID.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o uid -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"uid\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"UID\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain UID, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                try {\n+                    if (uid == Integer.parseInt(line)) {\n+                        return true;\n+                    }\n+                } catch (Exception ex) {\n+                    LOG.warn(\"Expecting UID integer but got {} in output of ps command\", line);\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o uid -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as UIDs {}: but expected userId is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), uid);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get the userId for a user name. This works on Posix systems by using \"id -u\" command.\n+     * Throw IllegalArgumentException on Windows.\n+     *\n+     * @param user username to be converted to UID. This is optional, in which case current user is returned.\n+     * @return UID for the specified user (if supplied), else UID of current user, -1 upon Exception.\n+     */\n+    public static int getUserId(String user) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"id\");\n+        cmdArgs.add(\"-u\");\n+        if (user != null && !user.isEmpty()) {\n+            cmdArgs.add(user);\n+        }\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#1: {}\", line);\n+            try {\n+                return Integer.parseInt(line.trim());\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting UID integer but got {} in output of \\\"id -u {}\\\" command\", line, user);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs)), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get the userId of the onwer of the path by running \"ls -n path\" command.\n+     * This command works on Posix systems only.\n+     *\n+     * @param fpath full path to the file.\n+     * @return UID for the specified if successful, -1 upon failure.\n+     */\n+    public static int getPathOwnerUId(String fpath) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        File f = new File(fpath);\n+        if (!f.exists()) {\n+            LOG.error(\"Cannot determine owner of non-existent file {}\", fpath);\n+            return -1;\n+        }\n+        LOG.debug(\"CMD: ls -n {}\", fpath);\n+        ProcessBuilder pb = new ProcessBuilder(\"ls\", \"-n\", fpath);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-OUTLINE: {}\", line);\n+            line = line.trim();\n+            String[] parts = line.split(\"\\\\s+\");\n+            if (parts.length < 3) {\n+                LOG.error(\"Expecting at least 3 space separated fields in \\\"ls -n {}\\\" output, got {}\", fpath, line);\n+                return -1;\n+            }\n+            try {\n+                return Integer.parseInt(parts[2]);\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting at third field {} to be numeric UID \\\"ls -n {}\\\" output, got {}\", parts[2], fpath, line);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"ls -n %s\\\"\", fpath), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get UID of the owner to the workerId PIDs Root directory.\n+     *\n+     * @return User ID (UID) of owner of the PID file, -1 if file is missing.\n+     */\n+    private int getPidPathOwnerUid(String workerId, long pid) {\n+        return getPathOwnerUId(ConfigUtils.workerPidPath(conf, workerId, pid));\n+    }\n+\n+    /**\n+     * Find if all processed for the user on workId are dead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNzk3NA==", "bodyText": "We don't have to check the owner of pid file. Checking the owner of the worker-id directory should be good enough.", "url": "https://github.com/apache/storm/pull/3273#discussion_r434127974", "createdAt": "2020-06-02T19:32:15Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o user -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified UID.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o uid -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"uid\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"UID\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain UID, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                try {\n+                    if (uid == Integer.parseInt(line)) {\n+                        return true;\n+                    }\n+                } catch (Exception ex) {\n+                    LOG.warn(\"Expecting UID integer but got {} in output of ps command\", line);\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o uid -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as UIDs {}: but expected userId is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), uid);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get the userId for a user name. This works on Posix systems by using \"id -u\" command.\n+     * Throw IllegalArgumentException on Windows.\n+     *\n+     * @param user username to be converted to UID. This is optional, in which case current user is returned.\n+     * @return UID for the specified user (if supplied), else UID of current user, -1 upon Exception.\n+     */\n+    public static int getUserId(String user) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"id\");\n+        cmdArgs.add(\"-u\");\n+        if (user != null && !user.isEmpty()) {\n+            cmdArgs.add(user);\n+        }\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#1: {}\", line);\n+            try {\n+                return Integer.parseInt(line.trim());\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting UID integer but got {} in output of \\\"id -u {}\\\" command\", line, user);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs)), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get the userId of the onwer of the path by running \"ls -n path\" command.\n+     * This command works on Posix systems only.\n+     *\n+     * @param fpath full path to the file.\n+     * @return UID for the specified if successful, -1 upon failure.\n+     */\n+    public static int getPathOwnerUId(String fpath) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        File f = new File(fpath);\n+        if (!f.exists()) {\n+            LOG.error(\"Cannot determine owner of non-existent file {}\", fpath);\n+            return -1;\n+        }\n+        LOG.debug(\"CMD: ls -n {}\", fpath);\n+        ProcessBuilder pb = new ProcessBuilder(\"ls\", \"-n\", fpath);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-OUTLINE: {}\", line);\n+            line = line.trim();\n+            String[] parts = line.split(\"\\\\s+\");\n+            if (parts.length < 3) {\n+                LOG.error(\"Expecting at least 3 space separated fields in \\\"ls -n {}\\\" output, got {}\", fpath, line);\n+                return -1;\n+            }\n+            try {\n+                return Integer.parseInt(parts[2]);\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting at third field {} to be numeric UID \\\"ls -n {}\\\" output, got {}\", parts[2], fpath, line);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"ls -n %s\\\"\", fpath), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get UID of the owner to the workerId PIDs Root directory.\n+     *\n+     * @return User ID (UID) of owner of the PID file, -1 if file is missing.\n+     */\n+    private int getPidPathOwnerUid(String workerId, long pid) {\n+        return getPathOwnerUId(ConfigUtils.workerPidPath(conf, workerId, pid));\n+    }\n+\n+    /**\n+     * Find if all processed for the user on workId are dead.\n+     * This method attempts to optimize the calls by:\n+     * <p>\n+     *     <li>creating a collection of ProcessIds and checking all of them at once</li>\n+     *     <li>using userId one Posix systems instead of user</li>\n+     * </p>\n+     *\n+     * @return true if all processes for the user are dead on the worker\n+     * @throws IOException if external commands have exception.\n+     */\n     @Override\n     public boolean areAllProcessesDead() throws IOException {\n         Set<Long> pids = getAllPids();\n         String user = getRunWorkerAsUser();\n \n         boolean allDead = true;\n-        for (Long pid : pids) {\n-            LOG.debug(\"Checking if pid {} owner {} is alive\", pid, user);\n-            if (!isProcessAlive(pid, user)) {\n-                LOG.debug(\"{}: PID {} is dead\", workerId, pid);\n+        try {\n+            if (pids.isEmpty()) {\n+                return true;\n+            }\n+            if (ServerUtils.IS_ON_WINDOWS) {\n+                return allDead = !isAnyProcessAlive(pids, user);\n+            }\n+            // optimized for Posix - try to use uid\n+            if (!cachedUserToUidMap.containsKey(user)) {\n+                int uid = getPidPathOwnerUid(workerId, pids.iterator().next());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 451}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTA5Mg==", "bodyText": "This is not the Assert we want to use I suppose.", "url": "https://github.com/apache/storm/pull/3273#discussion_r434129092", "createdAt": "2020-06-02T19:34:12Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/daemon/supervisor/ContainerTest.java", "diffHunk": "@@ -13,24 +13,34 @@\n package org.apache.storm.daemon.supervisor;\n \n import com.google.common.base.Joiner;\n+\n+import java.io.BufferedReader;\n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStreamReader;\n import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.logging.log4j.core.util.Assert;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTk1NQ==", "bodyText": "why not import org.junit.Assert  to make this line cleaner", "url": "https://github.com/apache/storm/pull/3273#discussion_r434129955", "createdAt": "2020-06-02T19:35:54Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/daemon/supervisor/ContainerTest.java", "diffHunk": "@@ -271,4 +281,88 @@ public boolean runProfiling(ProfileRequest request, boolean stop) throws IOExcep\n             return false;\n         }\n     }\n+\n+    private Collection<Long> getRunningProcessIds() throws IOException {\n+        // get list of few running processes\n+        Collection<Long> pids = new ArrayList<>();\n+        Process p = Runtime.getRuntime().exec(ServerUtils.IS_ON_WINDOWS ? \"tasklist\" : \"ps -e\");\n+        try (BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String line;\n+            while ((line = input.readLine()) != null) {\n+                line = line.trim();\n+                if (line.isEmpty()) {\n+                    continue;\n+                }\n+                try {\n+                    pids.add(Long.parseLong(line.split(\"\\\\s\")[0]));\n+                } catch (Exception ex) {\n+                    continue;\n+                }\n+            }\n+        }\n+        return pids;\n+    }\n+\n+    @Test\n+    public void testIsProcessAlive() throws Exception {\n+        // specific selected process should be alive for a randomly generated user\n+        String randomUser = RandomStringUtils.randomAlphanumeric(12);\n+\n+        // get list of few running processes\n+        Collection<Long> pids = getRunningProcessIds();\n+        Assert.isNonEmpty(pids);\n+        for (long pid: pids) {\n+            boolean status = Container.isProcessAlive(pid, randomUser);\n+            org.junit.Assert.assertFalse(\"Random user \" + randomUser + \" is not expected to own any process\", status);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMDMwNQ==", "bodyText": "should \"not\" be alive?", "url": "https://github.com/apache/storm/pull/3273#discussion_r434130305", "createdAt": "2020-06-02T19:36:35Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/daemon/supervisor/ContainerTest.java", "diffHunk": "@@ -271,4 +281,88 @@ public boolean runProfiling(ProfileRequest request, boolean stop) throws IOExcep\n             return false;\n         }\n     }\n+\n+    private Collection<Long> getRunningProcessIds() throws IOException {\n+        // get list of few running processes\n+        Collection<Long> pids = new ArrayList<>();\n+        Process p = Runtime.getRuntime().exec(ServerUtils.IS_ON_WINDOWS ? \"tasklist\" : \"ps -e\");\n+        try (BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String line;\n+            while ((line = input.readLine()) != null) {\n+                line = line.trim();\n+                if (line.isEmpty()) {\n+                    continue;\n+                }\n+                try {\n+                    pids.add(Long.parseLong(line.split(\"\\\\s\")[0]));\n+                } catch (Exception ex) {\n+                    continue;\n+                }\n+            }\n+        }\n+        return pids;\n+    }\n+\n+    @Test\n+    public void testIsProcessAlive() throws Exception {\n+        // specific selected process should be alive for a randomly generated user", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fea038ad4f9f1308f74aafacdb49eee811341df", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/2fea038ad4f9f1308f74aafacdb49eee811341df", "committedDate": "2020-06-04T13:09:12Z", "message": "[STORM-3638] Fix comment; use StringUtils.join ; check owner of worker-root instead of pid; use org.junit.Assert in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e90dffb08712f06084bdb870145c78d858abbb93", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/e90dffb08712f06084bdb870145c78d858abbb93", "committedDate": "2020-06-04T13:09:52Z", "message": "[STORM-3638] Fix comment; use StringUtils.join ; check owner of worker-root instead of pid; use org.junit.Assert in test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NTA5ODE4", "url": "https://github.com/apache/storm/pull/3273#pullrequestreview-424509818", "createdAt": "2020-06-04T14:29:56Z", "commit": {"oid": "e90dffb08712f06084bdb870145c78d858abbb93"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4585, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}