{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NzI3Mjk3", "number": 3322, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1MjowOVrOEXy3rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMjoxMlrOEfe8uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMzg2MTU3OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1MjowOVrOG_ybAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTo0MzozM1rOHARcHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTU4Ng==", "bodyText": "The topology here must be a userTopology (if it is a system topology, it will have loops because of ackers).\nSo I think we don't need to check Utils.isSystemId. And we don't need to get_inputs on spout since it will be empty. (see https://github.com/apache/storm/blob/master/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java#L162-L166)", "url": "https://github.com/apache/storm/pull/3322#discussion_r469539586", "createdAt": "2020-08-12T20:52:09Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0Nzc3NQ==", "bodyText": "I wondered about the code in TopologyDetails.getComponents() - but seems superfluous. I will remove the get_inputs on spout and check for isSystemId check.", "url": "https://github.com/apache/storm/pull/3322#discussion_r470047775", "createdAt": "2020-08-13T15:43:33Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTU4Ng=="}, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDAxMDkyOnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo0MDoxOVrOG_z1AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjowMjozMVrOHASMig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MjYyNQ==", "bodyText": "can we use non-stateful bolt? We don't really use it anywhere. And it will insert some bolts into the topology. So the unit test result might be hard to understand. For example, like https://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/scheduler/resource/TestResourceAwareScheduler.java#L200-L201", "url": "https://github.com/apache/storm/pull/3322#discussion_r469562625", "createdAt": "2020-08-12T21:40:19Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +254,184 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName;\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            private IRichSpout makeDummySpout() {\n+                return new BaseRichSpout() {\n+                    @Override\n+                    public void declareOutputFields(OutputFieldsDeclarer declarer) {\n+                    }\n+\n+                    @Override\n+                    public void open(Map<String, Object> conf, TopologyContext context, SpoutOutputCollector collector) {\n+                    }\n+\n+                    @Override\n+                    public void nextTuple() {\n+                    }\n+\n+                    private void writeObject(java.io.ObjectOutputStream stream) {\n+                    }\n+                };\n+            }\n+\n+            private IStatefulBolt makeDummyStatefulBolt() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2MDE3MA==", "bodyText": "Replaced with TestWordSpout and TestWordCounter", "url": "https://github.com/apache/storm/pull/3322#discussion_r470060170", "createdAt": "2020-08-13T16:02:31Z", "author": {"login": "bipinprasad"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +254,184 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName;\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            private IRichSpout makeDummySpout() {\n+                return new BaseRichSpout() {\n+                    @Override\n+                    public void declareOutputFields(OutputFieldsDeclarer declarer) {\n+                    }\n+\n+                    @Override\n+                    public void open(Map<String, Object> conf, TopologyContext context, SpoutOutputCollector collector) {\n+                    }\n+\n+                    @Override\n+                    public void nextTuple() {\n+                    }\n+\n+                    private void writeObject(java.io.ObjectOutputStream stream) {\n+                    }\n+                };\n+            }\n+\n+            private IStatefulBolt makeDummyStatefulBolt() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MjYyNQ=="}, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDAxMzMyOnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo0MTowNlrOG_z2ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzozMTo1MFrOHAWBlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mjk4MQ==", "bodyText": "This seems repeating the log message in validateConfs, and can be probably removed.", "url": "https://github.com/apache/storm/pull/3322#discussion_r469562981", "createdAt": "2020-08-12T21:41:06Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));\n+            return ret;\n+        }\n+\n+        Set<String> unreachable = new HashSet<>(edgesOut.keySet());\n+        topology.get_spouts().forEach((spoutId, spout)  -> {\n+            Stack<String> dfsStack = new Stack<>();\n+            dfsStack.push(spoutId);\n+            Set<String> seen = new HashSet<>();\n+            seen.add(spoutId);\n+            findComponentCyclesRecursion(dfsStack, edgesOut, seen, ret);\n+            unreachable.removeAll(seen);\n+        });\n+\n+        // warning about unreachable components\n+        if (!unreachable.isEmpty()) {\n+            LOG.warn(\"Topology {} contains unreachable components \\\"{}\\\"\", topoId, String.join(\",\", unreachable));\n+        }\n+\n+        // detected cycles\n+        if (!ret.isEmpty()) {\n+            LOG.error(\"Topology {} contains cycles {}\", topoId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMjkwMQ==", "bodyText": "removed", "url": "https://github.com/apache/storm/pull/3322#discussion_r470122901", "createdAt": "2020-08-13T17:31:50Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));\n+            return ret;\n+        }\n+\n+        Set<String> unreachable = new HashSet<>(edgesOut.keySet());\n+        topology.get_spouts().forEach((spoutId, spout)  -> {\n+            Stack<String> dfsStack = new Stack<>();\n+            dfsStack.push(spoutId);\n+            Set<String> seen = new HashSet<>();\n+            seen.add(spoutId);\n+            findComponentCyclesRecursion(dfsStack, edgesOut, seen, ret);\n+            unreachable.removeAll(seen);\n+        });\n+\n+        // warning about unreachable components\n+        if (!unreachable.isEmpty()) {\n+            LOG.warn(\"Topology {} contains unreachable components \\\"{}\\\"\", topoId, String.join(\",\", unreachable));\n+        }\n+\n+        // detected cycles\n+        if (!ret.isEmpty()) {\n+            LOG.error(\"Topology {} contains cycles {}\", topoId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mjk4MQ=="}, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDAxNDE2OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo0MToyOVrOG_z3Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNjowNDo0M1rOHASSAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MzEzOA==", "bodyText": "Looks like this needs to be tmp = tmp.subList(prevIdx, tmp.size()); otherwise the result will not be accurate", "url": "https://github.com/apache/storm/pull/3322#discussion_r469563138", "createdAt": "2020-08-12T21:41:29Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2MTU2OA==", "bodyText": "fixed", "url": "https://github.com/apache/storm/pull/3322#discussion_r470061568", "createdAt": "2020-08-13T16:04:43Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MzEzOA=="}, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDEwNzE4OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjoxNjoyMVrOG_0uaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNzozNjozNFrOHAWSbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NzMyMA==", "bodyText": "I haven't read the complete implementation of findComponentCycles. But there seems to be an issue on detecting complex cycles.\n tb = new TopologyBuilder();\n                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n                    tb.setSpout(\"spout2\", new TestWordSpout(), 10);\n                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\").shuffleGrouping(\"spout2\");\n\nThe result ( is\n contains cycles bolt3,bolt4 ; spout2,bolt4,bolt3\n\nspout2 shouldn't be in the result. Please let me know if I am doing anything wrong.", "url": "https://github.com/apache/storm/pull/3322#discussion_r469577320", "createdAt": "2020-08-12T22:16:21Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3NDM3Mw==", "bodyText": "This specific result will be fixed by the tmp.sublist.\nHowever, I am wondering if this will misclassify diamonds as a cycle (undesired), in which case, the code should be changed to require that #1974 be true for cycles.", "url": "https://github.com/apache/storm/pull/3322#discussion_r470074373", "createdAt": "2020-08-13T16:25:50Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NzMyMA=="}, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyNzIxMg==", "bodyText": "Added the complex cycle(s) test case. Exclude diamond connections from loops.", "url": "https://github.com/apache/storm/pull/3322#discussion_r470127212", "createdAt": "2020-08-13T17:36:34Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NzMyMA=="}, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzgyNDMxOnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDo0NjozNlrOHKIp9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo1Mzo1N1rOHKMctA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4OTYyMw==", "bodyText": "Should this be \"Three Level\" component hierarchy?", "url": "https://github.com/apache/storm/pull/3322#discussion_r480389623", "createdAt": "2020-08-31T20:46:36Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MTc2NA==", "bodyText": "Yes. Fixed.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480451764", "createdAt": "2020-08-31T22:53:57Z", "author": {"login": "bipinprasad"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4OTYyMw=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzgzMzI3OnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDo0OTo0MFrOHKIvdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjo1NDo1OVrOHKMf6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MTAyOQ==", "bodyText": "The description seems incorrect.\nIt should be\n // (S1 -> B1 -> B2 -> B3 -> B4 <- S2), (B4 -> B3), (B4 -> B1)", "url": "https://github.com/apache/storm/pull/3322#discussion_r480391029", "createdAt": "2020-08-31T20:49:40Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // single loop with three bolts\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3,bolt4,bolt5\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // two loops with three bolts, and one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    // loop bolt 6  (also connect bolt6 to spout 1)\n+                    tb.setBolt(\"bolt6\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt6\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) Two Loops\", testNo),\n+                            \"Four level component hierarchy with 2 cycles in bolt3,bolt4,bolt5 and bolt6\",\n+                            tb.createTopology(),\n+                            2));\n+                }\n+\n+                // complex cycle\n+                {\n+                    // (S1 -> B1 -> B2 -> B3 -> B4 <- S2), (B4 -> B3), (B4 -> B2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MjU4Nw==", "bodyText": "fixed", "url": "https://github.com/apache/storm/pull/3322#discussion_r480452587", "createdAt": "2020-08-31T22:54:59Z", "author": {"login": "bipinprasad"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // single loop with three bolts\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3,bolt4,bolt5\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // two loops with three bolts, and one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    // loop bolt 6  (also connect bolt6 to spout 1)\n+                    tb.setBolt(\"bolt6\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt6\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) Two Loops\", testNo),\n+                            \"Four level component hierarchy with 2 cycles in bolt3,bolt4,bolt5 and bolt6\",\n+                            tb.createTopology(),\n+                            2));\n+                }\n+\n+                // complex cycle\n+                {\n+                    // (S1 -> B1 -> B2 -> B3 -> B4 <- S2), (B4 -> B3), (B4 -> B2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MTAyOQ=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzg1NzM2OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDo1NzoyOFrOHKI-SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMjowNzowN1rOHKK2sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDgyNA==", "bodyText": "With a slightly modified test case,\n                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n                    tb.setSpout(\"spout2\", new TestWordSpout(), 10);\n                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt4\").shuffleGrouping(\"bolt2\");\n                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"spout2\");\n\nI am seeing\njava.lang.NullPointerException\n\tat org.apache.storm.utils.Utils.findComponentCyclesRecursion(Utils.java:1961)\n\tat org.apache.storm.utils.Utils.findComponentCyclesRecursion(Utils.java:1981)\n\nI am reading the code to try to figure out why", "url": "https://github.com/apache/storm/pull/3322#discussion_r480394824", "createdAt": "2020-08-31T20:57:28Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwODA5Nw==", "bodyText": "Fixed the NPE. But now I will add to randomly generate some topologies. To make sure that that this code is well exercised.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480408097", "createdAt": "2020-08-31T21:26:21Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDgyNA=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyNTY1MQ==", "bodyText": "Sounds good. I would add this test case too.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480425651", "createdAt": "2020-08-31T22:07:07Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDgyNA=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzg3MzYyOnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTowMjozMVrOHKJIBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTowNDoyM1rOHK6u_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NzMxNw==", "bodyText": "Comments  here and below need to be updated since the mapping only contains bolts.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480397317", "createdAt": "2020-08-31T21:02:31Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NjYzNw==", "bodyText": "Key can be bolt or spout. Value contains bolt ids only.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480446637", "createdAt": "2020-08-31T22:45:48Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NzMxNw=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIxMDEwOQ==", "bodyText": "okay", "url": "https://github.com/apache/storm/pull/3322#discussion_r481210109", "createdAt": "2020-09-01T15:04:23Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NzMxNw=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzg5ODE1OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMToxMDo0NFrOHKJW0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxMzoyNlrOHKNOeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMTEwNg==", "bodyText": "This doesn't mean it has cycles. We should separate them.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480401106", "createdAt": "2020-08-31T21:10:44Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    possibleCycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        // cycle (as opposed to diamond)\n+                        tmp = tmp.subList(prevIdx, tmp.size());\n+                        tmp.add(compId2);\n+                        possibleCycle.addAll(tmp);\n+                    }\n+                }\n+                if (!possibleCycle.isEmpty()) {\n+                    cycles.add(possibleCycle);\n+                    edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                    continue;\n+                }\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NDUwNA==", "bodyText": "Changed to return no cycle.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480464504", "createdAt": "2020-08-31T23:13:26Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    possibleCycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        // cycle (as opposed to diamond)\n+                        tmp = tmp.subList(prevIdx, tmp.size());\n+                        tmp.add(compId2);\n+                        possibleCycle.addAll(tmp);\n+                    }\n+                }\n+                if (!possibleCycle.isEmpty()) {\n+                    cycles.add(possibleCycle);\n+                    edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                    continue;\n+                }\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMTEwNg=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzkwNTE3OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMToxMjo1MlrOHKJa1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxNTowMFrOHM0Lig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA==", "bodyText": "I feel like this is not the right place to detect cycles.  We should probably put it in another function, like\nStormCommon.validateBasic\nhttps://git.vzbuilders.com/storm/storm/blob/master/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java#L156\nor create a new method.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480402134", "createdAt": "2020-08-31T21:12:52Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NjA3Mg==", "bodyText": "Created new method StormCommon.validateCycleFree", "url": "https://github.com/apache/storm/pull/3322#discussion_r481446072", "createdAt": "2020-09-01T21:36:39Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMTY1NA==", "bodyText": "Moving it to Utils is also okay, like\nUtils.validateTopologyBlobStoreMap\nUtils.validateTopologyName\netc.\nProbably makes more sense since findComponentCycles is implemented inside Utils.\nAnd we could make Utils.findComponentCycles \"@VisibleForTesting\". So the public method will be only Utils. validateCycleFree and the internal implementation can be changed if we'd like in the future.", "url": "https://github.com/apache/storm/pull/3322#discussion_r482121654", "createdAt": "2020-09-02T14:39:03Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM0Njk2Mw==", "bodyText": "@bipinprasad\nSorry for not being clear at the first comment. What do you think about moving it to Utils?^ Trying to not expose too many public methods.  Also StormCommon is org.apache.storm.daemon.StormCommon. StormSubmitter is completely on client side. I feel like Utils is a better place for this.", "url": "https://github.com/apache/storm/pull/3322#discussion_r482346963", "createdAt": "2020-09-02T19:34:36Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMjkzNw==", "bodyText": "Ok. Will switch.", "url": "https://github.com/apache/storm/pull/3322#discussion_r483112937", "createdAt": "2020-09-03T16:37:43Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5OTg4Mg==", "bodyText": "Moved from StormCommons to Utils.", "url": "https://github.com/apache/storm/pull/3322#discussion_r483199882", "createdAt": "2020-09-03T19:15:00Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ4MTE0OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMTozNVrOHLyBog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzowMzowOFrOHL4stw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjAwMg==", "bodyText": "Is this used anywhere?", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116002", "createdAt": "2020-09-02T14:31:35Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -51,6 +52,7 @@\n import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import sun.net.ProgressListener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyNTMzNQ==", "bodyText": "No. Will remove this.", "url": "https://github.com/apache/storm/pull/3322#discussion_r482225335", "createdAt": "2020-09-02T17:03:08Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -51,6 +52,7 @@\n import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import sun.net.ProgressListener;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjAwMg=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ4MTk2OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMTo0NlrOHLyCJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzo1Mjo1NlrOHL6sVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ==", "bodyText": "We should remove this", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116135", "createdAt": "2020-09-02T14:31:46Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);\n+            System.out.println(ex.get_msg());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMDIwOA==", "bodyText": "Did we not want to warn the user when submitting?", "url": "https://github.com/apache/storm/pull/3322#discussion_r482230208", "createdAt": "2020-09-02T17:09:08Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);\n+            System.out.println(ex.get_msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NTY3NA==", "bodyText": "LOG.warn should be sufficient. We don't need System.out.println()", "url": "https://github.com/apache/storm/pull/3322#discussion_r482255674", "createdAt": "2020-09-02T17:49:03Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);\n+            System.out.println(ex.get_msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1ODAwNA==", "bodyText": "ok. removed sysout.", "url": "https://github.com/apache/storm/pull/3322#discussion_r482258004", "createdAt": "2020-09-02T17:52:56Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);\n+            System.out.println(ex.get_msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDQ4Mzc2OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMjoxMlrOHLyDUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxOToxNDoxNVrOHM0KMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw==", "bodyText": "Will ex already contains ex.get_msg()? If so, we will see repeating messages, which should be avoid.", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116433", "createdAt": "2020-09-02T14:32:12Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMTkyMQ==", "bodyText": "The constructor seems to imply that the message will not be in the Exception, since the proper super method is not called.", "url": "https://github.com/apache/storm/pull/3322#discussion_r482231921", "createdAt": "2020-09-02T17:10:47Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NjMzMg==", "bodyText": "Do you have an output example that I can take a look?", "url": "https://github.com/apache/storm/pull/3322#discussion_r482256332", "createdAt": "2020-09-02T17:50:04Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MTcwMg==", "bodyText": "InvalidTopologyException constructor does not call Exception.super(msg): https://github.com/apache/storm/blob/master/storm-client/src/jvm/org/apache/storm/generated/InvalidTopologyException.java#L111\nhence, its msg variable is not available in the Exception.getMessage()", "url": "https://github.com/apache/storm/pull/3322#discussion_r482261702", "createdAt": "2020-09-02T17:59:20Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM0NjA4Nw==", "bodyText": "Right. So the log will look like\n19:22:23.981 [main] WARN  o.a.s.StormSubmitter - Topology wc contains cycles in components \"count,split\"\norg.apache.storm.generated.InvalidTopologyException: null\n\tat org.apache.storm.daemon.StormCommon.validateCycleFree(StormCommon.java:596) ~[storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.StormSubmitter.submitTopologyAs(StormSubmitter.java:244) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.StormSubmitter.submitTopology(StormSubmitter.java:214) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.StormSubmitter.submitTopology(StormSubmitter.java:177) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.topology.ConfigurableTopology.submit(ConfigurableTopology.java:119) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.starter.WordCountTopology.run(WordCountTopology.java:58) [storm-starter-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.topology.ConfigurableTopology.start(ConfigurableTopology.java:68) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.starter.WordCountTopology.main(WordCountTopology.java:36) [storm-starter-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\nWe can probably use WrappedInvalidTopologyException inside validateCycleFree method so the stacktrace will make more sense. What do you think?\nIt will be like\norg.apache.storm.utils.WrappedInvalidTopologyException: Topology wc2 contains cycles in components \"count,split\"\n\tat org.apache.storm.daemon.StormCommon.validateCycleFree(StormCommon.java:596) ~[storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\t.....", "url": "https://github.com/apache/storm/pull/3322#discussion_r482346087", "createdAt": "2020-09-02T19:33:56Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5OTUzNw==", "bodyText": "That is better than a scary \"null\" in the stack trace.\nChanged.", "url": "https://github.com/apache/storm/pull/3322#discussion_r483199537", "createdAt": "2020-09-03T19:14:15Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4184, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}