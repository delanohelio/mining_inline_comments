{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NzI3Mjk3", "number": 3322, "title": "[STORM-3685] Detect and prevent cycles when Topology is submitted.", "bodyText": "What is the purpose of the change\nTopology is expected to be a Directed Acyclic Graph. Cycles in component flow can cause unexpected behavior, for example a deadlock when one of the loop components signals a back-pressure. Or properly detecting proximity when scheduling.\nHow was the change tested\nNew test to create topology with and without cycles and test detection.", "createdAt": "2020-08-07T17:24:26Z", "url": "https://github.com/apache/storm/pull/3322", "merged": true, "mergeCommit": {"oid": "8399edcfbb06b484f7b06a08d4d75e0a2c8d4e86"}, "closed": true, "closedAt": "2020-09-04T14:23:06Z", "author": {"login": "bipinprasad"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8ns63AH2gAyNDY0NzI3Mjk3OmZmY2YxMTYxNWE1OTZiZmRiNTljMTI0YTNhN2MwNzI2OTc4MjMxZjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFl_jvAFqTQ4MjY5NDA4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ffcf11615a596bfdb59c124a3a7c0726978231f0", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/ffcf11615a596bfdb59c124a3a7c0726978231f0", "committedDate": "2020-08-07T17:16:54Z", "message": "[STORM-3685] Detect and prevent cycles when Topology is submitted."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "committedDate": "2020-08-07T17:57:57Z", "message": "[STORM-3685] Warn instead of rejecting Topology with cycles."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aefd3b3dda5f1c70868dc150c3dc925dcd23be56", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/aefd3b3dda5f1c70868dc150c3dc925dcd23be56", "committedDate": "2020-08-07T17:46:55Z", "message": "[STORM-3685] Warn instead of rejecting Topology with cycles."}, "afterCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "committedDate": "2020-08-07T17:57:57Z", "message": "[STORM-3685] Warn instead of rejecting Topology with cycles."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MjY4MjM1", "url": "https://github.com/apache/storm/pull/3322#pullrequestreview-466268235", "createdAt": "2020-08-12T20:52:09Z", "commit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDo1MjowOVrOG_ybAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMjoxNjoyMVrOG_0uaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTU4Ng==", "bodyText": "The topology here must be a userTopology (if it is a system topology, it will have loops because of ackers).\nSo I think we don't need to check Utils.isSystemId. And we don't need to get_inputs on spout since it will be empty. (see https://github.com/apache/storm/blob/master/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java#L162-L166)", "url": "https://github.com/apache/storm/pull/3322#discussion_r469539586", "createdAt": "2020-08-12T20:52:09Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MjYyNQ==", "bodyText": "can we use non-stateful bolt? We don't really use it anywhere. And it will insert some bolts into the topology. So the unit test result might be hard to understand. For example, like https://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/scheduler/resource/TestResourceAwareScheduler.java#L200-L201", "url": "https://github.com/apache/storm/pull/3322#discussion_r469562625", "createdAt": "2020-08-12T21:40:19Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +254,184 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName;\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            private IRichSpout makeDummySpout() {\n+                return new BaseRichSpout() {\n+                    @Override\n+                    public void declareOutputFields(OutputFieldsDeclarer declarer) {\n+                    }\n+\n+                    @Override\n+                    public void open(Map<String, Object> conf, TopologyContext context, SpoutOutputCollector collector) {\n+                    }\n+\n+                    @Override\n+                    public void nextTuple() {\n+                    }\n+\n+                    private void writeObject(java.io.ObjectOutputStream stream) {\n+                    }\n+                };\n+            }\n+\n+            private IStatefulBolt makeDummyStatefulBolt() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mjk4MQ==", "bodyText": "This seems repeating the log message in validateConfs, and can be probably removed.", "url": "https://github.com/apache/storm/pull/3322#discussion_r469562981", "createdAt": "2020-08-12T21:41:06Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));\n+            return ret;\n+        }\n+\n+        Set<String> unreachable = new HashSet<>(edgesOut.keySet());\n+        topology.get_spouts().forEach((spoutId, spout)  -> {\n+            Stack<String> dfsStack = new Stack<>();\n+            dfsStack.push(spoutId);\n+            Set<String> seen = new HashSet<>();\n+            seen.add(spoutId);\n+            findComponentCyclesRecursion(dfsStack, edgesOut, seen, ret);\n+            unreachable.removeAll(seen);\n+        });\n+\n+        // warning about unreachable components\n+        if (!unreachable.isEmpty()) {\n+            LOG.warn(\"Topology {} contains unreachable components \\\"{}\\\"\", topoId, String.join(\",\", unreachable));\n+        }\n+\n+        // detected cycles\n+        if (!ret.isEmpty()) {\n+            LOG.error(\"Topology {} contains cycles {}\", topoId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MzEzOA==", "bodyText": "Looks like this needs to be tmp = tmp.subList(prevIdx, tmp.size()); otherwise the result will not be accurate", "url": "https://github.com/apache/storm/pull/3322#discussion_r469563138", "createdAt": "2020-08-12T21:41:29Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NzMyMA==", "bodyText": "I haven't read the complete implementation of findComponentCycles. But there seems to be an issue on detecting complex cycles.\n tb = new TopologyBuilder();\n                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n                    tb.setSpout(\"spout2\", new TestWordSpout(), 10);\n                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\").shuffleGrouping(\"spout2\");\n\nThe result ( is\n contains cycles bolt3,bolt4 ; spout2,bolt4,bolt3\n\nspout2 shouldn't be in the result. Please let me know if I am doing anything wrong.", "url": "https://github.com/apache/storm/pull/3322#discussion_r469577320", "createdAt": "2020-08-12T22:16:21Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "committedDate": "2020-08-13T17:51:38Z", "message": "[STORM-3685] Exclude diamonds and add a complex cycle(s) test case."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4OTQyNTQ5", "url": "https://github.com/apache/storm/pull/3322#pullrequestreview-478942549", "createdAt": "2020-08-31T20:46:36Z", "commit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDo0NjozNlrOHKIp9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDo1NzoyOFrOHKI-SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4OTYyMw==", "bodyText": "Should this be \"Three Level\" component hierarchy?", "url": "https://github.com/apache/storm/pull/3322#discussion_r480389623", "createdAt": "2020-08-31T20:46:36Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MTAyOQ==", "bodyText": "The description seems incorrect.\nIt should be\n // (S1 -> B1 -> B2 -> B3 -> B4 <- S2), (B4 -> B3), (B4 -> B1)", "url": "https://github.com/apache/storm/pull/3322#discussion_r480391029", "createdAt": "2020-08-31T20:49:40Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // single loop with three bolts\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3,bolt4,bolt5\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // two loops with three bolts, and one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    // loop bolt 6  (also connect bolt6 to spout 1)\n+                    tb.setBolt(\"bolt6\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt6\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) Two Loops\", testNo),\n+                            \"Four level component hierarchy with 2 cycles in bolt3,bolt4,bolt5 and bolt6\",\n+                            tb.createTopology(),\n+                            2));\n+                }\n+\n+                // complex cycle\n+                {\n+                    // (S1 -> B1 -> B2 -> B3 -> B4 <- S2), (B4 -> B3), (B4 -> B2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDgyNA==", "bodyText": "With a slightly modified test case,\n                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n                    tb.setSpout(\"spout2\", new TestWordSpout(), 10);\n                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt4\").shuffleGrouping(\"bolt2\");\n                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"spout2\");\n\nI am seeing\njava.lang.NullPointerException\n\tat org.apache.storm.utils.Utils.findComponentCyclesRecursion(Utils.java:1961)\n\tat org.apache.storm.utils.Utils.findComponentCyclesRecursion(Utils.java:1981)\n\nI am reading the code to try to figure out why", "url": "https://github.com/apache/storm/pull/3322#discussion_r480394824", "createdAt": "2020-08-31T20:57:28Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4OTUyNjYz", "url": "https://github.com/apache/storm/pull/3322#pullrequestreview-478952663", "createdAt": "2020-08-31T21:02:31Z", "commit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMTowMjozMVrOHKJIBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMToxMjo1MlrOHKJa1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NzMxNw==", "bodyText": "Comments  here and below need to be updated since the mapping only contains bolts.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480397317", "createdAt": "2020-08-31T21:02:31Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMTEwNg==", "bodyText": "This doesn't mean it has cycles. We should separate them.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480401106", "createdAt": "2020-08-31T21:10:44Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    possibleCycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        // cycle (as opposed to diamond)\n+                        tmp = tmp.subList(prevIdx, tmp.size());\n+                        tmp.add(compId2);\n+                        possibleCycle.addAll(tmp);\n+                    }\n+                }\n+                if (!possibleCycle.isEmpty()) {\n+                    cycles.add(possibleCycle);\n+                    edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                    continue;\n+                }\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA==", "bodyText": "I feel like this is not the right place to detect cycles.  We should probably put it in another function, like\nStormCommon.validateBasic\nhttps://git.vzbuilders.com/storm/storm/blob/master/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java#L156\nor create a new method.", "url": "https://github.com/apache/storm/pull/3322#discussion_r480402134", "createdAt": "2020-08-31T21:12:52Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4117a14089b00e06ad514b4420ed4d4791229d27", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/4117a14089b00e06ad514b4420ed4d4791229d27", "committedDate": "2020-08-31T22:25:40Z", "message": "[STORM-3685] Fix NPE in a new test and add randomized 100 randomized topologies for cycle detection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a29dacf4b8ffa11d48ea752c9d9180757dbf4fb", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/4a29dacf4b8ffa11d48ea752c9d9180757dbf4fb", "committedDate": "2020-08-31T23:23:08Z", "message": "[STORM-3685] Missing spouts not signaled as error. Randomize spout/bolt connections counts. Fix topo comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/cc7a66d5c3771455926039cce900637b9350e800", "committedDate": "2020-09-01T21:40:43Z", "message": "[STORM-3685] Add new method StormCommon.validateCycleFree() and use in StormSubmitter.submitTopologyAs()."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwODgxODA2", "url": "https://github.com/apache/storm/pull/3322#pullrequestreview-480881806", "createdAt": "2020-09-02T14:31:35Z", "commit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMTozNVrOHLyBog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNDozMjoxMlrOHLyDUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjAwMg==", "bodyText": "Is this used anywhere?", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116002", "createdAt": "2020-09-02T14:31:35Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -51,6 +52,7 @@\n import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import sun.net.ProgressListener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ==", "bodyText": "We should remove this", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116135", "createdAt": "2020-09-02T14:31:46Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);\n+            System.out.println(ex.get_msg());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw==", "bodyText": "Will ex already contains ex.get_msg()? If so, we will see repeating messages, which should be avoid.", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116433", "createdAt": "2020-09-02T14:32:12Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc7a66d5c3771455926039cce900637b9350e800"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77e79fc25c1120d2e368c24e0fbb729779c35c94", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/77e79fc25c1120d2e368c24e0fbb729779c35c94", "committedDate": "2020-09-02T18:48:28Z", "message": "[STORM-3685] Remove unused imports and unused private static method; fix @throws tag; remove superfluous sysout.."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c34bf1b4a02035e2af94f7f37ef6dc71a635f347", "author": {"user": null}, "url": "https://github.com/apache/storm/commit/c34bf1b4a02035e2af94f7f37ef6dc71a635f347", "committedDate": "2020-09-03T19:08:05Z", "message": "[STORM-3685] Move validateCycleFree() to Utils and throw WrappedInvalidTopologyException."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNjk0MDgz", "url": "https://github.com/apache/storm/pull/3322#pullrequestreview-482694083", "createdAt": "2020-09-04T14:22:46Z", "commit": {"oid": "c34bf1b4a02035e2af94f7f37ef6dc71a635f347"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4906, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}