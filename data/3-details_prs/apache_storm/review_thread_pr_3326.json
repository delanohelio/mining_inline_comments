{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NjI5OTM2", "number": 3326, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoxMjowMVrOEe7Arw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMTowNFrOEe7QvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODU5NTY3OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/utils/ServerUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoxMjowMVrOHK4J1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzo1MjowOFrOHLB1Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE2NzgzMA==", "bodyText": "Should the last \"uid\" be \"pidUid\"?\nIt is not easy to distinguish \"user\" vs \"pidUser\", \"uid\" vs \"pidUid\". I suggest to change them to be\nactualUser vs expectedUser, actualUid vs expectedUid", "url": "https://github.com/apache/storm/pull/3326#discussion_r481167830", "createdAt": "2020-09-01T14:12:01Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/utils/ServerUtils.java", "diffHunk": "@@ -1217,9 +1199,127 @@ public static boolean areAllProcessesDead(Map<String, Object> conf, String user,\n             }\n         }\n         if (cachedUserToUidMap.containsKey(user)) {\n-            return allDead = !ServerUtils.isAnyProcessAlive(pids, cachedUserToUidMap.get(user));\n+            return !ServerUtils.isAnyProcessAlive(pids, cachedUserToUidMap.get(user));\n         } else {\n-            return allDead = !ServerUtils.isAnyProcessAlive(pids, user);\n+            return !ServerUtils.isAnyProcessAlive(pids, user);\n         }\n     }\n+\n+    /**\n+     * Find if the process is alive using the existence of /proc/&lt;pid&gt; directory\n+     * owned by the supplied user. This is an alternative to \"ps -p pid -u uid\" command\n+     * used in {@link #isAnyPosixProcessAlive(Collection, int)}\n+     *\n+     * <p>\n+     * Processes are tracked using the existence of the directory \"/proc/&lt;pid&gt;\n+     * For each of the supplied PIDs, their PID directory is checked for existence and ownership\n+     * by the specified uid.\n+     * </p>\n+     *\n+     * @param pids Process IDs that need to be monitored for liveness\n+     * @param user the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyPosixProcessPidDirAlive(Collection<Long> pids, String user) throws IOException {\n+        return isAnyPosixProcessPidDirAlive(pids, user, false);\n+    }\n+\n+    /**\n+     * Find if the process is alive using the existence of /proc/&lt;pid&gt; directory\n+     * owned by the supplied user. This is an alternative to \"ps -p pid -u uid\" command\n+     * used in {@link #isAnyPosixProcessAlive(Collection, int)}\n+     *\n+     * <p>\n+     * Processes are tracked using the existence of the directory \"/proc/&lt;pid&gt;\n+     * For each of the supplied PIDs, their PID directory is checked for existence and ownership\n+     * by the specified uid.\n+     * </p>\n+     *\n+     * @param pids Process IDs that need to be monitored for liveness\n+     * @param user the userId that is expected to own that process\n+     * @param mockFileOwnerToUid if true (used for testing), then convert File.owner to UID\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    @VisibleForTesting\n+    public static boolean isAnyPosixProcessPidDirAlive(Collection<Long> pids, String user, boolean mockFileOwnerToUid)\n+            throws IOException {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            throw new IOException(\"Missing process directory \" + procDir.getAbsolutePath() + \": method not supported on \"\n+                    + \"os.name=\" + System.getProperty(\"os.name\"));\n+        }\n+        for (long pid: pids) {\n+            File pidDir = new File(procDir, String.valueOf(pid));\n+            if (!pidDir.exists()) {\n+                continue;\n+            }\n+            // check if existing process is owned by the specified user, if not, the process is dead\n+            String pidUser;\n+            try {\n+                pidUser = Files.getOwner(pidDir.toPath()).getName();\n+            } catch (NoSuchFileException ex) {\n+                continue; // process died before the user can be checked\n+            }\n+            if (mockFileOwnerToUid) {\n+                // code activated in testing to simulate Files.getOwner returning UID (which sometimes happens in runtime)\n+                if (StringUtils.isNumeric(pidUser)) {\n+                    LOG.info(\"Skip mocking, since owner {} of pidDir {} is already numeric\", pidUser, pidDir);\n+                } else {\n+                    Integer uid = cachedUserToUidMap.get(pidUser);\n+                    if (uid == null) {\n+                        uid = ServerUtils.getUserId(pidUser);\n+                        if (uid < 0) {\n+                            String err = String.format(\"Cannot get UID for %s, while mocking the owner of pidDir %s\",\n+                                    pidUser, pidDir.getAbsolutePath());\n+                            throw new IOException(err);\n+                        }\n+                        cachedUserToUidMap.put(pidUser, uid);\n+                        LOG.info(\"Found UID {} for {}, while mocking the owner of pidDir {}\", uid, pidUser, pidDir);\n+                    } else {\n+                        LOG.info(\"Found cached UID {} for {}, while mocking the owner of pidDir {}\", uid, pidUser, pidDir);\n+                    }\n+                    pidUser = String.valueOf(uid);\n+                }\n+            }\n+            //sometimes uid is returned instead of username - if so, try to convert and compare with uid\n+            if (StringUtils.isNumeric(pidUser)) {\n+                // numeric pidUser - this is UID\n+                LOG.debug(\"Process directory {} owner is uid={}\", pidDir, pidUser);\n+                int pidUid = Integer.parseInt(pidUser);\n+                Integer uid = cachedUserToUidMap.get(user);\n+                if (uid == null) {\n+                    uid = ServerUtils.getUserId(user);\n+                    if (uid < 0) {\n+                        String err = String.format(\"Cannot get uid for %s to compare with owner id=%d of process directory %s\",\n+                                user, pidUid, pidDir.getAbsolutePath());\n+                        throw new IOException(err);\n+                    }\n+                    cachedUserToUidMap.put(user, uid);\n+                }\n+                if (uid == pidUid) {\n+                    LOG.debug(\"Process {} is alive and owned by user {}/{}\", pid, user, uid);\n+                    return true;\n+                } else {\n+                    LOG.info(\"Prior process is dead, since directory {} owner {} is not same as expected user {}/{}, \"\n+                            + \"likely pid {} was reused for a new process for uid {}\", pidDir, pidUser, user, uid, pid, uid);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNjQzNA==", "bodyText": "renamed variables", "url": "https://github.com/apache/storm/pull/3326#discussion_r481326434", "createdAt": "2020-09-01T17:52:08Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/utils/ServerUtils.java", "diffHunk": "@@ -1217,9 +1199,127 @@ public static boolean areAllProcessesDead(Map<String, Object> conf, String user,\n             }\n         }\n         if (cachedUserToUidMap.containsKey(user)) {\n-            return allDead = !ServerUtils.isAnyProcessAlive(pids, cachedUserToUidMap.get(user));\n+            return !ServerUtils.isAnyProcessAlive(pids, cachedUserToUidMap.get(user));\n         } else {\n-            return allDead = !ServerUtils.isAnyProcessAlive(pids, user);\n+            return !ServerUtils.isAnyProcessAlive(pids, user);\n         }\n     }\n+\n+    /**\n+     * Find if the process is alive using the existence of /proc/&lt;pid&gt; directory\n+     * owned by the supplied user. This is an alternative to \"ps -p pid -u uid\" command\n+     * used in {@link #isAnyPosixProcessAlive(Collection, int)}\n+     *\n+     * <p>\n+     * Processes are tracked using the existence of the directory \"/proc/&lt;pid&gt;\n+     * For each of the supplied PIDs, their PID directory is checked for existence and ownership\n+     * by the specified uid.\n+     * </p>\n+     *\n+     * @param pids Process IDs that need to be monitored for liveness\n+     * @param user the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyPosixProcessPidDirAlive(Collection<Long> pids, String user) throws IOException {\n+        return isAnyPosixProcessPidDirAlive(pids, user, false);\n+    }\n+\n+    /**\n+     * Find if the process is alive using the existence of /proc/&lt;pid&gt; directory\n+     * owned by the supplied user. This is an alternative to \"ps -p pid -u uid\" command\n+     * used in {@link #isAnyPosixProcessAlive(Collection, int)}\n+     *\n+     * <p>\n+     * Processes are tracked using the existence of the directory \"/proc/&lt;pid&gt;\n+     * For each of the supplied PIDs, their PID directory is checked for existence and ownership\n+     * by the specified uid.\n+     * </p>\n+     *\n+     * @param pids Process IDs that need to be monitored for liveness\n+     * @param user the userId that is expected to own that process\n+     * @param mockFileOwnerToUid if true (used for testing), then convert File.owner to UID\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    @VisibleForTesting\n+    public static boolean isAnyPosixProcessPidDirAlive(Collection<Long> pids, String user, boolean mockFileOwnerToUid)\n+            throws IOException {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            throw new IOException(\"Missing process directory \" + procDir.getAbsolutePath() + \": method not supported on \"\n+                    + \"os.name=\" + System.getProperty(\"os.name\"));\n+        }\n+        for (long pid: pids) {\n+            File pidDir = new File(procDir, String.valueOf(pid));\n+            if (!pidDir.exists()) {\n+                continue;\n+            }\n+            // check if existing process is owned by the specified user, if not, the process is dead\n+            String pidUser;\n+            try {\n+                pidUser = Files.getOwner(pidDir.toPath()).getName();\n+            } catch (NoSuchFileException ex) {\n+                continue; // process died before the user can be checked\n+            }\n+            if (mockFileOwnerToUid) {\n+                // code activated in testing to simulate Files.getOwner returning UID (which sometimes happens in runtime)\n+                if (StringUtils.isNumeric(pidUser)) {\n+                    LOG.info(\"Skip mocking, since owner {} of pidDir {} is already numeric\", pidUser, pidDir);\n+                } else {\n+                    Integer uid = cachedUserToUidMap.get(pidUser);\n+                    if (uid == null) {\n+                        uid = ServerUtils.getUserId(pidUser);\n+                        if (uid < 0) {\n+                            String err = String.format(\"Cannot get UID for %s, while mocking the owner of pidDir %s\",\n+                                    pidUser, pidDir.getAbsolutePath());\n+                            throw new IOException(err);\n+                        }\n+                        cachedUserToUidMap.put(pidUser, uid);\n+                        LOG.info(\"Found UID {} for {}, while mocking the owner of pidDir {}\", uid, pidUser, pidDir);\n+                    } else {\n+                        LOG.info(\"Found cached UID {} for {}, while mocking the owner of pidDir {}\", uid, pidUser, pidDir);\n+                    }\n+                    pidUser = String.valueOf(uid);\n+                }\n+            }\n+            //sometimes uid is returned instead of username - if so, try to convert and compare with uid\n+            if (StringUtils.isNumeric(pidUser)) {\n+                // numeric pidUser - this is UID\n+                LOG.debug(\"Process directory {} owner is uid={}\", pidDir, pidUser);\n+                int pidUid = Integer.parseInt(pidUser);\n+                Integer uid = cachedUserToUidMap.get(user);\n+                if (uid == null) {\n+                    uid = ServerUtils.getUserId(user);\n+                    if (uid < 0) {\n+                        String err = String.format(\"Cannot get uid for %s to compare with owner id=%d of process directory %s\",\n+                                user, pidUid, pidDir.getAbsolutePath());\n+                        throw new IOException(err);\n+                    }\n+                    cachedUserToUidMap.put(user, uid);\n+                }\n+                if (uid == pidUid) {\n+                    LOG.debug(\"Process {} is alive and owned by user {}/{}\", pid, user, uid);\n+                    return true;\n+                } else {\n+                    LOG.info(\"Prior process is dead, since directory {} owner {} is not same as expected user {}/{}, \"\n+                            + \"likely pid {} was reused for a new process for uid {}\", pidDir, pidUser, user, uid, pid, uid);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE2NzgzMA=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 328}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYyOTA1OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoxOToyOFrOHK4eWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOTowMjozOVrOHLEV8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzA4MQ==", "bodyText": "Isn't this already present?\nhttps://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java#L184", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173081", "createdAt": "2020-09-01T14:19:28Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NjE3Ng==", "bodyText": "Yes. Something is not right. I will do a force push with all changes.", "url": "https://github.com/apache/storm/pull/3326#discussion_r481366176", "createdAt": "2020-09-01T19:00:05Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzA4MQ=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzUzOA==", "bodyText": "You need to rebase on latest master. Then you should be able to see the conflicts/duplicates", "url": "https://github.com/apache/storm/pull/3326#discussion_r481367538", "createdAt": "2020-09-01T19:02:39Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzA4MQ=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYzMjQ4OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMDoxMFrOHK4geA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOTowMTo1MVrOHLEUhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzYyNA==", "bodyText": "this method already exist?", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173624", "createdAt": "2020-09-01T14:20:10Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {\n+        Class<? extends Process> pClass = p.getClass();\n+        String pObjStr = ToStringBuilder.reflectionToString(p, ToStringStyle.SHORT_PREFIX_STYLE);\n+        String pclassName = pClass.getName();\n+        try {\n+            if (pclassName.equals(\"java.lang.UNIXProcess\")) {\n+                Field f = pClass.getDeclaredField(\"pid\");\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            for (Field f : pClass.getDeclaredFields()) {\n+                if (!f.getName().equalsIgnoreCase(\"pid\")) {\n+                    continue;\n+                }\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found attribute {}#{}\", pclassName, f.getName());\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            // post JDK 9 there should be getPid() - future JDK-11 compatibility only for the sake of Travis test in community\n+            try {\n+                Method m = pClass.getDeclaredMethod(\"getPid\");\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found method {}#getPid()\\n\", pclassName);\n+                long pid = (Long)m.invoke(p);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"getPid()\\\" method in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            } catch (SecurityException e) {\n+                errors.add(\"\\t getPid() method in Process class \" + pclassName + \" cannot be called: \" + e.getMessage() + \", process=\" + pObjStr);\n+                return -1;\n+            } catch (NoSuchMethodException e) {\n+                // ignore and try something else\n+            }\n+            errors.add(\"\\t Process class \" + pclassName + \" missing field \\\"pid\\\" and missing method \\\"getPid()\\\", process=\" + pObjStr);\n+            return -1;\n+        } catch (Exception e) {\n+            errors.add(\"\\t Exception in Process class \" + pclassName + \": \" + e.getMessage() + \", process=\" + pObjStr);\n+            e.printStackTrace();\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Sleep for specified milliseconds and return true if sleep was interrupted.\n+     *\n+     * @param milliSeconds number of milliseconds to sleep\n+     * @return true if sleep was interrupted, false otherwise.\n+     */\n+    private boolean sleepInterrupted(long milliSeconds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MDExNw==", "bodyText": "I am not aware of any existing method with similar functionality.\nOr did you mean to ask why this is showing up in this pull request, since it should already exist.", "url": "https://github.com/apache/storm/pull/3326#discussion_r481340117", "createdAt": "2020-09-01T18:16:57Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {\n+        Class<? extends Process> pClass = p.getClass();\n+        String pObjStr = ToStringBuilder.reflectionToString(p, ToStringStyle.SHORT_PREFIX_STYLE);\n+        String pclassName = pClass.getName();\n+        try {\n+            if (pclassName.equals(\"java.lang.UNIXProcess\")) {\n+                Field f = pClass.getDeclaredField(\"pid\");\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            for (Field f : pClass.getDeclaredFields()) {\n+                if (!f.getName().equalsIgnoreCase(\"pid\")) {\n+                    continue;\n+                }\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found attribute {}#{}\", pclassName, f.getName());\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            // post JDK 9 there should be getPid() - future JDK-11 compatibility only for the sake of Travis test in community\n+            try {\n+                Method m = pClass.getDeclaredMethod(\"getPid\");\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found method {}#getPid()\\n\", pclassName);\n+                long pid = (Long)m.invoke(p);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"getPid()\\\" method in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            } catch (SecurityException e) {\n+                errors.add(\"\\t getPid() method in Process class \" + pclassName + \" cannot be called: \" + e.getMessage() + \", process=\" + pObjStr);\n+                return -1;\n+            } catch (NoSuchMethodException e) {\n+                // ignore and try something else\n+            }\n+            errors.add(\"\\t Process class \" + pclassName + \" missing field \\\"pid\\\" and missing method \\\"getPid()\\\", process=\" + pObjStr);\n+            return -1;\n+        } catch (Exception e) {\n+            errors.add(\"\\t Exception in Process class \" + pclassName + \": \" + e.getMessage() + \", process=\" + pObjStr);\n+            e.printStackTrace();\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Sleep for specified milliseconds and return true if sleep was interrupted.\n+     *\n+     * @param milliSeconds number of milliseconds to sleep\n+     * @return true if sleep was interrupted, false otherwise.\n+     */\n+    private boolean sleepInterrupted(long milliSeconds) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzYyNA=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzE3NA==", "bodyText": "https://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java#L324\nThis method already exists in ServerUtilsTest (from your another merged PR)", "url": "https://github.com/apache/storm/pull/3326#discussion_r481367174", "createdAt": "2020-09-01T19:01:51Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {\n+        Class<? extends Process> pClass = p.getClass();\n+        String pObjStr = ToStringBuilder.reflectionToString(p, ToStringStyle.SHORT_PREFIX_STYLE);\n+        String pclassName = pClass.getName();\n+        try {\n+            if (pclassName.equals(\"java.lang.UNIXProcess\")) {\n+                Field f = pClass.getDeclaredField(\"pid\");\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            for (Field f : pClass.getDeclaredFields()) {\n+                if (!f.getName().equalsIgnoreCase(\"pid\")) {\n+                    continue;\n+                }\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found attribute {}#{}\", pclassName, f.getName());\n+                f.setAccessible(true);\n+                long pid = f.getLong(p);\n+                f.setAccessible(false);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"pid\\\" attribute in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            }\n+            // post JDK 9 there should be getPid() - future JDK-11 compatibility only for the sake of Travis test in community\n+            try {\n+                Method m = pClass.getDeclaredMethod(\"getPid\");\n+                LOG.info(\"ServerUtilsTest.getPidOfPosixProcess(): found method {}#getPid()\\n\", pclassName);\n+                long pid = (Long)m.invoke(p);\n+                if (pid < 0) {\n+                    errors.add(\"\\t \\\"getPid()\\\" method in Process class \" + pclassName + \" returned -1, process=\" + pObjStr);\n+                }\n+                return pid;\n+            } catch (SecurityException e) {\n+                errors.add(\"\\t getPid() method in Process class \" + pclassName + \" cannot be called: \" + e.getMessage() + \", process=\" + pObjStr);\n+                return -1;\n+            } catch (NoSuchMethodException e) {\n+                // ignore and try something else\n+            }\n+            errors.add(\"\\t Process class \" + pclassName + \" missing field \\\"pid\\\" and missing method \\\"getPid()\\\", process=\" + pObjStr);\n+            return -1;\n+        } catch (Exception e) {\n+            errors.add(\"\\t Exception in Process class \" + pclassName + \": \" + e.getMessage() + \", process=\" + pObjStr);\n+            e.printStackTrace();\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Sleep for specified milliseconds and return true if sleep was interrupted.\n+     *\n+     * @param milliSeconds number of milliseconds to sleep\n+     * @return true if sleep was interrupted, false otherwise.\n+     */\n+    private boolean sleepInterrupted(long milliSeconds) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzYyNA=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYzMjYyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMDoxNFrOHK4gmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxOTowMjoxMFrOHLEVEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzY1Ng==", "bodyText": "this method already exist?", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173656", "createdAt": "2020-09-01T14:20:14Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MDA0OA==", "bodyText": "I am not aware of any existing method with similar functionality.", "url": "https://github.com/apache/storm/pull/3326#discussion_r481340048", "createdAt": "2020-09-01T18:16:49Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzY1Ng=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2NzMxNQ==", "bodyText": "https://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java#L266\nThis method already exists in ServerUtilsTest (from your another merged PR)", "url": "https://github.com/apache/storm/pull/3326#discussion_r481367315", "createdAt": "2020-09-01T19:02:10Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);\n+            // at least one pid will be owned by the current user (doing the testing)\n+            String currentUser = System.getProperty(\"user.name\");\n+            boolean status = ServerUtils.isAnyPosixProcessPidDirAlive(pids, currentUser, mockFileOwnerToUid);\n+            String err = String.format(\"(mockFileOwnerToUid=%s) Expecting user %s to own at least one process\",\n+                    mockFileOwnerToUid, currentUser);\n+            assertTrue(err, status);\n+        }\n+    }\n+\n+    /**\n+     * Make the best effort to obtain the Process ID from the Process object. Thus staying entirely with the JVM.\n+     *\n+     * @param p Process instance returned upon executing {@link Runtime#exec(String)}.\n+     * @param errors Populate errors when PID is a negative number.\n+     * @return positive PID upon success, otherwise negative.\n+     */\n+    private synchronized long getPidOfPosixProcess(Process p, List<String> errors) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzY1Ng=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYzMzgzOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMDoyN1rOHK4hTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzo1NDozMlrOHLB60w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzgzOQ==", "bodyText": "nit: more than 1 new line", "url": "https://github.com/apache/storm/pull/3326#discussion_r481173839", "createdAt": "2020-09-01T14:20:27Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMyNzgyNw==", "bodyText": "removed", "url": "https://github.com/apache/storm/pull/3326#discussion_r481327827", "createdAt": "2020-09-01T17:54:32Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3MzgzOQ=="}, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwODYzNjc2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMTowNFrOHK4jGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNDoyMTowNFrOHK4jGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3NDI5Ng==", "bodyText": "I would suggest to use Parameterized Test here.", "url": "https://github.com/apache/storm/pull/3326#discussion_r481174296", "createdAt": "2020-09-01T14:21:04Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/utils/ServerUtilsTest.java", "diffHunk": "@@ -162,6 +185,191 @@ public void testGetUserId() throws Exception {\n         int uid1 = ServerUtils.getUserId(null);\n         Path p = Files.createTempFile(\"testGetUser\", \".txt\");\n         int uid2 = ServerUtils.getPathOwnerUid(p.toString());\n+        if (!p.toFile().delete()) {\n+            LOG.warn(\"Could not delete tempoary file {}\", p);\n+        }\n         assertEquals(\"User UID \" + uid1 + \" is not same as file \" + p.toString() + \" owner UID of \" + uid2, uid1, uid2);\n     }\n+\n+    @Test\n+    public void testIsAnyProcessPosixProcessPidDirAlive() throws IOException {\n+        final String testName = \"testIsAnyProcessPosixProcessPidDirAlive\";\n+        List<String> errors = new ArrayList<>();\n+        int maxPidCnt = 5;\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            LOG.info(\"{}: test cannot be run on Windows. Marked as successful\", testName);\n+            return;\n+        }\n+        final Path parentDir = Paths.get(\"/proc\");\n+        if (!parentDir.toFile().exists()) {\n+            LOG.info(\"{}: test cannot be run on system without process directory {}, os.name={}\",\n+                    testName, parentDir, System.getProperty(\"os.name\"));\n+            // check if we can get process id on this Posix system - testing test code, useful on Mac\n+            String cmd = \"/bin/sleep 10\";\n+            if (getPidOfPosixProcess(Runtime.getRuntime().exec(cmd), errors) < 0) {\n+                fail(String.format(\"%s: Cannot obtain process id for executed command \\\"%s\\\"\\n%s\",\n+                        testName, cmd, String.join(\"\\n\\t\", errors)));\n+            }\n+            return;\n+        }\n+        // Create processes and wait for their termination\n+        Set<Long> observables = new HashSet<>();\n+\n+        for (int i = 0 ; i < maxPidCnt ; i++) {\n+            String cmd = \"sleep 2000\";\n+            Process process = Runtime.getRuntime().exec(cmd);\n+            long pid = getPidOfPosixProcess(process, errors);\n+            LOG.info(\"{}: ({}) ran process \\\"{}\\\" with pid={}\", testName, i, cmd, pid);\n+            if (pid < 0) {\n+                String e = String.format(\"%s: (%d) Cannot obtain process id for executed command \\\"%s\\\"\", testName, i, cmd);\n+                errors.add(e);\n+                LOG.error(e);\n+                continue;\n+            }\n+            observables.add(pid);\n+        }\n+        String userName = System.getProperty(\"user.name\");\n+        // now kill processes one by one\n+        List<Long> pidList = new ArrayList<>(observables);\n+        final long processKillIntervalMs = 2000;\n+        for (int i = 0; i < pidList.size(); i++) {\n+            long pid = pidList.get(i);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds before kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            Runtime.getRuntime().exec(\"kill -9 \" + pid);\n+            LOG.info(\"{}: ({}) Sleeping for {} milliseconds after kill\", testName, i, processKillIntervalMs);\n+            if (sleepInterrupted(processKillIntervalMs)) {\n+                return;\n+            }\n+            boolean pidDirsAvailable = ServerUtils.isAnyPosixProcessPidDirAlive(observables, userName);\n+            if (i < pidList.size() - 1) {\n+                if (pidDirsAvailable) {\n+                    LOG.info(\"{}: ({}) Found existing process directories before killing last process\", testName, i);\n+                } else {\n+                    String e = String.format(\"%s: (%d) Found no existing process directories before killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                }\n+            } else {\n+                if (pidDirsAvailable) {\n+                    String e = String.format(\"%s: (%d) Found existing process directories after killing last process\", testName, i);\n+                    errors.add(e);\n+                    LOG.error(e);\n+                } else {\n+                    LOG.info(\"{}: ({}) Found no existing process directories after killing last process\", testName, i);\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) {\n+            fail(String.format(\"There are %d failures in test:\\n\\t%s\", errors.size(), String.join(\"\\n\\t\", errors)));\n+        }\n+    }\n+\n+\n+    /**\n+     * Simulate the production scenario where the owner of the process directory is sometimes returned as the\n+     * UID instead of user. This scenario is simulated by calling\n+     * {@link ServerUtils#isAnyPosixProcessPidDirAlive(Collection, String, boolean)} with the last parameter\n+     * set to true as well as false.\n+     *\n+     * @throws Exception on I/O exception\n+     */\n+    @Test\n+    public void testIsAnyPosixProcessPidDirAliveMockingFileOwnerUid() throws Exception {\n+        File procDir = new File(\"/proc\");\n+        if (!procDir.exists()) {\n+            LOG.info(\"Test testIsAnyPosixProcessPidDirAlive is designed to run on systems with /proc directory only, marking as success\");\n+            return;\n+        }\n+        Collection<Long> pids = getRunningProcessIds();\n+        assertFalse(pids.isEmpty());\n+\n+        for (int i = 0 ; i < 2 ; i++) {\n+            boolean mockFileOwnerToUid = (i % 2 == 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b4e3c3979f3fc656c77d0ec6ec1236338df5267"}, "originalPosition": 189}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4190, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}