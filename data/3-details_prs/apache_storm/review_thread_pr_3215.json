{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5MzMyOTI2", "number": 3215, "reviewThreads": {"totalCount": 44, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxMDowNFrODjKcXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMTo0NjozNlrODm6b7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTk3ODU1OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxMDowNFrOFu0YQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTo0NDozOFrOFvCmTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzNjk5NA==", "bodyText": "Instead of using large number this should be function on total executors requested by topology.", "url": "https://github.com/apache/storm/pull/3215#discussion_r384636994", "createdAt": "2020-02-26T17:10:04Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -447,22 +518,24 @@ public boolean isExecAssignmentToWorkerValid(WorkerSlot worker, SearcherState st\n         return retMap;\n     }\n \n-    private ArrayList<ExecutorDetails> getSortedExecs(HashSet<String> spreadComps, Map<String, Map<String, Integer>> constraintMatrix,\n+    private ArrayList<ExecutorDetails> getSortedExecs(Map<String, Integer> spreadCompCnts,\n+                                                      Map<String, Set<String>> constraintMatrix,\n                                                       Map<String, Set<ExecutorDetails>> compToExecs) {\n         ArrayList<ExecutorDetails> retList = new ArrayList<>();\n         //find number of constraints per component\n         //Key->Comp Value-># of constraints\n-        Map<String, Integer> compConstraintCountMap = new HashMap<>();\n+        Map<String, Double> compConstraintCountMap = new HashMap<>();\n         constraintMatrix.forEach((comp, subMatrix) -> {\n-            int count = subMatrix.values().stream().mapToInt(Number::intValue).sum();\n-            //check component is declared for spreading\n-            if (spreadComps.contains(comp)) {\n-                count++;\n+            double count = subMatrix.size();\n+            // check if component is declared for spreading\n+            if (spreadCompCnts.containsKey(comp)) {\n+                // lower (1 and above only) value is most constrained should have higher count\n+                count += (1_000.0 / spreadCompCnts.get(comp));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139b5e232c7bafa26c40bdc34058cee560214f1"}, "originalPosition": 469}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTk2NA==", "bodyText": "Replaced 1000 with component count.", "url": "https://github.com/apache/storm/pull/3215#discussion_r384869964", "createdAt": "2020-02-27T01:44:38Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -447,22 +518,24 @@ public boolean isExecAssignmentToWorkerValid(WorkerSlot worker, SearcherState st\n         return retMap;\n     }\n \n-    private ArrayList<ExecutorDetails> getSortedExecs(HashSet<String> spreadComps, Map<String, Map<String, Integer>> constraintMatrix,\n+    private ArrayList<ExecutorDetails> getSortedExecs(Map<String, Integer> spreadCompCnts,\n+                                                      Map<String, Set<String>> constraintMatrix,\n                                                       Map<String, Set<ExecutorDetails>> compToExecs) {\n         ArrayList<ExecutorDetails> retList = new ArrayList<>();\n         //find number of constraints per component\n         //Key->Comp Value-># of constraints\n-        Map<String, Integer> compConstraintCountMap = new HashMap<>();\n+        Map<String, Double> compConstraintCountMap = new HashMap<>();\n         constraintMatrix.forEach((comp, subMatrix) -> {\n-            int count = subMatrix.values().stream().mapToInt(Number::intValue).sum();\n-            //check component is declared for spreading\n-            if (spreadComps.contains(comp)) {\n-                count++;\n+            double count = subMatrix.size();\n+            // check if component is declared for spreading\n+            if (spreadCompCnts.containsKey(comp)) {\n+                // lower (1 and above only) value is most constrained should have higher count\n+                count += (1_000.0 / spreadCompCnts.get(comp));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzNjk5NA=="}, "originalCommit": {"oid": "0139b5e232c7bafa26c40bdc34058cee560214f1"}, "originalPosition": 469}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTk5NjMxOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxNDoxMlrOFu0irA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTo0NTowN1rOFvCmxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzOTY2MA==", "bodyText": "rename?", "url": "https://github.com/apache/storm/pull/3215#discussion_r384639660", "createdAt": "2020-02-26T17:14:12Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -506,20 +581,21 @@ public SchedulingResult asSchedulingResult() {\n                 return SchedulingResult.success(\"Fully Scheduled by ConstraintSolverStrategy (\" + statesSearched\n                                                 + \" states traversed in \" + timeTakenMillis + \"ms, backtracked \" + backtracked + \" times)\");\n             }\n+            state.logNodeCompAssignments();\n             return SchedulingResult.failure(SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES,\n                                             \"Cannot find scheduling that satisfies all constraints (\" + statesSearched\n                                             + \" states traversed in \" + timeTakenMillis + \"ms, backtracked \" + backtracked + \" times)\");\n         }\n     }\n \n-    protected static class SearcherState {\n+    protected static final class SearcherState {\n         final long startTimeMillis;\n         private final long maxEndTimeMs;\n         // A map of the worker to the components in the worker to be able to enforce constraints.\n-        private final Map<WorkerSlot, Set<String>> workerCompAssignment;\n+        private final Map<WorkerSlot, Map<String, Integer>> workerCompAssignment;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139b5e232c7bafa26c40bdc34058cee560214f1"}, "originalPosition": 523}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3MDA4Nw==", "bodyText": "Changed names to end in Cnts.", "url": "https://github.com/apache/storm/pull/3215#discussion_r384870087", "createdAt": "2020-02-27T01:45:07Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -506,20 +581,21 @@ public SchedulingResult asSchedulingResult() {\n                 return SchedulingResult.success(\"Fully Scheduled by ConstraintSolverStrategy (\" + statesSearched\n                                                 + \" states traversed in \" + timeTakenMillis + \"ms, backtracked \" + backtracked + \" times)\");\n             }\n+            state.logNodeCompAssignments();\n             return SchedulingResult.failure(SchedulingStatus.FAIL_NOT_ENOUGH_RESOURCES,\n                                             \"Cannot find scheduling that satisfies all constraints (\" + statesSearched\n                                             + \" states traversed in \" + timeTakenMillis + \"ms, backtracked \" + backtracked + \" times)\");\n         }\n     }\n \n-    protected static class SearcherState {\n+    protected static final class SearcherState {\n         final long startTimeMillis;\n         private final long maxEndTimeMs;\n         // A map of the worker to the components in the worker to be able to enforce constraints.\n-        private final Map<WorkerSlot, Set<String>> workerCompAssignment;\n+        private final Map<WorkerSlot, Map<String, Integer>> workerCompAssignment;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzOTY2MA=="}, "originalCommit": {"oid": "0139b5e232c7bafa26c40bdc34058cee560214f1"}, "originalPosition": 523}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MTk5ODg2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxNDo0MlrOFu0kCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMTo0NToyNlrOFvCnFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MDAxMA==", "bodyText": "Remove commented code.", "url": "https://github.com/apache/storm/pull/3215#discussion_r384640010", "createdAt": "2020-02-26T17:14:42Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -54,27 +56,76 @@\n import org.apache.storm.metric.StormMetricsRegistry;\n import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n \n+@RunWith(Parameterized.class)\n public class TestConstraintSolverStrategy {\n+    @Parameters\n+    public static Object[] data() {\n+        return new Object[] { false, true };\n+    }\n+    //public static Collection<Object[]> data(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0139b5e232c7bafa26c40bdc34058cee560214f1"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3MDE2Ng==", "bodyText": "Removed comment lines", "url": "https://github.com/apache/storm/pull/3215#discussion_r384870166", "createdAt": "2020-02-27T01:45:26Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -54,27 +56,76 @@\n import org.apache.storm.metric.StormMetricsRegistry;\n import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n \n+@RunWith(Parameterized.class)\n public class TestConstraintSolverStrategy {\n+    @Parameters\n+    public static Object[] data() {\n+        return new Object[] { false, true };\n+    }\n+    //public static Collection<Object[]> data(){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MDAxMA=="}, "originalCommit": {"oid": "0139b5e232c7bafa26c40bdc34058cee560214f1"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjQxODA3OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxOTo0MDozOFrOFvesIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMjowMToxNFrOFw17ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDIwOQ==", "bodyText": "Please correct the comment, @Ethanlm  thinks the component exclusion is at worker level", "url": "https://github.com/apache/storm/pull/3215#discussion_r385330209", "createdAt": "2020-02-27T19:40:38Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -45,64 +45,142 @@\n     //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *      { \"comp-1\": [ 2, \"comp-2\", \"comp-3\" ], # comp-1 cannot exist on same node as comp-2 or comp-3, and at most 2 comp-1 same node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "512decd5667b24c3583967c9de50584201edb5c2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzNTExMQ==", "bodyText": "The description can be modified to https://github.com/apache/storm/blob/master/storm-client/src/jvm/org/apache/storm/Config.java#L307-L312\nAlso, validator needs to allow for list or map.\nThe configuration could be more explicit in mentioning node level collation and component isolation.\n{\"comp-1\": { \"maxNodeCollations\" : 2, \"incompatibleComponents\": [ \"comp-2\", \"comp-3\"  ]} }", "url": "https://github.com/apache/storm/pull/3215#discussion_r385335111", "createdAt": "2020-02-27T19:50:05Z", "author": {"login": "kishorvpatil"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -45,64 +45,142 @@\n     //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *      { \"comp-1\": [ 2, \"comp-2\", \"comp-3\" ], # comp-1 cannot exist on same node as comp-2 or comp-3, and at most 2 comp-1 same node", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDIwOQ=="}, "originalCommit": {"oid": "512decd5667b24c3583967c9de50584201edb5c2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc1OTU2Mg==", "bodyText": "Updated Config.java, ConfigValidationAnnotations.java, ConfigValidations.java, ConstraintSolverStrategy and TestConstraintSolverStrategy.", "url": "https://github.com/apache/storm/pull/3215#discussion_r386759562", "createdAt": "2020-03-03T02:01:14Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -45,64 +45,142 @@\n     //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *      { \"comp-1\": [ 2, \"comp-2\", \"comp-3\" ], # comp-1 cannot exist on same node as comp-2 or comp-3, and at most 2 comp-1 same node", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDIwOQ=="}, "originalCommit": {"oid": "512decd5667b24c3583967c9de50584201edb5c2"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDI0NjkwOnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDowMTozMlrOFxfV-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNjoyMToxMFrOFx0GVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzODA3Mg==", "bodyText": "typo: missing 'be\" in \"must  a instance\"", "url": "https://github.com/apache/storm/pull/3215#discussion_r387438072", "createdAt": "2020-03-04T04:01:32Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+\n+            HashMap<String, Exception> validatorExceptions = new HashMap<>();\n+            Set<String> selectedValidators = new HashSet<>();\n+            for (Class<?> vv : subValidators) {\n+                Object valueValidator;\n+                try {\n+                    valueValidator = vv.getConstructor().newInstance();\n+                } catch (Exception ex) {\n+                    throw new IllegalArgumentException(vv.getName() + \" instantiation failure\", ex);\n+                }\n+                if (valueValidator instanceof Validator) {\n+                    try {\n+                        ((Validator) valueValidator).validateField(name + \" \" + vv.getSimpleName() + \" value\", o);\n+                        selectedValidators.add(vv.getName());\n+                    } catch (Exception ex) {\n+                        // only one will pass, so ignore all validation errors - stored for future use\n+                        validatorExceptions.put(vv.getName(), ex);\n+                    }\n+                } else {\n+                    String err = String.format(\"validator: %s cannot be used in CustomExactlyOneOfValidators to validate values. \"\n+                            + \"Individual entry validators must a instance of Validator class\", vv.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc3ODEzMw==", "bodyText": "Good catch.This was copied message - changed here and two other places in original code.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387778133", "createdAt": "2020-03-04T16:21:10Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+\n+            HashMap<String, Exception> validatorExceptions = new HashMap<>();\n+            Set<String> selectedValidators = new HashSet<>();\n+            for (Class<?> vv : subValidators) {\n+                Object valueValidator;\n+                try {\n+                    valueValidator = vv.getConstructor().newInstance();\n+                } catch (Exception ex) {\n+                    throw new IllegalArgumentException(vv.getName() + \" instantiation failure\", ex);\n+                }\n+                if (valueValidator instanceof Validator) {\n+                    try {\n+                        ((Validator) valueValidator).validateField(name + \" \" + vv.getSimpleName() + \" value\", o);\n+                        selectedValidators.add(vv.getName());\n+                    } catch (Exception ex) {\n+                        // only one will pass, so ignore all validation errors - stored for future use\n+                        validatorExceptions.put(vv.getName(), ex);\n+                    }\n+                } else {\n+                    String err = String.format(\"validator: %s cannot be used in CustomExactlyOneOfValidators to validate values. \"\n+                            + \"Individual entry validators must a instance of Validator class\", vv.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzODA3Mg=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDI1NzM3OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDoxMDoxNlrOFxfcQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMzo0Mjo1N1rOFyBrRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTY4Mg==", "bodyText": "Originally when the validation class for topology.ras.constraints with ListOfListOfStringValidator, a value of null is accpetable.\nThe null check here will break backwards compatibility. So the question here is: do we want to maintain the backwards compatibility?\nOne thing I notice is that other validation classes accept null.  And we rely on NotNull annotation if we don't accept null as the value.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387439682", "createdAt": "2020-03-04T04:10:16Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAwMDU4Mw==", "bodyText": "Allow null in RasConstraintsTypeValidator and CustomIsExactlyOneOfValidators.", "url": "https://github.com/apache/storm/pull/3215#discussion_r388000583", "createdAt": "2020-03-04T23:42:57Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzOTY4Mg=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDI2Mjg4OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDoxNDoyOVrOFxffqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToyMDo1OVrOFx6Wvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0MDU1NQ==", "bodyText": "maybe (String) o3 is clearer than \"\" + o3?", "url": "https://github.com/apache/storm/pull/3215#discussion_r387440555", "createdAt": "2020-03-04T04:14:29Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+\n+            HashMap<String, Exception> validatorExceptions = new HashMap<>();\n+            Set<String> selectedValidators = new HashSet<>();\n+            for (Class<?> vv : subValidators) {\n+                Object valueValidator;\n+                try {\n+                    valueValidator = vv.getConstructor().newInstance();\n+                } catch (Exception ex) {\n+                    throw new IllegalArgumentException(vv.getName() + \" instantiation failure\", ex);\n+                }\n+                if (valueValidator instanceof Validator) {\n+                    try {\n+                        ((Validator) valueValidator).validateField(name + \" \" + vv.getSimpleName() + \" value\", o);\n+                        selectedValidators.add(vv.getName());\n+                    } catch (Exception ex) {\n+                        // only one will pass, so ignore all validation errors - stored for future use\n+                        validatorExceptions.put(vv.getName(), ex);\n+                    }\n+                } else {\n+                    String err = String.format(\"validator: %s cannot be used in CustomExactlyOneOfValidators to validate values. \"\n+                            + \"Individual entry validators must a instance of Validator class\", vv.getName());\n+                    LOG.warn(err);\n+                }\n+            }\n+            // check if one and only one validation succeeded\n+            if (selectedValidators.isEmpty()) {\n+                String parseErrs = String.join(\";\\n\\t\", validatorExceptions.entrySet().stream()\n+                        .map(e -> String.format(\"%s:%s\", e.getKey(), e.getValue())).collect(Collectors.toList()));\n+                String err = String.format(\"Field %s must be one of %s; parse errors are \\n\\t%s\", name,\n+                        String.join(\", \", validatorClassNames), parseErrs);\n+                throw new IllegalArgumentException(err);\n+            }\n+            if (selectedValidators.size() > 1) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must match exactly one of \" + String.join(\", \", selectedValidators));\n+            }\n+        }\n+    }\n+\n+    public static class RasConstraintsTypeValidator extends Validator {\n+        public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+        public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n+\n+        public static class RasConstraint {\n+            int maxNodeCoLocationCnt = -1;\n+            Set<String> incompatibleComponents = new HashSet<>();\n+        }\n+\n+        public Map<String, RasConstraint> rasConstraints = new HashMap<>(); // parsedConstraints\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+            if (!(o instanceof Map)) {\n+                throw new IllegalArgumentException(\n+                        \"Field \" + name + \" must be an Iterable containing only Map of Maps\");\n+            }\n+            Map<String, Object> map1 = (Map<String, Object>)o;\n+            for (Map.Entry<String, Object> entry1: map1.entrySet()) {\n+                String comp1 = entry1.getKey();\n+                Object o2 = entry1.getValue();\n+                RasConstraint rasConstraint = new RasConstraint();\n+                rasConstraints.put(comp1, rasConstraint);\n+                if (!(o2 instanceof Map)) {\n+                    String err = String.format(\"Field %s, component %s, expecting constraints Map with keys [\\\"%s\\\", \\\"%s\\\"], in \\\"%s\\\"\",\n+                            name, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, o);\n+                    throw new IllegalArgumentException(err);\n+                }\n+                Map<String, Object> map2 = (Map<String, Object>)o2;\n+                for (Map.Entry<String, Object> entry2: map2.entrySet()) {\n+                    String constraintType = entry2.getKey();\n+                    Object o3 = entry2.getValue();\n+                    switch (constraintType) {\n+                        case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                            try {\n+                                int intVal = Integer.parseInt(\"\" + o3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc4MDc1MQ==", "bodyText": "o3 is not necessarily a String. May come in as an Integer. In any case, casting is not good practice.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387780751", "createdAt": "2020-03-04T16:24:54Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+\n+            HashMap<String, Exception> validatorExceptions = new HashMap<>();\n+            Set<String> selectedValidators = new HashSet<>();\n+            for (Class<?> vv : subValidators) {\n+                Object valueValidator;\n+                try {\n+                    valueValidator = vv.getConstructor().newInstance();\n+                } catch (Exception ex) {\n+                    throw new IllegalArgumentException(vv.getName() + \" instantiation failure\", ex);\n+                }\n+                if (valueValidator instanceof Validator) {\n+                    try {\n+                        ((Validator) valueValidator).validateField(name + \" \" + vv.getSimpleName() + \" value\", o);\n+                        selectedValidators.add(vv.getName());\n+                    } catch (Exception ex) {\n+                        // only one will pass, so ignore all validation errors - stored for future use\n+                        validatorExceptions.put(vv.getName(), ex);\n+                    }\n+                } else {\n+                    String err = String.format(\"validator: %s cannot be used in CustomExactlyOneOfValidators to validate values. \"\n+                            + \"Individual entry validators must a instance of Validator class\", vv.getName());\n+                    LOG.warn(err);\n+                }\n+            }\n+            // check if one and only one validation succeeded\n+            if (selectedValidators.isEmpty()) {\n+                String parseErrs = String.join(\";\\n\\t\", validatorExceptions.entrySet().stream()\n+                        .map(e -> String.format(\"%s:%s\", e.getKey(), e.getValue())).collect(Collectors.toList()));\n+                String err = String.format(\"Field %s must be one of %s; parse errors are \\n\\t%s\", name,\n+                        String.join(\", \", validatorClassNames), parseErrs);\n+                throw new IllegalArgumentException(err);\n+            }\n+            if (selectedValidators.size() > 1) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must match exactly one of \" + String.join(\", \", selectedValidators));\n+            }\n+        }\n+    }\n+\n+    public static class RasConstraintsTypeValidator extends Validator {\n+        public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+        public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n+\n+        public static class RasConstraint {\n+            int maxNodeCoLocationCnt = -1;\n+            Set<String> incompatibleComponents = new HashSet<>();\n+        }\n+\n+        public Map<String, RasConstraint> rasConstraints = new HashMap<>(); // parsedConstraints\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+            if (!(o instanceof Map)) {\n+                throw new IllegalArgumentException(\n+                        \"Field \" + name + \" must be an Iterable containing only Map of Maps\");\n+            }\n+            Map<String, Object> map1 = (Map<String, Object>)o;\n+            for (Map.Entry<String, Object> entry1: map1.entrySet()) {\n+                String comp1 = entry1.getKey();\n+                Object o2 = entry1.getValue();\n+                RasConstraint rasConstraint = new RasConstraint();\n+                rasConstraints.put(comp1, rasConstraint);\n+                if (!(o2 instanceof Map)) {\n+                    String err = String.format(\"Field %s, component %s, expecting constraints Map with keys [\\\"%s\\\", \\\"%s\\\"], in \\\"%s\\\"\",\n+                            name, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, o);\n+                    throw new IllegalArgumentException(err);\n+                }\n+                Map<String, Object> map2 = (Map<String, Object>)o2;\n+                for (Map.Entry<String, Object> entry2: map2.entrySet()) {\n+                    String constraintType = entry2.getKey();\n+                    Object o3 = entry2.getValue();\n+                    switch (constraintType) {\n+                        case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                            try {\n+                                int intVal = Integer.parseInt(\"\" + o3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0MDU1NQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MDYzOQ==", "bodyText": "Thanks", "url": "https://github.com/apache/storm/pull/3215#discussion_r387880639", "createdAt": "2020-03-04T19:20:59Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+\n+            HashMap<String, Exception> validatorExceptions = new HashMap<>();\n+            Set<String> selectedValidators = new HashSet<>();\n+            for (Class<?> vv : subValidators) {\n+                Object valueValidator;\n+                try {\n+                    valueValidator = vv.getConstructor().newInstance();\n+                } catch (Exception ex) {\n+                    throw new IllegalArgumentException(vv.getName() + \" instantiation failure\", ex);\n+                }\n+                if (valueValidator instanceof Validator) {\n+                    try {\n+                        ((Validator) valueValidator).validateField(name + \" \" + vv.getSimpleName() + \" value\", o);\n+                        selectedValidators.add(vv.getName());\n+                    } catch (Exception ex) {\n+                        // only one will pass, so ignore all validation errors - stored for future use\n+                        validatorExceptions.put(vv.getName(), ex);\n+                    }\n+                } else {\n+                    String err = String.format(\"validator: %s cannot be used in CustomExactlyOneOfValidators to validate values. \"\n+                            + \"Individual entry validators must a instance of Validator class\", vv.getName());\n+                    LOG.warn(err);\n+                }\n+            }\n+            // check if one and only one validation succeeded\n+            if (selectedValidators.isEmpty()) {\n+                String parseErrs = String.join(\";\\n\\t\", validatorExceptions.entrySet().stream()\n+                        .map(e -> String.format(\"%s:%s\", e.getKey(), e.getValue())).collect(Collectors.toList()));\n+                String err = String.format(\"Field %s must be one of %s; parse errors are \\n\\t%s\", name,\n+                        String.join(\", \", validatorClassNames), parseErrs);\n+                throw new IllegalArgumentException(err);\n+            }\n+            if (selectedValidators.size() > 1) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must match exactly one of \" + String.join(\", \", selectedValidators));\n+            }\n+        }\n+    }\n+\n+    public static class RasConstraintsTypeValidator extends Validator {\n+        public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+        public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n+\n+        public static class RasConstraint {\n+            int maxNodeCoLocationCnt = -1;\n+            Set<String> incompatibleComponents = new HashSet<>();\n+        }\n+\n+        public Map<String, RasConstraint> rasConstraints = new HashMap<>(); // parsedConstraints\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must be set.\");\n+            }\n+            if (!(o instanceof Map)) {\n+                throw new IllegalArgumentException(\n+                        \"Field \" + name + \" must be an Iterable containing only Map of Maps\");\n+            }\n+            Map<String, Object> map1 = (Map<String, Object>)o;\n+            for (Map.Entry<String, Object> entry1: map1.entrySet()) {\n+                String comp1 = entry1.getKey();\n+                Object o2 = entry1.getValue();\n+                RasConstraint rasConstraint = new RasConstraint();\n+                rasConstraints.put(comp1, rasConstraint);\n+                if (!(o2 instanceof Map)) {\n+                    String err = String.format(\"Field %s, component %s, expecting constraints Map with keys [\\\"%s\\\", \\\"%s\\\"], in \\\"%s\\\"\",\n+                            name, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, o);\n+                    throw new IllegalArgumentException(err);\n+                }\n+                Map<String, Object> map2 = (Map<String, Object>)o2;\n+                for (Map.Entry<String, Object> entry2: map2.entrySet()) {\n+                    String constraintType = entry2.getKey();\n+                    Object o3 = entry2.getValue();\n+                    switch (constraintType) {\n+                        case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                            try {\n+                                int intVal = Integer.parseInt(\"\" + o3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0MDU1NQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDI5ODkzOnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo0NDowNlrOFxf2SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjoxMjozOFrOFx_ksg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NjM0NA==", "bodyText": "All the exceptions in the signature can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387446344", "createdAt": "2020-03-04T04:44:06Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MjQzNQ==", "bodyText": "All the tests have it. For consistency, they should all be removed or leave them as is?", "url": "https://github.com/apache/storm/pull/3215#discussion_r387872435", "createdAt": "2020-03-04T19:05:36Z", "author": {"login": "bipinprasad"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NjM0NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTc0Mg==", "bodyText": "They should be removed since they are not needed.  But we don't have to remove them from other tests in this PR since they are old code and not harmful. They can be done in a separate PR.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387881742", "createdAt": "2020-03-04T19:22:55Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NjM0NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2NjEzMA==", "bodyText": "Removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387966130", "createdAt": "2020-03-04T22:12:38Z", "author": {"login": "bipinprasad"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NjM0NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMwODkzOnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1MjowNlrOFxf8fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTowOTowM1rOFx59vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NzkzNQ==", "bodyText": "(Integer) can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387447935", "createdAt": "2020-03-04T04:52:06Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,\n+            InstantiationException, IllegalAccessException {\n+        TestConfig config = new TestConfig();\n+        Collection<Object> passCases = new LinkedList<Object>();\n+        Collection<Object> failCases = new LinkedList<Object>();\n+\n+        List<Object> passCaseListOfList = new ArrayList<>();\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp2\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp3\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp4\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp5\"));\n+\n+        Map<Object, Object> passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3NDIzOQ==", "bodyText": "Removed superflous Integer cast", "url": "https://github.com/apache/storm/pull/3215#discussion_r387874239", "createdAt": "2020-03-04T19:09:03Z", "author": {"login": "bipinprasad"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,\n+            InstantiationException, IllegalAccessException {\n+        TestConfig config = new TestConfig();\n+        Collection<Object> passCases = new LinkedList<Object>();\n+        Collection<Object> failCases = new LinkedList<Object>();\n+\n+        List<Object> passCaseListOfList = new ArrayList<>();\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp2\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp3\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp4\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp5\"));\n+\n+        Map<Object, Object> passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NzkzNQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMxMDA3OnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1Mjo0OFrOFxf9KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1Mjo0OFrOFxf9KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODEwNQ==", "bodyText": "(Integer) can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387448105", "createdAt": "2020-03-04T04:52:48Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,\n+            InstantiationException, IllegalAccessException {\n+        TestConfig config = new TestConfig();\n+        Collection<Object> passCases = new LinkedList<Object>();\n+        Collection<Object> failCases = new LinkedList<Object>();\n+\n+        List<Object> passCaseListOfList = new ArrayList<>();\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp2\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp3\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp4\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp5\"));\n+\n+        Map<Object, Object> passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMxMDIyOnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1Mjo1MlrOFxf9PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1Mjo1MlrOFxf9PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODEyNA==", "bodyText": "(Integer) can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387448124", "createdAt": "2020-03-04T04:52:52Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,\n+            InstantiationException, IllegalAccessException {\n+        TestConfig config = new TestConfig();\n+        Collection<Object> passCases = new LinkedList<Object>();\n+        Collection<Object> failCases = new LinkedList<Object>();\n+\n+        List<Object> passCaseListOfList = new ArrayList<>();\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp2\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp3\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp4\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp5\"));\n+\n+        Map<Object, Object> passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp4\", \"comp5\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMxMDM4OnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1Mjo1N1rOFxf9Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1Mjo1N1rOFxf9Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODE0Ng==", "bodyText": "(Integer) can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387448146", "createdAt": "2020-03-04T04:52:57Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,\n+            InstantiationException, IllegalAccessException {\n+        TestConfig config = new TestConfig();\n+        Collection<Object> passCases = new LinkedList<Object>();\n+        Collection<Object> failCases = new LinkedList<Object>();\n+\n+        List<Object> passCaseListOfList = new ArrayList<>();\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp2\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp3\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp4\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp5\"));\n+\n+        Map<Object, Object> passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp4\", \"comp5\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp4\", \"comp5\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, \"comp2\"},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMxMDc2OnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1MzowOVrOFxf9hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1MzowOVrOFxf9hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODE5Nw==", "bodyText": "(Integer) can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387448197", "createdAt": "2020-03-04T04:53:09Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,\n+            InstantiationException, IllegalAccessException {\n+        TestConfig config = new TestConfig();\n+        Collection<Object> passCases = new LinkedList<Object>();\n+        Collection<Object> failCases = new LinkedList<Object>();\n+\n+        List<Object> passCaseListOfList = new ArrayList<>();\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp2\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp3\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp4\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp5\"));\n+\n+        Map<Object, Object> passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp4\", \"comp5\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp4\", \"comp5\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, \"comp2\"},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, \"comp4\"},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        for (Object value : passCases) {\n+            config.put(TestConfig.TEST_MAP_CONFIG_9, value);\n+            ConfigValidation.validateFields(config, Arrays.asList(TestConfig.class));\n+        }\n+\n+        List<Object> failCaseList = new ArrayList<>();\n+        failCaseList.add(Arrays.asList(\"comp1\", Arrays.asList(\"comp2\", \"comp3\")));\n+        failCaseList.add(Arrays.asList(\"comp3\", Arrays.asList(\"comp4\", \"comp5\")));\n+        failCases.add(failCaseList);\n+\n+        Map<String, Object> failCaseMapOfMap = new HashMap<>();\n+        failCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMxMDkwOnYy", "diffSide": "RIGHT", "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1MzoxM1rOFxf9mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNDo1MzoxM1rOFxf9mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0ODIxNg==", "bodyText": "(Integer) can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387448216", "createdAt": "2020-03-04T04:53:13Z", "author": {"login": "Ethanlm"}, "path": "storm-client/test/jvm/org/apache/storm/TestConfigValidate.java", "diffHunk": "@@ -541,6 +547,127 @@ public void testMapEntryCustomAnnotation() throws InvocationTargetException, NoS\n         }\n     }\n \n+    @Test\n+    public void testExactlyOneOfCustomAnnotation() throws InvocationTargetException, NoSuchMethodException, NoSuchFieldException,\n+            InstantiationException, IllegalAccessException {\n+        TestConfig config = new TestConfig();\n+        Collection<Object> passCases = new LinkedList<Object>();\n+        Collection<Object> failCases = new LinkedList<Object>();\n+\n+        List<Object> passCaseListOfList = new ArrayList<>();\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp2\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp1\", \"comp3\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp4\"));\n+        passCaseListOfList.add(Arrays.asList(\"comp2\", \"comp5\"));\n+\n+        Map<Object, Object> passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp4\", \"comp5\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp2\", \"comp3\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(\"comp4\", \"comp5\")},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        passCaseMapOfMap = new HashMap<>();\n+        passCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, \"comp2\"},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, \"comp4\"},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        passCases.add(passCaseMapOfMap);\n+\n+        for (Object value : passCases) {\n+            config.put(TestConfig.TEST_MAP_CONFIG_9, value);\n+            ConfigValidation.validateFields(config, Arrays.asList(TestConfig.class));\n+        }\n+\n+        List<Object> failCaseList = new ArrayList<>();\n+        failCaseList.add(Arrays.asList(\"comp1\", Arrays.asList(\"comp2\", \"comp3\")));\n+        failCaseList.add(Arrays.asList(\"comp3\", Arrays.asList(\"comp4\", \"comp5\")));\n+        failCases.add(failCaseList);\n+\n+        Map<String, Object> failCaseMapOfMap = new HashMap<>();\n+        failCaseMapOfMap.put(\"comp1\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)10 },\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, Arrays.asList(1, 2, 3)},\n+                }).collect(Collectors.toMap(data -> data[0], data -> data[1]))\n+        );\n+        failCaseMapOfMap.put(\"comp2\",\n+                Stream.of(new Object[][] {\n+                        { RasConstraintsTypeValidator.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, (Integer)2 },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMyNDk4OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTowNDoyMVrOFxgGLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToxODoyMlrOFx6RSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MDQxNA==", "bodyText": "When !comps.contains(comp1), it would better to log some warning.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387450414", "createdAt": "2020-03-04T05:04:21Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;\n+                                    for (String comp2: list) {\n+                                        if (!comps.contains(comp2)) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not a valid component\", ctype, comp2, comp1);\n+                                            continue;\n+                                        }\n+                                        if (comp1.equals(comp2)) {\n+                                            if (!maxCoLocationCnts.containsKey(comp1)) {\n+                                                maxCoLocationCnts.put(comp1, 1);\n+                                            }\n+                                        } else {\n+                                            incompatibleComponents.get(comp1).add(comp2);\n+                                            incompatibleComponents.get(comp2).add(comp1);\n+                                        }\n+                                    }\n+                                    break;\n+\n+                                default:\n+                                    LOG.warn(\"ConstraintType={} invalid for component={}, valid values are {} and {}, ignoring value={}\",\n+                                            ctype, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT,\n+                                            CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, constraint);\n+                                    break;\n+                            }\n+                        });\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3OTI0MQ==", "bodyText": "Added warning log.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387879241", "createdAt": "2020-03-04T19:18:22Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;\n+                                    for (String comp2: list) {\n+                                        if (!comps.contains(comp2)) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not a valid component\", ctype, comp2, comp1);\n+                                            continue;\n+                                        }\n+                                        if (comp1.equals(comp2)) {\n+                                            if (!maxCoLocationCnts.containsKey(comp1)) {\n+                                                maxCoLocationCnts.put(comp1, 1);\n+                                            }\n+                                        } else {\n+                                            incompatibleComponents.get(comp1).add(comp2);\n+                                            incompatibleComponents.get(comp2).add(comp1);\n+                                        }\n+                                    }\n+                                    break;\n+\n+                                default:\n+                                    LOG.warn(\"ConstraintType={} invalid for component={}, valid values are {} and {}, ignoring value={}\",\n+                                            ctype, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT,\n+                                            CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, constraint);\n+                                    break;\n+                            }\n+                        });\n+                    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MDQxNA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMyNjIyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTowNToyOVrOFxgHCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOToyNzo1NFrOFx6luA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MDYzMw==", "bodyText": "(String) constraint will be better?", "url": "https://github.com/apache/storm/pull/3215#discussion_r387450633", "createdAt": "2020-03-04T05:05:29Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MDAzMg==", "bodyText": "constraint variable here may not be a String, i.e. could be an Integer, depends on how quoted/parsed as a Json string.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387880032", "createdAt": "2020-03-04T19:19:51Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MDYzMw=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4NDQ3Mg==", "bodyText": "Thanks", "url": "https://github.com/apache/storm/pull/3215#discussion_r387884472", "createdAt": "2020-03-04T19:27:54Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MDYzMw=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMyODg1OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTowNzoyNlrOFxgIoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTozMDoxNlrOFx6rEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MTA0MQ==", "bodyText": "nit: space between (String) and constraint, (List<String>) and constraint", "url": "https://github.com/apache/storm/pull/3215#discussion_r387451041", "createdAt": "2020-03-04T05:07:26Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4MTgyOA==", "bodyText": "Standard style is not to have a space between cast and variable. Is this not correct?\nChanged.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387881828", "createdAt": "2020-03-04T19:23:05Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MTA0MQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4NTg0MQ==", "bodyText": "Standard style is to have a space\nhttps://www.oracle.com/technetwork/java/codeconventions-150003.pdf (search Casts)", "url": "https://github.com/apache/storm/pull/3215#discussion_r387885841", "createdAt": "2020-03-04T19:30:16Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MTA0MQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDMzNzgxOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToxNDoyNlrOFxgOOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxOTozMTowOFrOFx6tJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MjQ3NQ==", "bodyText": "Consider this case:\n{\"comp-1\", {\"incompatibleComponents\", \"comp-1\"}, {\"maxNodeCoLocationCnt\" , 2}} \nThis means we can have at most 2 comp-1 on the same node, but no more than 1 comp-1 on the same worker.\nThe code here mixes worker-level and node-level constraints and the worker-level constraint will be ignored", "url": "https://github.com/apache/storm/pull/3215#discussion_r387452475", "createdAt": "2020-03-04T05:14:26Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;\n+                                    for (String comp2: list) {\n+                                        if (!comps.contains(comp2)) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not a valid component\", ctype, comp2, comp1);\n+                                            continue;\n+                                        }\n+                                        if (comp1.equals(comp2)) {\n+                                            if (!maxCoLocationCnts.containsKey(comp1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg4NjM3NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387886374", "createdAt": "2020-03-04T19:31:08Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;\n+                                    for (String comp2: list) {\n+                                        if (!comps.contains(comp2)) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not a valid component\", ctype, comp2, comp1);\n+                                            continue;\n+                                        }\n+                                        if (comp1.equals(comp2)) {\n+                                            if (!maxCoLocationCnts.containsKey(comp1)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MjQ3NQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDM0NTIwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToxOTo1M1rOFxgS0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQwMDo0Mjo0N1rOFyCxHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MzY0OA==", "bodyText": "This means we want TOPOLOGY_SPREAD_COMPONENTS to override the maxCoLocationCnts from TOPOLOGY_RAS_CONSTRAINTS. But it's not very obvious to users unless we have enough comments/docs to explain this.\nBut having two configs doing similar work is always confusing.\nI would suggest\n\ndeprecate this config\nfor backwards compatibility, when this config is provided by the topology, only use it when maxCoLocationCnts for the components is not defined in TOPOLOGY_RAS_CONSTRAINTS", "url": "https://github.com/apache/storm/pull/3215#discussion_r387453648", "createdAt": "2020-03-04T05:19:53Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;\n+                                    for (String comp2: list) {\n+                                        if (!comps.contains(comp2)) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not a valid component\", ctype, comp2, comp1);\n+                                            continue;\n+                                        }\n+                                        if (comp1.equals(comp2)) {\n+                                            if (!maxCoLocationCnts.containsKey(comp1)) {\n+                                                maxCoLocationCnts.put(comp1, 1);\n+                                            }\n+                                        } else {\n+                                            incompatibleComponents.get(comp1).add(comp2);\n+                                            incompatibleComponents.get(comp2).add(comp1);\n+                                        }\n+                                    }\n+                                    break;\n+\n+                                default:\n+                                    LOG.warn(\"ConstraintType={} invalid for component={}, valid values are {} and {}, ignoring value={}\",\n+                                            ctype, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT,\n+                                            CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, constraint);\n+                                    break;\n+                            }\n+                        });\n+                    }\n+                });\n+            }\n+\n+            // process Config.TOPOLOGY_SPREAD_COMPONENTS - old style\n+            Object obj = conf.get(Config.TOPOLOGY_SPREAD_COMPONENTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5NTg1NA==", "bodyText": "Changed code to use only if maxNodeCoLocationCnt is not already defined in TOPOLOGY_RAS_CONSTRAINTS., warn otherwise.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387895854", "createdAt": "2020-03-04T19:48:22Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;\n+                                    for (String comp2: list) {\n+                                        if (!comps.contains(comp2)) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not a valid component\", ctype, comp2, comp1);\n+                                            continue;\n+                                        }\n+                                        if (comp1.equals(comp2)) {\n+                                            if (!maxCoLocationCnts.containsKey(comp1)) {\n+                                                maxCoLocationCnts.put(comp1, 1);\n+                                            }\n+                                        } else {\n+                                            incompatibleComponents.get(comp1).add(comp2);\n+                                            incompatibleComponents.get(comp2).add(comp1);\n+                                        }\n+                                    }\n+                                    break;\n+\n+                                default:\n+                                    LOG.warn(\"ConstraintType={} invalid for component={}, valid values are {} and {}, ignoring value={}\",\n+                                            ctype, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT,\n+                                            CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, constraint);\n+                                    break;\n+                            }\n+                        });\n+                    }\n+                });\n+            }\n+\n+            // process Config.TOPOLOGY_SPREAD_COMPONENTS - old style\n+            Object obj = conf.get(Config.TOPOLOGY_SPREAD_COMPONENTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MzY0OA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxODQ2Mw==", "bodyText": "TOPOLOGY_SPREAD_COMPONENTS marked as @deprecated.", "url": "https://github.com/apache/storm/pull/3215#discussion_r388018463", "createdAt": "2020-03-05T00:42:47Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +39,188 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            this(topo.getConf(), topo.getComponents().keySet());\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt\n+                        v.forEach((ctype, constraint) -> {\n+                            switch (ctype) {\n+                                case CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT:\n+                                    try {\n+                                        int numValue = Integer.parseInt(\"\" + constraint);\n+                                        if (numValue < 1) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, numValue, comp1);\n+                                        } else {\n+                                            maxCoLocationCnts.put(comp1, numValue);\n+                                        }\n+                                    } catch (Exception ex) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expected >= 1\", ctype, constraint, comp1);\n+                                    }\n+                                    break;\n+\n+                                case CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS:\n+                                    if (!(constraint instanceof List || constraint instanceof String)) {\n+                                        LOG.warn(\"{} {} declared for Comp {} is not valid, expecting a list of components or 1 component\",\n+                                                ctype, constraint, comp1);\n+                                        break;\n+                                    }\n+                                    List<String> list;\n+                                    list = (constraint instanceof String) ? Arrays.asList((String)constraint) : (List<String>)constraint;\n+                                    for (String comp2: list) {\n+                                        if (!comps.contains(comp2)) {\n+                                            LOG.warn(\"{} {} declared for Comp {} is not a valid component\", ctype, comp2, comp1);\n+                                            continue;\n+                                        }\n+                                        if (comp1.equals(comp2)) {\n+                                            if (!maxCoLocationCnts.containsKey(comp1)) {\n+                                                maxCoLocationCnts.put(comp1, 1);\n+                                            }\n+                                        } else {\n+                                            incompatibleComponents.get(comp1).add(comp2);\n+                                            incompatibleComponents.get(comp2).add(comp1);\n+                                        }\n+                                    }\n+                                    break;\n+\n+                                default:\n+                                    LOG.warn(\"ConstraintType={} invalid for component={}, valid values are {} and {}, ignoring value={}\",\n+                                            ctype, comp1, CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT,\n+                                            CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, constraint);\n+                                    break;\n+                            }\n+                        });\n+                    }\n+                });\n+            }\n+\n+            // process Config.TOPOLOGY_SPREAD_COMPONENTS - old style\n+            Object obj = conf.get(Config.TOPOLOGY_SPREAD_COMPONENTS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1MzY0OA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDM0OTU2OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/Config.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToyMjo1NlrOFxgVdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMDowMDo0MVrOFx7s1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NDMyNA==", "bodyText": "We might need more detailed explanations on what this config does.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387454324", "createdAt": "2020-03-04T05:22:56Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/Config.java", "diffHunk": "@@ -304,11 +307,13 @@\n     // an error will be thrown by nimbus on topology submission and not by the client prior to submitting\n     // the topology.\n     public static final String TOPOLOGY_SCHEDULER_STRATEGY = \"topology.scheduler.strategy\";\n+\n     /**\n-     * Declare scheduling constraints for a topology used by the constraint solver strategy. A List of pairs (also a list) of components\n-     * that cannot coexist in the same worker.\n+     * Declare scheduling constraints for a topology used by the constraint solver strategy. The format can be either", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkwMjY3OA==", "bodyText": "Added comments on the config format.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387902678", "createdAt": "2020-03-04T20:00:41Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/Config.java", "diffHunk": "@@ -304,11 +307,13 @@\n     // an error will be thrown by nimbus on topology submission and not by the client prior to submitting\n     // the topology.\n     public static final String TOPOLOGY_SCHEDULER_STRATEGY = \"topology.scheduler.strategy\";\n+\n     /**\n-     * Declare scheduling constraints for a topology used by the constraint solver strategy. A List of pairs (also a list) of components\n-     * that cannot coexist in the same worker.\n+     * Declare scheduling constraints for a topology used by the constraint solver strategy. The format can be either", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NDMyNA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDM1NjcyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNToyODozMlrOFxgaAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMDowNDo1OVrOFx71Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NTQ5MA==", "bodyText": "constraintConfig doesn't seem necessary here", "url": "https://github.com/apache/storm/pull/3215#discussion_r387455490", "createdAt": "2020-03-04T05:28:32Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -134,48 +252,51 @@ private static boolean checkConstraintsSatisfied(Cluster cluster, TopologyDetail\n         return workerToNodes;\n     }\n \n-    private static boolean checkSpreadSchedulingValid(Cluster cluster, TopologyDetails topo) {\n+    private static boolean checkSpreadSchedulingValid(Cluster cluster, TopologyDetails topo, ConstraintConfig constraintConfig) {\n         LOG.info(\"Checking for a valid scheduling...\");\n         assert (cluster.getAssignmentById(topo.getId()) != null);\n-        Map<ExecutorDetails, WorkerSlot> result = cluster.getAssignmentById(topo.getId()).getExecutorToSlot();\n+        if (constraintConfig == null) {\n+            constraintConfig = new ConstraintConfig(topo);\n+        }\n         Map<ExecutorDetails, String> execToComp = topo.getExecutorToComponent();\n-        Map<WorkerSlot, HashSet<ExecutorDetails>> workerExecMap = new HashMap<>();\n-        Map<WorkerSlot, HashSet<String>> workerCompMap = new HashMap<>();\n-        Map<RasNode, HashSet<String>> nodeCompMap = new HashMap<>();\n+        Map<String, Map<String, Integer>> nodeCompMap = new HashMap<>(); // this is the critical count\n         Map<WorkerSlot, RasNode> workerToNodes = workerToNodes(cluster);\n         boolean ret = true;\n \n-        HashSet<String> spreadComps = getSpreadComps(topo);\n-        for (Map.Entry<ExecutorDetails, WorkerSlot> entry : result.entrySet()) {\n+        Map<String, Integer> spreadCompCnts = constraintConfig.maxCoLocationCnts;\n+        for (Map.Entry<ExecutorDetails, WorkerSlot> entry : cluster.getAssignmentById(topo.getId()).getExecutorToSlot().entrySet()) {\n             ExecutorDetails exec = entry.getKey();\n+            String comp = execToComp.get(exec);\n             WorkerSlot worker = entry.getValue();\n             RasNode node = workerToNodes.get(worker);\n-\n-            if (workerExecMap.computeIfAbsent(worker, (k) -> new HashSet<>()).contains(exec)) {\n-                LOG.error(\"Incorrect Scheduling: Found duplicate in scheduling\");\n-                return false;\n-            }\n-            workerExecMap.get(worker).add(exec);\n-            String comp = execToComp.get(exec);\n-            workerCompMap.computeIfAbsent(worker, (k) -> new HashSet<>()).add(comp);\n-            if (spreadComps.contains(comp)) {\n-                if (nodeCompMap.computeIfAbsent(node, (k) -> new HashSet<>()).contains(comp)) {\n-                    LOG.error(\"Incorrect Scheduling: Spread for Component: {} {} on node {} not satisfied {}\",\n-                              comp, exec, node.getId(), nodeCompMap.get(node));\n+            String nodeId = node.getId();\n+\n+            if (spreadCompCnts.containsKey(comp)) {\n+                int allowedColocationMaxCnt = spreadCompCnts.get(comp);\n+                Map<String, Integer> oneNodeCompMap = nodeCompMap.computeIfAbsent(nodeId, (k) -> new HashMap<>());\n+                oneNodeCompMap.put(comp, oneNodeCompMap.getOrDefault(comp, 0) + 1);\n+                if (allowedColocationMaxCnt < oneNodeCompMap.get(comp)) {\n+                    LOG.error(\"Incorrect Scheduling: MaxCoLocationCnt for Component: {} {} on node {} not satisfied, cnt {} > allowed {}\",\n+                            comp, exec, nodeId, oneNodeCompMap.get(comp), allowedColocationMaxCnt);\n                     ret = false;\n                 }\n             }\n-            nodeCompMap.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+        }\n+        if (!ret) {\n+            LOG.error(\"Incorrect MaxCoLocationCnts: Node-Component-Cnt {}\", nodeCompMap);\n         }\n         return ret;\n     }\n \n     /**\n      * Check if resource constraints satisfied.\n      */\n-    private static boolean checkResourcesCorrect(Cluster cluster, TopologyDetails topo) {\n+    private static boolean checkResourcesCorrect(Cluster cluster, TopologyDetails topo, ConstraintConfig constraintConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkwNDgwMg==", "bodyText": "removed unused param", "url": "https://github.com/apache/storm/pull/3215#discussion_r387904802", "createdAt": "2020-03-04T20:04:59Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -134,48 +252,51 @@ private static boolean checkConstraintsSatisfied(Cluster cluster, TopologyDetail\n         return workerToNodes;\n     }\n \n-    private static boolean checkSpreadSchedulingValid(Cluster cluster, TopologyDetails topo) {\n+    private static boolean checkSpreadSchedulingValid(Cluster cluster, TopologyDetails topo, ConstraintConfig constraintConfig) {\n         LOG.info(\"Checking for a valid scheduling...\");\n         assert (cluster.getAssignmentById(topo.getId()) != null);\n-        Map<ExecutorDetails, WorkerSlot> result = cluster.getAssignmentById(topo.getId()).getExecutorToSlot();\n+        if (constraintConfig == null) {\n+            constraintConfig = new ConstraintConfig(topo);\n+        }\n         Map<ExecutorDetails, String> execToComp = topo.getExecutorToComponent();\n-        Map<WorkerSlot, HashSet<ExecutorDetails>> workerExecMap = new HashMap<>();\n-        Map<WorkerSlot, HashSet<String>> workerCompMap = new HashMap<>();\n-        Map<RasNode, HashSet<String>> nodeCompMap = new HashMap<>();\n+        Map<String, Map<String, Integer>> nodeCompMap = new HashMap<>(); // this is the critical count\n         Map<WorkerSlot, RasNode> workerToNodes = workerToNodes(cluster);\n         boolean ret = true;\n \n-        HashSet<String> spreadComps = getSpreadComps(topo);\n-        for (Map.Entry<ExecutorDetails, WorkerSlot> entry : result.entrySet()) {\n+        Map<String, Integer> spreadCompCnts = constraintConfig.maxCoLocationCnts;\n+        for (Map.Entry<ExecutorDetails, WorkerSlot> entry : cluster.getAssignmentById(topo.getId()).getExecutorToSlot().entrySet()) {\n             ExecutorDetails exec = entry.getKey();\n+            String comp = execToComp.get(exec);\n             WorkerSlot worker = entry.getValue();\n             RasNode node = workerToNodes.get(worker);\n-\n-            if (workerExecMap.computeIfAbsent(worker, (k) -> new HashSet<>()).contains(exec)) {\n-                LOG.error(\"Incorrect Scheduling: Found duplicate in scheduling\");\n-                return false;\n-            }\n-            workerExecMap.get(worker).add(exec);\n-            String comp = execToComp.get(exec);\n-            workerCompMap.computeIfAbsent(worker, (k) -> new HashSet<>()).add(comp);\n-            if (spreadComps.contains(comp)) {\n-                if (nodeCompMap.computeIfAbsent(node, (k) -> new HashSet<>()).contains(comp)) {\n-                    LOG.error(\"Incorrect Scheduling: Spread for Component: {} {} on node {} not satisfied {}\",\n-                              comp, exec, node.getId(), nodeCompMap.get(node));\n+            String nodeId = node.getId();\n+\n+            if (spreadCompCnts.containsKey(comp)) {\n+                int allowedColocationMaxCnt = spreadCompCnts.get(comp);\n+                Map<String, Integer> oneNodeCompMap = nodeCompMap.computeIfAbsent(nodeId, (k) -> new HashMap<>());\n+                oneNodeCompMap.put(comp, oneNodeCompMap.getOrDefault(comp, 0) + 1);\n+                if (allowedColocationMaxCnt < oneNodeCompMap.get(comp)) {\n+                    LOG.error(\"Incorrect Scheduling: MaxCoLocationCnt for Component: {} {} on node {} not satisfied, cnt {} > allowed {}\",\n+                            comp, exec, nodeId, oneNodeCompMap.get(comp), allowedColocationMaxCnt);\n                     ret = false;\n                 }\n             }\n-            nodeCompMap.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+        }\n+        if (!ret) {\n+            LOG.error(\"Incorrect MaxCoLocationCnts: Node-Component-Cnt {}\", nodeCompMap);\n         }\n         return ret;\n     }\n \n     /**\n      * Check if resource constraints satisfied.\n      */\n-    private static boolean checkResourcesCorrect(Cluster cluster, TopologyDetails topo) {\n+    private static boolean checkResourcesCorrect(Cluster cluster, TopologyDetails topo, ConstraintConfig constraintConfig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NTQ5MA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDM5NDQ0OnYy", "diffSide": "LEFT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNTo1NDoxM1rOFxgxLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMDo1MjoyM1rOFx9MtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2MTQyMg==", "bodyText": "This constraintMatrix includes system components, like Acker because it gets components from execToComp\nBut topo.getComponents().keySet() in new ConstraintConfig(td); only includes non-system components.\nI have to say the storm code is confusing. But just want to point out the different between these two that will cause some behavior changes because of the code change here", "url": "https://github.com/apache/storm/pull/3215#discussion_r387461422", "createdAt": "2020-03-04T05:54:13Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -262,28 +367,27 @@ public SchedulingResult schedule(Cluster cluster, TopologyDetails td) {\n         //get mapping of components to executors\n         compToExecs = getCompToExecs(execToComp);\n \n-        //get topology constraints\n-        constraintMatrix = getConstraintMap(td, compToExecs.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyNzIyMA==", "bodyText": "Fixed - added system components so they can also be specified in constraints.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387927220", "createdAt": "2020-03-04T20:52:23Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -262,28 +367,27 @@ public SchedulingResult schedule(Cluster cluster, TopologyDetails td) {\n         //get mapping of components to executors\n         compToExecs = getCompToExecs(execToComp);\n \n-        //get topology constraints\n-        constraintMatrix = getConstraintMap(td, compToExecs.keySet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2MTQyMg=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDQxNDMzOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNjowNjozNlrOFxg9eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyMDozMlrOFygtWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NDU2OQ==", "bodyText": "Maybe we should change >= to >?\nHere coLocationMaxCnt is exclusive.  And coLocationMaxCnt=1 would mean 0 of this component can co-exist on the same node, which doesn't seem right to me", "url": "https://github.com/apache/storm/pull/3215#discussion_r387464569", "createdAt": "2020-03-04T06:06:36Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -420,21 +528,24 @@ public boolean isExecAssignmentToWorkerValid(WorkerSlot worker, SearcherState st\n \n         //check if exec can be on worker based on user defined component exclusions\n         String execComp = execToComp.get(exec);\n-        Set<String> components = state.workerCompAssignment.get(worker);\n-        if (components != null) {\n-            Map<String, Integer> subMatrix = constraintMatrix.get(execComp);\n-            for (String comp : components) {\n-                if (subMatrix.get(comp) != 0) {\n+        Map<String, Integer> compAssignmentCnts = state.workerCompAssignmentCnts.get(worker);\n+        if (compAssignmentCnts != null && constraintConfig.incompatibleComponents.containsKey(execComp)) {\n+            Set<String> subMatrix = constraintConfig.incompatibleComponents.get(execComp);\n+            for (String comp : compAssignmentCnts.keySet()) {\n+                if (subMatrix.contains(comp)) {\n                     LOG.trace(\"{} found {} constraint violation {} on {}\", exec, execComp, comp, worker);\n                     return false;\n                 }\n             }\n         }\n \n         //check if exec satisfy spread\n-        if (spreadComps.contains(execComp)) {\n-            if (state.nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).contains(execComp)) {\n-                LOG.trace(\"{} Found spread violation {} on node {}\", exec, execComp, node.getId());\n+        if (constraintConfig.maxCoLocationCnts.containsKey(execComp)) {\n+            int coLocationMaxCnt = constraintConfig.maxCoLocationCnts.get(execComp);\n+            if (state.nodeCompAssignmentCnts.containsKey(node)\n+                    && state.nodeCompAssignmentCnts.get(node).getOrDefault(execComp, 0) >= coLocationMaxCnt) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzMDE1Nw==", "bodyText": "This check is before assignment.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387930157", "createdAt": "2020-03-04T20:58:01Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -420,21 +528,24 @@ public boolean isExecAssignmentToWorkerValid(WorkerSlot worker, SearcherState st\n \n         //check if exec can be on worker based on user defined component exclusions\n         String execComp = execToComp.get(exec);\n-        Set<String> components = state.workerCompAssignment.get(worker);\n-        if (components != null) {\n-            Map<String, Integer> subMatrix = constraintMatrix.get(execComp);\n-            for (String comp : components) {\n-                if (subMatrix.get(comp) != 0) {\n+        Map<String, Integer> compAssignmentCnts = state.workerCompAssignmentCnts.get(worker);\n+        if (compAssignmentCnts != null && constraintConfig.incompatibleComponents.containsKey(execComp)) {\n+            Set<String> subMatrix = constraintConfig.incompatibleComponents.get(execComp);\n+            for (String comp : compAssignmentCnts.keySet()) {\n+                if (subMatrix.contains(comp)) {\n                     LOG.trace(\"{} found {} constraint violation {} on {}\", exec, execComp, comp, worker);\n                     return false;\n                 }\n             }\n         }\n \n         //check if exec satisfy spread\n-        if (spreadComps.contains(execComp)) {\n-            if (state.nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).contains(execComp)) {\n-                LOG.trace(\"{} Found spread violation {} on node {}\", exec, execComp, node.getId());\n+        if (constraintConfig.maxCoLocationCnts.containsKey(execComp)) {\n+            int coLocationMaxCnt = constraintConfig.maxCoLocationCnts.get(execComp);\n+            if (state.nodeCompAssignmentCnts.containsKey(node)\n+                    && state.nodeCompAssignmentCnts.get(node).getOrDefault(execComp, 0) >= coLocationMaxCnt) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NDU2OQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwOTAxNw==", "bodyText": "You are right. Thanks", "url": "https://github.com/apache/storm/pull/3215#discussion_r388509017", "createdAt": "2020-03-05T19:20:32Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -420,21 +528,24 @@ public boolean isExecAssignmentToWorkerValid(WorkerSlot worker, SearcherState st\n \n         //check if exec can be on worker based on user defined component exclusions\n         String execComp = execToComp.get(exec);\n-        Set<String> components = state.workerCompAssignment.get(worker);\n-        if (components != null) {\n-            Map<String, Integer> subMatrix = constraintMatrix.get(execComp);\n-            for (String comp : components) {\n-                if (subMatrix.get(comp) != 0) {\n+        Map<String, Integer> compAssignmentCnts = state.workerCompAssignmentCnts.get(worker);\n+        if (compAssignmentCnts != null && constraintConfig.incompatibleComponents.containsKey(execComp)) {\n+            Set<String> subMatrix = constraintConfig.incompatibleComponents.get(execComp);\n+            for (String comp : compAssignmentCnts.keySet()) {\n+                if (subMatrix.contains(comp)) {\n                     LOG.trace(\"{} found {} constraint violation {} on {}\", exec, execComp, comp, worker);\n                     return false;\n                 }\n             }\n         }\n \n         //check if exec satisfy spread\n-        if (spreadComps.contains(execComp)) {\n-            if (state.nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).contains(execComp)) {\n-                LOG.trace(\"{} Found spread violation {} on node {}\", exec, execComp, node.getId());\n+        if (constraintConfig.maxCoLocationCnts.containsKey(execComp)) {\n+            int coLocationMaxCnt = constraintConfig.maxCoLocationCnts.get(execComp);\n+            if (state.nodeCompAssignmentCnts.containsKey(node)\n+                    && state.nodeCompAssignmentCnts.get(node).getOrDefault(execComp, 0) >= coLocationMaxCnt) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2NDU2OQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 496}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDQ0MTMzOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNjoyMzowMFrOFxhOQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMDowNjoxNlrOF1HFeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2ODg2NA==", "bodyText": "Is this fixing some kind of bug?", "url": "https://github.com/apache/storm/pull/3215#discussion_r387468864", "createdAt": "2020-03-04T06:23:00Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -593,13 +710,26 @@ public ExecutorDetails currentExec() {\n             return execs.get(execIndex);\n         }\n \n+        /**\n+          * Assign executor to worker and node.\n+          * TODO: tryToSchedule is a misnomer, since it always schedules.\n+          * Assignment validity check is done before the call to tryToSchedule().\n+          *\n+          * @param execToComp Mapping from executor to component name.\n+          * @param node RasNode on which to schedule.\n+          * @param workerSlot WorkerSlot on which to schedule.\n+          */\n         public void tryToSchedule(Map<ExecutorDetails, String> execToComp, RasNode node, WorkerSlot workerSlot) {\n             ExecutorDetails exec = currentExec();\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Trying assignment of {} {} to {}\", exec, comp, workerSlot);\n-            //It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n-            okToRemoveFromWorker[execIndex] = workerCompAssignment.computeIfAbsent(workerSlot, (k) -> new HashSet<>()).add(comp);\n-            okToRemoveFromNode[execIndex] = nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+            // It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n+            Map<String, Integer> oneMap = workerCompAssignmentCnts.computeIfAbsent(workerSlot, (k) -> new HashMap<>());\n+            oneMap.put(comp, oneMap.getOrDefault(comp, 0) + 1); // increment assignment count\n+            okToRemoveFromWorker[execIndex] = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk0MDMzOA==", "bodyText": "Yes", "url": "https://github.com/apache/storm/pull/3215#discussion_r387940338", "createdAt": "2020-03-04T21:19:08Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -593,13 +710,26 @@ public ExecutorDetails currentExec() {\n             return execs.get(execIndex);\n         }\n \n+        /**\n+          * Assign executor to worker and node.\n+          * TODO: tryToSchedule is a misnomer, since it always schedules.\n+          * Assignment validity check is done before the call to tryToSchedule().\n+          *\n+          * @param execToComp Mapping from executor to component name.\n+          * @param node RasNode on which to schedule.\n+          * @param workerSlot WorkerSlot on which to schedule.\n+          */\n         public void tryToSchedule(Map<ExecutorDetails, String> execToComp, RasNode node, WorkerSlot workerSlot) {\n             ExecutorDetails exec = currentExec();\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Trying assignment of {} {} to {}\", exec, comp, workerSlot);\n-            //It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n-            okToRemoveFromWorker[execIndex] = workerCompAssignment.computeIfAbsent(workerSlot, (k) -> new HashSet<>()).add(comp);\n-            okToRemoveFromNode[execIndex] = nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+            // It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n+            Map<String, Integer> oneMap = workerCompAssignmentCnts.computeIfAbsent(workerSlot, (k) -> new HashMap<>());\n+            oneMap.put(comp, oneMap.getOrDefault(comp, 0) + 1); // increment assignment count\n+            okToRemoveFromWorker[execIndex] = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2ODg2NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTYzOQ==", "bodyText": "Originally, okToRemoveFromWorker is an indicator that whether the component should be removed from workerCompAssignment and nodeCompAssignment during backtracking since originally they are both <Map, Set>.  I don't see a bug here. It's more like an optimization.\nSince now we change workerCompAssignment and nodeCompAssignment to <Map, Map>,  okToRemoveFromWorker is actually not needed any more.\nOr if we leave workerCompAssignment as <Map, Set>, then we need to keep okToRemoveFromWorker.", "url": "https://github.com/apache/storm/pull/3215#discussion_r388505639", "createdAt": "2020-03-05T19:15:08Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -593,13 +710,26 @@ public ExecutorDetails currentExec() {\n             return execs.get(execIndex);\n         }\n \n+        /**\n+          * Assign executor to worker and node.\n+          * TODO: tryToSchedule is a misnomer, since it always schedules.\n+          * Assignment validity check is done before the call to tryToSchedule().\n+          *\n+          * @param execToComp Mapping from executor to component name.\n+          * @param node RasNode on which to schedule.\n+          * @param workerSlot WorkerSlot on which to schedule.\n+          */\n         public void tryToSchedule(Map<ExecutorDetails, String> execToComp, RasNode node, WorkerSlot workerSlot) {\n             ExecutorDetails exec = currentExec();\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Trying assignment of {} {} to {}\", exec, comp, workerSlot);\n-            //It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n-            okToRemoveFromWorker[execIndex] = workerCompAssignment.computeIfAbsent(workerSlot, (k) -> new HashSet<>()).add(comp);\n-            okToRemoveFromNode[execIndex] = nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+            // It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n+            Map<String, Integer> oneMap = workerCompAssignmentCnts.computeIfAbsent(workerSlot, (k) -> new HashMap<>());\n+            oneMap.put(comp, oneMap.getOrDefault(comp, 0) + 1); // increment assignment count\n+            okToRemoveFromWorker[execIndex] = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2ODg2NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc2ODM1MA==", "bodyText": "It was a bug - as it should be always removed upon backtracking if assigned - counting is just safety check to make sure it does not go below zero.", "url": "https://github.com/apache/storm/pull/3215#discussion_r389768350", "createdAt": "2020-03-09T15:30:20Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -593,13 +710,26 @@ public ExecutorDetails currentExec() {\n             return execs.get(execIndex);\n         }\n \n+        /**\n+          * Assign executor to worker and node.\n+          * TODO: tryToSchedule is a misnomer, since it always schedules.\n+          * Assignment validity check is done before the call to tryToSchedule().\n+          *\n+          * @param execToComp Mapping from executor to component name.\n+          * @param node RasNode on which to schedule.\n+          * @param workerSlot WorkerSlot on which to schedule.\n+          */\n         public void tryToSchedule(Map<ExecutorDetails, String> execToComp, RasNode node, WorkerSlot workerSlot) {\n             ExecutorDetails exec = currentExec();\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Trying assignment of {} {} to {}\", exec, comp, workerSlot);\n-            //It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n-            okToRemoveFromWorker[execIndex] = workerCompAssignment.computeIfAbsent(workerSlot, (k) -> new HashSet<>()).add(comp);\n-            okToRemoveFromNode[execIndex] = nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+            // It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n+            Map<String, Integer> oneMap = workerCompAssignmentCnts.computeIfAbsent(workerSlot, (k) -> new HashMap<>());\n+            oneMap.put(comp, oneMap.getOrDefault(comp, 0) + 1); // increment assignment count\n+            okToRemoveFromWorker[execIndex] = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2ODg2NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMTIxNw==", "bodyText": "Let me explain my understanding of the original code and please let me know what I am missing.\nLet's say we are trying to assign exec1 (whose component is comp1) to node1. And let's discuss only nodeCompAssignment for simplicity.\nFirst of all, we have isExecAssignmentToWorkerValid check before tryToSchedule, so there won't be any cases where comp1 is already in on node1 in nodeCompAssignment map, so okToRemoveFromNoder[exec1] is true. When we backtrack, we find it true and set it false. It looks okToRemoveFromNoder is not needed at all.\nSecondly, if we don't check isExecAssignmentToWorkerValid before tryToSchedule, let's say we already have exec0 (whose component is comp1) scheduled on node1 and now we want to schedule exec1.\nNow we will have okToRemoveFromNoder[exec1]=false since comp1 is already in nodeCompAssignment map. And when we backtrack, since okToRemoveFromNoder[exec1]=false, we will not remove comp1 from nodeCompAssignment map since there is a exec0 (also a comp1) scheduled on this node1. This is also a correct behavior.\nSo I don't see a bug in the original code. Please elaborate the bug you observed (asking this just for my knowledge). Thanks.\n\nIf we change workerCompAssignment and nodeCompAssignment from <Map, Set> to <Map, Map> (as in this PR),  I believe okToRemoveFromWorker and okToRemoveFromNode are not needed anymore.\nAnother solution is to change okToRemoveFromNode from boolean[] to int[] to keep track how many of the same component is on this node so far.\nI can't say which solution is better. I believe okToRemoveFromNode was introduced for performance but I don't know how much the performance gain is.", "url": "https://github.com/apache/storm/pull/3215#discussion_r389921217", "createdAt": "2020-03-09T19:46:22Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -593,13 +710,26 @@ public ExecutorDetails currentExec() {\n             return execs.get(execIndex);\n         }\n \n+        /**\n+          * Assign executor to worker and node.\n+          * TODO: tryToSchedule is a misnomer, since it always schedules.\n+          * Assignment validity check is done before the call to tryToSchedule().\n+          *\n+          * @param execToComp Mapping from executor to component name.\n+          * @param node RasNode on which to schedule.\n+          * @param workerSlot WorkerSlot on which to schedule.\n+          */\n         public void tryToSchedule(Map<ExecutorDetails, String> execToComp, RasNode node, WorkerSlot workerSlot) {\n             ExecutorDetails exec = currentExec();\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Trying assignment of {} {} to {}\", exec, comp, workerSlot);\n-            //It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n-            okToRemoveFromWorker[execIndex] = workerCompAssignment.computeIfAbsent(workerSlot, (k) -> new HashSet<>()).add(comp);\n-            okToRemoveFromNode[execIndex] = nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+            // It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n+            Map<String, Integer> oneMap = workerCompAssignmentCnts.computeIfAbsent(workerSlot, (k) -> new HashMap<>());\n+            oneMap.put(comp, oneMap.getOrDefault(comp, 0) + 1); // increment assignment count\n+            okToRemoveFromWorker[execIndex] = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2ODg2NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1Njc3NA==", "bodyText": "Current (and prior) code always checks before assignment. So let's consider that case only for simplicity - that the executor can be assigned to the selected worker and node.\nIf the executor is scheduled in tryToSchedule() then the okToRemoveFromNode flag should be flipped to true, so that when backtracking, the component (or component count) is properly decremented).\nEarlier code would not not remove a component once added (because the flag would only be flipped to true once and any subsequent  assignment backtracking would not remove the component - leading to inconsistent understanding of the current component distribution (and constraint evaluation). So the error will manifest when backtracking.\nLet's say exec1 and exec2 are both assigning the same component to the same worker/node and backtracking happens for exec2 assignment. is exec2 component is not properly decremented out of node1.\nThe assignment (nodeCompAssignment) is a shared variable across executors. So there is no indicator which executor assigned. This flag is only retained in the okToRemove.\nHope this makes sense - unless I am confused!", "url": "https://github.com/apache/storm/pull/3215#discussion_r389956774", "createdAt": "2020-03-09T20:56:19Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -593,13 +710,26 @@ public ExecutorDetails currentExec() {\n             return execs.get(execIndex);\n         }\n \n+        /**\n+          * Assign executor to worker and node.\n+          * TODO: tryToSchedule is a misnomer, since it always schedules.\n+          * Assignment validity check is done before the call to tryToSchedule().\n+          *\n+          * @param execToComp Mapping from executor to component name.\n+          * @param node RasNode on which to schedule.\n+          * @param workerSlot WorkerSlot on which to schedule.\n+          */\n         public void tryToSchedule(Map<ExecutorDetails, String> execToComp, RasNode node, WorkerSlot workerSlot) {\n             ExecutorDetails exec = currentExec();\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Trying assignment of {} {} to {}\", exec, comp, workerSlot);\n-            //It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n-            okToRemoveFromWorker[execIndex] = workerCompAssignment.computeIfAbsent(workerSlot, (k) -> new HashSet<>()).add(comp);\n-            okToRemoveFromNode[execIndex] = nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+            // It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n+            Map<String, Integer> oneMap = workerCompAssignmentCnts.computeIfAbsent(workerSlot, (k) -> new HashMap<>());\n+            oneMap.put(comp, oneMap.getOrDefault(comp, 0) + 1); // increment assignment count\n+            okToRemoveFromWorker[execIndex] = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2ODg2NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 628}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNDkzNw==", "bodyText": "As we discussed offline, the previous code doesn't have a bug.\nokToRemoveFromWorker and okToRemoveFromNode are kept here just for safety and can be removed.", "url": "https://github.com/apache/storm/pull/3215#discussion_r391234937", "createdAt": "2020-03-11T20:06:16Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -593,13 +710,26 @@ public ExecutorDetails currentExec() {\n             return execs.get(execIndex);\n         }\n \n+        /**\n+          * Assign executor to worker and node.\n+          * TODO: tryToSchedule is a misnomer, since it always schedules.\n+          * Assignment validity check is done before the call to tryToSchedule().\n+          *\n+          * @param execToComp Mapping from executor to component name.\n+          * @param node RasNode on which to schedule.\n+          * @param workerSlot WorkerSlot on which to schedule.\n+          */\n         public void tryToSchedule(Map<ExecutorDetails, String> execToComp, RasNode node, WorkerSlot workerSlot) {\n             ExecutorDetails exec = currentExec();\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Trying assignment of {} {} to {}\", exec, comp, workerSlot);\n-            //It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n-            okToRemoveFromWorker[execIndex] = workerCompAssignment.computeIfAbsent(workerSlot, (k) -> new HashSet<>()).add(comp);\n-            okToRemoveFromNode[execIndex] = nodeCompAssignment.computeIfAbsent(node, (k) -> new HashSet<>()).add(comp);\n+            // It is possible that this component is already scheduled on this node or worker.  If so when we backtrack we cannot remove it\n+            Map<String, Integer> oneMap = workerCompAssignmentCnts.computeIfAbsent(workerSlot, (k) -> new HashMap<>());\n+            oneMap.put(comp, oneMap.getOrDefault(comp, 0) + 1); // increment assignment count\n+            okToRemoveFromWorker[execIndex] = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2ODg2NA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 628}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMDQ0MzU5OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwNjoyNDoyNFrOFxhPqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMToxNToyMFrOFx94xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2OTIyNQ==", "bodyText": "new TreeSet<RasNode> can be new TreeSet<>", "url": "https://github.com/apache/storm/pull/3215#discussion_r387469225", "createdAt": "2020-03-04T06:24:24Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -613,14 +743,51 @@ public void backtrack(Map<ExecutorDetails, String> execToComp, RasNode node, Wor\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Backtracking {} {} from {}\", exec, comp, workerSlot);\n             if (okToRemoveFromWorker[execIndex]) {\n-                workerCompAssignment.get(workerSlot).remove(comp);\n+                Map<String, Integer> oneMap = workerCompAssignmentCnts.get(workerSlot);\n+                oneMap.put(comp, oneMap.getOrDefault(comp, 0) - 1); // decrement assignment count\n                 okToRemoveFromWorker[execIndex] = false;\n             }\n             if (okToRemoveFromNode[execIndex]) {\n-                nodeCompAssignment.get(node).remove(comp);\n+                Map<String, Integer> oneMap = nodeCompAssignmentCnts.get(node);\n+                oneMap.put(comp, oneMap.getOrDefault(comp, 0) - 1); // decrement assignment count\n                 okToRemoveFromNode[execIndex] = false;\n             }\n             node.freeSingleExecutor(exec, td);\n         }\n+\n+        /**\n+         * Use this method to log the current component assignments on the Node.\n+         * Useful for debugging and tests.\n+         */\n+        public void logNodeCompAssignments() {\n+            if (nodeCompAssignmentCnts == null || nodeCompAssignmentCnts.isEmpty()) {\n+                LOG.info(\"NodeCompAssignment is empty\");\n+                return;\n+            }\n+            StringBuffer sb = new StringBuffer();\n+            int cntAllNodes = 0;\n+            int cntFilledNodes = 0;\n+            for (RasNode node: new TreeSet<RasNode>(nodeCompAssignmentCnts.keySet())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 665}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzODUwMQ==", "bodyText": "fixed", "url": "https://github.com/apache/storm/pull/3215#discussion_r387938501", "createdAt": "2020-03-04T21:15:20Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -613,14 +743,51 @@ public void backtrack(Map<ExecutorDetails, String> execToComp, RasNode node, Wor\n             String comp = execToComp.get(exec);\n             LOG.trace(\"Backtracking {} {} from {}\", exec, comp, workerSlot);\n             if (okToRemoveFromWorker[execIndex]) {\n-                workerCompAssignment.get(workerSlot).remove(comp);\n+                Map<String, Integer> oneMap = workerCompAssignmentCnts.get(workerSlot);\n+                oneMap.put(comp, oneMap.getOrDefault(comp, 0) - 1); // decrement assignment count\n                 okToRemoveFromWorker[execIndex] = false;\n             }\n             if (okToRemoveFromNode[execIndex]) {\n-                nodeCompAssignment.get(node).remove(comp);\n+                Map<String, Integer> oneMap = nodeCompAssignmentCnts.get(node);\n+                oneMap.put(comp, oneMap.getOrDefault(comp, 0) - 1); // decrement assignment count\n                 okToRemoveFromNode[execIndex] = false;\n             }\n             node.freeSingleExecutor(exec, td);\n         }\n+\n+        /**\n+         * Use this method to log the current component assignments on the Node.\n+         * Useful for debugging and tests.\n+         */\n+        public void logNodeCompAssignments() {\n+            if (nodeCompAssignmentCnts == null || nodeCompAssignmentCnts.isEmpty()) {\n+                LOG.info(\"NodeCompAssignment is empty\");\n+                return;\n+            }\n+            StringBuffer sb = new StringBuffer();\n+            int cntAllNodes = 0;\n+            int cntFilledNodes = 0;\n+            for (RasNode node: new TreeSet<RasNode>(nodeCompAssignmentCnts.keySet())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ2OTIyNQ=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 665}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMjI3MTYyOnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/Config.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNTo1MDozOFrOFxy0Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMToxNTo1MVrOFx95uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc1NzExNA==", "bodyText": "Some examples of old style and new style configurations might help.", "url": "https://github.com/apache/storm/pull/3215#discussion_r387757114", "createdAt": "2020-03-04T15:50:38Z", "author": {"login": "kishorvpatil"}, "path": "storm-client/src/jvm/org/apache/storm/Config.java", "diffHunk": "@@ -304,11 +307,13 @@\n     // an error will be thrown by nimbus on topology submission and not by the client prior to submitting\n     // the topology.\n     public static final String TOPOLOGY_SCHEDULER_STRATEGY = \"topology.scheduler.strategy\";\n+\n     /**\n-     * Declare scheduling constraints for a topology used by the constraint solver strategy. A List of pairs (also a list) of components\n-     * that cannot coexist in the same worker.\n+     * Declare scheduling constraints for a topology used by the constraint solver strategy. The format can be either\n+     * old style (validated by ListOfListOfStringValidator.class or the newer style, which is a list of specific type of\n+     * Maps (validated by RasConstraintsTypeValidator.class). The value must be in one or the other format.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzODc0NQ==", "bodyText": "Added", "url": "https://github.com/apache/storm/pull/3215#discussion_r387938745", "createdAt": "2020-03-04T21:15:51Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/Config.java", "diffHunk": "@@ -304,11 +307,13 @@\n     // an error will be thrown by nimbus on topology submission and not by the client prior to submitting\n     // the topology.\n     public static final String TOPOLOGY_SCHEDULER_STRATEGY = \"topology.scheduler.strategy\";\n+\n     /**\n-     * Declare scheduling constraints for a topology used by the constraint solver strategy. A List of pairs (also a list) of components\n-     * that cannot coexist in the same worker.\n+     * Declare scheduling constraints for a topology used by the constraint solver strategy. The format can be either\n+     * old style (validated by ListOfListOfStringValidator.class or the newer style, which is a list of specific type of\n+     * Maps (validated by RasConstraintsTypeValidator.class). The value must be in one or the other format.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc1NzExNA=="}, "originalCommit": {"oid": "47877020c4e6f9e2ee0eec87937d847860def2a5"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwMzU3NzU4OnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/Config.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQyMjoxNjo1MVrOFx_sHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzowMTo0NFrOFzmB8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2ODAzMQ==", "bodyText": "typo: \"node\" -> \"worker\"", "url": "https://github.com/apache/storm/pull/3215#discussion_r387968031", "createdAt": "2020-03-04T22:16:51Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/Config.java", "diffHunk": "@@ -304,15 +307,38 @@\n     // an error will be thrown by nimbus on topology submission and not by the client prior to submitting\n     // the topology.\n     public static final String TOPOLOGY_SCHEDULER_STRATEGY = \"topology.scheduler.strategy\";\n+\n     /**\n-     * Declare scheduling constraints for a topology used by the constraint solver strategy. A List of pairs (also a list) of components\n-     * that cannot coexist in the same worker.\n+     * Declare scheduling constraints for a topology used by the constraint solver strategy. The format can be either\n+     * old style (validated by ListOfListOfStringValidator.class or the newer style, which is a list of specific type of\n+     * Maps (validated by RasConstraintsTypeValidator.class). The value must be in one or the other format.\n+     *\n+     * <p>\n+     * Old style Config.TOPOLOGY_RAS_CONSTRAINTS (ListOfListOfString) specified a list of components that cannot\n+     * co-exist on the same Worker.\n+     * </p>\n+     *\n+     * <p>\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * (which serves the same function as the old style configuration) and optional number that specifies\n+     * the maximum co-location count for the component on a node.\n+     * </p>\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68b235902719d856cf9f1ce929e445f8bdf1e633"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDc4NA==", "bodyText": "fixed", "url": "https://github.com/apache/storm/pull/3215#discussion_r389644784", "createdAt": "2020-03-09T13:01:44Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/Config.java", "diffHunk": "@@ -304,15 +307,38 @@\n     // an error will be thrown by nimbus on topology submission and not by the client prior to submitting\n     // the topology.\n     public static final String TOPOLOGY_SCHEDULER_STRATEGY = \"topology.scheduler.strategy\";\n+\n     /**\n-     * Declare scheduling constraints for a topology used by the constraint solver strategy. A List of pairs (also a list) of components\n-     * that cannot coexist in the same worker.\n+     * Declare scheduling constraints for a topology used by the constraint solver strategy. The format can be either\n+     * old style (validated by ListOfListOfStringValidator.class or the newer style, which is a list of specific type of\n+     * Maps (validated by RasConstraintsTypeValidator.class). The value must be in one or the other format.\n+     *\n+     * <p>\n+     * Old style Config.TOPOLOGY_RAS_CONSTRAINTS (ListOfListOfString) specified a list of components that cannot\n+     * co-exist on the same Worker.\n+     * </p>\n+     *\n+     * <p>\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * (which serves the same function as the old style configuration) and optional number that specifies\n+     * the maximum co-location count for the component on a node.\n+     * </p>\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2ODAzMQ=="}, "originalCommit": {"oid": "68b235902719d856cf9f1ce929e445f8bdf1e633"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjYzOTQwOnYy", "diffSide": "RIGHT", "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzoyODo1M1rOFyc9rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNToxNzoxM1rOFzs_2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ0NzY2MQ==", "bodyText": "Line 911-916 doesn't seem necessary?  Or at least it should be private", "url": "https://github.com/apache/storm/pull/3215#discussion_r388447661", "createdAt": "2020-03-05T17:28:53Z", "author": {"login": "Ethanlm"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                return;\n+            }\n+\n+            HashMap<String, Exception> validatorExceptions = new HashMap<>();\n+            Set<String> selectedValidators = new HashSet<>();\n+            for (Class<?> vv : subValidators) {\n+                Object valueValidator;\n+                try {\n+                    valueValidator = vv.getConstructor().newInstance();\n+                } catch (Exception ex) {\n+                    throw new IllegalArgumentException(vv.getName() + \" instantiation failure\", ex);\n+                }\n+                if (valueValidator instanceof Validator) {\n+                    try {\n+                        ((Validator) valueValidator).validateField(name + \" \" + vv.getSimpleName() + \" value\", o);\n+                        selectedValidators.add(vv.getName());\n+                    } catch (Exception ex) {\n+                        // only one will pass, so ignore all validation errors - stored for future use\n+                        validatorExceptions.put(vv.getName(), ex);\n+                    }\n+                } else {\n+                    String err = String.format(\"validator: %s cannot be used in CustomExactlyOneOfValidators to validate values. \"\n+                            + \"Individual entry validators must a instance of Validator class\", vv.getName());\n+                    LOG.warn(err);\n+                }\n+            }\n+            // check if one and only one validation succeeded\n+            if (selectedValidators.isEmpty()) {\n+                String parseErrs = String.join(\";\\n\\t\", validatorExceptions.entrySet().stream()\n+                        .map(e -> String.format(\"%s:%s\", e.getKey(), e.getValue())).collect(Collectors.toList()));\n+                String err = String.format(\"Field %s must be one of %s; parse errors are \\n\\t%s\", name,\n+                        String.join(\", \", validatorClassNames), parseErrs);\n+                throw new IllegalArgumentException(err);\n+            }\n+            if (selectedValidators.size() > 1) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must match exactly one of \" + String.join(\", \", selectedValidators));\n+            }\n+        }\n+    }\n+\n+    public static class RasConstraintsTypeValidator extends Validator {\n+        public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+        public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n+\n+        public static class RasConstraint {\n+            int maxNodeCoLocationCnt = -1;\n+            Set<String> incompatibleComponents = new HashSet<>();\n+        }\n+\n+        public Map<String, RasConstraint> rasConstraints = new HashMap<>(); // parsedConstraints", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc1ODkzNg==", "bodyText": "Originally I thought this could be used in testing and parsing. But due to package structure it cant. Removed this class. Check for validity only (also added test for the String in list check.", "url": "https://github.com/apache/storm/pull/3215#discussion_r389758936", "createdAt": "2020-03-09T15:17:13Z", "author": {"login": "bipinprasad"}, "path": "storm-client/src/jvm/org/apache/storm/validation/ConfigValidation.java", "diffHunk": "@@ -850,6 +852,128 @@ public void validateField(String name, Object o) {\n         }\n     }\n \n+    public static class CustomIsExactlyOneOfValidators extends Validator {\n+        private Class<?>[] subValidators;\n+        private List<String> validatorClassNames;\n+\n+        public CustomIsExactlyOneOfValidators(Map<String, Object> params) {\n+            this.subValidators = (Class<?>[]) params.get(ConfigValidationAnnotations.ValidatorParams.VALUE_VALIDATOR_CLASSES);\n+            this.validatorClassNames = Arrays.asList(subValidators).stream().map(x -> x.getName()).collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public void validateField(String name, Object o) {\n+            if (o == null) {\n+                return;\n+            }\n+\n+            HashMap<String, Exception> validatorExceptions = new HashMap<>();\n+            Set<String> selectedValidators = new HashSet<>();\n+            for (Class<?> vv : subValidators) {\n+                Object valueValidator;\n+                try {\n+                    valueValidator = vv.getConstructor().newInstance();\n+                } catch (Exception ex) {\n+                    throw new IllegalArgumentException(vv.getName() + \" instantiation failure\", ex);\n+                }\n+                if (valueValidator instanceof Validator) {\n+                    try {\n+                        ((Validator) valueValidator).validateField(name + \" \" + vv.getSimpleName() + \" value\", o);\n+                        selectedValidators.add(vv.getName());\n+                    } catch (Exception ex) {\n+                        // only one will pass, so ignore all validation errors - stored for future use\n+                        validatorExceptions.put(vv.getName(), ex);\n+                    }\n+                } else {\n+                    String err = String.format(\"validator: %s cannot be used in CustomExactlyOneOfValidators to validate values. \"\n+                            + \"Individual entry validators must a instance of Validator class\", vv.getName());\n+                    LOG.warn(err);\n+                }\n+            }\n+            // check if one and only one validation succeeded\n+            if (selectedValidators.isEmpty()) {\n+                String parseErrs = String.join(\";\\n\\t\", validatorExceptions.entrySet().stream()\n+                        .map(e -> String.format(\"%s:%s\", e.getKey(), e.getValue())).collect(Collectors.toList()));\n+                String err = String.format(\"Field %s must be one of %s; parse errors are \\n\\t%s\", name,\n+                        String.join(\", \", validatorClassNames), parseErrs);\n+                throw new IllegalArgumentException(err);\n+            }\n+            if (selectedValidators.size() > 1) {\n+                throw new IllegalArgumentException(\"Field \" + name + \" must match exactly one of \" + String.join(\", \", selectedValidators));\n+            }\n+        }\n+    }\n+\n+    public static class RasConstraintsTypeValidator extends Validator {\n+        public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+        public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n+\n+        public static class RasConstraint {\n+            int maxNodeCoLocationCnt = -1;\n+            Set<String> incompatibleComponents = new HashSet<>();\n+        }\n+\n+        public Map<String, RasConstraint> rasConstraints = new HashMap<>(); // parsedConstraints", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ0NzY2MQ=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjY1OTkxOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzozNDo0N1rOFydKUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowMTozMFrOFzu3Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MDg5OQ==", "bodyText": "typo: node -> worker", "url": "https://github.com/apache/storm/pull/3215#discussion_r388450899", "createdAt": "2020-03-05T17:34:47Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4OTQ4Mg==", "bodyText": "Fixed", "url": "https://github.com/apache/storm/pull/3215#discussion_r389789482", "createdAt": "2020-03-09T16:01:30Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MDg5OQ=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjY2MzUxOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzozNTo0NlrOFydMgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowNzo1OFrOFzvHpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTQ1OA==", "bodyText": "Sets.union doesn't seem necessary since the former is a subset of the latter", "url": "https://github.com/apache/storm/pull/3215#discussion_r388451458", "createdAt": "2020-03-05T17:35:46Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            // getExecutorToComponent().values() also contains system components\n+            this(topo.getConf(), Sets.union(topo.getComponents().keySet(), new HashSet(topo.getExecutorToComponent().values())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MzcwMQ==", "bodyText": "There is no guarantee in TopologyDetails.class that latter is necessarily a superset. Such assumption should not be made in ConstraintConfig - even if true in most instances.", "url": "https://github.com/apache/storm/pull/3215#discussion_r389793701", "createdAt": "2020-03-09T16:07:58Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            // getExecutorToComponent().values() also contains system components\n+            this(topo.getConf(), Sets.union(topo.getComponents().keySet(), new HashSet(topo.getExecutorToComponent().values())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MTQ1OA=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjY4MDgwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzo0MDowMVrOFydWdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjoxMTozNlrOFzvQmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1NDAwNg==", "bodyText": "incompatibleComponents means the component cannot co-exist on the same worker. It does not necessary mean that there can only be at most one of this component on the same node.\nHere we don't need to (or shouldn't) differentiate whether comp1.equals(comp2) or not and we can deal with it just like others.", "url": "https://github.com/apache/storm/pull/3215#discussion_r388454006", "createdAt": "2020-03-05T17:40:01Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            // getExecutorToComponent().values() also contains system components\n+            this(topo.getConf(), Sets.union(topo.getComponents().keySet(), new HashSet(topo.getExecutorToComponent().values())));\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NTk5NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/storm/pull/3215#discussion_r389795994", "createdAt": "2020-03-09T16:11:36Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            // getExecutorToComponent().values() also contains system components\n+            this(topo.getConf(), Sets.union(topo.getComponents().keySet(), new HashSet(topo.getExecutorToComponent().values())));\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1NDAwNg=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjY5NjE0OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzo0NDo0MVrOFydgAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzo0NDo0MVrOFydgAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1NjQ0OA==", "bodyText": "The meaning of this comment is not very clear to me", "url": "https://github.com/apache/storm/pull/3215#discussion_r388456448", "createdAt": "2020-03-05T17:44:41Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            // getExecutorToComponent().values() also contains system components\n+            this(topo.getConf(), Sets.union(topo.getComponents().keySet(), new HashSet(topo.getExecutorToComponent().values())));\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjg0NjA5OnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODozMDoxMFrOFye_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxODozMDoxMFrOFye_uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ4MDk1NQ==", "bodyText": "This comment is no longer valid. v is a map now.", "url": "https://github.com/apache/storm/pull/3215#discussion_r388480955", "createdAt": "2020-03-05T18:30:10Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -38,71 +42,182 @@\n import org.apache.storm.shade.com.google.common.annotations.VisibleForTesting;\n import org.apache.storm.utils.ObjectReader;\n import org.apache.storm.utils.Time;\n+import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class ConstraintSolverStrategy extends BaseResourceAwareStrategy {\n-    //hard coded max number of states to search\n     private static final Logger LOG = LoggerFactory.getLogger(ConstraintSolverStrategy.class);\n \n-    //constraints and spreads\n-    private Map<String, Map<String, Integer>> constraintMatrix;\n-    private HashSet<String> spreadComps = new HashSet<>();\n+    public static final String CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT = \"maxNodeCoLocationCnt\";\n+    public static final String CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS = \"incompatibleComponents\";\n \n-    private Map<String, RasNode> nodes;\n-    private Map<ExecutorDetails, String> execToComp;\n-    private Map<String, Set<ExecutorDetails>> compToExecs;\n-    private List<String> favoredNodeIds;\n-    private List<String> unFavoredNodeIds;\n+    /**\n+     * Component constraint as derived from configuration.\n+     * This is backward compatible and can parse old style Config.TOPOLOGY_RAS_CONSTRAINTS and Config.TOPOLOGY_SPREAD_COMPONENTS.\n+     * New style Config.TOPOLOGY_RAS_CONSTRAINTS is map where each component has a list of other incompatible components\n+     * and an optional number that specifies the maximum co-location count for the component on a node.\n+     *\n+     * <p>comp-1 cannot exist on same worker as comp-2 or comp-3, and at most \"2\" comp-1 on same node</p>\n+     * <p>comp-2 and comp-4 cannot be on same node (missing comp-1 is implied from comp-1 constraint)</p>\n+     *\n+     *  <p>\n+     *      { \"comp-1\": { \"maxNodeCoLocationCnt\": 2, \"incompatibleComponents\": [\"comp-2\", \"comp-3\" ] },\n+     *        \"comp-2\": { \"incompatibleComponents\": [ \"comp-4\" ] }\n+     *      }\n+     *  </p>\n+     */\n+    public static final class ConstraintConfig {\n+        private Map<String, Set<String>> incompatibleComponents = new HashMap<>();\n+        private Map<String, Integer> maxCoLocationCnts = new HashMap<>(); // maximum node CoLocationCnt for restricted components\n \n-    static Map<String, Map<String, Integer>> getConstraintMap(TopologyDetails topo, Set<String> comps) {\n-        Map<String, Map<String, Integer>> matrix = new HashMap<>();\n-        for (String comp : comps) {\n-            matrix.put(comp, new HashMap<>());\n-            for (String comp2 : comps) {\n-                matrix.get(comp).put(comp2, 0);\n-            }\n+        ConstraintConfig(TopologyDetails topo) {\n+            // getExecutorToComponent().values() also contains system components\n+            this(topo.getConf(), Sets.union(topo.getComponents().keySet(), new HashSet(topo.getExecutorToComponent().values())));\n         }\n-        List<List<String>> constraints = (List<List<String>>) topo.getConf().get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n-        if (constraints != null) {\n-            for (List<String> constraintPair : constraints) {\n-                String comp1 = constraintPair.get(0);\n-                String comp2 = constraintPair.get(1);\n-                if (!matrix.containsKey(comp1)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n-                    continue;\n+\n+        ConstraintConfig(Map<String, Object> conf, Set<String> comps) {\n+            // spread constraints, old style may come from Config.TOPOLOGY_RAS_CONSTRAINTS where the target\n+            Object rasConstraints = conf.get(Config.TOPOLOGY_RAS_CONSTRAINTS);\n+            comps.forEach(k -> incompatibleComponents.computeIfAbsent(k, x -> new HashSet<>()));\n+            if (rasConstraints instanceof List) {\n+                // old style\n+                List<List<String>> constraints = (List<List<String>>) rasConstraints;\n+                for (List<String> constraintPair : constraints) {\n+                    String comp1 = constraintPair.get(0);\n+                    String comp2 = constraintPair.get(1);\n+                    if (!comps.contains(comp1)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp1);\n+                        continue;\n+                    }\n+                    if (!comps.contains(comp2)) {\n+                        LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n+                        continue;\n+                    }\n+                    if (comp1.equals(comp2)) {\n+                        maxCoLocationCnts.put(comp1, 1);\n+                    } else {\n+                        incompatibleComponents.get(comp1).add(comp2);\n+                        incompatibleComponents.get(comp2).add(comp1);\n+                    }\n                 }\n-                if (!matrix.containsKey(comp2)) {\n-                    LOG.warn(\"Comp: {} declared in constraints is not valid!\", comp2);\n-                    continue;\n+            } else {\n+                Map<String, Map<String,?>> constraintMap = (Map<String, Map<String,?>>) rasConstraints;\n+                constraintMap.forEach((comp1, v) -> {\n+                    if (comps.contains(comp1)) {\n+                        // v is a list of other components and an optional number which is a maxCoLocationCnt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzAzNDYzOnYy", "diffSide": "RIGHT", "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyMzo0MFrOFyg0hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyMzo0MFrOFyg0hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMDg1NA==", "bodyText": "typo: most -> more", "url": "https://github.com/apache/storm/pull/3215#discussion_r388510854", "createdAt": "2020-03-05T19:23:40Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/main/java/org/apache/storm/scheduler/resource/strategies/scheduling/ConstraintSolverStrategy.java", "diffHunk": "@@ -447,22 +552,24 @@ public boolean isExecAssignmentToWorkerValid(WorkerSlot worker, SearcherState st\n         return retMap;\n     }\n \n-    private ArrayList<ExecutorDetails> getSortedExecs(HashSet<String> spreadComps, Map<String, Map<String, Integer>> constraintMatrix,\n+    private ArrayList<ExecutorDetails> getSortedExecs(Map<String, Integer> spreadCompCnts,\n+                                                      Map<String, Set<String>> constraintMatrix,\n                                                       Map<String, Set<ExecutorDetails>> compToExecs) {\n         ArrayList<ExecutorDetails> retList = new ArrayList<>();\n         //find number of constraints per component\n         //Key->Comp Value-># of constraints\n-        Map<String, Integer> compConstraintCountMap = new HashMap<>();\n+        Map<String, Double> compConstraintCountMap = new HashMap<>();\n         constraintMatrix.forEach((comp, subMatrix) -> {\n-            int count = subMatrix.values().stream().mapToInt(Number::intValue).sum();\n-            //check component is declared for spreading\n-            if (spreadComps.contains(comp)) {\n-                count++;\n+            double count = subMatrix.size();\n+            // check if component is declared for spreading\n+            if (spreadCompCnts.containsKey(comp)) {\n+                // lower (1 and above only) value is most constrained should have higher count", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 513}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA0ODQ3OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOToyNzozM1rOFyg9LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzowMzoxNlrOF0nyiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzA2OA==", "bodyText": "\"\"+ doesn't seem necessary.", "url": "https://github.com/apache/storm/pull/3215#discussion_r388513068", "createdAt": "2020-03-05T19:27:33Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -54,27 +58,70 @@\n import org.apache.storm.metric.StormMetricsRegistry;\n import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n \n+@RunWith(Parameterized.class)\n public class TestConstraintSolverStrategy {\n+    @Parameters\n+    public static Object[] data() {\n+        return new Object[] { false, true };\n+    }\n+\n     private static final Logger LOG = LoggerFactory.getLogger(TestConstraintSolverStrategy.class);\n     private static final int MAX_TRAVERSAL_DEPTH = 2000;\n     private static final int NORMAL_BOLT_PARALLEL = 11;\n     //Dropping the parallelism of the bolts to 3 instead of 11 so we can find a solution in a reasonable amount of work when backtracking.\n     private static final int BACKTRACK_BOLT_PARALLEL = 3;\n+    private static final int CO_LOCATION_CNT = 2;\n \n-    public Map<String, Object> makeTestTopoConf() {\n+    // class members\n+    public Boolean consolidatedConfigFlag = Boolean.TRUE;\n+\n+    public TestConstraintSolverStrategy(boolean consolidatedConfigFlag) {\n+        this.consolidatedConfigFlag = consolidatedConfigFlag;\n+        LOG.info(\"Running tests with consolidatedConfigFlag={}\", \"\"+consolidatedConfigFlag);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyMjE4NQ==", "bodyText": "fix", "url": "https://github.com/apache/storm/pull/3215#discussion_r390722185", "createdAt": "2020-03-11T03:03:16Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -54,27 +58,70 @@\n import org.apache.storm.metric.StormMetricsRegistry;\n import org.apache.storm.scheduler.resource.normalization.ResourceMetrics;\n \n+@RunWith(Parameterized.class)\n public class TestConstraintSolverStrategy {\n+    @Parameters\n+    public static Object[] data() {\n+        return new Object[] { false, true };\n+    }\n+\n     private static final Logger LOG = LoggerFactory.getLogger(TestConstraintSolverStrategy.class);\n     private static final int MAX_TRAVERSAL_DEPTH = 2000;\n     private static final int NORMAL_BOLT_PARALLEL = 11;\n     //Dropping the parallelism of the bolts to 3 instead of 11 so we can find a solution in a reasonable amount of work when backtracking.\n     private static final int BACKTRACK_BOLT_PARALLEL = 3;\n+    private static final int CO_LOCATION_CNT = 2;\n \n-    public Map<String, Object> makeTestTopoConf() {\n+    // class members\n+    public Boolean consolidatedConfigFlag = Boolean.TRUE;\n+\n+    public TestConstraintSolverStrategy(boolean consolidatedConfigFlag) {\n+        this.consolidatedConfigFlag = consolidatedConfigFlag;\n+        LOG.info(\"Running tests with consolidatedConfigFlag={}\", \"\"+consolidatedConfigFlag);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzA2OA=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA2MjM2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTozMTo0NlrOFyhF9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzowMzoyN1rOF0nyvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNTMxNw==", "bodyText": "typo: when --> is", "url": "https://github.com/apache/storm/pull/3215#discussion_r388515317", "createdAt": "2020-03-05T19:31:46Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyMjIzNg==", "bodyText": "fix", "url": "https://github.com/apache/storm/pull/3215#discussion_r390722236", "createdAt": "2020-03-11T03:03:27Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNTMxNw=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA2NzYwOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTozMzozNVrOFyhJOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzowNTozNVrOF0n0YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjE1Mg==", "bodyText": "nit: space after (List<Object>)\nString,Object can be deleted\nObject in new ArrayList<Object> can be deleted (Line157)", "url": "https://github.com/apache/storm/pull/3215#discussion_r388516152", "createdAt": "2020-03-05T19:33:35Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyMjY1Nw==", "bodyText": "fix", "url": "https://github.com/apache/storm/pull/3215#discussion_r390722657", "createdAt": "2020-03-11T03:05:35Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjE1Mg=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzA3MDk2OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTozNDo0NVrOFyhLYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzoxMToxNVrOF0n5Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjcwNA==", "bodyText": "String,Object can be removed; \"\"+ doesn't seem necessary", "url": "https://github.com/apache/storm/pull/3215#discussion_r388516704", "createdAt": "2020-03-05T19:34:45Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcyMzkzNQ==", "bodyText": "yes on first\nsending in String into Map only.", "url": "https://github.com/apache/storm/pull/3215#discussion_r390723935", "createdAt": "2020-03-11T03:11:15Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjcwNA=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzEwODk0OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTo0NTo1MVrOFyhjSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjoyMDo1NlrOFzvpBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgyNw==", "bodyText": "This method is not used by anyone and can be removed", "url": "https://github.com/apache/storm/pull/3215#discussion_r388522827", "createdAt": "2020-03-05T19:45:51Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));\n+            }\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, modifiedConstraints);\n+        } else {\n+            // constraint and MaxCoLocationCnts are separate - no maxCoLocationCnt implied as 1\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n+            config.put(Config.TOPOLOGY_SPREAD_COMPONENTS, spreads.entrySet().stream().map(e -> Arrays.asList()));\n+        }\n+    }\n+\n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidated is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidated is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads List of components that can have only one Executor on a node (i.e. their maxCoLocationCnt = 1)\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, List<String> spreads, Map<String, Object> config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwMjI0NA==", "bodyText": "Somehow this \"should' be used otherwise an edge test case will not be properly handled. Removing it for now.", "url": "https://github.com/apache/storm/pull/3215#discussion_r389802244", "createdAt": "2020-03-09T16:20:56Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));\n+            }\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, modifiedConstraints);\n+        } else {\n+            // constraint and MaxCoLocationCnts are separate - no maxCoLocationCnt implied as 1\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n+            config.put(Config.TOPOLOGY_SPREAD_COMPONENTS, spreads.entrySet().stream().map(e -> Arrays.asList()));\n+        }\n+    }\n+\n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidated is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidated is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads List of components that can have only one Executor on a node (i.e. their maxCoLocationCnt = 1)\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, List<String> spreads, Map<String, Object> config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgyNw=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzEzNzQzOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxOTo1MzozN1rOFyh0tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjozMDoyMFrOFzwA6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyNzI4Ng==", "bodyText": "Will this include the value, which are integers into the array? maybe new ArrayList<>(spreads.keySet()); is what should be here", "url": "https://github.com/apache/storm/pull/3215#discussion_r388527286", "createdAt": "2020-03-05T19:53:37Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));\n+            }\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, modifiedConstraints);\n+        } else {\n+            // constraint and MaxCoLocationCnts are separate - no maxCoLocationCnt implied as 1\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n+            config.put(Config.TOPOLOGY_SPREAD_COMPONENTS, spreads.entrySet().stream().map(e -> Arrays.asList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODM2Mw==", "bodyText": "fixed", "url": "https://github.com/apache/storm/pull/3215#discussion_r389808363", "createdAt": "2020-03-09T16:30:20Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,80 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));\n+            }\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, modifiedConstraints);\n+        } else {\n+            // constraint and MaxCoLocationCnts are separate - no maxCoLocationCnt implied as 1\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n+            config.put(Config.TOPOLOGY_SPREAD_COMPONENTS, spreads.entrySet().stream().map(e -> Arrays.asList()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyNzI4Ng=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzE2MTAxOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDowMDo0NlrOFyiDkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjozMjo0OFrOFzwICQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTA5MA==", "bodyText": "nit: space after (int)", "url": "https://github.com/apache/storm/pull/3215#discussion_r388531090", "createdAt": "2020-03-05T20:00:46Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -146,7 +267,43 @@ public void basicUnitTestWithKillAndRecover(ConstraintSolverStrategy cs, int bol\n \n         Assert.assertTrue(\"Assert scheduling topology success \" + result, result.isSuccess());\n         Assert.assertEquals(\"topo all executors scheduled?\", 0, cluster.getUnassignedExecutors(topo).size());\n-        Assert.assertTrue(\"Valid Scheduling?\", ConstraintSolverStrategy.validateSolution(cluster, topo));\n+        Assert.assertTrue(\"Valid Scheduling?\", ConstraintSolverStrategy.validateSolution(cluster, topo, null));\n+    }\n+\n+    @Test\n+    public void testNewConstraintFormat() {\n+        String s = String.format(\n+                \"{ \\\"comp-1\\\": \"\n+                        + \"                  { \\\"%s\\\": 2, \"\n+                        + \"                    \\\"%s\\\": [\\\"comp-2\\\", \\\"comp-3\\\" ] }, \"\n+                        + \"     \\\"comp-2\\\": \"\n+                        + \"                  { \\\"%s\\\": [ \\\"comp-4\\\" ] }, \"\n+                        + \"     \\\"comp-3\\\": \"\n+                        + \"                  { \\\"%s\\\": \\\"comp-5\\\" } \"\n+                        + \"}\",\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT,\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS,\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS,\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS\n+        );\n+        Object jsonValue = JSONValue.parse(s);\n+        Map<String, Object> config = Utils.readDefaultConfig();\n+        config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, jsonValue);\n+        Set<String> allComps = new HashSet<>();\n+        allComps.addAll(Arrays.asList(\"comp-1\", \"comp-2\", \"comp-3\", \"comp-4\", \"comp-5\"));\n+        ConstraintSolverStrategy.ConstraintConfig constraintConfig = new ConstraintSolverStrategy.ConstraintConfig(config, allComps);\n+\n+        Set<String> expectedSetComp1 = new HashSet<>();\n+        expectedSetComp1.addAll(Arrays.asList(\"comp-2\", \"comp-3\"));\n+        Set<String> expectedSetComp2 = new HashSet<>();\n+        expectedSetComp2.addAll(Arrays.asList(\"comp-1\", \"comp-4\"));\n+        Set<String> expectedSetComp3 = new HashSet<>();\n+        expectedSetComp3.addAll(Arrays.asList(\"comp-1\", \"comp-5\"));\n+        Assert.assertEquals(\"comp-1 incompatible components\", expectedSetComp1, constraintConfig.getIncompatibleComponents().get(\"comp-1\"));\n+        Assert.assertEquals(\"comp-2 incompatible components\", expectedSetComp2, constraintConfig.getIncompatibleComponents().get(\"comp-2\"));\n+        Assert.assertEquals(\"comp-3 incompatible components\", expectedSetComp3, constraintConfig.getIncompatibleComponents().get(\"comp-3\"));\n+        Assert.assertEquals(\"comp-1 maxNodeCoLocationCnt\", (int)2, (int)constraintConfig.getMaxCoLocationCnts().getOrDefault(\"comp-1\", -1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxMDE4NQ==", "bodyText": "fixed cast", "url": "https://github.com/apache/storm/pull/3215#discussion_r389810185", "createdAt": "2020-03-09T16:32:48Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -146,7 +267,43 @@ public void basicUnitTestWithKillAndRecover(ConstraintSolverStrategy cs, int bol\n \n         Assert.assertTrue(\"Assert scheduling topology success \" + result, result.isSuccess());\n         Assert.assertEquals(\"topo all executors scheduled?\", 0, cluster.getUnassignedExecutors(topo).size());\n-        Assert.assertTrue(\"Valid Scheduling?\", ConstraintSolverStrategy.validateSolution(cluster, topo));\n+        Assert.assertTrue(\"Valid Scheduling?\", ConstraintSolverStrategy.validateSolution(cluster, topo, null));\n+    }\n+\n+    @Test\n+    public void testNewConstraintFormat() {\n+        String s = String.format(\n+                \"{ \\\"comp-1\\\": \"\n+                        + \"                  { \\\"%s\\\": 2, \"\n+                        + \"                    \\\"%s\\\": [\\\"comp-2\\\", \\\"comp-3\\\" ] }, \"\n+                        + \"     \\\"comp-2\\\": \"\n+                        + \"                  { \\\"%s\\\": [ \\\"comp-4\\\" ] }, \"\n+                        + \"     \\\"comp-3\\\": \"\n+                        + \"                  { \\\"%s\\\": \\\"comp-5\\\" } \"\n+                        + \"}\",\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT,\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS,\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS,\n+                ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS\n+        );\n+        Object jsonValue = JSONValue.parse(s);\n+        Map<String, Object> config = Utils.readDefaultConfig();\n+        config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, jsonValue);\n+        Set<String> allComps = new HashSet<>();\n+        allComps.addAll(Arrays.asList(\"comp-1\", \"comp-2\", \"comp-3\", \"comp-4\", \"comp-5\"));\n+        ConstraintSolverStrategy.ConstraintConfig constraintConfig = new ConstraintSolverStrategy.ConstraintConfig(config, allComps);\n+\n+        Set<String> expectedSetComp1 = new HashSet<>();\n+        expectedSetComp1.addAll(Arrays.asList(\"comp-2\", \"comp-3\"));\n+        Set<String> expectedSetComp2 = new HashSet<>();\n+        expectedSetComp2.addAll(Arrays.asList(\"comp-1\", \"comp-4\"));\n+        Set<String> expectedSetComp3 = new HashSet<>();\n+        expectedSetComp3.addAll(Arrays.asList(\"comp-1\", \"comp-5\"));\n+        Assert.assertEquals(\"comp-1 incompatible components\", expectedSetComp1, constraintConfig.getIncompatibleComponents().get(\"comp-1\"));\n+        Assert.assertEquals(\"comp-2 incompatible components\", expectedSetComp2, constraintConfig.getIncompatibleComponents().get(\"comp-2\"));\n+        Assert.assertEquals(\"comp-3 incompatible components\", expectedSetComp3, constraintConfig.getIncompatibleComponents().get(\"comp-3\"));\n+        Assert.assertEquals(\"comp-1 maxNodeCoLocationCnt\", (int)2, (int)constraintConfig.getMaxCoLocationCnts().getOrDefault(\"comp-1\", -1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTA5MA=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzE2Nzk0OnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDowMzowNFrOFyiHrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODoxMTowNlrOFzz1lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMjE0MQ==", "bodyText": "What's the different between this and testConstraintSolverForceBacktrack", "url": "https://github.com/apache/storm/pull/3215#discussion_r388532141", "createdAt": "2020-03-05T20:03:04Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -159,12 +316,30 @@ public void testConstraintSolverForceBacktrack() {\n                 return super.sortByValues(map).descendingMap();\n             }\n         };\n-        basicUnitTestWithKillAndRecover(cs, BACKTRACK_BOLT_PARALLEL);\n+        basicUnitTestWithKillAndRecover(cs, BACKTRACK_BOLT_PARALLEL, 2);\n+    }\n+\n+    @Test\n+    public void testConstraintSolverForceBacktrackWithSpreadCoLocation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxMjMwOA==", "bodyText": "None. Removed testConstraintSolverForceBacktrack().", "url": "https://github.com/apache/storm/pull/3215#discussion_r389812308", "createdAt": "2020-03-09T16:36:15Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -159,12 +316,30 @@ public void testConstraintSolverForceBacktrack() {\n                 return super.sortByValues(map).descendingMap();\n             }\n         };\n-        basicUnitTestWithKillAndRecover(cs, BACKTRACK_BOLT_PARALLEL);\n+        basicUnitTestWithKillAndRecover(cs, BACKTRACK_BOLT_PARALLEL, 2);\n+    }\n+\n+    @Test\n+    public void testConstraintSolverForceBacktrackWithSpreadCoLocation() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMjE0MQ=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDk5Nw==", "bodyText": "Also added Assertion to check for invalid test case (i.e. when maxCoLocationCnt is set to > 1 and testing under old config scenario.", "url": "https://github.com/apache/storm/pull/3215#discussion_r389870997", "createdAt": "2020-03-09T18:11:06Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -159,12 +316,30 @@ public void testConstraintSolverForceBacktrack() {\n                 return super.sortByValues(map).descendingMap();\n             }\n         };\n-        basicUnitTestWithKillAndRecover(cs, BACKTRACK_BOLT_PARALLEL);\n+        basicUnitTestWithKillAndRecover(cs, BACKTRACK_BOLT_PARALLEL, 2);\n+    }\n+\n+    @Test\n+    public void testConstraintSolverForceBacktrackWithSpreadCoLocation() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMjE0MQ=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIxOTgyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxODowN1rOFyimSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxODowOToxMFrOFzzxuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTk3Ng==", "bodyText": "Remove this if it is not needed?", "url": "https://github.com/apache/storm/pull/3215#discussion_r388539976", "createdAt": "2020-03-05T20:18:07Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -239,42 +435,50 @@ public void testScheduleLargeExecutorConstraintCount(int parallelismMultiplier)\n         scheduler.schedule(topologies, cluster);\n \n         boolean scheduleSuccess = isStatusSuccess(cluster.getStatus(topo.getId()));\n-        LOG.info(\"testScheduleLargeExecutorCount scheduling {} with {}x executor multiplier\", scheduleSuccess ? \"succeeds\" : \"fails\",\n-                parallelismMultiplier);\n+        LOG.info(\"testScheduleLargeExecutorCount scheduling {} with {}x executor multiplier, consolidatedConfigFlag={}\",\n+                scheduleSuccess ? \"succeeds\" : \"fails\", parallelismMultiplier, consolidatedConfigFlag);\n         Assert.assertTrue(scheduleSuccess);\n     }\n \n     @Test\n     public void testIntegrationWithRAS() {\n-        List<List<String>> constraints = new LinkedList<>();\n-        addContraints(\"spout-0\", \"bolt-0\", constraints);\n-        addContraints(\"bolt-1\", \"bolt-1\", constraints);\n-        addContraints(\"bolt-1\", \"bolt-2\", constraints);\n-        List<String> spread = new LinkedList<>();\n-        spread.add(\"spout-0\");\n+        if (!consolidatedConfigFlag) {\n+            LOG.info(\"Skipping test since bolt-1 maxCoLocationCnt=10 requires consolidatedConfigFlag=true, current={}\", consolidatedConfigFlag);\n+            return;\n+        }\n \n         Map<String, Object> config = Utils.readDefaultConfig();\n         config.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, ConstraintSolverStrategy.class.getName());\n-        config.put(Config.TOPOLOGY_SPREAD_COMPONENTS, spread);\n-        config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n         config.put(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH, MAX_TRAVERSAL_DEPTH);\n         config.put(Config.TOPOLOGY_WORKER_MAX_HEAP_SIZE_MB, 100_000);\n         config.put(Config.TOPOLOGY_PRIORITY, 1);\n         config.put(Config.TOPOLOGY_COMPONENT_CPU_PCORE_PERCENT, 10);\n         config.put(Config.TOPOLOGY_COMPONENT_RESOURCES_ONHEAP_MEMORY_MB, 100);\n         config.put(Config.TOPOLOGY_COMPONENT_RESOURCES_OFFHEAP_MEMORY_MB, 0.0);\n \n+        List<List<String>> constraints = new LinkedList<>();\n+        addConstraints(\"spout-0\", \"bolt-0\", constraints);\n+        // commented out unsatisfiable constraint since there are 300 executors and cannot fit on 30 nodes, added as spread\n+        // addConstraints(\"bolt-1\", \"bolt-1\", constraints);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDAxMQ==", "bodyText": "Added back. Constraint is satifisfiable when bolt-1 -> bolt-1 is not interpreted as maxNodeCoLocationCnt (fixed in ConstraintSolverStrategy)", "url": "https://github.com/apache/storm/pull/3215#discussion_r389870011", "createdAt": "2020-03-09T18:09:10Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -239,42 +435,50 @@ public void testScheduleLargeExecutorConstraintCount(int parallelismMultiplier)\n         scheduler.schedule(topologies, cluster);\n \n         boolean scheduleSuccess = isStatusSuccess(cluster.getStatus(topo.getId()));\n-        LOG.info(\"testScheduleLargeExecutorCount scheduling {} with {}x executor multiplier\", scheduleSuccess ? \"succeeds\" : \"fails\",\n-                parallelismMultiplier);\n+        LOG.info(\"testScheduleLargeExecutorCount scheduling {} with {}x executor multiplier, consolidatedConfigFlag={}\",\n+                scheduleSuccess ? \"succeeds\" : \"fails\", parallelismMultiplier, consolidatedConfigFlag);\n         Assert.assertTrue(scheduleSuccess);\n     }\n \n     @Test\n     public void testIntegrationWithRAS() {\n-        List<List<String>> constraints = new LinkedList<>();\n-        addContraints(\"spout-0\", \"bolt-0\", constraints);\n-        addContraints(\"bolt-1\", \"bolt-1\", constraints);\n-        addContraints(\"bolt-1\", \"bolt-2\", constraints);\n-        List<String> spread = new LinkedList<>();\n-        spread.add(\"spout-0\");\n+        if (!consolidatedConfigFlag) {\n+            LOG.info(\"Skipping test since bolt-1 maxCoLocationCnt=10 requires consolidatedConfigFlag=true, current={}\", consolidatedConfigFlag);\n+            return;\n+        }\n \n         Map<String, Object> config = Utils.readDefaultConfig();\n         config.put(Config.TOPOLOGY_SCHEDULER_STRATEGY, ConstraintSolverStrategy.class.getName());\n-        config.put(Config.TOPOLOGY_SPREAD_COMPONENTS, spread);\n-        config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n         config.put(Config.TOPOLOGY_RAS_CONSTRAINT_MAX_STATE_SEARCH, MAX_TRAVERSAL_DEPTH);\n         config.put(Config.TOPOLOGY_WORKER_MAX_HEAP_SIZE_MB, 100_000);\n         config.put(Config.TOPOLOGY_PRIORITY, 1);\n         config.put(Config.TOPOLOGY_COMPONENT_CPU_PCORE_PERCENT, 10);\n         config.put(Config.TOPOLOGY_COMPONENT_RESOURCES_ONHEAP_MEMORY_MB, 100);\n         config.put(Config.TOPOLOGY_COMPONENT_RESOURCES_OFFHEAP_MEMORY_MB, 0.0);\n \n+        List<List<String>> constraints = new LinkedList<>();\n+        addConstraints(\"spout-0\", \"bolt-0\", constraints);\n+        // commented out unsatisfiable constraint since there are 300 executors and cannot fit on 30 nodes, added as spread\n+        // addConstraints(\"bolt-1\", \"bolt-1\", constraints);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTk3Ng=="}, "originalCommit": {"oid": "a5ee93f209a5c2af0209085ce4420cd1ed717be5"}, "originalPosition": 391}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTI5OTAyOnYy", "diffSide": "RIGHT", "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMTo0NjozNlrOF0mrrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMjo0ODo0OFrOF0nllA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNDA0Nw==", "bodyText": "Maybe this should be != 1? There are a few places like these should be changed if you think this makes sense", "url": "https://github.com/apache/storm/pull/3215#discussion_r390704047", "createdAt": "2020-03-11T01:46:36Z", "author": {"login": "Ethanlm"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,54 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));\n+            }\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, modifiedConstraints);\n+        } else {\n+            // constraint and MaxCoLocationCnts are separate - no maxCoLocationCnt implied as 1\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n+            for (Map.Entry<String, Integer> e: spreads.entrySet()) {\n+                if (e.getValue() > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7e213c0e446907ad597bc4a5fba96bd66118ee"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcxODg2OA==", "bodyText": "maxNodeCoLocationCnt is set to 1 or higher only. != 1 and >1 mean the same here. No change required.", "url": "https://github.com/apache/storm/pull/3215#discussion_r390718868", "createdAt": "2020-03-11T02:48:48Z", "author": {"login": "bipinprasad"}, "path": "storm-server/src/test/java/org/apache/storm/scheduler/resource/strategies/scheduling/TestConstraintSolverStrategy.java", "diffHunk": "@@ -85,6 +132,54 @@\n         return config;\n     }\n \n+    /**\n+     * Set Config.TOPOLOGY_RAS_CONSTRAINTS (when consolidatedConfigFlag is true) or both\n+     * Config.TOPOLOGY_RAS_CONSTRAINTS/Config.TOPOLOGY_SPREAD_COMPONENTS (when consolidatedConfigFlag is false).\n+     *\n+     * When consolidatedConfigFlag when true, use the new more consolidated format to set Config.TOPOLOGY_RAS_CONSTRAINTS.\n+     * When false, use the old configuration format for Config.TOPOLOGY_RAS_CONSTRAINTS/TOPOLOGY_SPREAD_COMPONENTS.\n+     *\n+     * @param constraints List of components, where the first one cannot co-exist with the others in the list\n+     * @param spreads Map of component and its maxCoLocationCnt\n+     * @param config Configuration to be updated\n+     */\n+    private void setConstraintConfig(List<List<String>> constraints, Map<String, Integer> spreads, Map<String, Object> config) {\n+        if (consolidatedConfigFlag) {\n+            // single configuration for each component\n+            Map<String, Map<String,Object>> modifiedConstraints = new HashMap<>();\n+            for (List<String> constraint: constraints) {\n+                if (constraint.size() < 2) {\n+                    continue;\n+                }\n+                String comp = constraint.get(0);\n+                List<String> others = constraint.subList(1, constraint.size());\n+                List<Object> incompatibleComponents = (List<Object>)modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>())\n+                        .computeIfAbsent(ConstraintSolverStrategy.CONSTRAINT_TYPE_INCOMPATIBLE_COMPONENTS, k -> new ArrayList<Object>());\n+                incompatibleComponents.addAll(others);\n+            }\n+            for (String comp: spreads.keySet()) {\n+                modifiedConstraints.computeIfAbsent(comp, k -> new HashMap<String,Object>()).put(ConstraintSolverStrategy.CONSTRAINT_TYPE_MAX_NODE_CO_LOCATION_CNT, \"\"+spreads.get(comp));\n+            }\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, modifiedConstraints);\n+        } else {\n+            // constraint and MaxCoLocationCnts are separate - no maxCoLocationCnt implied as 1\n+            config.put(Config.TOPOLOGY_RAS_CONSTRAINTS, constraints);\n+            for (Map.Entry<String, Integer> e: spreads.entrySet()) {\n+                if (e.getValue() > 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDcwNDA0Nw=="}, "originalCommit": {"oid": "ab7e213c0e446907ad597bc4a5fba96bd66118ee"}, "originalPosition": 147}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4246, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}