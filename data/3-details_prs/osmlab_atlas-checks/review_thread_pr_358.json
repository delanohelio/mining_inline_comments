{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMzA2MzU0", "number": 358, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1OTo1OVrOEko-LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNTozMToyOFrOEpsjHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU1NDY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1OTo1OVrOHTsvKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTo0Mzo0MFrOHbQh0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzk2Mw==", "bodyText": "It would be great if these could be added as tag classed here.", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490417963", "createdAt": "2020-09-17T16:59:59Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDA5Ng==", "bodyText": "Waiting on this: osmlab/atlas#679", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r491034096", "createdAt": "2020-09-18T15:41:08Z", "author": {"login": "brianjor"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzk2Mw=="}, "originalCommit": {"oid": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0NDQwMw==", "bodyText": "I didn't add \"date_on\" because it has no mention of it in the OSM wiki, should it still be included?", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498344403", "createdAt": "2020-10-01T15:43:40Z", "author": {"login": "brianjor"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzk2Mw=="}, "originalCommit": {"oid": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU4NDI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowNzo1NVrOHTtBsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowNzo1NVrOHTtBsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjcwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");\n          \n          \n            \n                private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY.toString(), LandUseTag.KEY.toString(), BuildingTag.KEY.toString());", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490422704", "createdAt": "2020-09-17T17:07:55Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",\n+            \"construction:date\", \"temporary:date_on\", \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODU5NTUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxMTowOFrOHTtI2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxMTowOFrOHTtI2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNDUzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .anyMatch(tag -> tag.equals(\"construction\")\n          \n          \n            \n                            .anyMatch(tag -> tag.equals(ConstructionTag.KEY.toString())\n          \n      \n    \n    \n  \n\nor if you pass in the atlas object:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .anyMatch(tag -> tag.equals(\"construction\")\n          \n          \n            \n                            .anyMatch(tag -> Validators.hasValueFor(object, ConstructionTag.class)", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490424538", "createdAt": "2020-09-17T17:11:08Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",\n+            \"construction:date\", \"temporary:date_on\", \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");\n+\n+    private final int oldConstructionDays;\n+    private final int oldCheckDateMonths;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public ConstructionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.oldConstructionDays = this.configurationValue(configuration, \"oldConstructionDays\",\n+                OLD_CONSTRUCTION_DAYS_DEFAULT, Double::intValue);\n+        this.oldCheckDateMonths = this.configurationValue(configuration, \"oldCheckDateMonth\",\n+                OLD_CHECK_DATE_MONTHS_DEFAULT, Double::intValue);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        final Map<String, String> keySet = object.getOsmTags();\n+        return !this.isFlagged(object.getOsmIdentifier()) && isConstruction(keySet);\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        this.markAsFlagged(object.getOsmIdentifier());\n+\n+        final Map<String, String> tags = object.getTags();\n+\n+        final Optional<String> dateTag = getDateTag(tags);\n+        if (dateTag.isPresent())\n+        {\n+            final String tagDate = tags.get(dateTag.get());\n+\n+            final Optional<LocalDate> parsedDate = parseDate(tagDate);\n+            if (parsedDate.isPresent() && parsedDate.get().isBefore(TODAYS_DATE))\n+            {\n+                return Optional\n+                        .of(createFlag(object, this.getLocalizedInstruction(0, dateTag.get())));\n+            }\n+        }\n+\n+        if (tags.containsKey(\"check_date\"))\n+        {\n+            final Optional<LocalDate> parseDateChecked = parseDate(tags.get(\"check_date\"));\n+            if (parseDateChecked.isPresent())\n+            {\n+                final long monthsBetween = ChronoUnit.MONTHS.between(parseDateChecked.get(),\n+                        TODAYS_DATE);\n+                if (monthsBetween > this.oldCheckDateMonths)\n+                {\n+                    return Optional.of(createFlag(object,\n+                            this.getLocalizedInstruction(1, this.oldCheckDateMonths)));\n+                }\n+            }\n+        }\n+\n+        if (tags.containsKey(\"last_edit_time\"))\n+        {\n+            final long timestamp = Long.parseLong(tags.get(\"last_edit_time\"));\n+            final LocalDate lastEditDate = Instant.ofEpochMilli(timestamp)\n+                    .atZone(ZoneId.systemDefault()).toLocalDate();\n+\n+            final long numberOfDays = ChronoUnit.DAYS.between(lastEditDate, TODAYS_DATE);\n+            if (numberOfDays > this.oldConstructionDays)\n+            {\n+                return Optional.of(createFlag(object,\n+                        this.getLocalizedInstruction(2, this.oldConstructionDays)));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Gets the tag that holds a date.\n+     *\n+     * @param keySet\n+     *            Tags from the object.\n+     * @return a tag that is considered a date for construction.\n+     */\n+    private Optional<String> getDateTag(final Map<String, String> keySet)\n+    {\n+        return DATE_TAGS.stream().filter(keySet::containsKey).findFirst();\n+    }\n+\n+    /**\n+     * Checks if the tags of an object signify it as being under construction.\n+     *\n+     * @param tags\n+     *            Tags from the object\n+     * @return true if the object is under construction, otherwise false\n+     */\n+    private boolean isConstruction(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream()\n+                .anyMatch(tag -> tag.equals(\"construction\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODYxMjk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxNjowNFrOHTtT-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxNjowNFrOHTtT-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNzM4NQ==", "bodyText": "If the object is an Edge we will want to flag all the master edges with the same OSM ID (see InvalidTagsCheck for an example).", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490427385", "createdAt": "2020-09-17T17:16:04Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",\n+            \"construction:date\", \"temporary:date_on\", \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");\n+\n+    private final int oldConstructionDays;\n+    private final int oldCheckDateMonths;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public ConstructionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.oldConstructionDays = this.configurationValue(configuration, \"oldConstructionDays\",\n+                OLD_CONSTRUCTION_DAYS_DEFAULT, Double::intValue);\n+        this.oldCheckDateMonths = this.configurationValue(configuration, \"oldCheckDateMonth\",\n+                OLD_CHECK_DATE_MONTHS_DEFAULT, Double::intValue);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        final Map<String, String> keySet = object.getOsmTags();\n+        return !this.isFlagged(object.getOsmIdentifier()) && isConstruction(keySet);\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        this.markAsFlagged(object.getOsmIdentifier());\n+\n+        final Map<String, String> tags = object.getTags();\n+\n+        final Optional<String> dateTag = getDateTag(tags);\n+        if (dateTag.isPresent())\n+        {\n+            final String tagDate = tags.get(dateTag.get());\n+\n+            final Optional<LocalDate> parsedDate = parseDate(tagDate);\n+            if (parsedDate.isPresent() && parsedDate.get().isBefore(TODAYS_DATE))\n+            {\n+                return Optional\n+                        .of(createFlag(object, this.getLocalizedInstruction(0, dateTag.get())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTU2NzczOnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNToyOTo0NlrOHbhkpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNTo0Mzo1OVrOHbyjfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzY1Mg==", "bodyText": "Just curious - whats the reasoning behind these values? Is 2 years a recommend length of time for checking these highways?", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498623652", "createdAt": "2020-10-02T05:29:46Z", "author": {"login": "danielduhh"}, "path": "config/configuration.json", "diffHunk": "@@ -189,6 +189,16 @@\n       \"tags\": \"highway\"\n     }\n   },\n+  \"ConstructionCheck\": {\n+    \"oldConstructionDays\": 730.0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e33bc063a1a76f6e692c91a414281cd3660bca5b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwMTg4Nw==", "bodyText": "Osmose uses 2 years as the limit for something to have been in construction when no date tags are available\nhttps://github.com/osm-fr/osmose-backend/blob/master/plugins/Construction.py#L36\nAnd the 6 month check_date was also from their check, though someone would have to update the check_date each time it gets flagged instead of marking as false positive:\nhttps://github.com/osm-fr/osmose-backend/blob/master/plugins/Construction.py#L98", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498901887", "createdAt": "2020-10-02T15:43:59Z", "author": {"login": "brianjor"}, "path": "config/configuration.json", "diffHunk": "@@ -189,6 +189,16 @@\n       \"tags\": \"highway\"\n     }\n   },\n+  \"ConstructionCheck\": {\n+    \"oldConstructionDays\": 730.0,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzY1Mg=="}, "originalCommit": {"oid": "e33bc063a1a76f6e692c91a414281cd3660bca5b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTU2OTU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNTozMToyOFrOHbhlxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNTozMToyOFrOHbhlxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzk0MQ==", "bodyText": "This could be useful in atlas \ud83d\ude04", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498623941", "createdAt": "2020-10-02T05:31:28Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,258 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.BuildingTag;\n+import org.openstreetmap.atlas.tags.CheckDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LandUseTag;\n+import org.openstreetmap.atlas.tags.LastEditTimeTag;\n+import org.openstreetmap.atlas.tags.OpenDateTag;\n+import org.openstreetmap.atlas.tags.OpeningDateTag;\n+import org.openstreetmap.atlas.tags.TemporaryDateOnTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(OpeningDateTag.KEY, OpenDateTag.KEY,\n+            ConstructionDateTag.KEY, TemporaryDateOnTag.KEY, \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, LandUseTag.KEY,\n+            BuildingTag.KEY);\n+\n+    private final int oldConstructionDays;\n+    private final int oldCheckDateMonths;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public ConstructionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.oldConstructionDays = this.configurationValue(configuration, \"oldConstructionDays\",\n+                OLD_CONSTRUCTION_DAYS_DEFAULT, Double::intValue);\n+        this.oldCheckDateMonths = this.configurationValue(configuration, \"oldCheckDateMonth\",\n+                OLD_CHECK_DATE_MONTHS_DEFAULT, Double::intValue);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        final Map<String, String> keySet = object.getOsmTags();\n+        return !this.isFlagged(object.getOsmIdentifier()) && this.isConstruction(keySet);\n+    }\n+\n+    @Override\n+    protected CheckFlag createFlag(final AtlasObject object, final String instruction)\n+    {\n+        if (object instanceof Edge)\n+        {\n+            return super.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction);\n+        }\n+        return super.createFlag(object, instruction);\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        this.markAsFlagged(object.getOsmIdentifier());\n+\n+        final Map<String, String> tags = object.getTags();\n+\n+        final Optional<String> dateTag = this.getDateTag(tags);\n+        if (dateTag.isPresent())\n+        {\n+            final String tagDate = tags.get(dateTag.get());\n+\n+            final Optional<LocalDate> parsedDate = this.parseDate(tagDate);\n+            if (parsedDate.isPresent() && parsedDate.get().isBefore(TODAYS_DATE))\n+            {\n+                return Optional.of(\n+                        this.createFlag(object, this.getLocalizedInstruction(0, dateTag.get())));\n+            }\n+        }\n+\n+        if (tags.containsKey(CheckDateTag.KEY))\n+        {\n+            final Optional<LocalDate> parseDateChecked = this.parseDate(tags.get(CheckDateTag.KEY));\n+            if (parseDateChecked.isPresent())\n+            {\n+                final long monthsBetween = ChronoUnit.MONTHS.between(parseDateChecked.get(),\n+                        TODAYS_DATE);\n+                if (monthsBetween > this.oldCheckDateMonths)\n+                {\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(1, this.oldCheckDateMonths)));\n+                }\n+            }\n+        }\n+\n+        if (tags.containsKey(LastEditTimeTag.KEY))\n+        {\n+            final long timestamp = Long.parseLong(tags.get(LastEditTimeTag.KEY));\n+            final LocalDate lastEditDate = Instant.ofEpochMilli(timestamp)\n+                    .atZone(ZoneId.systemDefault()).toLocalDate();\n+\n+            final long numberOfDays = ChronoUnit.DAYS.between(lastEditDate, TODAYS_DATE);\n+            if (numberOfDays > this.oldConstructionDays)\n+            {\n+                return Optional.of(this.createFlag(object,\n+                        this.getLocalizedInstruction(2, this.oldConstructionDays)));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Gets the tag that holds a date.\n+     *\n+     * @param keySet\n+     *            Tags from the object.\n+     * @return a tag that is considered a date for construction.\n+     */\n+    private Optional<String> getDateTag(final Map<String, String> keySet)\n+    {\n+        return DATE_TAGS.stream().filter(keySet::containsKey).findFirst();\n+    }\n+\n+    /**\n+     * Checks if the tags of an object signify it as being under construction.\n+     *\n+     * @param tags\n+     *            Tags from the object\n+     * @return true if the object is under construction, otherwise false\n+     */\n+    private boolean isConstruction(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream()\n+                .anyMatch(tag -> tag.equals(ConstructionTag.KEY)\n+                        || tag.startsWith(\"construction:\") && !tag.equals(ConstructionDateTag.KEY))\n+                || CONSTRUCTION_TAGS.stream()\n+                        .anyMatch(tag -> ConstructionTag.KEY.equals(tags.get(tag)));\n+    }\n+\n+    /**\n+     * Attempts to parse the date string to ISO 8601 yyyy-mm-dd.\n+     *\n+     * @param tagDate\n+     *            String representation of a date from a tag.\n+     * @return the parsed date.\n+     */\n+    private Optional<LocalDate> parseDate(final String tagDate)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e33bc063a1a76f6e692c91a414281cd3660bca5b"}, "originalPosition": 224}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3170, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}