{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNDU2OTkz", "number": 449, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoyMDowOFrOFGcW9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjoxNzozOVrOFL65jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzAwNDA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoyMDowOFrOIHdfVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwMDowNTowOFrOIOsEew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5NDEwMA==", "bodyText": "A roundabout can be made up of multiple Ways, so to would be better to use the roundaboutEdgeSet here.", "url": "https://github.com/osmlab/atlas-checks/pull/449#discussion_r544694100", "createdAt": "2020-12-16T23:20:08Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "diffHunk": "@@ -99,17 +104,43 @@ public boolean validCheckForObject(final AtlasObject object)\n         // Create a ComplexRoundabout based on object\n         final ComplexRoundabout complexRoundabout = new ComplexRoundabout((Edge) object,\n                 this.leftDrivingCountries);\n-        // If the ComplexRoundbaout is invalid add the reasons why to the instructions, so that it\n-        // will be flagged\n-        if (!complexRoundabout.isValid())\n-        {\n-            instructions.addAll(complexRoundabout.getAllInvalidations().stream()\n-                    .map(ComplexEntity.ComplexEntityError::getReason).collect(Collectors.toSet()));\n-        }\n         // Get the roundabout Edges\n         final Set<Edge> roundaboutEdgeSet = complexRoundabout.getRoundaboutEdgeSet();\n         // Get the roundabout Route\n         final Route roundaboutEdges = complexRoundabout.getRoundaboutRoute();\n+\n+        // If the ComplexRoundabout is invalid add the reasons why to the instructions, so that it\n+        // will be flagged\n+        if (!complexRoundabout.isValid())\n+        {\n+            // AutoFix candidate only for wrong direction case.\n+            if (complexRoundabout.getAllInvalidations().size() == 1 && complexRoundabout\n+                    .getAllInvalidations().get(0).getReason().equals(WRONG_WAY_INVALIDATION))\n+            {\n+                // Mark that the Edges have been processed\n+                roundaboutEdgeSet.forEach(\n+                        roundaboutEdge -> this.markAsFlagged(roundaboutEdge.getIdentifier()));\n+\n+                return Optional.of(this\n+                        .createFlag(new OsmWayWalker((Edge) object).collectEdges(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "691114a5d646d6e396f256fc3bc5ebf46762dcc9"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwNDY4Mw==", "bodyText": "Thanks @Bentleysb ! good suggestion", "url": "https://github.com/osmlab/atlas-checks/pull/449#discussion_r544704683", "createdAt": "2020-12-16T23:46:26Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "diffHunk": "@@ -99,17 +104,43 @@ public boolean validCheckForObject(final AtlasObject object)\n         // Create a ComplexRoundabout based on object\n         final ComplexRoundabout complexRoundabout = new ComplexRoundabout((Edge) object,\n                 this.leftDrivingCountries);\n-        // If the ComplexRoundbaout is invalid add the reasons why to the instructions, so that it\n-        // will be flagged\n-        if (!complexRoundabout.isValid())\n-        {\n-            instructions.addAll(complexRoundabout.getAllInvalidations().stream()\n-                    .map(ComplexEntity.ComplexEntityError::getReason).collect(Collectors.toSet()));\n-        }\n         // Get the roundabout Edges\n         final Set<Edge> roundaboutEdgeSet = complexRoundabout.getRoundaboutEdgeSet();\n         // Get the roundabout Route\n         final Route roundaboutEdges = complexRoundabout.getRoundaboutRoute();\n+\n+        // If the ComplexRoundabout is invalid add the reasons why to the instructions, so that it\n+        // will be flagged\n+        if (!complexRoundabout.isValid())\n+        {\n+            // AutoFix candidate only for wrong direction case.\n+            if (complexRoundabout.getAllInvalidations().size() == 1 && complexRoundabout\n+                    .getAllInvalidations().get(0).getReason().equals(WRONG_WAY_INVALIDATION))\n+            {\n+                // Mark that the Edges have been processed\n+                roundaboutEdgeSet.forEach(\n+                        roundaboutEdge -> this.markAsFlagged(roundaboutEdge.getIdentifier()));\n+\n+                return Optional.of(this\n+                        .createFlag(new OsmWayWalker((Edge) object).collectEdges(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5NDEwMA=="}, "originalCommit": {"oid": "691114a5d646d6e396f256fc3bc5ebf46762dcc9"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MzAxOQ==", "bodyText": "@Bentleysb, I moved back to new OsmWayWalker. 1) since we are dealing with single entity Roundabout only. 2) its sorted by way section id unlike roundaboutEdgeSet.", "url": "https://github.com/osmlab/atlas-checks/pull/449#discussion_r552273019", "createdAt": "2021-01-06T00:05:08Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "diffHunk": "@@ -99,17 +104,43 @@ public boolean validCheckForObject(final AtlasObject object)\n         // Create a ComplexRoundabout based on object\n         final ComplexRoundabout complexRoundabout = new ComplexRoundabout((Edge) object,\n                 this.leftDrivingCountries);\n-        // If the ComplexRoundbaout is invalid add the reasons why to the instructions, so that it\n-        // will be flagged\n-        if (!complexRoundabout.isValid())\n-        {\n-            instructions.addAll(complexRoundabout.getAllInvalidations().stream()\n-                    .map(ComplexEntity.ComplexEntityError::getReason).collect(Collectors.toSet()));\n-        }\n         // Get the roundabout Edges\n         final Set<Edge> roundaboutEdgeSet = complexRoundabout.getRoundaboutEdgeSet();\n         // Get the roundabout Route\n         final Route roundaboutEdges = complexRoundabout.getRoundaboutRoute();\n+\n+        // If the ComplexRoundabout is invalid add the reasons why to the instructions, so that it\n+        // will be flagged\n+        if (!complexRoundabout.isValid())\n+        {\n+            // AutoFix candidate only for wrong direction case.\n+            if (complexRoundabout.getAllInvalidations().size() == 1 && complexRoundabout\n+                    .getAllInvalidations().get(0).getReason().equals(WRONG_WAY_INVALIDATION))\n+            {\n+                // Mark that the Edges have been processed\n+                roundaboutEdgeSet.forEach(\n+                        roundaboutEdge -> this.markAsFlagged(roundaboutEdge.getIdentifier()));\n+\n+                return Optional.of(this\n+                        .createFlag(new OsmWayWalker((Edge) object).collectEdges(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5NDEwMA=="}, "originalCommit": {"oid": "691114a5d646d6e396f256fc3bc5ebf46762dcc9"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzEzOTU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowNzo1MlrOIHep1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowNzo1MlrOIHep1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMzE3NA==", "bodyText": "Sorry, I misread this slightly the first time. As well as flagging each edge in roundaboutEdgeSet, as you have now done, each of those edges also needs its own fix suggestion to reverse the geometry.", "url": "https://github.com/osmlab/atlas-checks/pull/449#discussion_r544713174", "createdAt": "2020-12-17T00:07:52Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "diffHunk": "@@ -99,17 +103,43 @@ public boolean validCheckForObject(final AtlasObject object)\n         // Create a ComplexRoundabout based on object\n         final ComplexRoundabout complexRoundabout = new ComplexRoundabout((Edge) object,\n                 this.leftDrivingCountries);\n-        // If the ComplexRoundbaout is invalid add the reasons why to the instructions, so that it\n-        // will be flagged\n-        if (!complexRoundabout.isValid())\n-        {\n-            instructions.addAll(complexRoundabout.getAllInvalidations().stream()\n-                    .map(ComplexEntity.ComplexEntityError::getReason).collect(Collectors.toSet()));\n-        }\n         // Get the roundabout Edges\n         final Set<Edge> roundaboutEdgeSet = complexRoundabout.getRoundaboutEdgeSet();\n         // Get the roundabout Route\n         final Route roundaboutEdges = complexRoundabout.getRoundaboutRoute();\n+\n+        // If the ComplexRoundabout is invalid add the reasons why to the instructions, so that it\n+        // will be flagged\n+        if (!complexRoundabout.isValid())\n+        {\n+            // AutoFix candidate only for wrong direction case.\n+            if (complexRoundabout.getAllInvalidations().size() == 1 && complexRoundabout\n+                    .getAllInvalidations().get(0).getReason().equals(WRONG_WAY_INSTRUCTIONS))\n+            {\n+                // Mark that the Edges have been processed\n+                roundaboutEdgeSet.forEach(\n+                        roundaboutEdge -> this.markAsFlagged(roundaboutEdge.getIdentifier()));\n+\n+                return Optional.of(this\n+                        .createFlag(roundaboutEdgeSet,\n+                                this.getLocalizedInstruction(1, object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55a560d840a4b0bd3d9ab047abda8767ae4780e1"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDQzNjYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjoxNzozOVrOIPX-Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjoxNzozOVrOIPX-Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk5MjI5OA==", "bodyText": "This is an interesting way to combine the edges into a single fix suggestion. It could result in some nondeterminism due to taking on the atlas id of the starting object, but I think that is ok in this instance.", "url": "https://github.com/osmlab/atlas-checks/pull/449#discussion_r552992298", "createdAt": "2021-01-06T22:17:39Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/MalformedRoundaboutCheck.java", "diffHunk": "@@ -112,28 +114,32 @@ public boolean validCheckForObject(final AtlasObject object)\n         // will be flagged\n         if (!complexRoundabout.isValid())\n         {\n-            // AutoFix candidate only for wrong direction case.\n-            if (complexRoundabout.getAllInvalidations().size() == 1 && complexRoundabout\n-                    .getAllInvalidations().get(0).getReason().equals(WRONG_WAY_INSTRUCTIONS))\n+            // AutoFix candidate only for Single Way Roundabout with wrong direction.\n+            if (complexRoundabout.getAllInvalidations().size() == 1\n+                    && complexRoundabout.getAllInvalidations().get(0).getReason()\n+                            .equals(WRONG_WAY_INSTRUCTIONS)\n+                    && !this.isMultiWayRoundabout(roundaboutEdgeSet))\n             {\n                 // Mark that the Edges have been processed\n                 roundaboutEdgeSet.forEach(\n                         roundaboutEdge -> this.markAsFlagged(roundaboutEdge.getIdentifier()));\n \n                 return Optional.of(this\n-                        .createFlag(roundaboutEdgeSet,\n+                        .createFlag(new OsmWayWalker((Edge) object).collectEdges(),\n                                 this.getLocalizedInstruction(1, object.getOsmIdentifier()))\n-                        .addFixSuggestion(FeatureChange.add(\n-                                (AtlasEntity) ((CompleteEntity) CompleteEntity\n-                                        .from((AtlasEntity) object)).withGeometry(\n-                                                ((Edge) object).asPolyLine().reversed()),\n-                                object.getAtlas())));\n+                        .addFixSuggestion(\n+                                FeatureChange.add(\n+                                        (AtlasEntity) ((CompleteEntity) CompleteEntity\n+                                                .from((AtlasEntity) object)).withGeometry(\n+                                                        CommonMethods.buildOriginalOsmWayGeometry(\n+                                                                (Edge) object).reversed()),\n+                                        object.getAtlas())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc2f9f7b2c0b4b818f8e4b70e996d49b82916e8e"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3233, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}