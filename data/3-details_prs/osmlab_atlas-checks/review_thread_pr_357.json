{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMDc3OTUw", "number": 357, "reviewThreads": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDowMDoyMVrOFvSPxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0NzoyOFrOGWHZSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1MTI2MzQwOnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDowMDoyMVrOJE0JKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDo1OTo1OVrOJE2a7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTAyODM5Mw==", "bodyText": "careful - this needs to be reverted.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609028393", "createdAt": "2021-04-07T20:00:21Z", "author": {"login": "atiannicelli"}, "path": "config/configuration.json", "diffHunk": "@@ -4,7 +4,7 @@\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n     \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true\n+    \"enabled.value.default\": false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTA2NTcxMQ==", "bodyText": "Fixed", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609065711", "createdAt": "2021-04-07T20:59:59Z", "author": {"login": "tsmock"}, "path": "config/configuration.json", "diffHunk": "@@ -4,7 +4,7 @@\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n     \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true\n+    \"enabled.value.default\": false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTAyODM5Mw=="}, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1MTI2NjQwOnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDowMDo1MVrOJE0LCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDowMDo1MVrOJE0LCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTAyODg3NQ==", "bodyText": "needs to be removed.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609028875", "createdAt": "2021-04-07T20:00:51Z", "author": {"login": "atiannicelli"}, "path": "config/configuration.json", "diffHunk": "@@ -1270,14 +1288,15 @@\n     }\n   },\n   \"WaterWayCheck\": {\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1MTMxMTU5OnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDowOTo1NFrOJE0nhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMTowMDoxOVrOJE2bpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTAzNjE2NQ==", "bodyText": "needs to be made executable.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609036165", "createdAt": "2021-04-07T20:09:54Z", "author": {"login": "atiannicelli"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTA2NTg5Mw==", "bodyText": "Done", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609065893", "createdAt": "2021-04-07T21:00:19Z", "author": {"login": "tsmock"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTAzNjE2NQ=="}, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1MTM3NzMwOnYy", "diffSide": "RIGHT", "path": "gradle.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyNzoxNVrOJE1PNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyNzoxNVrOJE1PNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTA0NjMyNw==", "bodyText": "Guessing you want to take this out of the pr\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            checks.local.input=file://@BUILDDIR@/../atlas/\n          \n          \n            \n            #checks.local.input=hdfs://10.135.134.89:9000/tsmock/atlas/\n          \n          \n            \n            checks.local.input=file://@BUILDDIR@/example/data/atlas/", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609046327", "createdAt": "2021-04-07T20:27:15Z", "author": {"login": "atiannicelli"}, "path": "gradle.properties", "diffHunk": "@@ -14,14 +14,20 @@ profile=local\n ## Local (default)\n checks.local.sharded=true\n checks.local.configFiles=file://@ROOTDIR@/config/configuration.json\n-checks.local.input=file://@BUILDDIR@/example/data/atlas/\n+checks.local.input=file://@BUILDDIR@/../atlas/\n+#checks.local.input=hdfs://10.135.134.89:9000/tsmock/atlas/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1MTM4MDczOnYy", "diffSide": "RIGHT", "path": "gradle.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyODowN1rOJE1ROw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyODowN1rOJE1ROw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTA0Njg0Mw==", "bodyText": "I think you want to revert this entire file, right?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609046843", "createdAt": "2021-04-07T20:28:07Z", "author": {"login": "atiannicelli"}, "path": "gradle.properties", "diffHunk": "@@ -14,14 +14,20 @@ profile=local\n ## Local (default)\n checks.local.sharded=true\n checks.local.configFiles=file://@ROOTDIR@/config/configuration.json\n-checks.local.input=file://@BUILDDIR@/example/data/atlas/\n+checks.local.input=file://@BUILDDIR@/../atlas/\n+#checks.local.input=hdfs://10.135.134.89:9000/tsmock/atlas/\n checks.local.output=file://@BUILDDIR@/example/data/output/\n-checks.local.outputFormats=flags,geojson,metrics\n-checks.local.countries=BLZ\n+checks.local.outputFormats=flags,geojson,metrics,tippecanoe\n+# AIA,AUS,CHN,CYM,DMA,NZL,SMR,TUR\n+# AUS,CHN died\n+# Removed NZL for runtime\n+# AIA,CYM,DMA,SMR,NZL\n+checks.local.countries=AIA,CYM,DMA,SMR,NZL\n #checks.local.pbfBoundingBox=\n checks.local.savePbfAtlas=true\n checks.local.compressOutput=false\n checks.local.startedFolder=file://@BUILDDIR@/example/tmp/\n checks.local.cluster=local\n+#checks.local.cluster=spark://taylorrpi1:7077\n checks.local.multiAtlas=true\n-checks.local.sparkOptions=spark.executor.memory->4g,spark.driver.memory->4g,spark.rdd.compress->true\n+checks.local.sparkOptions=spark.executor.memory->2g,spark.driver.memory->1g,spark.rdd.compress->true,spark.default.parallelism->8", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1MTM4NDMyOnYy", "diffSide": "RIGHT", "path": "gradle/execute.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyODo1NVrOJE1TQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyODo1NVrOJE1TQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTA0NzM2Mw==", "bodyText": "did you really want this?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609047363", "createdAt": "2021-04-07T20:28:55Z", "author": {"login": "atiannicelli"}, "path": "gradle/execute.gradle", "diffHunk": "@@ -50,7 +50,7 @@ task runChecks(type: JavaExec, dependsOn: 'assemble', description: 'Executes the\n     classpath('./config/log4j')\n \n     // uncomment to change jvm args\n-    // jvmArgs([\"-Xmx8g\",\"-Xms8g\"])\n+    jvmArgs([\"-Xmx2g\",\"-Xms2g\", \"-XX:+HeapDumpOnOutOfMemoryError\"])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1MTM4ODEzOnYy", "diffSide": "RIGHT", "path": "settings.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyOTo1MFrOJE1Vkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QyMDoyOTo1MFrOJE1Vkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTA0Nzk1NA==", "bodyText": "Can you remove these comments?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609047954", "createdAt": "2021-04-07T20:29:50Z", "author": {"login": "atiannicelli"}, "path": "settings.gradle", "diffHunk": "@@ -1 +1,3 @@\n rootProject.name = 'atlas-checks'\n+//includeBuild '../atlas'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89e4aeb45c6c77a109977601606198a8225e3dc8"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1NjE1OTAzOnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQxMzo1OTo0MFrOJFfJUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQxMzo1OTo0MFrOJFfJUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTczMjk0NQ==", "bodyText": "I see that you removed elevation.path in the ElevationUtilities md file... but added it here. Should this be elevation.prefix?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r609732945", "createdAt": "2021-04-08T13:59:40Z", "author": {"login": "atiannicelli"}, "path": "config/configuration.json", "diffHunk": "@@ -1290,6 +1308,9 @@\n       \"defaultPriority\": \"LOW\"\n     }\n   },\n+  \"ElevationUtilities\": {\n+     \"elevation.path\": \"extra/elevation\"\n+  },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b93472489fa786ccf03648ddefacca2244f270d5"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0MzYxOTM0OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNlQxNDoxODowOFrOJuf2Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNlQxNDoyMTo0NlrOJugEMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MjczNjA4Mg==", "bodyText": "Can you change this to \"EXPERT\"?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  \"difficulty\": \"Medium\",\n          \n          \n            \n                  \"difficulty\": \"EXPERT\",\n          \n      \n    \n    \n  \n\nI think that we want this to be noted as an expert challenge and if I am reading the code correctly the correct value is \"EXPERT\".\nhttps://github.com/osmlab/atlas-checks/blob/dev/src/main/java/org/openstreetmap/atlas/checks/maproulette/data/ChallengeDifficulty.java#L10", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r652736082", "createdAt": "2021-06-16T14:18:08Z", "author": {"login": "atiannicelli"}, "path": "config/configuration.json", "diffHunk": "@@ -315,6 +315,24 @@\n       \"tags\":\"coastline\"\n     }\n   },\n+  \"GenericTagCheck\": {\n+    \"db\": {\n+      \"taginfo\": \"extra/taginfo-db.db\",\n+      \"wikidata\": \"extra/wikidata.db\"\n+    },\n+    \"tag\": {\n+      \"usage.min\": 100,\n+      \"percentage_of_key_for_popular\": 10\n+    },\n+    \"wikidata.tag_removal\": [\"abandoned\", \"deprecated\", \"imported\", \"obsolete\", \"rejected\"],\n+    \"challenge\": {\n+      \"description\": \"Tasks containing features with tags containing missing, conflicting, incorrect or illegal values\",\n+      \"blurb\": \"Features with invalid tags\",\n+      \"instruction\": \"Open your favorite editor and check that the listed tags are correct.\",\n+      \"difficulty\": \"Medium\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b93472489fa786ccf03648ddefacca2244f270d5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MjczOTYzNA==", "bodyText": "And done. :)", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r652739634", "createdAt": "2021-06-16T14:21:46Z", "author": {"login": "tsmock"}, "path": "config/configuration.json", "diffHunk": "@@ -315,6 +315,24 @@\n       \"tags\":\"coastline\"\n     }\n   },\n+  \"GenericTagCheck\": {\n+    \"db\": {\n+      \"taginfo\": \"extra/taginfo-db.db\",\n+      \"wikidata\": \"extra/wikidata.db\"\n+    },\n+    \"tag\": {\n+      \"usage.min\": 100,\n+      \"percentage_of_key_for_popular\": 10\n+    },\n+    \"wikidata.tag_removal\": [\"abandoned\", \"deprecated\", \"imported\", \"obsolete\", \"rejected\"],\n+    \"challenge\": {\n+      \"description\": \"Tasks containing features with tags containing missing, conflicting, incorrect or illegal values\",\n+      \"blurb\": \"Features with invalid tags\",\n+      \"instruction\": \"Open your favorite editor and check that the listed tags are correct.\",\n+      \"difficulty\": \"Medium\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MjczNjA4Mg=="}, "originalCommit": {"oid": "b93472489fa786ccf03648ddefacca2244f270d5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE1NDYwMjIzOnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxMzoyODozMlrOJwHNsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjowOToxOFrOJzmi0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDQyOTYxOQ==", "bodyText": "Please expand this description. For example:\n\nThis challenge contains tasks that identify features with OSM Tags (https://wiki.openstreetmap.org/wiki/Tags) that contain invalid tag keys or missing, conflicting, incorrect or illegal tag values. In many tasks in this challenge the task will identify an illegal or questionable tag key or value and provide a link to the Control Wiki Page (wiki page with identification string starting with Q, following with 3 to 4 digits, e.g. https://wiki.osm.org/Item:Q1189) that is used to define that tag\u2019s characteristics in a computer readable format. That Control Wiki Page should contain a link to the Documentation Wiki Page for that tag that is a human readable page that discusses the proper use of the tag and other useful information.\nFor some tasks in this challenge the task may indicate a tag value that is valid or widely used that is not documented in the wiki. For these cases the mapper should not make any changes to the OSM data, but should instead consider adding documentation to the wiki to validate the tag value officially.\nFor more information on the Atlas Check that is used to create this challenge please go to https://github.com/osmlab/atlas-checks/tree/dev/docs/checks/genericTagCheck.md", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r654429619", "createdAt": "2021-06-18T13:28:32Z", "author": {"login": "atiannicelli"}, "path": "config/configuration.json", "diffHunk": "@@ -315,6 +315,24 @@\n       \"tags\":\"coastline\"\n     }\n   },\n+  \"GenericTagCheck\": {\n+    \"db\": {\n+      \"taginfo\": \"extra/taginfo-db.db\",\n+      \"wikidata\": \"extra/wikidata.db\"\n+    },\n+    \"tag\": {\n+      \"usage.min\": 100,\n+      \"percentage_of_key_for_popular\": 10\n+    },\n+    \"wikidata.tag_removal\": [\"abandoned\", \"deprecated\", \"imported\", \"obsolete\", \"rejected\"],\n+    \"challenge\": {\n+      \"description\": \"Tasks containing features with tags containing missing, conflicting, incorrect or illegal values\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b93472489fa786ccf03648ddefacca2244f270d5"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODA4ODY1OA==", "bodyText": "Fixed in c3810a7", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r658088658", "createdAt": "2021-06-24T16:09:18Z", "author": {"login": "tsmock"}, "path": "config/configuration.json", "diffHunk": "@@ -315,6 +315,24 @@\n       \"tags\":\"coastline\"\n     }\n   },\n+  \"GenericTagCheck\": {\n+    \"db\": {\n+      \"taginfo\": \"extra/taginfo-db.db\",\n+      \"wikidata\": \"extra/wikidata.db\"\n+    },\n+    \"tag\": {\n+      \"usage.min\": 100,\n+      \"percentage_of_key_for_popular\": 10\n+    },\n+    \"wikidata.tag_removal\": [\"abandoned\", \"deprecated\", \"imported\", \"obsolete\", \"rejected\"],\n+    \"challenge\": {\n+      \"description\": \"Tasks containing features with tags containing missing, conflicting, incorrect or illegal values\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDQyOTYxOQ=="}, "originalCommit": {"oid": "b93472489fa786ccf03648ddefacca2244f270d5"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTYzMzM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODozMTo1OFrOJzstWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODo1MDoxN1rOJztbJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE4OTY1OA==", "bodyText": "One more to convert to var\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            final WikiData roleInfo = this\n          \n          \n            \n                            final var roleInfo = this", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r658189658", "createdAt": "2021-06-24T18:31:58Z", "author": {"login": "atiannicelli"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,939 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final WikiData roleInfo = this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65dab299c4c81c793bf8ef2cd78e368bd4332a13"}, "originalPosition": 537}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODIwMTM4MA==", "bodyText": "It is always fun when you miss one.\n8999207", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r658201380", "createdAt": "2021-06-24T18:50:17Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,939 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final WikiData roleInfo = this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE4OTY1OA=="}, "originalCommit": {"oid": "65dab299c4c81c793bf8ef2cd78e368bd4332a13"}, "originalPosition": 537}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTQ2MjQ2OnYy", "diffSide": "RIGHT", "path": "docs/checks/genericTagCheck.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNTo1ODoxNlrOJ96hpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxMzo0Mzo0MVrOJ-m2_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkwMTc5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            key for the `wikidata` database, `\"wikidata.tag_removal\"` in main InvalidTagsCheck check configuration section. This\n          \n          \n            \n            key for the `wikidata` database, `\"wikidata.tag_removal\"` in main GenericTagCheck check configuration section. This", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668901796", "createdAt": "2021-07-13T15:58:16Z", "author": {"login": "Bentleysb"}, "path": "docs/checks/genericTagCheck.md", "diffHunk": "@@ -0,0 +1,89 @@\n+# Generic Tag Check\n+\n+This check uses TagInfo and WikiData databases to look for invalid, deprecated, or otherwise invalid tags.\n+In addition, there is a fallback check that uses TagInfo data and WikiData items to determine if a tag is valid.\n+The fallback check can be enabled or disabled by setting `\"fallback\"` to `false`. The location of the databases are\n+set in a `\"db\"` section with either `\"wikidata\"` or `\"taginfo\"` as the key, and then the path as the value. This\n+_must_ be changed in Microsoft Windows environments (due to differences in file path separators). There is an additional\n+key for the `wikidata` database, `\"wikidata.tag_removal\"` in main InvalidTagsCheck check configuration section. This", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTYyODE1Ng==", "bodyText": "Oops. I was originally modifying the InvalidTagsCheck, but later decided to move it into its own check.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669628156", "createdAt": "2021-07-14T13:43:41Z", "author": {"login": "tsmock"}, "path": "docs/checks/genericTagCheck.md", "diffHunk": "@@ -0,0 +1,89 @@\n+# Generic Tag Check\n+\n+This check uses TagInfo and WikiData databases to look for invalid, deprecated, or otherwise invalid tags.\n+In addition, there is a fallback check that uses TagInfo data and WikiData items to determine if a tag is valid.\n+The fallback check can be enabled or disabled by setting `\"fallback\"` to `false`. The location of the databases are\n+set in a `\"db\"` section with either `\"wikidata\"` or `\"taginfo\"` as the key, and then the path as the value. This\n+_must_ be changed in Microsoft Windows environments (due to differences in file path separators). There is an additional\n+key for the `wikidata` database, `\"wikidata.tag_removal\"` in main InvalidTagsCheck check configuration section. This", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkwMTc5Ng=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTUzNDg1OnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoxMTozNVrOJ97NYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNToyMToxN1rOJ-sQwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkxMjk5Mw==", "bodyText": "Could you add a requirements.txt for this script? There are some non-default libraries here.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668912993", "createdAt": "2021-07-13T16:11:35Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTcxNjY3NA==", "bodyText": "Yep. I'm going to do a minimal requirements.txt file (mostly to avoid having to manually update the requirements.txt all the time).", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669716674", "createdAt": "2021-07-14T15:21:17Z", "author": {"login": "tsmock"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkxMjk5Mw=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTU1ODg5OnYy", "diffSide": "RIGHT", "path": "scripts/wikidata/requirements.txt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoxNjoxMFrOJ97brA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNToyMTo1MlrOJ-sS-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkxNjY1Mg==", "bodyText": "pandas is missing", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668916652", "createdAt": "2021-07-13T16:16:10Z", "author": {"login": "Bentleysb"}, "path": "scripts/wikidata/requirements.txt", "diffHunk": "@@ -0,0 +1,25 @@\n+appdirs>=1.4.4\n+black>=20.8b1\n+CacheControl>=0.12.6\n+certifi>=2020.6.20\n+chardet>=3.0.4\n+click>=7.1.2\n+coverage>=5.3\n+flake8>=3.8.3\n+idna>=2.10\n+importlib-metadata>=1.7.0\n+lockfile>=0.12.2\n+mccabe>=0.6.1\n+msgpack>=1.0.0\n+mypy-extensions>=0.4.3\n+pathspec>=0.8.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTcxNzI0MQ==", "bodyText": "Oops. I'm adding that now, and doing the same to the requirements.txt file as I'm doing for the downloadTagInfo.py requirements.txt file.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669717241", "createdAt": "2021-07-14T15:21:52Z", "author": {"login": "tsmock"}, "path": "scripts/wikidata/requirements.txt", "diffHunk": "@@ -0,0 +1,25 @@\n+appdirs>=1.4.4\n+black>=20.8b1\n+CacheControl>=0.12.6\n+certifi>=2020.6.20\n+chardet>=3.0.4\n+click>=7.1.2\n+coverage>=5.3\n+flake8>=3.8.3\n+idna>=2.10\n+importlib-metadata>=1.7.0\n+lockfile>=0.12.2\n+mccabe>=0.6.1\n+msgpack>=1.0.0\n+mypy-extensions>=0.4.3\n+pathspec>=0.8.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkxNjY1Mg=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTU3NjMyOnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoxOTo0MFrOJ97mWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoxOTo0MFrOJ97mWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkxOTM4Ng==", "bodyText": "It would be great to have a docstring to describe this script.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668919386", "createdAt": "2021-07-13T16:19:40Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTU5NDAxOnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoyMjo1OFrOJ97w9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoyMjo1OFrOJ97w9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyMjEwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:\n          \n          \n            \n                    with open(os.path.join(directory, os.path.basename(name)), \"wb\") as file_handler:", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668922102", "createdAt": "2021-07-13T16:22:58Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n+        with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTYwMDQ2OnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoyNDoxOVrOJ971IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoyNDoxOVrOJ971IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyMzE2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n          \n          \n            \n                    progress = tqdm(total=size, unit=\"iB\", unit_scale=True, desc=\"Downloading taginfo-db\")", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668923169", "createdAt": "2021-07-13T16:24:19Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTYxMTU2OnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoyNjozNlrOJ9779Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMjoyNjowNFrOJ-9QKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyNDkxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        t = table[0]\n          \n          \n            \n                        table_name = table[0]", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668924917", "createdAt": "2021-07-13T16:26:36Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n+        with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:\n+            for content in response.iter_content(chunk_size=block_size):\n+                fh.write(content)\n+                progress.update(len(content))\n+        progress.close()\n+\n+\n+def cleanup(database :str, min_count: int=100):\n+    \"\"\"\n+    Remove unnecessary data\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        for table in [\"key_characters\", \"key_combinations\", \"key_distributions\", \"prevalent_roles\", \"prevalent_values\", \"relation_roles\", \"relation_types\", \"similar_keys\", \"similar_keys_common_rare\", \"tag_combinations\", \"tag_distributions\"]:\n+            conn.execute(\"DROP TABLE IF EXISTS {}\".format(table))\n+        for table in [\"keys\", \"tags\"]:\n+            conn.execute(\"DELETE FROM {} WHERE count_all < {}\".format(table, min_count))\n+            # Remove \"known good\" keys that inflate the database, or keys that\n+            # are from imports and are largely unique. Also, some keys that can\n+            # be validated from the surrounding relations are dropped.\n+            for key in [\"name\", \"addr:housenumber\", \"addr:city\", \"addr:place\", \"addr:suburb\", \"tiger:zip_left\", \"tiger:name_base\", \"tiger:zip_right\", \"tiger:county\", \"tiger:upload_uuid\"]:\n+                conn.execute(\"DELETE FROM {} WHERE key = '{}'\".format(table, key))\n+        conn.commit()\n+        conn.execute(\"VACUUM\")\n+\n+def convert_to_parquet(database: str, save_directory: str=\"parquet\"):\n+    \"\"\"\n+    Convert an sqlite db to parquet files\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        path = os.path.join(save_directory, \"taginfo\")\n+        if not os.path.exists(path):\n+            os.makedirs(path)\n+        for table in conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall():\n+            t = table[0]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTg3MDA3Ng==", "bodyText": "@tsmock", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669870076", "createdAt": "2021-07-14T18:52:08Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n+        with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:\n+            for content in response.iter_content(chunk_size=block_size):\n+                fh.write(content)\n+                progress.update(len(content))\n+        progress.close()\n+\n+\n+def cleanup(database :str, min_count: int=100):\n+    \"\"\"\n+    Remove unnecessary data\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        for table in [\"key_characters\", \"key_combinations\", \"key_distributions\", \"prevalent_roles\", \"prevalent_values\", \"relation_roles\", \"relation_types\", \"similar_keys\", \"similar_keys_common_rare\", \"tag_combinations\", \"tag_distributions\"]:\n+            conn.execute(\"DROP TABLE IF EXISTS {}\".format(table))\n+        for table in [\"keys\", \"tags\"]:\n+            conn.execute(\"DELETE FROM {} WHERE count_all < {}\".format(table, min_count))\n+            # Remove \"known good\" keys that inflate the database, or keys that\n+            # are from imports and are largely unique. Also, some keys that can\n+            # be validated from the surrounding relations are dropped.\n+            for key in [\"name\", \"addr:housenumber\", \"addr:city\", \"addr:place\", \"addr:suburb\", \"tiger:zip_left\", \"tiger:name_base\", \"tiger:zip_right\", \"tiger:county\", \"tiger:upload_uuid\"]:\n+                conn.execute(\"DELETE FROM {} WHERE key = '{}'\".format(table, key))\n+        conn.commit()\n+        conn.execute(\"VACUUM\")\n+\n+def convert_to_parquet(database: str, save_directory: str=\"parquet\"):\n+    \"\"\"\n+    Convert an sqlite db to parquet files\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        path = os.path.join(save_directory, \"taginfo\")\n+        if not os.path.exists(path):\n+            os.makedirs(path)\n+        for table in conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall():\n+            t = table[0]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyNDkxNw=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTkxODEyOQ==", "bodyText": "Sorry about missing these -- GitHub had them hidden (it said \"5 hidden conversations\", and I wrongly assumed that you had created them, and then decided that they weren't needed).", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669918129", "createdAt": "2021-07-14T20:08:31Z", "author": {"login": "tsmock"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n+        with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:\n+            for content in response.iter_content(chunk_size=block_size):\n+                fh.write(content)\n+                progress.update(len(content))\n+        progress.close()\n+\n+\n+def cleanup(database :str, min_count: int=100):\n+    \"\"\"\n+    Remove unnecessary data\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        for table in [\"key_characters\", \"key_combinations\", \"key_distributions\", \"prevalent_roles\", \"prevalent_values\", \"relation_roles\", \"relation_types\", \"similar_keys\", \"similar_keys_common_rare\", \"tag_combinations\", \"tag_distributions\"]:\n+            conn.execute(\"DROP TABLE IF EXISTS {}\".format(table))\n+        for table in [\"keys\", \"tags\"]:\n+            conn.execute(\"DELETE FROM {} WHERE count_all < {}\".format(table, min_count))\n+            # Remove \"known good\" keys that inflate the database, or keys that\n+            # are from imports and are largely unique. Also, some keys that can\n+            # be validated from the surrounding relations are dropped.\n+            for key in [\"name\", \"addr:housenumber\", \"addr:city\", \"addr:place\", \"addr:suburb\", \"tiger:zip_left\", \"tiger:name_base\", \"tiger:zip_right\", \"tiger:county\", \"tiger:upload_uuid\"]:\n+                conn.execute(\"DELETE FROM {} WHERE key = '{}'\".format(table, key))\n+        conn.commit()\n+        conn.execute(\"VACUUM\")\n+\n+def convert_to_parquet(database: str, save_directory: str=\"parquet\"):\n+    \"\"\"\n+    Convert an sqlite db to parquet files\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        path = os.path.join(save_directory, \"taginfo\")\n+        if not os.path.exists(path):\n+            os.makedirs(path)\n+        for table in conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall():\n+            t = table[0]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyNDkxNw=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5NTA0OQ==", "bodyText": "No worries. I guessed something like that might be the case.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669995049", "createdAt": "2021-07-14T22:26:04Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n+        with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:\n+            for content in response.iter_content(chunk_size=block_size):\n+                fh.write(content)\n+                progress.update(len(content))\n+        progress.close()\n+\n+\n+def cleanup(database :str, min_count: int=100):\n+    \"\"\"\n+    Remove unnecessary data\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        for table in [\"key_characters\", \"key_combinations\", \"key_distributions\", \"prevalent_roles\", \"prevalent_values\", \"relation_roles\", \"relation_types\", \"similar_keys\", \"similar_keys_common_rare\", \"tag_combinations\", \"tag_distributions\"]:\n+            conn.execute(\"DROP TABLE IF EXISTS {}\".format(table))\n+        for table in [\"keys\", \"tags\"]:\n+            conn.execute(\"DELETE FROM {} WHERE count_all < {}\".format(table, min_count))\n+            # Remove \"known good\" keys that inflate the database, or keys that\n+            # are from imports and are largely unique. Also, some keys that can\n+            # be validated from the surrounding relations are dropped.\n+            for key in [\"name\", \"addr:housenumber\", \"addr:city\", \"addr:place\", \"addr:suburb\", \"tiger:zip_left\", \"tiger:name_base\", \"tiger:zip_right\", \"tiger:county\", \"tiger:upload_uuid\"]:\n+                conn.execute(\"DELETE FROM {} WHERE key = '{}'\".format(table, key))\n+        conn.commit()\n+        conn.execute(\"VACUUM\")\n+\n+def convert_to_parquet(database: str, save_directory: str=\"parquet\"):\n+    \"\"\"\n+    Convert an sqlite db to parquet files\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        path = os.path.join(save_directory, \"taginfo\")\n+        if not os.path.exists(path):\n+            os.makedirs(path)\n+        for table in conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall():\n+            t = table[0]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyNDkxNw=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTYyMDE4OnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoyODoxNFrOJ98BQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjoyODoxNFrOJ98BQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyNjI3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for data in tqdm(iter(lambda: compressed.read(100 * block_size), b\"\")):\n          \n          \n            \n                        for data in tqdm(iter(lambda: compressed.read(100 * block_size), b\"\"), desc=\"Writing tags\"):", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668926274", "createdAt": "2021-07-13T16:28:14Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n+        with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:\n+            for content in response.iter_content(chunk_size=block_size):\n+                fh.write(content)\n+                progress.update(len(content))\n+        progress.close()\n+\n+\n+def cleanup(database :str, min_count: int=100):\n+    \"\"\"\n+    Remove unnecessary data\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        for table in [\"key_characters\", \"key_combinations\", \"key_distributions\", \"prevalent_roles\", \"prevalent_values\", \"relation_roles\", \"relation_types\", \"similar_keys\", \"similar_keys_common_rare\", \"tag_combinations\", \"tag_distributions\"]:\n+            conn.execute(\"DROP TABLE IF EXISTS {}\".format(table))\n+        for table in [\"keys\", \"tags\"]:\n+            conn.execute(\"DELETE FROM {} WHERE count_all < {}\".format(table, min_count))\n+            # Remove \"known good\" keys that inflate the database, or keys that\n+            # are from imports and are largely unique. Also, some keys that can\n+            # be validated from the surrounding relations are dropped.\n+            for key in [\"name\", \"addr:housenumber\", \"addr:city\", \"addr:place\", \"addr:suburb\", \"tiger:zip_left\", \"tiger:name_base\", \"tiger:zip_right\", \"tiger:county\", \"tiger:upload_uuid\"]:\n+                conn.execute(\"DELETE FROM {} WHERE key = '{}'\".format(table, key))\n+        conn.commit()\n+        conn.execute(\"VACUUM\")\n+\n+def convert_to_parquet(database: str, save_directory: str=\"parquet\"):\n+    \"\"\"\n+    Convert an sqlite db to parquet files\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        path = os.path.join(save_directory, \"taginfo\")\n+        if not os.path.exists(path):\n+            os.makedirs(path)\n+        for table in conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall():\n+            t = table[0]\n+            data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+            filename = os.path.join(path, t)\n+            if (os.path.isfile(filename)):\n+                os.remove(filename)\n+            data_frame.to_parquet(filename)\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\n+        \"-d\", \"--directory\", help=\"The directory to save the file to\"\n+    )\n+    parser.add_argument(\"-u\", \"--url\", help=\"The url for the TagInfo database\")\n+    parser.add_argument(\"--minimum_count\", help=\"The minimum count to keep for tags\", default=100)\n+    args = parser.parse_args()\n+    db = \"taginfo-db.db\"\n+    url = (\n+        args.url\n+        if args.url\n+        else \"https://taginfo.openstreetmap.org/download/taginfo-db.db.bz2\"\n+    )\n+    directory = args.directory if args.directory else \"./\"\n+    if not os.path.isfile(os.path.join(directory, db + \".bz2\")):\n+        download_file(url, directory)\n+    if not os.path.isfile(os.path.join(directory, db)):\n+        block_size = 4096\n+        with open(\n+            os.path.join(directory, db), \"wb\"\n+        ) as taginfo_db, bz2.BZ2File(\n+            os.path.join(directory, db + \".bz2\"), \"rb\"\n+        ) as compressed:\n+            for data in tqdm(iter(lambda: compressed.read(100 * block_size), b\"\")):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTYzNTU0OnYy", "diffSide": "RIGHT", "path": "scripts/wikidata/get_wikidata.py", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjozMToyN1rOJ98KuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMjoyNjoyMlrOJ-9QoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyODY5Nw==", "bodyText": "What are all these?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668928697", "createdAt": "2021-07-13T16:31:27Z", "author": {"login": "Bentleysb"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTg3MDE1MA==", "bodyText": "@tsmock", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669870150", "createdAt": "2021-07-14T18:52:15Z", "author": {"login": "Bentleysb"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyODY5Nw=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTkxMjM4Mg==", "bodyText": "These are doctests ( https://docs.python.org/3/library/doctest.html ).", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669912382", "createdAt": "2021-07-14T19:58:45Z", "author": {"login": "tsmock"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyODY5Nw=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5NTE2OQ==", "bodyText": "Interesting, I had not encountered that before. Cool!", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669995169", "createdAt": "2021-07-14T22:26:22Z", "author": {"login": "Bentleysb"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyODY5Nw=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTY0MDExOnYy", "diffSide": "RIGHT", "path": "scripts/wikidata/get_wikidata.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjozMjozMlrOJ98NxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxODo1MjoxOVrOJ-1ocg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyOTQ3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for i in claim:\n          \n          \n            \n                for claim_item in claim:", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668929476", "createdAt": "2021-07-13T16:32:32Z", "author": {"login": "Bentleysb"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P16\",\"hash\":\"9eb4b6015212b132f8ed28074659f06b58cad1d2\",\"datavalue\":{\"value\":\"ref:EU:ENTSOE_EIC\",\"type\":\"string\"},\"datatype\":\"string\"},\"type\":\"statement\",\"id\":\"Q4108$31C4E97A-C439-4ECB-803C-AA73B02C9EC9\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'ref:EU:ENTSOE_EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P33\",\"hash\":\"787ef76c487fb28eedcc10c388fb4245e2b92e0f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$8B848D75-5817-40EB-9A48-EF2A2D350C3C\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P34\",\"hash\":\"0020131857e3f842017ae00fb42c27556e40ba4d\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$62AD3599-0926-42E0-8FB8-45E20105BCB4\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P35\",\"hash\":\"8d54b8f7391e3f783fe3d76d15d9036b90305842\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$0F868DF0-E602-4545-AAF4-6A6A7749FC51\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P36\",\"hash\":\"724c9a8f85dfb6c9de78ecb25a7504e02b40a8c7\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$364FDFEB-46D4-4FF2-8973-EFC08450CFBB\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P25\",\"hash\":\"2cb6aaaf2e30dcb19fc1ac1a5f671d26516cdc8f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4680,\"id\":\"Q4680\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$27A9F1C7-65E0-4495-B08F-E27530B145B7\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Q4680'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"c93b534c6eef1b3953670dfe6e014675e880d62f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4766,\"id\":\"Q4766\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$470D4B95-6738-4F3E-896A-B8EBE1F56248\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"e03b53a3a83e1e611c7e6e0f86cf0b30bd645c37\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4954,\"id\":\"Q4954\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$177046FD-4E6F-4074-B7C4-0E05F95B7CC8\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"db5bdfb387965b655d9019a16cbe4a49b93e9df9\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4990,\"id\":\"Q4990\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$B0C90B34-1741-4933-9F0E-FBB9D5CC9AE4\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"479e97d7efe88373b437fa5097a7bc2af2def907\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5254,\"id\":\"Q5254\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$18F12696-579F-4688-9939-31837D3ADAA0\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"1f834ec797f2c558120484498b794382fba0ae0c\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5792,\"id\":\"Q5792\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$17789653-0C21-4B38-BCF7-1080F22D2429\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    ['Q4766', 'Q4954', 'Q4990', 'Q5254', 'Q5792']\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P31\",\"hash\":\"7bb636ede2668f353c188e243443eb44b582bf46\",\"datavalue\":{\"value\":{\"text\":\"Key:ref:EU:ENTSOE EIC\",\"language\":\"en\"},\"type\":\"monolingualtext\"},\"datatype\":\"monolingualtext\"},\"type\":\"statement\",\"id\":\"Q4108$96D9A775-073F-49A4-83F1-82AB3E3217B7\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Key:ref:EU:ENTSOE EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P13\",\"hash\":\"1352cfc4840bb96337bfc822ceb0255686e3e9e7\",\"datavalue\":{\"value\":\"[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*\",\"type\":\"string\"},\"datatype\":\"external-id\"},\"type\":\"statement\",\"id\":\"Q4108$a03623d5-4420-9b6c-9787-69a8bbb2c605\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    '[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*'\n+\n+    \"\"\"\n+    rrlist = []\n+    for i in claim:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTg3MDE5NA==", "bodyText": "@tsmock", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669870194", "createdAt": "2021-07-14T18:52:19Z", "author": {"login": "Bentleysb"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P16\",\"hash\":\"9eb4b6015212b132f8ed28074659f06b58cad1d2\",\"datavalue\":{\"value\":\"ref:EU:ENTSOE_EIC\",\"type\":\"string\"},\"datatype\":\"string\"},\"type\":\"statement\",\"id\":\"Q4108$31C4E97A-C439-4ECB-803C-AA73B02C9EC9\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'ref:EU:ENTSOE_EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P33\",\"hash\":\"787ef76c487fb28eedcc10c388fb4245e2b92e0f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$8B848D75-5817-40EB-9A48-EF2A2D350C3C\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P34\",\"hash\":\"0020131857e3f842017ae00fb42c27556e40ba4d\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$62AD3599-0926-42E0-8FB8-45E20105BCB4\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P35\",\"hash\":\"8d54b8f7391e3f783fe3d76d15d9036b90305842\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$0F868DF0-E602-4545-AAF4-6A6A7749FC51\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P36\",\"hash\":\"724c9a8f85dfb6c9de78ecb25a7504e02b40a8c7\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$364FDFEB-46D4-4FF2-8973-EFC08450CFBB\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P25\",\"hash\":\"2cb6aaaf2e30dcb19fc1ac1a5f671d26516cdc8f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4680,\"id\":\"Q4680\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$27A9F1C7-65E0-4495-B08F-E27530B145B7\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Q4680'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"c93b534c6eef1b3953670dfe6e014675e880d62f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4766,\"id\":\"Q4766\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$470D4B95-6738-4F3E-896A-B8EBE1F56248\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"e03b53a3a83e1e611c7e6e0f86cf0b30bd645c37\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4954,\"id\":\"Q4954\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$177046FD-4E6F-4074-B7C4-0E05F95B7CC8\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"db5bdfb387965b655d9019a16cbe4a49b93e9df9\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4990,\"id\":\"Q4990\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$B0C90B34-1741-4933-9F0E-FBB9D5CC9AE4\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"479e97d7efe88373b437fa5097a7bc2af2def907\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5254,\"id\":\"Q5254\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$18F12696-579F-4688-9939-31837D3ADAA0\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"1f834ec797f2c558120484498b794382fba0ae0c\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5792,\"id\":\"Q5792\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$17789653-0C21-4B38-BCF7-1080F22D2429\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    ['Q4766', 'Q4954', 'Q4990', 'Q5254', 'Q5792']\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P31\",\"hash\":\"7bb636ede2668f353c188e243443eb44b582bf46\",\"datavalue\":{\"value\":{\"text\":\"Key:ref:EU:ENTSOE EIC\",\"language\":\"en\"},\"type\":\"monolingualtext\"},\"datatype\":\"monolingualtext\"},\"type\":\"statement\",\"id\":\"Q4108$96D9A775-073F-49A4-83F1-82AB3E3217B7\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Key:ref:EU:ENTSOE EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P13\",\"hash\":\"1352cfc4840bb96337bfc822ceb0255686e3e9e7\",\"datavalue\":{\"value\":\"[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*\",\"type\":\"string\"},\"datatype\":\"external-id\"},\"type\":\"statement\",\"id\":\"Q4108$a03623d5-4420-9b6c-9787-69a8bbb2c605\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    '[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*'\n+\n+    \"\"\"\n+    rrlist = []\n+    for i in claim:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkyOTQ3Ng=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 335}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTY0Njg4OnYy", "diffSide": "RIGHT", "path": "scripts/wikidata/get_wikidata.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjozMzo1NlrOJ98R8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNTo0ODoxNlrOJ-ts8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkzMDU0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                progress = tqdm()\n          \n          \n            \n                progress = tqdm(desc=\"Downloading wiki data entries\")", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668930544", "createdAt": "2021-07-13T16:33:56Z", "author": {"login": "Bentleysb"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P16\",\"hash\":\"9eb4b6015212b132f8ed28074659f06b58cad1d2\",\"datavalue\":{\"value\":\"ref:EU:ENTSOE_EIC\",\"type\":\"string\"},\"datatype\":\"string\"},\"type\":\"statement\",\"id\":\"Q4108$31C4E97A-C439-4ECB-803C-AA73B02C9EC9\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'ref:EU:ENTSOE_EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P33\",\"hash\":\"787ef76c487fb28eedcc10c388fb4245e2b92e0f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$8B848D75-5817-40EB-9A48-EF2A2D350C3C\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P34\",\"hash\":\"0020131857e3f842017ae00fb42c27556e40ba4d\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$62AD3599-0926-42E0-8FB8-45E20105BCB4\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P35\",\"hash\":\"8d54b8f7391e3f783fe3d76d15d9036b90305842\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$0F868DF0-E602-4545-AAF4-6A6A7749FC51\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P36\",\"hash\":\"724c9a8f85dfb6c9de78ecb25a7504e02b40a8c7\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$364FDFEB-46D4-4FF2-8973-EFC08450CFBB\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P25\",\"hash\":\"2cb6aaaf2e30dcb19fc1ac1a5f671d26516cdc8f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4680,\"id\":\"Q4680\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$27A9F1C7-65E0-4495-B08F-E27530B145B7\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Q4680'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"c93b534c6eef1b3953670dfe6e014675e880d62f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4766,\"id\":\"Q4766\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$470D4B95-6738-4F3E-896A-B8EBE1F56248\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"e03b53a3a83e1e611c7e6e0f86cf0b30bd645c37\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4954,\"id\":\"Q4954\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$177046FD-4E6F-4074-B7C4-0E05F95B7CC8\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"db5bdfb387965b655d9019a16cbe4a49b93e9df9\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4990,\"id\":\"Q4990\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$B0C90B34-1741-4933-9F0E-FBB9D5CC9AE4\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"479e97d7efe88373b437fa5097a7bc2af2def907\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5254,\"id\":\"Q5254\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$18F12696-579F-4688-9939-31837D3ADAA0\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"1f834ec797f2c558120484498b794382fba0ae0c\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5792,\"id\":\"Q5792\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$17789653-0C21-4B38-BCF7-1080F22D2429\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    ['Q4766', 'Q4954', 'Q4990', 'Q5254', 'Q5792']\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P31\",\"hash\":\"7bb636ede2668f353c188e243443eb44b582bf46\",\"datavalue\":{\"value\":{\"text\":\"Key:ref:EU:ENTSOE EIC\",\"language\":\"en\"},\"type\":\"monolingualtext\"},\"datatype\":\"monolingualtext\"},\"type\":\"statement\",\"id\":\"Q4108$96D9A775-073F-49A4-83F1-82AB3E3217B7\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Key:ref:EU:ENTSOE EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P13\",\"hash\":\"1352cfc4840bb96337bfc822ceb0255686e3e9e7\",\"datavalue\":{\"value\":\"[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*\",\"type\":\"string\"},\"datatype\":\"external-id\"},\"type\":\"statement\",\"id\":\"Q4108$a03623d5-4420-9b6c-9787-69a8bbb2c605\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    '[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*'\n+\n+    \"\"\"\n+    rrlist = []\n+    for i in claim:\n+        if (\n+            \"mainsnak\" in i\n+            and \"snaktype\" in i[\"mainsnak\"]\n+            and i[\"mainsnak\"][\"snaktype\"] == \"value\"\n+            and \"datavalue\" in i[\"mainsnak\"]\n+        ):\n+            data = i[\"mainsnak\"][\"datavalue\"]\n+            item = parse_data_value(data)\n+            if \"qualifiers\" in i:\n+                d = {}\n+                for j in i[\"qualifiers\"]:\n+                    qlist = []\n+                    d[j] = qlist\n+                    for k in i[\"qualifiers\"][j]:\n+                        if \"datavalue\" in k:\n+                            data_value = parse_data_value(k)\n+                            if data_value:\n+                                qlist.append(data_value)\n+                item = {item: d}\n+\n+            if item is not None:\n+                rrlist.append(item)\n+\n+    if len(rrlist) == 0:\n+        return None\n+    return rrlist if len(rrlist) > 1 else rrlist[0]\n+\n+\n+def main():\n+    \"\"\"\n+    Main loop (iterates through Properties and Items until a set number have\n+    failed, then stops)\n+    \"\"\"\n+    special = populate_special()\n+    filecache = FileCache(\".web_cache\", forever=True)\n+    session = CacheControl(requests.Session(), filecache)\n+    session.headers.update({\"User-Agent\": user_agent})\n+    db = DataBase(\"wikidata.db\")\n+    table = \"wiki_data\"\n+    db.add_table(table)\n+    skipped = 0\n+    index = 1\n+    progress = tqdm()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc0MDI3Mw==", "bodyText": "I've gone ahead and added the desc param to the tqdm calls.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669740273", "createdAt": "2021-07-14T15:48:16Z", "author": {"login": "tsmock"}, "path": "scripts/wikidata/get_wikidata.py", "diffHunk": "@@ -0,0 +1,479 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Scrape the OSM Wiki Data base for wiki data items to be used with a fallback\n+tag checker.\n+\"\"\"\n+import argparse\n+import json\n+import logging\n+import re\n+import requests\n+import sqlite3\n+import time\n+import pandas\n+import os\n+\n+from cachecontrol import CacheControl\n+from cachecontrol.caches.file_cache import FileCache\n+from tqdm import tqdm\n+\n+user_agent = (\n+    \"atlas osm wiki db download/0.1 (https://github.com/osmlab/atlas-checks)\"\n+)\n+\n+\n+CHANGED_ENTRIES = \"changed.log\"\n+\"\"\"\n+The logfile to write what has changed for WikiData items since the last run\n+\"\"\"\n+\n+\n+class WikiData:\n+    \"\"\"\n+    A base class for wiki data\n+    \"\"\"\n+\n+    def __init__(self):\n+        # 503/200, see https://www.mediawiki.org/wiki/Manual:Maxlag_parameter\n+        self.maxlag = 1\n+        base_url = \"https://wiki.openstreetmap.org\"\n+        self.baseurl = f\"{base_url}/w/api.php?maxlag={self.maxlag}&format=json\"\n+\n+\n+class Properties(WikiData):\n+    \"\"\"\n+    A class for wiki data property items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=P\" + str(self.id)\n+\n+\n+class Item(WikiData):\n+    \"\"\"\n+    A class for wiki data items\n+    \"\"\"\n+\n+    def __init__(self, item: int):\n+        super().__init__()\n+        self.id = item\n+        self.url = self.baseurl + \"&action=wbgetentities&ids=Q\" + str(self.id)\n+\n+\n+class DataBase:\n+    def __init__(self, database: str):\n+        self.db = database\n+\n+    def add_table(self, table: str):\n+        \"\"\"\n+        Add a table to a database\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"CREATE TABLE IF NOT EXISTS {0} (id STRING PRIMARY KEY)\".format(\n+                    table\n+                )\n+            )\n+            conn.commit()\n+\n+    def add_column_to_table(self, table: str, column: str, column_def: str):\n+        \"\"\"\n+        Add a column to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(\n+                \"ALTER TABLE {0} ADD {1} {2}\".format(table, column, column_def)\n+            )\n+            conn.commit()\n+\n+    def does_primary_key_exist(self, table, id):\n+        \"\"\"\n+        Check if a primary key exists\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            result = conn.execute(\n+                \"SELECT * FROM {0} WHERE id = ?\".format(table), (id,)\n+            ).fetchone()\n+            return result is not None\n+\n+    def does_column_exist(self, table, header):\n+        \"\"\"\n+        Check if a column exists in a table, baseds off of the header\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            results = conn.execute(\n+                \"PRAGMA table_info({0})\".format(table)\n+            ).fetchall()\n+            # tuple(cid, name, type, notnull, default value, primary key)\n+            headers = [r[1] for r in results]\n+            return header in headers\n+\n+    def add_row_to_table(self, table: str, row: dict):\n+        \"\"\"\n+        Add a row to a table\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            match = re.compile(\"P[0-9]+\")\n+            headers = []\n+            values = []\n+            for k in row:\n+                if match.match(k) or \"id\" == k:\n+                    headers.append(k)\n+                    values.append(row[k])\n+            # valuesQ MUST come before headers\n+            valuesQ = \", \".join([\"?\" for k in headers])\n+            headers = \", \".join(headers)\n+            values = [self.convert(i) for i in values]\n+            rtuple = tuple(values)\n+            current = conn.execute(\n+                f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+            ).fetchone()\n+            if current:\n+                conn.execute(f\"DELETE FROM {table} WHERE id=?\", (row[\"id\"],))\n+            try:\n+                conn.execute(\n+                    \"INSERT INTO {0} ({1}) VALUES ({2})\".format(\n+                        table, headers, valuesQ\n+                    ),\n+                    rtuple,\n+                )\n+            except sqlite3.IntegrityError as exception:\n+                logging.error(f\"INSERT INTO {table} ({headers}) VALUES ({rtuple})\")\n+                raise exception\n+            if current:\n+                cursor = conn.execute(\n+                    f\"SELECT * FROM {table} WHERE id=?\", (row[\"id\"],)\n+                )\n+                names = [desc[0] for desc in cursor.description]\n+                new = cursor.fetchone()\n+                logging.info(new)\n+                entries = len(new)\n+                entry = 0\n+                while entry < entries:\n+                    if new[entry] != current[entry]:\n+                        message = \" \".join(\n+                            [\n+                                row[\"id\"],\n+                                \"changed\",\n+                                str(names[entry]),\n+                                str(current[entry]),\n+                                \"to\",\n+                                str(new[entry]),\n+                                os.linesep,\n+                            ]\n+                        )\n+                        logging.error(message)\n+                        with open(CHANGED_ENTRIES, \"a\") as log:\n+                            log.write(message)\n+                    entry = entry + 1\n+            conn.commit()\n+\n+    def create_index(self, table: str, column: str, unique: bool = False):\n+        \"\"\"\n+        Create an index to speed queries up\n+        \"\"\"\n+        statement = \"CREATE \"\n+        if unique:\n+            statement += \"UNIQUE \"\n+        statement += \"INDEX IF NOT EXISTS {0}_{1}_idx ON {0} ({1})\"\n+        with sqlite3.connect(self.db) as conn:\n+            conn.execute(statement.format(table, column))\n+\n+    def convert_to_parquet(self, save_directory: str = \"parquet\"):\n+        \"\"\"\n+        Convert an sqlite db to parquet files\n+        \"\"\"\n+        with sqlite3.connect(self.db) as conn:\n+            path = os.path.join(save_directory, self.db.rstrip(\".db\"))\n+            if not os.path.exists(path):\n+                os.makedirs(path)\n+            for table in conn.execute(\n+                \"SELECT name FROM sqlite_master WHERE type='table'\"\n+            ).fetchall():\n+                t = table[0]\n+                data_frame = pandas.read_sql(f\"SELECT * FROM {t}\", conn)\n+                filename = os.path.join(path, t)\n+                if os.path.isfile(filename):\n+                    os.remove(filename)\n+                data_frame.to_parquet(filename)\n+\n+    @staticmethod\n+    def convert(obj):\n+        \"\"\"\n+        Convert an object to a standard instance (e.g., number or string)\n+        \"\"\"\n+        if isinstance(obj, dict) or isinstance(obj, list):\n+            return json.dumps(obj)\n+        if isinstance(obj, int) or isinstance(obj, float):\n+            return obj\n+        if isinstance(obj, str):\n+            return obj\n+        return str(obj)\n+\n+\n+def get_wiki_response(\n+    url: str, session: requests.sessions.Session = requests.Session()\n+) -> requests.Response:\n+    \"\"\"\n+    Get a wiki response for a URL in a (relatively) safe manner (for bots)\n+    \"\"\"\n+    try:\n+        response = session.get(url)\n+        while (\n+            response.status_code == 503 or response.status_code == 200\n+        ) and \"Retry-After\" in response.headers:\n+            timeout = response.headers[\"Retry-After\"]\n+            logging.info(f\"Sleeping for {timeout}\")\n+            time.sleep(response.headers[\"Retry-After\"])\n+            response = session.get(url)\n+        time.sleep(1)\n+        response.raise_for_status()\n+        return response\n+    except requests.ConnectionError as e:\n+        logging.exception(e)\n+        if e.response:\n+            logging.error(e.response.text())\n+        time.sleep(10)\n+        return get_wiki_response(url, session=session)\n+\n+\n+def populate_special():\n+    special = {}\n+    special[\"Q2\"] = \"tag\"\n+    special[\"Q7\"] = \"key\"\n+    special[\"Q9\"] = \"element\"\n+    special[\"Q10\"] = \"OSM concept\"\n+    special[\"Q11\"] = \"status\"\n+    special[\"Q12\"] = \"group\"\n+    special[\"Q13\"] = \"de facto\"\n+    special[\"Q14\"] = \"in use\"\n+    special[\"Q15\"] = \"approved\"\n+    special[\"Q16\"] = \"rejected\"\n+    special[\"Q17\"] = \"voting\"\n+    special[\"Q18\"] = \"draft\"\n+    special[\"Q19\"] = \"abandoned\"\n+    special[\"Q20\"] = \"proposed\"\n+    special[\"Q2761\"] = \"sandbox\"\n+    special[\"Q5060\"] = \"obsolete\"\n+    special[\"Q5061\"] = \"deprecated\"\n+    special[\"Q7550\"] = \"discardable\"\n+    special[\"Q21146\"] = \"imported\"\n+    special[\"Q8001\"] = \"is prohibited\"\n+    special[\"Q8000\"] = \"is allowed\"\n+\n+    return special\n+\n+\n+def parse_data_value(datavalue, special: dict = populate_special()):\n+    if \"mainsnak\" in datavalue:\n+        return parse_data_value(datavalue[\"mainsnak\"], special=special)\n+    if \"datavalue\" in datavalue:\n+        return parse_data_value(datavalue[\"datavalue\"])\n+    if \"type\" in datavalue:\n+        datatype = datavalue[\"type\"]\n+        if datatype == \"wikibase-entityid\":\n+            tid = datavalue[\"value\"][\"id\"]\n+            if tid in special:\n+                return special[tid]\n+            else:\n+                return tid\n+        if datatype == \"string\":\n+            return str(datavalue[\"value\"])\n+        if datatype == \"monolingualtext\":\n+            return str(datavalue[\"value\"][\"text\"])\n+    logging.error(f\"Unsupported data value: {datavalue}\")\n+\n+\n+def parse_claim(claim: list, special: dict = populate_special()):\n+    \"\"\"\n+    Parse a claim from a WikiData dict\n+    >>> import json\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P2\",\"hash\":\"9c1b9f9b61faedefa272a9c8c980faba6cefe7d5\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":7,\"id\":\"Q7\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$D0688651-E4D8-41AF-B1C8-69C4FD0A9654\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'key'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P16\",\"hash\":\"9eb4b6015212b132f8ed28074659f06b58cad1d2\",\"datavalue\":{\"value\":\"ref:EU:ENTSOE_EIC\",\"type\":\"string\"},\"datatype\":\"string\"},\"type\":\"statement\",\"id\":\"Q4108$31C4E97A-C439-4ECB-803C-AA73B02C9EC9\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'ref:EU:ENTSOE_EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P33\",\"hash\":\"787ef76c487fb28eedcc10c388fb4245e2b92e0f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$8B848D75-5817-40EB-9A48-EF2A2D350C3C\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P34\",\"hash\":\"0020131857e3f842017ae00fb42c27556e40ba4d\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$62AD3599-0926-42E0-8FB8-45E20105BCB4\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P35\",\"hash\":\"8d54b8f7391e3f783fe3d76d15d9036b90305842\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$0F868DF0-E602-4545-AAF4-6A6A7749FC51\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P36\",\"hash\":\"724c9a8f85dfb6c9de78ecb25a7504e02b40a8c7\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":8000,\"id\":\"Q8000\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$364FDFEB-46D4-4FF2-8973-EFC08450CFBB\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'is allowed'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P25\",\"hash\":\"2cb6aaaf2e30dcb19fc1ac1a5f671d26516cdc8f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4680,\"id\":\"Q4680\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$27A9F1C7-65E0-4495-B08F-E27530B145B7\",\"rank\":\"preferred\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Q4680'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"c93b534c6eef1b3953670dfe6e014675e880d62f\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4766,\"id\":\"Q4766\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$470D4B95-6738-4F3E-896A-B8EBE1F56248\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"e03b53a3a83e1e611c7e6e0f86cf0b30bd645c37\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4954,\"id\":\"Q4954\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$177046FD-4E6F-4074-B7C4-0E05F95B7CC8\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"db5bdfb387965b655d9019a16cbe4a49b93e9df9\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":4990,\"id\":\"Q4990\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$B0C90B34-1741-4933-9F0E-FBB9D5CC9AE4\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"479e97d7efe88373b437fa5097a7bc2af2def907\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5254,\"id\":\"Q5254\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$18F12696-579F-4688-9939-31837D3ADAA0\",\"rank\":\"normal\"},{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P46\",\"hash\":\"1f834ec797f2c558120484498b794382fba0ae0c\",\"datavalue\":{\"value\":{\"entity-type\":\"item\",\"numeric-id\":5792,\"id\":\"Q5792\"},\"type\":\"wikibase-entityid\"},\"datatype\":\"wikibase-item\"},\"type\":\"statement\",\"id\":\"Q4108$17789653-0C21-4B38-BCF7-1080F22D2429\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    ['Q4766', 'Q4954', 'Q4990', 'Q5254', 'Q5792']\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P31\",\"hash\":\"7bb636ede2668f353c188e243443eb44b582bf46\",\"datavalue\":{\"value\":{\"text\":\"Key:ref:EU:ENTSOE EIC\",\"language\":\"en\"},\"type\":\"monolingualtext\"},\"datatype\":\"monolingualtext\"},\"type\":\"statement\",\"id\":\"Q4108$96D9A775-073F-49A4-83F1-82AB3E3217B7\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    'Key:ref:EU:ENTSOE EIC'\n+\n+    >>> json_data = json.loads('[{\"mainsnak\":{\"snaktype\":\"value\",\"property\":\"P13\",\"hash\":\"1352cfc4840bb96337bfc822ceb0255686e3e9e7\",\"datavalue\":{\"value\":\"[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*\",\"type\":\"string\"},\"datatype\":\"external-id\"},\"type\":\"statement\",\"id\":\"Q4108$a03623d5-4420-9b6c-9787-69a8bbb2c605\",\"rank\":\"normal\"}]')  # noqa: E501\n+    >>> parse_claim(json_data)\n+    '[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z](;[1-6][0-9][ATVWXYZ][0-9A-Z-]{12}[0-9A-Z])*'\n+\n+    \"\"\"\n+    rrlist = []\n+    for i in claim:\n+        if (\n+            \"mainsnak\" in i\n+            and \"snaktype\" in i[\"mainsnak\"]\n+            and i[\"mainsnak\"][\"snaktype\"] == \"value\"\n+            and \"datavalue\" in i[\"mainsnak\"]\n+        ):\n+            data = i[\"mainsnak\"][\"datavalue\"]\n+            item = parse_data_value(data)\n+            if \"qualifiers\" in i:\n+                d = {}\n+                for j in i[\"qualifiers\"]:\n+                    qlist = []\n+                    d[j] = qlist\n+                    for k in i[\"qualifiers\"][j]:\n+                        if \"datavalue\" in k:\n+                            data_value = parse_data_value(k)\n+                            if data_value:\n+                                qlist.append(data_value)\n+                item = {item: d}\n+\n+            if item is not None:\n+                rrlist.append(item)\n+\n+    if len(rrlist) == 0:\n+        return None\n+    return rrlist if len(rrlist) > 1 else rrlist[0]\n+\n+\n+def main():\n+    \"\"\"\n+    Main loop (iterates through Properties and Items until a set number have\n+    failed, then stops)\n+    \"\"\"\n+    special = populate_special()\n+    filecache = FileCache(\".web_cache\", forever=True)\n+    session = CacheControl(requests.Session(), filecache)\n+    session.headers.update({\"User-Agent\": user_agent})\n+    db = DataBase(\"wikidata.db\")\n+    table = \"wiki_data\"\n+    db.add_table(table)\n+    skipped = 0\n+    index = 1\n+    progress = tqdm()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODkzMDU0NA=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 378}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MTc3NDY0OnYy", "diffSide": "RIGHT", "path": "scripts/taginfo/downloadTagInfo.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjo1ODoyNVrOJ99d9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QxNjo1ODoyNVrOJ99d9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODk1MDAwNw==", "bodyText": "It would be nice if this tag list was configurable.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r668950007", "createdAt": "2021-07-13T16:58:25Z", "author": {"login": "Bentleysb"}, "path": "scripts/taginfo/downloadTagInfo.py", "diffHunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3\n+import os\n+import requests\n+import argparse\n+import bz2\n+import sqlite3\n+from tqdm import tqdm\n+import pandas\n+\n+\n+def download_file(name: str, directory: str):\n+    with requests.get(name, stream=True) as response:\n+        response.raise_for_status()\n+        size = int(response.headers.get(\"content-length\", 0))\n+        block_size = 4096\n+        progress = tqdm(total=size, unit=\"iB\", unit_scale=True)\n+        with open(os.path.join(directory, os.path.basename(name)), \"wb\") as fh:\n+            for content in response.iter_content(chunk_size=block_size):\n+                fh.write(content)\n+                progress.update(len(content))\n+        progress.close()\n+\n+\n+def cleanup(database :str, min_count: int=100):\n+    \"\"\"\n+    Remove unnecessary data\n+    \"\"\"\n+    with sqlite3.connect(database) as conn:\n+        for table in [\"key_characters\", \"key_combinations\", \"key_distributions\", \"prevalent_roles\", \"prevalent_values\", \"relation_roles\", \"relation_types\", \"similar_keys\", \"similar_keys_common_rare\", \"tag_combinations\", \"tag_distributions\"]:\n+            conn.execute(\"DROP TABLE IF EXISTS {}\".format(table))\n+        for table in [\"keys\", \"tags\"]:\n+            conn.execute(\"DELETE FROM {} WHERE count_all < {}\".format(table, min_count))\n+            # Remove \"known good\" keys that inflate the database, or keys that\n+            # are from imports and are largely unique. Also, some keys that can\n+            # be validated from the surrounding relations are dropped.\n+            for key in [\"name\", \"addr:housenumber\", \"addr:city\", \"addr:place\", \"addr:suburb\", \"tiger:zip_left\", \"tiger:name_base\", \"tiger:zip_right\", \"tiger:county\", \"tiger:upload_uuid\"]:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MjYyNzQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/KeyFullyCheckedUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QyMDoyNToxNFrOJ-Frsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QyMDoyNToxNFrOJ-Frsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA4NDU5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    catch (final IOException e)\n          \n          \n            \n                    catch (final IOException exception)", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669084594", "createdAt": "2021-07-13T20:25:14Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/KeyFullyCheckedUtils.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import org.apache.commons.lang3.reflect.FieldUtils;\n+import org.openstreetmap.atlas.checks.validation.tag.GenericTagCheck;\n+import org.openstreetmap.atlas.checks.validation.tag.InvalidTagsCheck;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.reflect.ClassPath;\n+import com.google.common.reflect.ClassPath.ClassInfo;\n+\n+/**\n+ * Utils to find fully checked keys (only use this for generic tests, such as\n+ * {@link GenericTagCheck}).\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class KeyFullyCheckedUtils\n+{\n+    private static final Logger logger = LoggerFactory.getLogger(KeyFullyCheckedUtils.class);\n+\n+    /**\n+     * Populate ignore tags using reflection and looking for annotations using\n+     * {@link KeyFullyChecked} in the current package.\n+     *\n+     * @return A collection of predicates to use to determine if a tag should be ignored.\n+     */\n+    public static Collection<Predicate<Taggable>> populateIgnoreTags()\n+    {\n+        final List<TaggableFilter> filters = new ArrayList<>();\n+        final List<Predicate<Taggable>> predicateFilters = new ArrayList<>();\n+        final var classLoader = InvalidTagsCheck.class.getClassLoader();\n+        Set<ClassInfo> classInfoList;\n+        try\n+        {\n+            classInfoList = ClassPath.from(classLoader)\n+                    .getTopLevelClassesRecursive(InvalidTagsCheck.class.getPackageName());\n+        }\n+        catch (final IOException e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MjY3NDA0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QyMDozNjoyNlrOJ-GHpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNzoyODozM1rOJ-yN0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5MTc0OA==", "bodyText": "I'm guessing this was to test something?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669091748", "createdAt": "2021-07-13T20:36:26Z", "author": {"login": "Bentleysb"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java", "diffHunk": "@@ -73,6 +73,11 @@ private boolean runTest(final Atlas atlas, final Configuration config,\n \n         bigNodes.forEach(bigNode ->\n         {\n+            if (bigNode.nodes().stream().mapToLong(node -> node.getOsmIdentifier())\n+                    .anyMatch(number -> number == 812034701L))\n+            {\n+                logger.info(\"found something\");\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTgxNDIyNQ==", "bodyText": "Yes. I think I was having issues with a test failing somewhere when I was updating to newer atlas/atlas-generator versions.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669814225", "createdAt": "2021-07-14T17:28:33Z", "author": {"login": "tsmock"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/BigNodeBadDataCheckTest.java", "diffHunk": "@@ -73,6 +73,11 @@ private boolean runTest(final Atlas atlas, final Configuration config,\n \n         bigNodes.forEach(bigNode ->\n         {\n+            if (bigNode.nodes().stream().mapToLong(node -> node.getOsmIdentifier())\n+                    .anyMatch(number -> number == 812034701L))\n+            {\n+                logger.info(\"found something\");\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5MTc0OA=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1MjcwMzIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QyMDo0Mjo1N1rOJ-GYhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xM1QyMDo0Mjo1N1rOJ-GYhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTA5NjA3MA==", "bodyText": "The main edge does not encompass all edges with the same ID. It is just the main direction of a way setioned edge.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                ? this.createFlag(((Edge) object).getMainEdge(), instruction)\n          \n          \n            \n                               ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669096070", "createdAt": "2021-07-13T20:42:57Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,940 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(((Edge) object).getMainEdge(), instruction)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1Njk0ODI3OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNTo1NTo1MFrOJ-uFhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNzo0MjoyNlrOJ-yzLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc0NjU2NQ==", "bodyText": "Where is this being used? Wouldn't it cause a conflict with \n  \n    \n      atlas-checks/config/configuration.json\n    \n    \n         Line 1373\n      in\n      fe33333\n    \n    \n    \n    \n\n        \n          \n           \"elevation.path\": \"elevation\" \n        \n    \n  \n\n ?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669746565", "createdAt": "2021-07-14T15:55:50Z", "author": {"login": "sayas01"}, "path": "config/configuration.json", "diffHunk": "@@ -1336,6 +1354,9 @@\n       \"defaultPriority\": \"LOW\"\n     }\n   },\n+  \"ElevationUtilities\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTgyMzc4OQ==", "bodyText": "Yep. I probably missed it. Even though it is only 10 lines or so down.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669823789", "createdAt": "2021-07-14T17:42:26Z", "author": {"login": "tsmock"}, "path": "config/configuration.json", "diffHunk": "@@ -1336,6 +1354,9 @@\n       \"defaultPriority\": \"LOW\"\n     }\n   },\n+  \"ElevationUtilities\": {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc0NjU2NQ=="}, "originalCommit": {"oid": "fe33333d169d44c3bb679decd0c7f055d3ed27dd"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1Njk4MzM3OnYy", "diffSide": "RIGHT", "path": "docs/checks/genericTagCheck.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjowMjo0NlrOJ-ubOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjowMjo0NlrOJ-ubOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc1MjEyMQ==", "bodyText": "Thanks for adding a well written doc for the check!", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669752121", "createdAt": "2021-07-14T16:02:46Z", "author": {"login": "sayas01"}, "path": "docs/checks/genericTagCheck.md", "diffHunk": "@@ -0,0 +1,89 @@\n+# Generic Tag Check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11ef87577a123f32502e55ec8960b6e1ed40af4a"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1NzAxMDEyOnYy", "diffSide": "RIGHT", "path": "docs/checks/invalidTagsCheck.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjowODoxM1rOJ-urtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjozMDo1MFrOJ-vvww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc1NjM0Mg==", "bodyText": "Looks like this part was added by mistake here?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669756342", "createdAt": "2021-07-14T16:08:13Z", "author": {"login": "sayas01"}, "path": "docs/checks/invalidTagsCheck.md", "diffHunk": "@@ -78,16 +78,25 @@ In [Atlas](https://github.com/osmlab/atlas), OSM elements are represented as Edg\n [Relations](https://github.com/osmlab/atlas/blob/dev/src/main/java/org/openstreetmap/atlas/geography/atlas/items/Relation.java).\n \n Due to the general nature of this check, most features are valid for this check.\n-The only validation requirement is that a feature of the same type and OSM ID has not been flagged before. \n-Many other checks only look at the OSM ID when checking if a feature is flagged. Because this check deals \n+The only validation requirement is that a feature of the same type and OSM ID has not been flagged before.\n+Many other checks only look at the OSM ID when checking if a feature is flagged. Because this check deals\n with multiple types of features, and ids are not unique across types, this check has to check the type and id.\n \n Once a feature has passed validation it is checked against the filters that are set in the constructor of the check, based on the config values mentioned in the check description.\n For each filter the feature is checked that it is of a type given in the first part of the filter\n-and passes the filter. If both these things are true then the feature is flagged. \n+and passes the filter. If both these things are true then the feature is flagged.\n \n-For each filter a feature passes an instruction is added to the flag. The tag keys from the TaggableFilter and the \n-RegexTaggableFilter are pulled out and added to the instruction to give guidance on where the problem is. \n+For each filter a feature passes an instruction is added to the flag. The tag keys from the TaggableFilter and the\n+RegexTaggableFilter are pulled out and added to the instruction to give guidance on where the problem is.\n \n-To learn more about the code, please look at the comments in the source code for the check:  \n+The `fallback` check first checks to see if the tag has been fully checked by another check, then it checks to see if the tag is in OpenStreetMap Wiki Data (must be downloaded separately, see [get_wikidata.py](../../scripts/get_wikidata.py)).\n+If the tag does _not_ exist in OSM WikiData AND the key does exist and specifies that all values are `well-known`, an instruction is generated.\n+If the tag does _not_ exist in OSM WikiData AND the key does exist AND the key specifies a value validation regex AND the value fails the regex, an instruction is generated.\n+If the tag does exist in the OSM WikiData AND the key has been marked as unwanted, an instruction is generated.\n+If the tag does _not_ exist in OSM WikiData AND the key does not exist THEN the TagInfo database is queried. If the uses of the tag is low (less than the `tag.usage.min` variable, or `100` if the variable is unset), an instruction for an editor is generated, otherwise an instruction for a wiki editor is generated.\n+\n+For each filter a feature passes an instruction is added to the flag. The tag keys from the TaggableFilter\n+are pulled out and added to the instruction to give guidance on where the problem is.\n+\n+To learn more about the code, please look at the comments in the source code for the check:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11ef87577a123f32502e55ec8960b6e1ed40af4a"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc3Mzc2Mw==", "bodyText": "It was left by mistake, yes. I was originally putting the code in the InvalidTagsCheck file, and later decided to move it out.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669773763", "createdAt": "2021-07-14T16:30:50Z", "author": {"login": "tsmock"}, "path": "docs/checks/invalidTagsCheck.md", "diffHunk": "@@ -78,16 +78,25 @@ In [Atlas](https://github.com/osmlab/atlas), OSM elements are represented as Edg\n [Relations](https://github.com/osmlab/atlas/blob/dev/src/main/java/org/openstreetmap/atlas/geography/atlas/items/Relation.java).\n \n Due to the general nature of this check, most features are valid for this check.\n-The only validation requirement is that a feature of the same type and OSM ID has not been flagged before. \n-Many other checks only look at the OSM ID when checking if a feature is flagged. Because this check deals \n+The only validation requirement is that a feature of the same type and OSM ID has not been flagged before.\n+Many other checks only look at the OSM ID when checking if a feature is flagged. Because this check deals\n with multiple types of features, and ids are not unique across types, this check has to check the type and id.\n \n Once a feature has passed validation it is checked against the filters that are set in the constructor of the check, based on the config values mentioned in the check description.\n For each filter the feature is checked that it is of a type given in the first part of the filter\n-and passes the filter. If both these things are true then the feature is flagged. \n+and passes the filter. If both these things are true then the feature is flagged.\n \n-For each filter a feature passes an instruction is added to the flag. The tag keys from the TaggableFilter and the \n-RegexTaggableFilter are pulled out and added to the instruction to give guidance on where the problem is. \n+For each filter a feature passes an instruction is added to the flag. The tag keys from the TaggableFilter and the\n+RegexTaggableFilter are pulled out and added to the instruction to give guidance on where the problem is.\n \n-To learn more about the code, please look at the comments in the source code for the check:  \n+The `fallback` check first checks to see if the tag has been fully checked by another check, then it checks to see if the tag is in OpenStreetMap Wiki Data (must be downloaded separately, see [get_wikidata.py](../../scripts/get_wikidata.py)).\n+If the tag does _not_ exist in OSM WikiData AND the key does exist and specifies that all values are `well-known`, an instruction is generated.\n+If the tag does _not_ exist in OSM WikiData AND the key does exist AND the key specifies a value validation regex AND the value fails the regex, an instruction is generated.\n+If the tag does exist in the OSM WikiData AND the key has been marked as unwanted, an instruction is generated.\n+If the tag does _not_ exist in OSM WikiData AND the key does not exist THEN the TagInfo database is queried. If the uses of the tag is low (less than the `tag.usage.min` variable, or `100` if the variable is unset), an instruction for an editor is generated, otherwise an instruction for a wiki editor is generated.\n+\n+For each filter a feature passes an instruction is added to the flag. The tag keys from the TaggableFilter\n+are pulled out and added to the instruction to give guidance on where the problem is.\n+\n+To learn more about the code, please look at the comments in the source code for the check:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc1NjM0Mg=="}, "originalCommit": {"oid": "11ef87577a123f32502e55ec8960b6e1ed40af4a"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1NzAxMjM0OnYy", "diffSide": "RIGHT", "path": "docs/checks/invalidTagsCheck.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjowODo0MFrOJ-utHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjoyOToyNFrOJ-vr0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc1NjcwMA==", "bodyText": "Are these changes to resolve some sonar issues?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669756700", "createdAt": "2021-07-14T16:08:40Z", "author": {"login": "sayas01"}, "path": "docs/checks/invalidTagsCheck.md", "diffHunk": "@@ -1,17 +1,17 @@\n # Invalid Tags Check\n \n This check flags features for invalid tags based on a list of TaggableFilters and RegexTaggableFilters. The list of filters for this check are passed through the config and/or through resource files.\n-The two configurable boolean values, \"filters.resource.append\" and \"filters.resource.override\", \n+The two configurable boolean values, \"filters.resource.append\" and \"filters.resource.override\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11ef87577a123f32502e55ec8960b6e1ed40af4a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc3Mjc1NQ==", "bodyText": "No. My text editor (vim) is set up to autotrim trailing spaces on lines, which doesn't always make sense (specifically, for markdown files).", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669772755", "createdAt": "2021-07-14T16:29:24Z", "author": {"login": "tsmock"}, "path": "docs/checks/invalidTagsCheck.md", "diffHunk": "@@ -1,17 +1,17 @@\n # Invalid Tags Check\n \n This check flags features for invalid tags based on a list of TaggableFilters and RegexTaggableFilters. The list of filters for this check are passed through the config and/or through resource files.\n-The two configurable boolean values, \"filters.resource.append\" and \"filters.resource.override\", \n+The two configurable boolean values, \"filters.resource.append\" and \"filters.resource.override\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc1NjcwMA=="}, "originalCommit": {"oid": "11ef87577a123f32502e55ec8960b6e1ed40af4a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1NzAyMDUyOnYy", "diffSide": "RIGHT", "path": "docs/utilities/elevationUtilities.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjoxMDoxNFrOJ-uyFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNzo1MjoyNVrOJ-zOJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc1Nzk3Mw==", "bodyText": "Are these changes associated with GenericTagCheck addition?", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669757973", "createdAt": "2021-07-14T16:10:14Z", "author": {"login": "sayas01"}, "path": "docs/utilities/elevationUtilities.md", "diffHunk": "@@ -5,12 +5,14 @@ This is a general utilities class that allows checks to get elevation data. The\n \n #### Configuration\n \n+The `elevation.prefix` is used to help filter files on Spark (all extra data files are put in the _same_ directory).\n+\n ```json\n {\n     \"ElevationUtilities\": {\n         \"elevation.srtm_extent\": 1.0 (degree),\n         \"elevation.srtm_ext\": \"hgt\" (file extension),\n-        \"elevation.path\": \"elevation\"\n+        \"elevation.prefix\": \"elevation-\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11ef87577a123f32502e55ec8960b6e1ed40af4a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTgzMDY5Mg==", "bodyText": "No. I think it is a holdover from when I was fiddling with methods for transferring files between spark nodes.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669830692", "createdAt": "2021-07-14T17:52:25Z", "author": {"login": "tsmock"}, "path": "docs/utilities/elevationUtilities.md", "diffHunk": "@@ -5,12 +5,14 @@ This is a general utilities class that allows checks to get elevation data. The\n \n #### Configuration\n \n+The `elevation.prefix` is used to help filter files on Spark (all extra data files are put in the _same_ directory).\n+\n ```json\n {\n     \"ElevationUtilities\": {\n         \"elevation.srtm_extent\": 1.0 (degree),\n         \"elevation.srtm_ext\": \"hgt\" (file extension),\n-        \"elevation.path\": \"elevation\"\n+        \"elevation.prefix\": \"elevation-\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc1Nzk3Mw=="}, "originalCommit": {"oid": "11ef87577a123f32502e55ec8960b6e1ed40af4a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1NzE5OTA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/database/wikidata/WikiDataItem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjo0Nzo1OVrOJ-wgXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjo0Nzo1OVrOJ-wgXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4NjIwNQ==", "bodyText": "nit: please avoid single letter variable", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669786205", "createdAt": "2021-07-14T16:47:59Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/database/wikidata/WikiDataItem.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// License: GPL. For details, see LICENSE file.\n+package org.openstreetmap.atlas.checks.database.wikidata;\n+\n+import java.text.MessageFormat;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * WikiDataItem special entries\n+ *\n+ * @author Taylor Smock\n+ */\n+public enum WikiDataItem implements WikiItemInterface\n+{\n+    // OSM Concepts\n+    ELEMENT_Q9,\n+    KEY_Q7,\n+    TAG_Q2,\n+    /** Status of the key/tag */\n+    STATUS_Q11,\n+    /** Allowed on nodes/ways/relations/areas */\n+    STATUS_Q8010,\n+    // Statuses (STATUS_Q11)\n+    DE_FACTO_Q13(STATUS_Q11),\n+    IN_USE_Q14(STATUS_Q11),\n+    APPROVED_Q15(STATUS_Q11),\n+    REJECTED_Q16(STATUS_Q11),\n+    VOTING_Q17(STATUS_Q11),\n+    DRAFT_Q18(STATUS_Q11),\n+    ABANDONED_Q19(STATUS_Q11),\n+    PROPOSED_Q20(STATUS_Q11),\n+    OBSOLETE_Q5060(STATUS_Q11),\n+    DEPRECATED_Q5061(STATUS_Q11),\n+    DISCARDABLE_Q7550(STATUS_Q11),\n+    IMPORTED_Q21146(STATUS_Q11),\n+    // Statuses (STATUS_Q8010)\n+    IS_ALLOWED_Q8000(STATUS_Q8010),\n+    IS_PROHIBITED_Q8001(STATUS_Q8010),\n+    // Special\n+    WELL_KNOWN_VALUES_Q8,\n+    GROUP_Q12,\n+    OSM_CONCEPT_Q10,\n+    SANDBOX_Q2761;\n+\n+    @Nullable\n+    private final WikiDataItem parent;\n+    @Nonnull\n+    private final String pid;\n+    @Nonnull\n+    private final String rName;\n+\n+    /**\n+     * Get a well-known wiki data item from a value\n+     *\n+     * @param value\n+     *            The value to look for\n+     * @return A WikiDataItem or {@code null}\n+     */\n+    public static WikiDataItem fromValue(final String value)\n+    {\n+        WikiDataItem rItem = Stream.of(WikiDataItem.values())\n+                .filter(p -> p.getId().equalsIgnoreCase(value)).findFirst().orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f9616fed683129eba242736296db4af5c8edbcd"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1NzIxODI3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxNjo1MjowOVrOJ-wsDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMjoyMzoyM1rOJ-9L9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA==", "bodyText": "Looks good, feel like this could be in Atlas project.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669789198", "createdAt": "2021-07-14T16:52:09Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.util.EnumMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.validation.relations.InvalidMultiPolygonRelationCheck;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Convert Atlas ItemTypes into OSM types\n+ *\n+ * @author Taylor Smock, extracted from {@link InvalidMultiPolygonRelationCheck}.\n+ */\n+public final class AtlasToOsmType", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f9616fed683129eba242736296db4af5c8edbcd"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk4NDg2MQ==", "bodyText": "It probably could be. I think I didn't do that since I've got a few projects with various moving parts, and I didn't want to deal with yet another one at the time, and then forgot about it.\nI've had too many PR's that depend upon other PR's that depend upon yet another PR...", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669984861", "createdAt": "2021-07-14T22:02:30Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.util.EnumMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.validation.relations.InvalidMultiPolygonRelationCheck;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Convert Atlas ItemTypes into OSM types\n+ *\n+ * @author Taylor Smock, extracted from {@link InvalidMultiPolygonRelationCheck}.\n+ */\n+public final class AtlasToOsmType", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}, "originalCommit": {"oid": "9f9616fed683129eba242736296db4af5c8edbcd"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5MzM1MQ==", "bodyText": "This can defiantly be something that is done later.", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669993351", "createdAt": "2021-07-14T22:21:51Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.util.EnumMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.validation.relations.InvalidMultiPolygonRelationCheck;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Convert Atlas ItemTypes into OSM types\n+ *\n+ * @author Taylor Smock, extracted from {@link InvalidMultiPolygonRelationCheck}.\n+ */\n+public final class AtlasToOsmType", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}, "originalCommit": {"oid": "9f9616fed683129eba242736296db4af5c8edbcd"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk5Mzk3NQ==", "bodyText": "Yp!!", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669993975", "createdAt": "2021-07-14T22:23:23Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/AtlasToOsmType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.util.EnumMap;\n+\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.validation.relations.InvalidMultiPolygonRelationCheck;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Convert Atlas ItemTypes into OSM types\n+ *\n+ * @author Taylor Smock, extracted from {@link InvalidMultiPolygonRelationCheck}.\n+ */\n+public final class AtlasToOsmType", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTc4OTE5OA=="}, "originalCommit": {"oid": "9f9616fed683129eba242736296db4af5c8edbcd"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1ODQyMTc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0NDo0NFrOJ-8GGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0NDo0NFrOJ-8GGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NjA5MA==", "bodyText": "unused param", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669976090", "createdAt": "2021-07-14T21:44:44Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed"}, "originalPosition": 421}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1ODQyNjI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0NjoxMVrOJ-8I2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0NjoxMVrOJ-8I2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3Njc5NQ==", "bodyText": "@param object", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669976795", "createdAt": "2021-07-14T21:46:11Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed"}, "originalPosition": 507}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1ODQyNzkzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0Njo0NFrOJ-8J6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0Njo0NFrOJ-8J6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzA2Nw==", "bodyText": "unused param", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977067", "createdAt": "2021-07-14T21:46:44Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed"}, "originalPosition": 564}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1ODQyODM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0Njo1N1rOJ-8KQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0Njo1N1rOJ-8KQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzE1NQ==", "bodyText": "unused param", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977155", "createdAt": "2021-07-14T21:46:57Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes\n+     *            The changes to add a change to (removal)\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @param wellKnown\n+     *            If the tag has well-defined values\n+     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n+     */\n+    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n+    {\n+        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n+                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n+        {\n+            instructions.put(\n+                    this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n+                            tag.getKey(), tag.getValue(),\n+                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n+                            checkInfo.getId()),\n+                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for instances where a key is well-known but the value is not one of the well-known\n+     * values.\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed"}, "originalPosition": 598}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI1ODQzMDE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0NzoyOFrOJ-8LVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQyMTo0NzoyOFrOJ-8LVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTk3NzQyOA==", "bodyText": "unused param", "url": "https://github.com/osmlab/atlas-checks/pull/357#discussion_r669977428", "createdAt": "2021-07-14T21:47:28Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/GenericTagCheck.java", "diffHunk": "@@ -0,0 +1,941 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.base.ExternalDataFetcher;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeyTagCommon;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoKeys;\n+import org.openstreetmap.atlas.checks.database.taginfo.TagInfoTags;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiData;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiDataItem;\n+import org.openstreetmap.atlas.checks.database.wikidata.WikiProperty;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.AtlasToOsmType;\n+import org.openstreetmap.atlas.checks.utility.KeyFullyCheckedUtils;\n+import org.openstreetmap.atlas.checks.utility.SQLiteUtils;\n+import org.openstreetmap.atlas.checks.utility.feature_change.IFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.RemoveTagFeatureChange;\n+import org.openstreetmap.atlas.checks.utility.feature_change.ReplaceTagFeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.locale.IsoCountry;\n+import org.openstreetmap.atlas.streaming.resource.Resource;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.Taggable;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.testing.TestTaggable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic tag check using OSM Wiki Data and Tag Info databases.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class GenericTagCheck extends BaseCheck<String>\n+{\n+    private static final long serialVersionUID = 5150282147895785829L;\n+    private static final String DEFAULT_NR_TAGS_INSTRUCTION = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String DEFAULT_INSTRUCTION = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_CONFLICTING_TAGS = \"Check the following tags for missing, conflicting, or incorrect values: {0}\";\n+    private static final String INSTRUCTION_INVALID_TAGS = \"OSM feature {0,number,#} has invalid tags\";\n+    private static final String INSTRUCTION_MISMATCHED_REGEX = \"{0} does not match the regex {1} for the key {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_PROHIBITED_USAGE = \"{0}={1} is prohibited on {2}. To determine whether to remove or change this tag please see this tag's Wiki Data page, https://wiki.osm.org/Item:{3} or the associated documentation Wiki Page on the Wiki Data page).\";\n+    private static final String INSTRUCTION_REPLACE = \"{0} should probably be replaced with {1} (see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_TAGINFO_POPULAR = \"{0} is probably an undocumented {1} ({2} instances). This should be documented on the wiki at https://wiki.osm.org/{3} and in the OpenStreetMap Wiki Data ( https://wiki.osm.org/Data_items ).\";\n+    private static final String INSTRUCTION_TAGINFO_UNPOPULAR = \"{0} is an unpopular key ({1} instances)\";\n+    private static final String INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION = \"{0}={1} should not be used in {2} (see https://wiki.osm.org/Item:{3})\";\n+    private static final String INSTRUCTION_UNDOCUMENTED_POPULAR_TAG = \"{0}={1} is not currently documented. Its global popularity ({2} uses) may merit adding wiki documentation for this value. Please consider adding a new Wiki Data page for {0}={1}.\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_ROLE = \"{0}={1} is an unknown relation role for {0} ({2} {3,number,#} on relation {4,number,#}, see https://wiki.osm.org/Item:{5})\";\n+    private static final String INSTRUCTION_UNKNOWN_RELATION_TYPE = \"type={0} is an unknown relation type (relation {1,number,#}, see https://wiki.osm.org/Item:{2})\";\n+    private static final String INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE = \"{0} is not a well-known value for {1}\";\n+    private static final String INSTRUCTION_WIKI_DATA_REMOVAL = \"{0}={1} should probably be removed (it is {2}, see https://wiki.osm.org/Item:{3})\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Stream.of(DEFAULT_NR_TAGS_INSTRUCTION,\n+            DEFAULT_INSTRUCTION, INSTRUCTION_INVALID_TAGS, INSTRUCTION_CONFLICTING_TAGS,\n+            INSTRUCTION_MISMATCHED_REGEX, INSTRUCTION_UNDOCUMENTED_POPULAR_TAG,\n+            INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE, INSTRUCTION_WIKI_DATA_REMOVAL,\n+            INSTRUCTION_PROHIBITED_USAGE, INSTRUCTION_TAGINFO_UNPOPULAR,\n+            INSTRUCTION_TAGINFO_POPULAR, INSTRUCTION_REPLACE, INSTRUCTION_UNKNOWN_RELATION_ROLE,\n+            INSTRUCTION_UNKNOWN_RELATION_TYPE, INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION)\n+            .collect(Collectors.toCollection(ArrayList::new));\n+    private static final long DEFAULT_MIN_TAG_USAGE = 100;\n+\n+    private static final String DEFAULT_WIKI_TABLE = \"wiki_data\";\n+    private static final String DEFAULT_TAGINFO_TAG_TABLE = \"tags\";\n+    private static final String DEFAULT_TAGINFO_KEY_TABLE = \"keys\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(GenericTagCheck.class);\n+\n+    private final Long minTagUsage;\n+    // Due to serialization, this *cannot* be final\n+    private transient Collection<Predicate<Taggable>> ignoreTags = KeyFullyCheckedUtils\n+            .populateIgnoreTags();\n+\n+    private static final List<String> DEFAULT_TAGS_TO_REMOVE = Arrays.asList(\"abandoned\",\n+            \"discardable\", \"imported\", \"obsolete\", \"rejected\");\n+    private final List<String> tagsToRemove;\n+    private SQLiteUtils sqliteUtilsTagInfoTagTable;\n+    private SQLiteUtils sqliteUtilsTagInfoKeyTable;\n+    private SQLiteUtils sqliteUtilsWikiData;\n+    private static final String DEFAULT_TAGINFO_DB = \"taginfo-db.db\";\n+    private static final String DEFAULT_WIKIDATA_DB = \"wikidata.db\";\n+    private static final int DEFAULT_TAG_PERCENTAGE_KEY = 10;\n+    private final String tagInfoDB;\n+    private final String wikiDataDB;\n+    private final String wikiTable;\n+    private final String tagInfoTagTable;\n+    private final String tagInfoKeyTable;\n+    private final int popularTagPercentageKey;\n+\n+    /**\n+     * Check if an object is an area (i.e., an actual Area object OR a multipolygon)\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object is an area\n+     */\n+    private static boolean isArea(final Taggable object)\n+    {\n+        return object instanceof Area\n+                || (object instanceof Relation && ((Relation) object).isMultiPolygon());\n+    }\n+\n+    /**\n+     * Check if an object may be an area\n+     *\n+     * @param object\n+     *            The object to check\n+     * @return {@code true} if the object <i>may</i> be an area.\n+     */\n+    private static boolean isClosedLine(final Taggable object)\n+    {\n+        return object instanceof LineItem && ((LineItem) object).isClosed();\n+    }\n+\n+    /**\n+     * Convert a tag entry into a string\n+     *\n+     * @param tag\n+     *            The tag to convert\n+     * @return A &ltkey&gt=&ltvalue&gt string\n+     */\n+    private static String tagToString(final Map.Entry<String, String> tag)\n+    {\n+        return Stream.of(tag.getKey(), tag.getValue()).filter(Objects::nonNull)\n+                .filter(string -> !string.isBlank()).collect(Collectors.joining(\"=\"));\n+    }\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     * @param fileFetcher\n+     *            A fetcher to get external data with\n+     */\n+    public GenericTagCheck(final Configuration configuration, final ExternalDataFetcher fileFetcher)\n+    {\n+        super(configuration);\n+        this.minTagUsage = this.configurationValue(configuration, \"tag.usage.min\",\n+                DEFAULT_MIN_TAG_USAGE);\n+\n+        this.tagsToRemove = this.configurationValue(configuration, \"wikidata.tag_removal\",\n+                DEFAULT_TAGS_TO_REMOVE);\n+        this.wikiTable = DEFAULT_WIKI_TABLE;\n+        this.tagInfoTagTable = DEFAULT_TAGINFO_TAG_TABLE;\n+        this.tagInfoKeyTable = DEFAULT_TAGINFO_KEY_TABLE;\n+        this.tagInfoDB = this.configurationValue(configuration, \"db.taginfo\", DEFAULT_TAGINFO_DB);\n+        this.wikiDataDB = this.configurationValue(configuration, \"db.wikidata\",\n+                DEFAULT_WIKIDATA_DB);\n+\n+        // At time of implementation, this.configurationValue(..., ..., Integer) returns\n+        // a Long.\n+        this.popularTagPercentageKey = this\n+                .configurationValue(configuration, \"tag.percentage_of_key_for_popular\",\n+                        ((Integer) DEFAULT_TAG_PERCENTAGE_KEY).longValue())\n+                .intValue();\n+\n+        // No matter what the atlas is, we need the db files. But only if we can get\n+        // them.\n+        if (fileFetcher == null)\n+        {\n+            return;\n+        }\n+        for (final String file : Arrays.asList(this.tagInfoDB, this.wikiDataDB))\n+        {\n+            final Optional<Resource> resource = fileFetcher.apply(file);\n+            if (!resource.isPresent() && logger.isDebugEnabled())\n+            {\n+                logger.debug(MessageFormat.format(\"{0} is not present\", file));\n+            }\n+        }\n+        this.fetchWikiData(fileFetcher);\n+        this.fetchTagInfo(fileFetcher);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !object.getOsmTags().isEmpty()\n+                && !this.isFlagged(this.getUniqueOSMIdentifier(object));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // Test against each filter and create an instruction if the object passes\n+        final Map<String, Collection<IFeatureChange>> instructions = new TreeMap<>();\n+\n+        if (this.sqliteUtilsTagInfoTagTable != null && this.sqliteUtilsWikiData != null)\n+        {\n+            if (this.ignoreTags == null || this.ignoreTags.isEmpty())\n+            {\n+                this.ignoreTags = KeyFullyCheckedUtils.populateIgnoreTags();\n+            }\n+            this.flagTags(object, instructions);\n+        }\n+\n+        if (!instructions.isEmpty())\n+        {\n+            // Mark objects flagged by their class and id to allow for the same id in\n+            // different object types\n+            this.markAsFlagged(this.getUniqueOSMIdentifier(object));\n+\n+            // Create a flag with generic instructions\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_INVALID_TAGS),\n+                    object.getOsmIdentifier());\n+            // If the object is an edge add the edges with the same OSM id\n+            final CheckFlag flag = (object instanceof Edge)\n+                    ? this.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction)\n+                    : this.createFlag(object, instruction);\n+\n+            // Add the specific instructions\n+            instructions.keySet().forEach(flag::addInstruction);\n+            /*\n+             * Only add autofixes when instructions are the same size as the changes. This avoids\n+             * situations where a change is available and is valid, but there is an additional issue\n+             * that is not able to be automatically fixed. If MapRoulette ever supports a method to\n+             * indicate that a change partially fixes the flag, this can be changed back to {@code\n+             * changes.isEmpty()}.\n+             */\n+            if (instructions.entrySet().stream().noneMatch(entry -> entry.getValue().isEmpty()))\n+            {\n+                flag.addFixSuggestions(Collections.singleton(\n+                        IFeatureChange.createFeatureChange(FeatureChange::add, (AtlasEntity) object,\n+                                instructions.values().stream().flatMap(Collection::stream)\n+                                        .filter(Objects::nonNull).distinct()\n+                                        .collect(Collectors.toList()))));\n+            }\n+            return Optional.of(flag);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Check for country specific rules\n+     *\n+     * @param instructions\n+     *            The instructions for the object\n+     * @param object\n+     *            The taggable object which should have country tags\n+     * @param tag\n+     *            The actual tag we are checking\n+     * @param wikiMap\n+     *            The map of wiki information\n+     * @return {@code true} if the check failed (i.e., an instruction has been generated)\n+     */\n+    private boolean checkCountrySpecific(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData wikiMap)\n+    {\n+        // P48 shouldn't be used on actual key/tag items\n+        if (wikiMap != null && (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty()\n+                || !wikiMap.getNotToBeUsedInRegionP30().isEmpty()))\n+        {\n+            /* Create a function that converts country/region wiki data into ISO3 codes */\n+            final UnaryOperator<Collection<String>> toWikiData = countries -> countries.stream()\n+                    .map(this::getWikiDataId)\n+                    .filter(Objects::nonNull/* Ignore values that aren't in the db */)\n+                    .map(WikiData::getGeographicCodeP49)\n+                    .filter(Objects::nonNull/* Q21351 has a null value here */)\n+                    .flatMap(Collection::stream)\n+                    .map(IsoCountry::iso3ForIso2/* Convert ISO2 to ISO3 codes */)\n+                    .filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());\n+            // Object ISOCountryTags appear to be ISO3 codes.\n+            final List<String> countries = Iterables.asList(ISOCountryTag.all(object));\n+            String instruction = null;\n+            // The region keys are one or the other, but should never be both.\n+            if (!wikiMap.getMustOnlyBeUsedInRegionP29().isEmpty())\n+            {\n+                final Collection<String> onlyUsedInRegion = toWikiData\n+                        .apply(wikiMap.getMustOnlyBeUsedInRegionP29());\n+                // Some primitives may cross country lines, so if any country is a valid region,\n+                // continue on.\n+                if (countries.stream().noneMatch(onlyUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // check on P30 becomes redundant due to earlier check.\n+            else\n+            {\n+                final Collection<String> notUsedInRegion = toWikiData\n+                        .apply(wikiMap.getNotToBeUsedInRegionP30());\n+                // If countries is empty, then don't bother checking. Otherwise, allMatch\n+                // returns true.\n+                if (!countries.isEmpty() && countries.stream().allMatch(notUsedInRegion::contains))\n+                {\n+                    instruction = INSTRUCTION_TAG_SHOULD_NOT_BE_USED_IN_REGION;\n+                }\n+            }\n+            // If the tag shouldn't be used in the region/area, it should be removed\n+            if (instruction != null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(instruction),\n+                                tag.getKey(), tag.getValue(), String.join(\", \", countries),\n+                                wikiMap.getId()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+\n+            return instruction != null;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for fallback issues (mostly unpopular/popular tags not caught by wiki checks)\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param keyInfo\n+     *            The information for the key\n+     * @param popular\n+     *            {@code true} if the key is \"popular\"\n+     * @param tagOccurrence\n+     *            The information from TagInfo for the tag\n+     * @param keyOccurrence\n+     *            The information from TagInfo for the key\n+     */\n+    private void checkFallback(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData keyInfo, final boolean popular,\n+            final TagInfoTags tagOccurrence, final TagInfoKeys keyOccurrence)\n+    {\n+        if (keyInfo == null)\n+        {\n+            final String count;\n+            final Map.Entry<String, String> messageTag;\n+            if (tagOccurrence.getCountAll() != null)\n+            {\n+                count = tagOccurrence.getCountAll().toString();\n+                messageTag = tag;\n+            }\n+            else if (keyOccurrence.getCountAll() != null)\n+            {\n+                count = keyOccurrence.getCountAll().toString();\n+                messageTag = Map.entry(tag.getKey(), \"\");\n+            }\n+            else\n+            {\n+                count = \"<\" + this.minTagUsage.toString();\n+                messageTag = tag;\n+            }\n+            // Check for unpopular/bad tags not already caught by wiki check\n+            if (!popular)\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_UNPOPULAR),\n+                        tagToString(tag), count), Collections.emptyList());\n+            }\n+            else\n+            {\n+                final String type = messageTag.getValue().isBlank() ? \"Key\" : \"Tag\";\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_TAGINFO_POPULAR),\n+                        tagToString(messageTag), type.toLowerCase(Locale.ENGLISH), count,\n+                        new StringBuilder(type).append(':').append(tagToString(messageTag))\n+                                .toString()),\n+                        Collections.emptyList());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check if a wiki data item for a tag redirects to another tag, and if so, create an\n+     * instruction and change for that.\n+     *\n+     * @param instructions\n+     *            The instructions collection to add to\n+     * @param changes\n+     *            The changes collection to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @return {@code true} if the tag fails the regex\n+     */\n+    private boolean checkRedirectTo(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && !checkInfo.getRedirectToP17().isEmpty())\n+        {\n+            final String value = checkInfo.getInstanceOfP2().contains(\"key\")\n+                    ? checkInfo.getPermanentKeyIdP16()\n+                    : checkInfo.getPermanentTagIdP19();\n+            final Collection<String> redirects = checkInfo.getRedirectToP17();\n+            final Map<String, String> replacements = redirects.stream().map(replacementId ->\n+\n+            WikiData.getWikiData(this.sqliteUtilsWikiData.getRows(Map.of(\"id\", replacementId)))\n+\n+            ).filter(Objects::nonNull).map(this::parseTags).filter(Objects::nonNull)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            final Collection<IFeatureChange> featureChanges;\n+            if (!replacements.isEmpty())\n+            {\n+                featureChanges = new ArrayList<>();\n+                featureChanges.add(new RemoveTagFeatureChange(tag));\n+                for (final Map.Entry<String, String> newTag : replacements.entrySet())\n+                {\n+                    featureChanges.add(new ReplaceTagFeatureChange(tag, newTag));\n+                }\n+            }\n+            else\n+            {\n+                featureChanges = Collections.emptyList();\n+            }\n+\n+            instructions.put(\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_REPLACE),\n+                            value,\n+                            replacements.entrySet().stream().map(GenericTagCheck::tagToString)\n+                                    .collect(Collectors.joining(\", \")),\n+                            checkInfo.getId()),\n+                    featureChanges);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check regexes for a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @return {@code true} if the regex failed\n+     */\n+    private boolean checkRegex(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        // \"P13\" is \"value validation regex\". We must wrap with \"^(\" and \")$\"\n+        if (checkInfo != null && checkInfo.getValueValidationRegexP13() != null)\n+        {\n+            // Reuse the compiled patterns\n+            final var pattern = checkInfo.getValueValidationRegexP13();\n+            if (!pattern.matcher(tag.getValue()).matches())\n+            {\n+                instructions.put(this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_MISMATCHED_REGEX), tag.getValue(),\n+                        pattern.toString(), tag.getKey(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Do relation specific checks\n+     *\n+     * @param instructions\n+     *            Instructions to add to\n+     * @param The\n+     *            object to check\n+     * @param checkInfo\n+     *            The wiki information for the tag to be checked\n+     * @param tag\n+     *            The tag to be checked\n+     * @return {@code true} if the relation had a problem\n+     */\n+    private boolean checkRelations(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Taggable object, final Map.Entry<String, String> tag, final WikiData checkInfo)\n+    {\n+        if (checkInfo != null && object instanceof Relation && checkInfo.isUseOnRelationsP36()\n+                && \"type\".equals(tag.getKey()))\n+        {\n+            final var relation = (Relation) object;\n+            final var relationInfo = this.getWikiData(\n+                    Map.of(WikiProperty.PERMANENT_RELATION_TYPE_ID_P41.getId(), tag.getValue()));\n+            if (relationInfo == null)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_TYPE),\n+                                tag.getValue(), relation.getOsmIdentifier(), checkInfo.getId()),\n+                        Collections.emptyList());\n+                return true;\n+            }\n+            final Collection<String> additionalInstructions = new TreeSet<>();\n+            for (final RelationMember relationMember : relation.members())\n+            {\n+                // Empty roles should exist in WikiData\n+                final String role = relationMember.getRole();\n+                final var roleInfo = this\n+                        .getWikiData(Map.of(WikiProperty.RELATION_ROLE_ID_P21.getId(),\n+                                relationInfo.getPermanentRelationTypeIdP41() + \"=\" + role));\n+                if (roleInfo == null)\n+                {\n+                    final var roleMember = relationMember.getEntity();\n+                    additionalInstructions.add(this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNKNOWN_RELATION_ROLE),\n+                            relationInfo.getPermanentRelationTypeIdP41(), role,\n+                            AtlasToOsmType.convert(roleMember.getType()),\n+                            roleMember.getOsmIdentifier(), relation.getOsmIdentifier(),\n+                            checkInfo.getId()));\n+                }\n+            }\n+            additionalInstructions\n+                    .forEach(instruction -> instructions.put(instruction, Collections.emptyList()));\n+            return !additionalInstructions.isEmpty();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the status of a tag\n+     *\n+     * @param instructions\n+     *            The instruction collection to append instructions to\n+     * @param changes\n+     *            The changes to add a change to (removal)\n+     * @param tag\n+     *            The specific tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (specific, if available)\n+     * @param wellKnown\n+     *            If the tag has well-defined values\n+     * @return {@code true} if the tag should be removed (change already added to {@code changes})\n+     */\n+    private boolean checkStatus(final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown)\n+    {\n+        if (wellKnown && checkInfo != null && checkInfo.getStatusP6() != null\n+                && this.tagsToRemove.stream().anyMatch(t -> checkInfo.getStatusP6().matches(t)))\n+        {\n+            instructions.put(\n+                    this.getLocalizedInstruction(\n+                            FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_WIKI_DATA_REMOVAL),\n+                            tag.getKey(), tag.getValue(),\n+                            checkInfo.getStatusP6().getDescriptor().toLowerCase(Locale.ENGLISH),\n+                            checkInfo.getId()),\n+                    Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check for instances where a key is well-known but the value is not one of the well-known\n+     * values.\n+     *\n+     * @param instructions\n+     *            The instructions to add to\n+     * @param changes\n+     *            The changes to add to\n+     * @param tag\n+     *            The tag to check\n+     * @param checkInfo\n+     *            Wiki Data information (more specific)\n+     * @param wellKnown\n+     *            {@code true} if values are well-known\n+     * @param popular\n+     *            {@code true} if the tag is popular\n+     * @param tagOccurrence\n+     *            The TagInfo information for the tag\n+     * @return {@code true} if an issue was found\n+     */\n+    private boolean checkUndocumentedPopularWellDefined(\n+            final Map<String, Collection<IFeatureChange>> instructions,\n+            final Map.Entry<String, String> tag, final WikiData checkInfo, final boolean wellKnown,\n+            final boolean popular, final TagInfoTags tagOccurrence)\n+    {\n+        if (wellKnown && checkInfo == null)\n+        {\n+            if (popular)\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(INSTRUCTION_UNDOCUMENTED_POPULAR_TAG),\n+                                tag.getKey(), tag.getValue(), tagOccurrence.getCountAll()),\n+                        Collections.emptyList());\n+            }\n+            else\n+            {\n+                instructions.put(\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS\n+                                        .indexOf(INSTRUCTION_WELL_DEFINED_TAG_UNKNOWN_VALUE),\n+                                tag.getValue(), tag.getKey()),\n+                        Collections.singleton(new RemoveTagFeatureChange(tag)));\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check the tag against wiki data for cases where it should not appear on the object.\n+     *\n+     * @param changes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac3dad22c01430cc121a5c7ef7a7018f1d2cd6ed"}, "originalPosition": 644}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3167, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}