{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MzAyMzU4", "number": 432, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxNDozN1rOE9XHxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo0NzozMFrOE_YuOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzc3NDE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxNDozN1rOH6A0aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNTo0MFrOH8knGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5Mjg3Mg==", "bodyText": "This needs to be updated.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530592872", "createdAt": "2020-11-25T19:14:37Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NjQ0MA==", "bodyText": "Addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533276440", "createdAt": "2020-12-01T10:15:40Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5Mjg3Mg=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzc3NTAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxNTowMVrOH6A0_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNjowNFrOH8koyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5MzAyMA==", "bodyText": "This is still the default and needs to be regenerated.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530593020", "createdAt": "2020-11-25T19:15:01Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3Njg3Mg==", "bodyText": "Addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533276872", "createdAt": "2020-12-01T10:16:04Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5MzAyMA=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzgxNTA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToyODo1MFrOH6BN3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNjoxNlrOH8kpoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5OTM4OA==", "bodyText": "I believe this can be simplified.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n          \n          \n            \n                            && HighwayTag.isCarNavigableHighway(object)\n          \n          \n            \n                            && !isFlagged(object.getOsmIdentifier()))\n          \n          \n            \n                    {\n          \n          \n            \n                        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n          \n          \n            \n                        final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n          \n          \n            \n                        return !this.isPrivateAccess(keySet)\n          \n          \n            \n                                && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n          \n          \n            \n                    }\n          \n          \n            \n                    return false;\n          \n          \n            \n                    return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n          \n          \n            \n                            && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n          \n          \n            \n                            && !isFlagged(object.getOsmIdentifier())\n          \n          \n            \n                            && !this.isPrivateAccess(((Edge) object).getOsmTags());", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530599388", "createdAt": "2020-11-25T19:28:50Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NzA4OA==", "bodyText": "Addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533277088", "createdAt": "2020-12-01T10:16:16Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5OTM4OA=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzgxOTA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTozMDowM1rOH6BQSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNzoyMlrOH8kvAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMDAwOA==", "bodyText": "abt?", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530600008", "createdAt": "2020-11-25T19:30:03Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3ODE4Nw==", "bodyText": "Addressed and fixed; Changed name to alreadyBeenCheckedNeafrbyTollEdges. abt meant \"already been touched\"", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533278187", "createdAt": "2020-12-01T10:17:08Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMDAwOA=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3ODQ2Nw==", "bodyText": "Updated all instances of abt", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533278467", "createdAt": "2020-12-01T10:17:22Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMDAwOA=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg2MzE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo0NDo0MVrOH6Bq-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozMDoyOFrOH8ls-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNjg0MA==", "bodyText": "This can be simplified if you use the Atlas Heading and Angle classes. If you go with this it will require changing doubles to Angles in a few other places.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n          \n          \n            \n                {\n          \n          \n            \n                    final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n          \n          \n            \n                    final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n          \n          \n            \n                    final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n          \n          \n            \n                    final Segment edge2StartSeg = edge2Segments.get(0);\n          \n          \n            \n                    final double aLength = edge1EndSeg.length().asMeters();\n          \n          \n            \n                    final double bLength = edge2StartSeg.length().asMeters();\n          \n          \n            \n                    final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n          \n          \n            \n                            .asMeters();\n          \n          \n            \n                    return Math.toDegrees(Math.acos(\n          \n          \n            \n                            (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n          \n          \n            \n                }\n          \n          \n            \n                private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n          \n          \n            \n                {\n          \n          \n            \n                    final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n          \n          \n            \n                    final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n          \n          \n            \n                    if (edge1heading.isPresent() && edge2heading.isPresent()){\n          \n          \n            \n                        return edge1heading.get().difference(edge2heading.get());\n          \n          \n            \n                    }\n          \n          \n            \n                    return Angle.NONE;\n          \n          \n            \n                }", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530606840", "createdAt": "2020-11-25T19:44:41Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5NDMzMA==", "bodyText": "Addressed and fixed. One small difference is that this is just the difference between the angles and not the angle that the segments make by connecting so I had to update MIN_ANGLE_DEFAULT --> MAX_ANGLE_DIFF_DEFAULT and minAngleForContiguousWays --> maxAngleDiffForContiguousWays", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533294330", "createdAt": "2020-12-01T10:30:28Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNjg0MA=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg5Mjk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NDo0NVrOH6B9Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NDo0NVrOH6B9Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMTQ5MA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530611490", "createdAt": "2020-11-25T19:54:45Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg5MzYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NDo1OFrOH6B9jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NDo1OFrOH6B9jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMTU5OA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530611598", "createdAt": "2020-11-25T19:54:58Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg5NzEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NjowNVrOH6B_tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NjowNVrOH6B_tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjE1MA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530612150", "createdAt": "2020-11-25T19:56:05Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkwMDM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NzowMFrOH6CBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NzowMFrOH6CBmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjYzMw==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530612633", "createdAt": "2020-11-25T19:57:00Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkwMjA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NzozN1rOH6CCrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1NzozN1rOH6CCrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjkwOQ==", "bodyText": "nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n          \n          \n            \n                    return edge.inEdges().stream().filter(someEdge -> someEdge.isMainEdge()", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530612909", "createdAt": "2020-11-25T19:57:37Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 379}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkwMzk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1ODoxN1rOH6CDzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1ODoxN1rOH6CDzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzE5OA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530613198", "createdAt": "2020-11-25T19:58:17Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 432}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkwNzExOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1OToyN1rOH6CFxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTo1OToyN1rOH6CFxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzcwMw==", "bodyText": "nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n          \n          \n            \n                    return edge.outEdges().stream().filter(someEdge -> someEdge.isMainEdge()", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530613703", "createdAt": "2020-11-25T19:59:27Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 442}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkxMDkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDoyOVrOH6CH7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozMTowN1rOH8lv9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDI1Mw==", "bodyText": "nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n          \n          \n            \n                                    && inEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(inEdge))", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530614253", "createdAt": "2020-11-25T20:00:29Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 455}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5NTA5Mg==", "bodyText": "Addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533295092", "createdAt": "2020-12-01T10:31:07Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDI1Mw=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 455}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkxMTcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMDo0NVrOH6CIbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozMTo1OFrOH8l0CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDM4Mw==", "bodyText": "nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n          \n          \n            \n                                    && outEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(outEdge))", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530614383", "createdAt": "2020-11-25T20:00:45Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 459}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5NjEzNw==", "bodyText": "Addressed and fixed", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533296137", "createdAt": "2020-12-01T10:31:58Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDM4Mw=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 459}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkxNTk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMjowN1rOH6CLCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozMjowN1rOH8l0rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTA0OA==", "bodyText": "It would be good to give a description of what this case covers here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530615048", "createdAt": "2020-11-25T20:02:07Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 538}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5NjMwMg==", "bodyText": "Addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533296302", "createdAt": "2020-12-01T10:32:07Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTA0OA=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 538}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkxNjQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMjoxN1rOH6CLTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozMjoxOFrOH8l1jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTExNw==", "bodyText": "It would be good to give a description of what this case covers here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530615117", "createdAt": "2020-11-25T20:02:17Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            the edge in question\n+     * @param edgeInQuestionTags\n+     *            tags of edge in question\n+     * @return boolean if is case one\n+     */\n+    private boolean isCaseOne(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags)\n+    {\n+        return !this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.markedIntersectingTollFeature.contains(edgeInQuestion.getOsmIdentifier())\n+                && this.edgeIntersectsTollFeature(edgeInQuestion);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 553}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5NjUyNA==", "bodyText": "Addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533296524", "createdAt": "2020-12-01T10:32:18Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            the edge in question\n+     * @param edgeInQuestionTags\n+     *            tags of edge in question\n+     * @return boolean if is case one\n+     */\n+    private boolean isCaseOne(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags)\n+    {\n+        return !this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.markedIntersectingTollFeature.contains(edgeInQuestion.getOsmIdentifier())\n+                && this.edgeIntersectsTollFeature(edgeInQuestion);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTExNw=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 553}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzkxNjkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMjoyM1rOH6CLiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDozMjoyN1rOH8l2Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTE3OQ==", "bodyText": "It would be good to give a description of what this case covers here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530615179", "createdAt": "2020-11-25T20:02:23Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            the edge in question\n+     * @param edgeInQuestionTags\n+     *            tags of edge in question\n+     * @return boolean if is case one\n+     */\n+    private boolean isCaseOne(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags)\n+    {\n+        return !this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.markedIntersectingTollFeature.contains(edgeInQuestion.getOsmIdentifier())\n+                && this.edgeIntersectsTollFeature(edgeInQuestion);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            edge in question\n+     * @param edgeInQuestionTags\n+     *            edge in question osm tags\n+     * @param escapableInEdge\n+     *            edge that proves edge in question is toll escapable\n+     * @param escapableOutEdge\n+     *            edge that proves edge in question is toll escapable\n+     * @return boolean if is case three\n+     */\n+    private boolean isCaseThree(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags, final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.edgeIntersectsTollFeature(edgeInQuestion)\n+                && !this.hasInconsistentTollTag(escapableOutEdge)\n+                && !this.hasInconsistentTollTag(escapableInEdge);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 574}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5NjY4Nw==", "bodyText": "Addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533296687", "createdAt": "2020-12-01T10:32:27Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            the edge in question\n+     * @param edgeInQuestionTags\n+     *            tags of edge in question\n+     * @return boolean if is case one\n+     */\n+    private boolean isCaseOne(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags)\n+    {\n+        return !this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.markedIntersectingTollFeature.contains(edgeInQuestion.getOsmIdentifier())\n+                && this.edgeIntersectsTollFeature(edgeInQuestion);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            edge in question\n+     * @param edgeInQuestionTags\n+     *            edge in question osm tags\n+     * @param escapableInEdge\n+     *            edge that proves edge in question is toll escapable\n+     * @param escapableOutEdge\n+     *            edge that proves edge in question is toll escapable\n+     * @return boolean if is case three\n+     */\n+    private boolean isCaseThree(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags, final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.edgeIntersectsTollFeature(edgeInQuestion)\n+                && !this.hasInconsistentTollTag(escapableOutEdge)\n+                && !this.hasInconsistentTollTag(escapableInEdge);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTE3OQ=="}, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 574}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODUwNDg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMTowMTo1MlrOH8_n0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1NjowM1rOH9Eq3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxODk5Mw==", "bodyText": "Is there any chance that this could end up taking a long time to complete, either because the closest toll feature is a long ways away or because this is a depth first search and it takes a while to get to the nearby toll feature.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533718993", "createdAt": "2020-12-01T21:01:52Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,609 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc2MTQ2OQ==", "bodyText": "I can just set a limit on how far the search will go. This is just complimentary information for the editor when they are investigating the toll tag modeling. I will limit to around 15 iterations in the search.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533761469", "createdAt": "2020-12-01T22:23:33Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,609 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxODk5Mw=="}, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMTY5NQ==", "bodyText": "Same with my other comment about combing two similar methods into one -- I believe this and its outEdge counterpart can be combined", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533801695", "createdAt": "2020-12-01T23:56:03Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,609 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxODk5Mw=="}, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODUxODEwOnYy", "diffSide": "RIGHT", "path": "docs/checks/tollValidationCheck", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMTowNTo1MFrOH8_vwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzoyNjo1OVrOH9EBeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMTAyNA==", "bodyText": "It would be nice to have a description of the configurables here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533721024", "createdAt": "2020-12-01T21:05:50Z", "author": {"login": "Bentleysb"}, "path": "docs/checks/tollValidationCheck", "diffHunk": "@@ -0,0 +1,41 @@\n+# TollValidationCheck\n+\n+#### Description\n+\n+The purpose of this check is to identify ways that need to have their toll tags investigated/added/removed.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MTA5OA==", "bodyText": "addressed and fixed!", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533791098", "createdAt": "2020-12-01T23:26:59Z", "author": {"login": "reichg"}, "path": "docs/checks/tollValidationCheck", "diffHunk": "@@ -0,0 +1,41 @@\n+# TollValidationCheck\n+\n+#### Description\n+\n+The purpose of this check is to identify ways that need to have their toll tags investigated/added/removed.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMTAyNA=="}, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODk3MDk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzozMjozNFrOH9EJTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMDo1NjoyN1rOH9F-Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MzEwMQ==", "bodyText": "Is it desired behavior to short circuit here with possibly returning false and not checking other areas/nodes?", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533793101", "createdAt": "2020-12-01T23:32:34Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyMzA1OQ==", "bodyText": "This is a good point. It shouldn't. I will update this. I think I adjusted this to reduce the cognitive complexity.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533823059", "createdAt": "2020-12-02T00:56:27Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MzEwMQ=="}, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODk4NjQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzozODo1MlrOH9ESQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMDowNDo1MlrOH9E34w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NTM5Mw==", "bodyText": "Not a huge deal but we could rename this variable (especially in the config) as it seems to be functioning as an exact constraint, not a min", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533795393", "createdAt": "2020-12-01T23:38:52Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges, double recursionCount)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, alreadyCheckedNearbyTollEdges);\n+            }\n+            if (recursionCount <= this.maxIterationForNearbySearch\n+                    && inEdges.size() >= this.minInAndOutEdges\n+                    && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                alreadyCheckedNearbyTollEdges.add(inEdge.getIdentifier());\n+                recursionCount++;\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, alreadyCheckedNearbyTollEdges,\n+                        recursionCount);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges, double recursionCount)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, alreadyCheckedNearbyTollEdges);\n+            }\n+            if (recursionCount <= this.maxIterationForNearbySearch\n+                    && outEdges.size() >= this.minInAndOutEdges\n+                    && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                alreadyCheckedNearbyTollEdges.add(outEdge.getIdentifier());\n+                recursionCount++;\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, alreadyCheckedNearbyTollEdges,\n+                        recursionCount);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwNTAyNw==", "bodyText": "For this specific instance I am just using the config value since it is 1. That variable is used other places as a min. I can just use 1", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533805027", "createdAt": "2020-12-02T00:04:52Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges, double recursionCount)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, alreadyCheckedNearbyTollEdges);\n+            }\n+            if (recursionCount <= this.maxIterationForNearbySearch\n+                    && inEdges.size() >= this.minInAndOutEdges\n+                    && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                alreadyCheckedNearbyTollEdges.add(inEdge.getIdentifier());\n+                recursionCount++;\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, alreadyCheckedNearbyTollEdges,\n+                        recursionCount);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges, double recursionCount)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, alreadyCheckedNearbyTollEdges);\n+            }\n+            if (recursionCount <= this.maxIterationForNearbySearch\n+                    && outEdges.size() >= this.minInAndOutEdges\n+                    && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                alreadyCheckedNearbyTollEdges.add(outEdge.getIdentifier());\n+                recursionCount++;\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, alreadyCheckedNearbyTollEdges,\n+                        recursionCount);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NTM5Mw=="}, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 478}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODk5Mjc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo0MToxOFrOH9EV2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwMTowMDoxOVrOH9GD8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NjMxMg==", "bodyText": "I think we can use BaseCheck's markAsFlagged here instead of these Sets, just because it's more conventional and the memory should be allocated already", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533796312", "createdAt": "2020-12-01T23:41:18Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyNDQ5OQ==", "bodyText": "I think I originally was wanting to track these cases individually and not with markAsFlagged but now it should be okay to do so. Will update", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533824499", "createdAt": "2020-12-02T01:00:19Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NjMxMg=="}, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0OTAwNzkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo0NzozMFrOH9EeqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODo1NDoxMVrOH9phaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5ODU2OA==", "bodyText": "Could we combine this and edgeProvingForwardIsEscapable() into a new method where the params would just be Edge edge, Set<Edge> connectedEdges, Set<Long> alreadyCheckedObjectIds)?", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533798568", "createdAt": "2020-12-01T23:47:30Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMDA0MA==", "bodyText": "Actually I just noticed they call each other... if there's not already a stack overflow problem or anything I don't think my suggestion alone should cause that either", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533800040", "createdAt": "2020-12-01T23:51:37Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5ODU2OA=="}, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgyODU4MA==", "bodyText": "I personally would like to keep them separate just for ease of access and understandability? Same with the nearby toll features request. If this is an issue maybe the PR could be accepted without combining the functions and I can see what I Can work out when I add in the autofix suggestions. What do you think?", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533828580", "createdAt": "2020-12-02T01:10:50Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5ODU2OA=="}, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNTQ4MA==", "bodyText": "Yeah that sounds good. Usually sonar throws a duplication warning but looks like we're good here since inEdges is replaced by outEdges in a few lines. So not really a priority at this point", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r534405480", "createdAt": "2020-12-02T18:54:11Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5ODU2OA=="}, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 259}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3225, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}