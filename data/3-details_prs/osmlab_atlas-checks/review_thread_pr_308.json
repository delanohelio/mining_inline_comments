{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxMzQ2Mjkx", "number": 308, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDowNzowNlrOEIHcYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoxNjowNFrOEL3EjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTQ2MDE4OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDowNzowNlrOGn4tGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDowNzowNlrOGn4tGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3NjY5Nw==", "bodyText": "Could you please add a challenge object to this configuration. You can look at other checks' configurations for examples. This information is used when creating MapRoulette challenges.", "url": "https://github.com/osmlab/atlas-checks/pull/308#discussion_r444476697", "createdAt": "2020-06-23T20:07:06Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -51,6 +51,12 @@\n       \"difficulty\": \"HARD\"\n     }\n   },\n+  \"ApproximateWayCheck\": {\n+    \"deviation.minimum.meters\": 35.0,\n+    \"angle.minimum\": 100.0,\n+    \"bezierStep\": 0.01,\n+    \"highway.minimum\": \"service\"\n+  },", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7de8103333b91712299eacc713751c6d5765b6d"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzA2Mzk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/ApproximateWayCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzoyNToxNlrOGob88A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzoyNToxNlrOGob88A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NDE5Mg==", "bodyText": "nit: Please avoid one letter variables.", "url": "https://github.com/osmlab/atlas-checks/pull/308#discussion_r445054192", "createdAt": "2020-06-24T17:25:16Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/ApproximateWayCheck.java", "diffHunk": "@@ -0,0 +1,198 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import static java.lang.Math.pow;\n+import static java.lang.Math.sqrt;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.stream.IntStream;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags edges that deviate from the assumed curve of a road by at least\n+ * {@value DEVIATION_MINIMUM_METERS_DEFAULT} meters.\n+ *\n+ * @author v-brjor\n+ */\n+public class ApproximateWayCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final String EDGE_DEVIATION_INSTRUCTION = \"Way {0,number,#} deviates by {1,number,#} meters\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(EDGE_DEVIATION_INSTRUCTION);\n+    public static final double DEVIATION_MINIMUM_METERS_DEFAULT = 35.0;\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.SERVICE.toString();\n+    public static final double MINIMUM_ANGLE_DEFAULT = 100.0;\n+    public static final double BEZIER_STEP_DEFAULT = 0.01;\n+\n+    private final Distance minimumDeviation;\n+    private final HighwayTag highwayMinimum;\n+    private final double minimumAngle;\n+    private final double bezierStep;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public ApproximateWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.minimumDeviation = configurationValue(configuration, \"deviation.minimum.meters\",\n+                DEVIATION_MINIMUM_METERS_DEFAULT, Distance::meters);\n+        final String highwayType = this.configurationValue(configuration, \"highway.minimum\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.highwayMinimum = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minimumAngle = configurationValue(configuration, \"angle.minimum\",\n+                MINIMUM_ANGLE_DEFAULT);\n+        this.bezierStep = configurationValue(configuration, \"bezierStep\", BEZIER_STEP_DEFAULT);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(object) && isMinimumHighwayType(object);\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged. A\n+     * majority of flagged edges were those that contained correctly mapped ~90 degree angles, we\n+     * also don't want to worry about sharp angles as those are flagged in {@link SharpAngleCheck}\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final List<Segment> segments = ((Edge) object).asPolyLine().segments();\n+\n+        if (segments.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        final OptionalDouble max = IntStream.range(0, segments.size() - 1).mapToDouble(index ->\n+        {\n+            final Segment seg1 = segments.get(index);\n+            final Segment seg2 = segments.get(index + 1);\n+            if (findAngle(seg1, seg2) < minimumAngle)\n+            {\n+                return 0;\n+            }\n+            return quadraticBezier(seg1.first(), seg2.first(), seg2.end());\n+        }).reduce(Math::max);\n+\n+        if (max.isPresent() && max.getAsDouble() > this.minimumDeviation.asMeters())\n+        {\n+            return Optional.of(createFlag(object,\n+                    this.getLocalizedInstruction(0, object.getOsmIdentifier(), max.getAsDouble())));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private double distance(final double startX, final double startY, final double endX,\n+            final double endY)\n+    {\n+        return sqrt(pow(endX - startX, 2) + pow(endY - startY, 2));\n+    }\n+\n+    /**\n+     * Calculates the angle between the two segments.\n+     */\n+    private double findAngle(final Segment seg1, final Segment seg2)\n+    {\n+        final double aLength = seg1.length().asMeters();\n+        final double bLength = seg2.length().asMeters();\n+        final double cLength = new Segment(seg1.start(), seg2.end()).length().asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * Checks if highway tag of given {@link AtlasObject} is of greater or equal priority than the\n+     * minimum highway type given in the configurable. If no value is given in configurable, the\n+     * default highway type of \"SERVICE\" will be set as minimum.\n+     *\n+     * @param object\n+     *            an {@link AtlasObject}\n+     * @return {@code true} if the highway tag of this object is greater than or equal to the\n+     *         minimum type\n+     */\n+    private boolean isMinimumHighwayType(final AtlasObject object)\n+    {\n+        final Optional<HighwayTag> highwayTagOfObject = HighwayTag.highwayTag(object);\n+        return highwayTagOfObject.isPresent()\n+                && highwayTagOfObject.get().isMoreImportantThanOrEqualTo(this.highwayMinimum);\n+    }\n+\n+    /**\n+     * Constructs a quadratic bezier curve and finds the closest distance of the curve to the\n+     * anchor.\n+     * \n+     * @param start\n+     *            start point of bezier curve\n+     * @param anchor\n+     *            anchor for the curve\n+     * @param end\n+     *            end point of bezier curve\n+     * @return distance in meters from closest point on bezier curve\n+     */\n+    private double quadraticBezier(final Location start, final Location anchor, final Location end)\n+    {\n+        final double startX = start.getLongitude().onEarth().asMeters();\n+        final double startY = start.getLatitude().onEarth().asMeters();\n+        final double anchorX = anchor.getLongitude().onEarth().asMeters();\n+        final double anchorY = anchor.getLatitude().onEarth().asMeters();\n+        final double endX = end.getLongitude().onEarth().asMeters();\n+        final double endY = end.getLatitude().onEarth().asMeters();\n+\n+        double min = Double.POSITIVE_INFINITY;\n+        for (double i = 0; i <= 1; i += bezierStep)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7de8103333b91712299eacc713751c6d5765b6d"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzA3NDk2OnYy", "diffSide": "RIGHT", "path": "docs/checks/approximateWayCheck.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzoyODo0M1rOGocEbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzoyODo0M1rOGocEbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjExMA==", "bodyText": "Could you add a section to include examples? You can refer any of the existing docs for the details. Thanks!", "url": "https://github.com/osmlab/atlas-checks/pull/308#discussion_r445056110", "createdAt": "2020-06-24T17:28:43Z", "author": {"login": "sayas01"}, "path": "docs/checks/approximateWayCheck.md", "diffHunk": "@@ -0,0 +1,10 @@\n+# ApproximateWayCheck\n+\n+#### Description", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39d7b6539aa1ccc03b0d91a7c848ed5ae118a02"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzE3OTAzOnYy", "diffSide": "RIGHT", "path": "docs/checks/approximateWayCheck.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzo1OToxNlrOGodIDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzo1OToxNlrOGodIDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3MzQyMw==", "bodyText": "It would be great if you could add a brief description of some off the more complex logic here. I think an explanation of your findAngle and quadraticBezier methods would be useful.", "url": "https://github.com/osmlab/atlas-checks/pull/308#discussion_r445073423", "createdAt": "2020-06-24T17:59:16Z", "author": {"login": "Bentleysb"}, "path": "docs/checks/approximateWayCheck.md", "diffHunk": "@@ -0,0 +1,10 @@\n+# ApproximateWayCheck\n+\n+#### Description\n+\n+The purpose of this check is to identify ways that are crudely drawn, there is a discrepancy between the drawing and the real way, especially for curves.\n+\n+#### Code Review", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39d7b6539aa1ccc03b0d91a7c848ed5ae118a02"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODcxMjUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/ApproximateWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoxMjoyOVrOGtovBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoxMjoyOVrOGtovBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNjUwMw==", "bodyText": "Please regenerate the UID.", "url": "https://github.com/osmlab/atlas-checks/pull/308#discussion_r450506503", "createdAt": "2020-07-06T22:12:29Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/ApproximateWayCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import static java.lang.Math.pow;\n+import static java.lang.Math.sqrt;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags edges that deviate from the assumed curve of a road by at least\n+ * {@value DEVIATION_MINIMUM_LENGTH_DEFAULT} meters.\n+ *\n+ * @author v-brjor\n+ */\n+public class ApproximateWayCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ef47efed208a1b3967e853697d8f80e4786f5a9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODcyMDc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/ApproximateWayCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoxNjowNFrOGto0DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoxNjowNFrOGto0DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNzc4OA==", "bodyText": "The instruction could be more descriptive like \"Way {0,number,#} is crude.  Add more nodes/rearrange current nodes\".", "url": "https://github.com/osmlab/atlas-checks/pull/308#discussion_r450507788", "createdAt": "2020-07-06T22:16:04Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/ApproximateWayCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import static java.lang.Math.pow;\n+import static java.lang.Math.sqrt;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags edges that deviate from the assumed curve of a road by at least\n+ * {@value DEVIATION_MINIMUM_LENGTH_DEFAULT} meters.\n+ *\n+ * @author v-brjor\n+ */\n+public class ApproximateWayCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final String EDGE_DEVIATION_INSTRUCTION = \"Way {0,number,#} is crude\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ef47efed208a1b3967e853697d8f80e4786f5a9"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3318, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}