{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMjE0Mjgw", "number": 315, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo0MDowMVrOEG6_nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowNjoyNlrOEIff3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjkzNDcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo0MDowMVrOGmBItg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOTozMzo0NVrOGn3qqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng==", "bodyText": "Because you know you are dealing with the first edge section, you could just check that the in Edges contain an edge with the same OSM id. That would save you having to traverse along the whole Way.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442517686", "createdAt": "2020-06-18T21:40:01Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                        this.getLocalizedInstruction(0)));\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())\n+                // de-duplication sectioned edges\n+                .forEach(wayId -> connectedEdges.add(wayId.getOsmIdentifier())));\n+        return connectedEdges.size() > MINIMUM_INTERSECTION;\n+    }\n+\n+    /**\n+     * Check if Edge is part of Closed Way. See https://wiki.openstreetmap.org/wiki/Item:Q4669\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if edge is part of closed way.\n+     */\n+    private boolean isPartOfClosedWay(final Edge edge)\n+    {\n+        final HashSet<Long> wayIds = new HashSet<>();\n+        Edge nextEdge = edge;\n+        // Loop through out going edges with the same OSM id\n+        while (nextEdge != null)\n+        {\n+            wayIds.add(nextEdge.getIdentifier());\n+            final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)\n+                    .filter(outEdge -> outEdge.getOsmIdentifier() == edge.getOsmIdentifier())\n+                    .collectToList();\n+            nextEdge = nextEdgeList.isEmpty() ? null : nextEdgeList.get(0);\n+            // If original edge is found, the way is closed\n+            if (nextEdge != null && wayIds.contains(nextEdge.getIdentifier()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3MTY0Nw==", "bodyText": "Thanks for suggestion!", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442571647", "createdAt": "2020-06-19T00:36:37Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                        this.getLocalizedInstruction(0)));\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())\n+                // de-duplication sectioned edges\n+                .forEach(wayId -> connectedEdges.add(wayId.getOsmIdentifier())));\n+        return connectedEdges.size() > MINIMUM_INTERSECTION;\n+    }\n+\n+    /**\n+     * Check if Edge is part of Closed Way. See https://wiki.openstreetmap.org/wiki/Item:Q4669\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if edge is part of closed way.\n+     */\n+    private boolean isPartOfClosedWay(final Edge edge)\n+    {\n+        final HashSet<Long> wayIds = new HashSet<>();\n+        Edge nextEdge = edge;\n+        // Loop through out going edges with the same OSM id\n+        while (nextEdge != null)\n+        {\n+            wayIds.add(nextEdge.getIdentifier());\n+            final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)\n+                    .filter(outEdge -> outEdge.getOsmIdentifier() == edge.getOsmIdentifier())\n+                    .collectToList();\n+            nextEdge = nextEdgeList.isEmpty() ? null : nextEdgeList.get(0);\n+            // If original edge is found, the way is closed\n+            if (nextEdge != null && wayIds.contains(nextEdge.getIdentifier()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk1MDY5NA==", "bodyText": "In this case every way will be closedWay. Instead of \"contain\" we need:\nreturn Edges.get(0).start().getLocation().equals(Edges.get(Edges.size()-1).end().getLocation());\nit slower than Edge Walker.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442950694", "createdAt": "2020-06-19T16:59:07Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                        this.getLocalizedInstruction(0)));\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())\n+                // de-duplication sectioned edges\n+                .forEach(wayId -> connectedEdges.add(wayId.getOsmIdentifier())));\n+        return connectedEdges.size() > MINIMUM_INTERSECTION;\n+    }\n+\n+    /**\n+     * Check if Edge is part of Closed Way. See https://wiki.openstreetmap.org/wiki/Item:Q4669\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if edge is part of closed way.\n+     */\n+    private boolean isPartOfClosedWay(final Edge edge)\n+    {\n+        final HashSet<Long> wayIds = new HashSet<>();\n+        Edge nextEdge = edge;\n+        // Loop through out going edges with the same OSM id\n+        while (nextEdge != null)\n+        {\n+            wayIds.add(nextEdge.getIdentifier());\n+            final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)\n+                    .filter(outEdge -> outEdge.getOsmIdentifier() == edge.getOsmIdentifier())\n+                    .collectToList();\n+            nextEdge = nextEdgeList.isEmpty() ? null : nextEdgeList.get(0);\n+            // If original edge is found, the way is closed\n+            if (nextEdge != null && wayIds.contains(nextEdge.getIdentifier()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1ODQ2Nw==", "bodyText": "What about using edge.inEdges().stream().filter(e -> e.getOsmIdentifier() == edge.getOsmIdentifier()).count() == 1?", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444358467", "createdAt": "2020-06-23T16:36:21Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                        this.getLocalizedInstruction(0)));\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())\n+                // de-duplication sectioned edges\n+                .forEach(wayId -> connectedEdges.add(wayId.getOsmIdentifier())));\n+        return connectedEdges.size() > MINIMUM_INTERSECTION;\n+    }\n+\n+    /**\n+     * Check if Edge is part of Closed Way. See https://wiki.openstreetmap.org/wiki/Item:Q4669\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if edge is part of closed way.\n+     */\n+    private boolean isPartOfClosedWay(final Edge edge)\n+    {\n+        final HashSet<Long> wayIds = new HashSet<>();\n+        Edge nextEdge = edge;\n+        // Loop through out going edges with the same OSM id\n+        while (nextEdge != null)\n+        {\n+            wayIds.add(nextEdge.getIdentifier());\n+            final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)\n+                    .filter(outEdge -> outEdge.getOsmIdentifier() == edge.getOsmIdentifier())\n+                    .collectToList();\n+            nextEdge = nextEdgeList.isEmpty() ? null : nextEdgeList.get(0);\n+            // If original edge is found, the way is closed\n+            if (nextEdge != null && wayIds.contains(nextEdge.getIdentifier()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1OTY4OQ==", "bodyText": "slick suggestion! need to add our favorite .filter(Edge::isMasterEdge) to make it complete. thanks a lot!!", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444459689", "createdAt": "2020-06-23T19:33:45Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                        this.getLocalizedInstruction(0)));\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())\n+                // de-duplication sectioned edges\n+                .forEach(wayId -> connectedEdges.add(wayId.getOsmIdentifier())));\n+        return connectedEdges.size() > MINIMUM_INTERSECTION;\n+    }\n+\n+    /**\n+     * Check if Edge is part of Closed Way. See https://wiki.openstreetmap.org/wiki/Item:Q4669\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if edge is part of closed way.\n+     */\n+    private boolean isPartOfClosedWay(final Edge edge)\n+    {\n+        final HashSet<Long> wayIds = new HashSet<>();\n+        Edge nextEdge = edge;\n+        // Loop through out going edges with the same OSM id\n+        while (nextEdge != null)\n+        {\n+            wayIds.add(nextEdge.getIdentifier());\n+            final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)\n+                    .filter(outEdge -> outEdge.getOsmIdentifier() == edge.getOsmIdentifier())\n+                    .collectToList();\n+            nextEdge = nextEdgeList.isEmpty() ? null : nextEdgeList.get(0);\n+            // If original edge is found, the way is closed\n+            if (nextEdge != null && wayIds.contains(nextEdge.getIdentifier()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzY4Ng=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njk0MzI5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo0MzoyOFrOGmBONQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjo0ODo0N1rOGmbSsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTA5Mw==", "bodyText": "You use the way walker 3 times to collect the entire way (here, in buildOriginalOsmWayGeometry, and in intersectingWithMoreThan). While this is not a super expensive function, its repeated use can add up. It might be a bit better to call it once and then pass the edge set to each of the places that need it.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442519093", "createdAt": "2020-06-18T21:43:28Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTcwOA==", "bodyText": "Thanks for suggestion!", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442531708", "createdAt": "2020-06-18T22:16:27Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTA5Mw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk0NjIyNg==", "bodyText": "compilation time. tested against China data on local:\n1 - use WayWalker in each method - 7,48 min (current)\n2 - call WayWalker only ones and pass Set Edges to every method - 9,64 min\n3 - make Set Edges static - 8,50 minutes.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442946226", "createdAt": "2020-06-19T16:48:47Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        // process only first sectioned Edge\n+        if (edge.getIdentifier() % MODULUS == FIRST_EDGE_SECTION && edge.isMasterEdge()\n+                && HighwayTag.isCarNavigableHighway(edge) && edge.getTag(JunctionTag.KEY).isEmpty()\n+                && edge.getTag(AreaTag.KEY).isEmpty() && isPartOfClosedWay(edge)\n+                && intersectingWithMoreThan(edge))\n+        {\n+            // rebuild original OSM Way geometry\n+            final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+            // check maximum angle\n+            final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                    .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+            // check minimum angle\n+            final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                    .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+            if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+            {\n+                this.markAsFlagged(object.getOsmIdentifier());\n+                return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTA5Mw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njk0NDI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/OverlappingEdgeCheck.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo0Mzo0OVrOGmBOwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo0NTowOFrOGn54Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw==", "bodyText": "Why is this being added?", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442519233", "createdAt": "2020-06-18T21:43:49Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/OverlappingEdgeCheck.java", "diffHunk": "@@ -184,6 +184,7 @@ private boolean isPartOfClosedWay(final Edge object)\n         {\n             wayIds.add(nextEdge.getIdentifier());\n             final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMDEwMA==", "bodyText": "its a bug. please refer #302.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442530100", "createdAt": "2020-06-18T22:11:42Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/OverlappingEdgeCheck.java", "diffHunk": "@@ -184,6 +184,7 @@ private boolean isPartOfClosedWay(final Edge object)\n         {\n             wayIds.add(nextEdge.getIdentifier());\n             final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1NTM1Ng==", "bodyText": "For tracking purposes, I think this would be better in a separate PR.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444355356", "createdAt": "2020-06-23T16:31:06Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/OverlappingEdgeCheck.java", "diffHunk": "@@ -184,6 +184,7 @@ private boolean isPartOfClosedWay(final Edge object)\n         {\n             wayIds.add(nextEdge.getIdentifier());\n             final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NDUyNw==", "bodyText": "@Bentleysb This one has also been added. I think the branch is out of date with the dev branch.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444494527", "createdAt": "2020-06-23T20:42:28Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/OverlappingEdgeCheck.java", "diffHunk": "@@ -184,6 +184,7 @@ private boolean isPartOfClosedWay(final Edge object)\n         {\n             wayIds.add(nextEdge.getIdentifier());\n             final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NTkxOQ==", "bodyText": "@Bentleysb This has also been added in a prev PR. I think this branch is out of date with the dev branch.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444495919", "createdAt": "2020-06-23T20:45:08Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/OverlappingEdgeCheck.java", "diffHunk": "@@ -184,6 +184,7 @@ private boolean isPartOfClosedWay(final Edge object)\n         {\n             wayIds.add(nextEdge.getIdentifier());\n             final List<Edge> nextEdgeList = Iterables.stream(nextEdge.outEdges())\n+                    .filter(Edge::isMasterEdge)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTIzMw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njk0NjA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/base/BaseCheck.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTo0NDozNFrOGmBP3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDozNDoyN1rOGn5i9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTUxNw==", "bodyText": "Is there a reason for this change? It appears to be redundant as the atlas identifier already contains the OSM id.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442519517", "createdAt": "2020-06-18T21:44:34Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/base/BaseCheck.java", "diffHunk": "@@ -128,8 +128,8 @@ public BaseCheck(final Configuration configuration)\n         }\n         catch (final Exception oops)\n         {\n-            logger.error(String.format(\"%s failed on feature %s.\", this.getCheckName(),\n-                    object.getIdentifier()), oops);\n+            logger.error(String.format(\"%s failed on feature %s (%s).\", this.getCheckName(),\n+                    object.getIdentifier(), object.getOsmIdentifier()), oops);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNTM2OQ==", "bodyText": "yes. for debugging purpose its very convenient to copy original OSM id instead of playing with sectioned id in cases where original ID ends with 0 or small.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r442525369", "createdAt": "2020-06-18T21:59:18Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/base/BaseCheck.java", "diffHunk": "@@ -128,8 +128,8 @@ public BaseCheck(final Configuration configuration)\n         }\n         catch (final Exception oops)\n         {\n-            logger.error(String.format(\"%s failed on feature %s.\", this.getCheckName(),\n-                    object.getIdentifier()), oops);\n+            logger.error(String.format(\"%s failed on feature %s (%s).\", this.getCheckName(),\n+                    object.getIdentifier(), object.getOsmIdentifier()), oops);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTUxNw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5MDQ4Nw==", "bodyText": "@Bentleysb this change was integrated in https://github.com/osmlab/atlas-checks/pull/305/files", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444490487", "createdAt": "2020-06-23T20:34:27Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/base/BaseCheck.java", "diffHunk": "@@ -128,8 +128,8 @@ public BaseCheck(final Configuration configuration)\n         }\n         catch (final Exception oops)\n         {\n-            logger.error(String.format(\"%s failed on feature %s.\", this.getCheckName(),\n-                    object.getIdentifier()), oops);\n+            logger.error(String.format(\"%s failed on feature %s (%s).\", this.getCheckName(),\n+                    object.getIdentifier(), object.getOsmIdentifier()), oops);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxOTUxNw=="}, "originalCommit": {"oid": "a38d21649ceab4c02b57b3d45dbd6d1ac49df566"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTU1NDE5OnYy", "diffSide": "RIGHT", "path": "docs/available_checks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDozNzozM1rOGn5o1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDozNzozM1rOGn5o1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5MTk5MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444491991", "createdAt": "2020-06-23T20:37:33Z", "author": {"login": "sayas01"}, "path": "docs/available_checks.md", "diffHunk": "@@ -28,6 +28,7 @@ This document is a list of tables with a description and link to documentation f\n | [~~RoundaboutClosedLoopCheck~~ (Deprecated)](checks/roundaboutClosedLoopCheck.md) | The purpose of this check is to identify Roundabout Edges that are bi-directional or have an end Node with less than 2 connections.  **This check has been deprecated and is no longer active.** |\n | [RoundaboutConnectorCheck](checks/roundaboutConnectorCheck.md) | The purpose of this check is to identify roads that connect to a roundabout at too sharp an angle |\n | [RoundaboutValenceCheck](checks/roundaboutValenceCheck.md) | The purpose of this check is to identify OpenStreetMap (OSM) tagged roundabouts that have an unusual number of edges connected to them. |\n+| [RoundaboutMissingTag](checks/roundaboutMissingTagCheck.md) | The purpose of this check is to identify Roundabouts with missing junction=roundabout tag. Candidate must be navigable, closed and round shape OSM Way that intersects with at least two navigable roads. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTU3NTE5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo0NDoxNVrOGn52dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzoxODowOVrOGn9wzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NTQ3Ng==", "bodyText": "Could you update this description to include \"missing junction=roundabout\" ?", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444495476", "createdAt": "2020-06-23T20:44:15Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1OTU2Ng==", "bodyText": "thanks! added.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444559566", "createdAt": "2020-06-23T23:18:09Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NTQ3Ng=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTU3ODcyOnYy", "diffSide": "RIGHT", "path": "docs/available_checks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo0NToyNVrOGn54sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo0NToyNVrOGn54sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5NjA1MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444496050", "createdAt": "2020-06-23T20:45:25Z", "author": {"login": "sayas01"}, "path": "docs/available_checks.md", "diffHunk": "@@ -28,6 +28,7 @@ This document is a list of tables with a description and link to documentation f\n | [~~RoundaboutClosedLoopCheck~~ (Deprecated)](checks/roundaboutClosedLoopCheck.md) | The purpose of this check is to identify Roundabout Edges that are bi-directional or have an end Node with less than 2 connections.  **This check has been deprecated and is no longer active.** |\n | [RoundaboutConnectorCheck](checks/roundaboutConnectorCheck.md) | The purpose of this check is to identify roads that connect to a roundabout at too sharp an angle |\n | [RoundaboutValenceCheck](checks/roundaboutValenceCheck.md) | The purpose of this check is to identify OpenStreetMap (OSM) tagged roundabouts that have an unusual number of edges connected to them. |\n+| [RoundaboutMissingTag](checks/roundaboutMissingTagCheck.md) | The purpose of this check is to identify Roundabouts with missing junction=roundabout tag. Candidate must be navigable, closed and round shape OSM Way that intersects with at least two navigable roads. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTU4MzI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo0Njo0OVrOGn57fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo0Njo0OVrOGn57fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5Njc2Ng==", "bodyText": "nit: asList could be replaced with Collections.singletonList as it has just one item in it.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444496766", "createdAt": "2020-06-23T20:46:49Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTU5Mzk5OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo1MDowOVrOGn6Ceg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzo1MDo1N1rOGn-VpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5ODU1NA==", "bodyText": "Looks like the config is missing the \"threshold.degrees\" keys.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444498554", "createdAt": "2020-06-23T20:50:09Z", "author": {"login": "sayas01"}, "path": "config/configuration.json", "diffHunk": "@@ -711,6 +711,17 @@\n       \"difficulty\": \"NORMAL\"\n     }\n   },\n+  \"RoundaboutMissingTagCheck\": {\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2ODk5Ng==", "bodyText": "thanks! added.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444568996", "createdAt": "2020-06-23T23:50:57Z", "author": {"login": "vladlemberg"}, "path": "config/configuration.json", "diffHunk": "@@ -711,6 +711,17 @@\n       \"difficulty\": \"NORMAL\"\n     }\n   },\n+  \"RoundaboutMissingTagCheck\": {\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5ODU1NA=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTU5ODI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo1MTozM1rOGn6FGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzo1MToxNVrOGn-WAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5OTIyNg==", "bodyText": "Shouldn't there be two separate config keys, \"threshold.degrees.maximum\" and \"threshold.degrees.minimum\" ?", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444499226", "createdAt": "2020-06-23T20:51:33Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU2OTA4OA==", "bodyText": "added", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444569088", "createdAt": "2020-06-23T23:51:15Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5OTIyNg=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTU5OTY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo1MTo1OFrOGn6F-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo1MTo1OFrOGn6F-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ5OTQ1MQ==", "bodyText": "Nice. Unrelated to this PR, I think we should update ReverseIdentifierFactory.getWaySectionIndex(atlas id) for this as it seems to be gaining popularity", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444499451", "createdAt": "2020-06-23T20:51:58Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTYxNjAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo1NToxOFrOGn6RqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowMzoxMVrOGn9ePQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwMjQ0MA==", "bodyText": "OSM Way walker should give you master edges by default, so no need to filter", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444502440", "createdAt": "2020-06-23T20:55:18Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDgxMw==", "bodyText": "Thanks!", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444554813", "createdAt": "2020-06-23T23:03:11Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwMjQ0MA=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTYzMTQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDo1OTozNlrOGn6cWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzozMDowNVrOGocHZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNTE3OA==", "bodyText": "The way walker you used actually sorts by way section id (TreeSet) already so you could try using the default behavior. Ordering is defined in the WaySectionComparator", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444505178", "createdAt": "2020-06-23T20:59:36Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1Njg2OQ==", "bodyText": "thanks!", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445056869", "createdAt": "2020-06-24T17:30:05Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNTE3OA=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTY0NTQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTowMzo0NlrOGn6k-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTowMzo0NlrOGn6k-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNzM4Ng==", "bodyText": "nit: these could be combined to one statement  new OsmWayWalker(edge).collectEdges().stream() .filter(Edge::isMasterEdge).distinct() .sorted(Comparator.comparingLong(AtlasObject::getIdentifier)) .collect(Collectors.toList());", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444507386", "createdAt": "2020-06-23T21:03:46Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTY0NzY4OnYy", "diffSide": "RIGHT", "path": "docs/checks/roundaboutMissingTagCheck.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTowNDoyOFrOGn6mPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMDowNzoyMVrOGohTEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNzcwOA==", "bodyText": "If we're making sure a valid edge is the first section of a way to ensure that the way has more than 2 edges, we could note that here", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444507708", "createdAt": "2020-06-23T21:04:28Z", "author": {"login": "seancoulter"}, "path": "docs/checks/roundaboutMissingTagCheck.md", "diffHunk": "@@ -0,0 +1,39 @@\n+# Roundabout Missing Tag Check\n+\n+#### Description\n+This check identifies closed navigable ways https://wiki.openstreetmap.org/wiki/Item:Q4669 \n+that have a round shape and intersecting with at least two navigable ways.    \n+\n+#### Live Example\n+Roundabout without `junction=roundabout` tag.\n+1) [id:592687817](https://www.openstreetmap.org/way/592687817) \n+2) [id:548529232](https://www.openstreetmap.org/way/548529232)\n+3) [id:150664424](https://www.openstreetmap.org/way/150664424)\n+4) [id:287957529](https://www.openstreetmap.org/way/287957529)\n+\n+#### Code Review\n+\n+In [Atlas](https://github.com/osmlab/atlas), OSM elements are represented as Edges, Points, Lines, \n+Nodes & Relations; in our case, we\u2019re working with [Edges](https://github.com/osmlab/atlas/blob/dev/src/main/java/org/openstreetmap/atlas/geography/atlas/items/Edge.java).\n+In OpenStreetMap, roundabouts are [Ways](https://wiki.openstreetmap.org/wiki/Way) classified with\n+the `junction=roundabout` tag. We\u2019ll identify ways that are roundabouts without `junction=roundabout` tag.\n+\n+Our first goal is to validate the incoming Atlas Object.\n+* Must be a first section of valid master Edge\n+* Must have not already been flagged\n+* Must be car navigable\n+* Must have not `junction` and `area` tag\n+* Must be a closed way [OSM-wiki:Closed Way](https://wiki.openstreetmap.org/wiki/Item:Q4669)\n+* Must intersect at minimum with two navigable ways \n+\n+After the preliminary filtering of features we need to rebuild original OSM way geometry.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NDcxMw==", "bodyText": "its noted:\n\nMust be a first section of valid master Edge\nMust intersect at minimum with two navigable ways", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445054713", "createdAt": "2020-06-24T17:26:13Z", "author": {"login": "vladlemberg"}, "path": "docs/checks/roundaboutMissingTagCheck.md", "diffHunk": "@@ -0,0 +1,39 @@\n+# Roundabout Missing Tag Check\n+\n+#### Description\n+This check identifies closed navigable ways https://wiki.openstreetmap.org/wiki/Item:Q4669 \n+that have a round shape and intersecting with at least two navigable ways.    \n+\n+#### Live Example\n+Roundabout without `junction=roundabout` tag.\n+1) [id:592687817](https://www.openstreetmap.org/way/592687817) \n+2) [id:548529232](https://www.openstreetmap.org/way/548529232)\n+3) [id:150664424](https://www.openstreetmap.org/way/150664424)\n+4) [id:287957529](https://www.openstreetmap.org/way/287957529)\n+\n+#### Code Review\n+\n+In [Atlas](https://github.com/osmlab/atlas), OSM elements are represented as Edges, Points, Lines, \n+Nodes & Relations; in our case, we\u2019re working with [Edges](https://github.com/osmlab/atlas/blob/dev/src/main/java/org/openstreetmap/atlas/geography/atlas/items/Edge.java).\n+In OpenStreetMap, roundabouts are [Ways](https://wiki.openstreetmap.org/wiki/Way) classified with\n+the `junction=roundabout` tag. We\u2019ll identify ways that are roundabouts without `junction=roundabout` tag.\n+\n+Our first goal is to validate the incoming Atlas Object.\n+* Must be a first section of valid master Edge\n+* Must have not already been flagged\n+* Must be car navigable\n+* Must have not `junction` and `area` tag\n+* Must be a closed way [OSM-wiki:Closed Way](https://wiki.openstreetmap.org/wiki/Item:Q4669)\n+* Must intersect at minimum with two navigable ways \n+\n+After the preliminary filtering of features we need to rebuild original OSM way geometry.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNzcwOA=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MTc3Ng==", "bodyText": "Right -- i was more referring to the \"why\" we need to ensure a valid edge is the first section of the edge, as opposed to some other part of the edge. I might be alone in thinking that level of documentation is necessary so up to you!", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445141776", "createdAt": "2020-06-24T20:07:21Z", "author": {"login": "seancoulter"}, "path": "docs/checks/roundaboutMissingTagCheck.md", "diffHunk": "@@ -0,0 +1,39 @@\n+# Roundabout Missing Tag Check\n+\n+#### Description\n+This check identifies closed navigable ways https://wiki.openstreetmap.org/wiki/Item:Q4669 \n+that have a round shape and intersecting with at least two navigable ways.    \n+\n+#### Live Example\n+Roundabout without `junction=roundabout` tag.\n+1) [id:592687817](https://www.openstreetmap.org/way/592687817) \n+2) [id:548529232](https://www.openstreetmap.org/way/548529232)\n+3) [id:150664424](https://www.openstreetmap.org/way/150664424)\n+4) [id:287957529](https://www.openstreetmap.org/way/287957529)\n+\n+#### Code Review\n+\n+In [Atlas](https://github.com/osmlab/atlas), OSM elements are represented as Edges, Points, Lines, \n+Nodes & Relations; in our case, we\u2019re working with [Edges](https://github.com/osmlab/atlas/blob/dev/src/main/java/org/openstreetmap/atlas/geography/atlas/items/Edge.java).\n+In OpenStreetMap, roundabouts are [Ways](https://wiki.openstreetmap.org/wiki/Way) classified with\n+the `junction=roundabout` tag. We\u2019ll identify ways that are roundabouts without `junction=roundabout` tag.\n+\n+Our first goal is to validate the incoming Atlas Object.\n+* Must be a first section of valid master Edge\n+* Must have not already been flagged\n+* Must be car navigable\n+* Must have not `junction` and `area` tag\n+* Must be a closed way [OSM-wiki:Closed Way](https://wiki.openstreetmap.org/wiki/Item:Q4669)\n+* Must intersect at minimum with two navigable ways \n+\n+After the preliminary filtering of features we need to rebuild original OSM way geometry.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwNzcwOA=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTY1MjA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTowNTo1MlrOGn6o8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTowNTo1MlrOGn6o8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwODQwMw==", "bodyText": "Please avoid single letter variable names.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444508403", "createdAt": "2020-06-23T21:05:52Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTY1MjY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTowNjowMlrOGn6pSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowNToxN1rOGn9g7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwODQ4OQ==", "bodyText": "Nice, would be cool to have this pulled out into the Edge class or something sometime down the line", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444508489", "createdAt": "2020-06-23T21:06:02Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTUwMw==", "bodyText": "Thanks!", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444555503", "createdAt": "2020-06-23T23:05:17Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwODQ4OQ=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTY1NTk4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMTowNzowOVrOGn6rWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzoyOTowM1rOGocFMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwOTAxOA==", "bodyText": "We could cache the waywalker call at the beginning of this method", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444509018", "createdAt": "2020-06-23T21:07:09Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxMDQ3OA==", "bodyText": "Or potentially in the validCheckForObject method, as I see now the usage is out of this scope", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444510478", "createdAt": "2020-06-23T21:10:07Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwOTAxOA=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NjMwNw==", "bodyText": "yes. tested it, however it significantly slowing down the performance.\ncompilation time. tested against China data on local:\n1 - use WayWalker in each method - 7,48 min (current)\n2 - cache WayWalker and pass Set Edges to every method - 9,64 min", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445056307", "createdAt": "2020-06-24T17:29:03Z", "author": {"login": "vladlemberg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUwOTAxOA=="}, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTY2NjUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMToxMDoyNVrOGn6xog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMToxMDoyNVrOGn6xog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxMDYyNg==", "bodyText": "Same as my prev comment. .filter(edge -> edge.getTag(ServiceTag.KEY).isEmpty())", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r444510626", "createdAt": "2020-06-23T21:10:25Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,193 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed shaped and have minimum of two intersections with navigable roads.\n+ * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} connections. See\n+ * https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more information about\n+ * roundabouts\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays\n+            .asList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"threshold.degrees\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);\n+    }\n+\n+    /**\n+     * Flags an {@link Edge} is its circular shape and connected to at least\n+     * {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION} navigable roads. {@link Edge} doesn't\n+     * have junction=roundabout or area=yes tags.\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edge = (Edge) object;\n+\n+        final PolyLine originalGeom = buildOriginalOsmWayGeometry(edge);\n+        // check maximum angle\n+        final List<Tuple<Angle, Location>> maxOffendingAngles = originalGeom\n+                .anglesGreaterThanOrEqualTo(this.maxAngleThreshold);\n+        // check minimum angle\n+        final List<Tuple<Angle, Location>> minOffendingAngles = originalGeom\n+                .anglesLessThanOrEqualTo(this.minAngleThreshold);\n+\n+        if (maxOffendingAngles.isEmpty() && minOffendingAngles.isEmpty())\n+        {\n+            this.markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(createFlag(new OsmWayWalker(edge).collectEdges(),\n+                    this.getLocalizedInstruction(0)));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Build original OSW way geometry from all MasterEdge sections\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return original Way geometry polyline\n+     */\n+    private PolyLine buildOriginalOsmWayGeometry(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+\n+        // Sort sectioned Edges by Ids\n+        final List<Edge> sortedEdges = new ArrayList<>(edgesFormingOSMWay);\n+        sortedEdges.sort(Comparator.comparingLong(AtlasObject::getIdentifier));\n+\n+        // Build original OSM polyline\n+        PolyLine geometry = new PolyLine(sortedEdges.get(0).getRawGeometry());\n+        for (int i = 1; i < sortedEdges.size(); i++)\n+        {\n+            geometry = geometry.append(sortedEdges.get(i).asPolyLine());\n+        }\n+        return geometry;\n+    }\n+\n+    /**\n+     * Check if original OSM Way is intersecting with CAR_NAVIGABLE_HIGHWAYS. See {@link HighwayTag}\n+     *\n+     * @param edge\n+     *            entity to check\n+     * @return true if way intersecting with more more than\n+     *         {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+     */\n+    private boolean intersectingWithMoreThan(final Edge edge)\n+    {\n+        // Identify all sections of original OSM way\n+        final Set<Edge> edgesFormingOSMWay = new OsmWayWalker(edge).collectEdges().stream()\n+                .filter(Edge::isMasterEdge).collect(Collectors.toSet());\n+        final Set<Long> connectedEdges = new HashSet<>();\n+        edgesFormingOSMWay.forEach(obj -> obj.connectedEdges().stream().filter(Edge::isMasterEdge)\n+                // intersection with navigable roads\n+                .filter(HighwayTag::isCarNavigableHighway)\n+                .filter(e -> e.getTag(ServiceTag.KEY).isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25018e1f85a92876ce0eb774b6f570bec4dc3fa9"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzM5MzYyOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheckTestRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowNDowNFrOGofSBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowNDowNFrOGofSBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwODc0MQ==", "bodyText": "@vladlemberg Just one more request to clean up this class a bit. You can import @TestAtlas.Node, @TestAtlas.Node etc. here.", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445108741", "createdAt": "2020-06-24T19:04:04Z", "author": {"login": "sayas01"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheckTestRule.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.utilities.testing.CoreTestRule;\n+import org.openstreetmap.atlas.utilities.testing.TestAtlas;\n+\n+/**\n+ * {@link RoundaboutMissingTagCheckTest} data generator\n+ *\n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheckTestRule extends CoreTestRule\n+{\n+    // roundabout nodes\n+    private static final String TEST_NODE_VERTEX_1 = \"37.3293541,-121.9156701\";\n+    private static final String TEST_NODE_SHP_1 = \"37.3293187,-121.9157123\";\n+    private static final String TEST_NODE_SHP_2 = \"37.3292841,-121.9157281\";\n+    private static final String TEST_NODE_SHP_3 = \"37.3292474,-121.9157280\";\n+    private static final String TEST_NODE_VERTEX_2 = \"37.3292026,-121.9157035\";\n+    private static final String TEST_NODE_SHP_4 = \"37.3291717,-121.9156569\";\n+    private static final String TEST_NODE_SHP_5 = \"37.3291612,-121.9156132\";\n+    private static final String TEST_NODE_SHP_6 = \"37.3291632,-121.9155676\";\n+    private static final String TEST_NODE_VERTEX_3 = \"37.3291845,-121.9155131\";\n+    private static final String TEST_NODE_SHP_7 = \"37.3292123,-121.9154833\";\n+    private static final String TEST_NODE_SHP_8 = \"37.3292464,-121.9154672\";\n+    private static final String TEST_NODE_SHP_9 = \"37.3292949,-121.9154700\";\n+    private static final String TEST_NODE_VERTEX_4 = \"37.3293277,-121.9154900\";\n+    private static final String TEST_NODE_SHP_10 = \"37.3293534,-121.9155234\";\n+    private static final String TEST_NODE_SHP_11 = \"37.3293683,-121.9155658\";\n+    private static final String TEST_NODE_SHP_12 = \"37.3293686,-121.9156274\";\n+    // connected way nodes\n+    private static final String TEST_NODE_5 = \"37.3303971,-121.9139893\";\n+    private static final String TEST_NODE_6 = \"37.3281316,-121.9170493\";\n+\n+    @TestAtlas(\n+            // nodes\n+            nodes = { @TestAtlas.Node(coordinates = @TestAtlas.Loc(value = TEST_NODE_VERTEX_1)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5106dcae632cec5aefe8f667d804a74bdfeb329d"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzQwMTI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowNjoyNlrOGofW0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTowNjoyNlrOGofW0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwOTk2OA==", "bodyText": "nit: this.isPartOfClosedWay((Edge) object) && this.intersectingWithMoreThan((Edge) object)", "url": "https://github.com/osmlab/atlas-checks/pull/315#discussion_r445109968", "createdAt": "2020-06-24T19:06:26Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/RoundaboutMissingTagCheck.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.AreaTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.ServiceTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.tuples.Tuple;\n+\n+/**\n+ * Flags edges that are closed and round shaped without junction=roundabout tag and have minimum of\n+ * two intersections with navigable roads {@link RoundaboutMissingTagCheck#MINIMUM_INTERSECTION}\n+ * connections. See https://wiki.openstreetmap.org/wiki/Tag:junction%3Droundabout for more\n+ * information about roundabouts\n+ * \n+ * @author vladlemberg\n+ */\n+\n+public class RoundaboutMissingTagCheck extends BaseCheck<Long>\n+{\n+    // Instructions\n+    public static final String MISSING_JUNCTION_TAG_INSTRUCTION = \"This edge might be a roundabout\";\n+    // Minimum intersection with Navigable Roads\n+    private static final int MINIMUM_INTERSECTION = 2;\n+    private static final int MODULUS = 10;\n+    private static final int FIRST_EDGE_SECTION = 1;\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(MISSING_JUNCTION_TAG_INSTRUCTION);\n+    private static final double MAX_THRESHOLD_DEGREES_DEFAULT = 40.0;\n+    private static final double MIN_THRESHOLD_DEGREES_DEFAULT = 10.0;\n+    private final Angle maxAngleThreshold;\n+    private final Angle minAngleThreshold;\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public RoundaboutMissingTagCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.maxAngleThreshold = configurationValue(configuration, \"angle.threshold.maximum_degree\",\n+                MAX_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+        this.minAngleThreshold = configurationValue(configuration, \"angle.threshold.minimum_degree\",\n+                MIN_THRESHOLD_DEGREES_DEFAULT, Angle::degrees);\n+    }\n+\n+    /**\n+     * Validates if given {@link AtlasObject} is actually an {@link Edge} and is a potential\n+     * roundabout and also corresponding OSM identifier shouldn't be flagged before (this is for\n+     * avoiding duplicate flags)\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && !this.isFlagged(object.getOsmIdentifier())\n+                && object.getIdentifier() % MODULUS == FIRST_EDGE_SECTION\n+                && ((Edge) object).isMasterEdge() && HighwayTag.isCarNavigableHighway(object)\n+                && object.getTag(JunctionTag.KEY).isEmpty() && object.getTag(AreaTag.KEY).isEmpty()\n+                && isPartOfClosedWay((Edge) object) && intersectingWithMoreThan((Edge) object);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5106dcae632cec5aefe8f667d804a74bdfeb329d"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3332, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}