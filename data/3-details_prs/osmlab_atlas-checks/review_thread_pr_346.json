{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwOTgwMTA1", "number": 346, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo1Mjo0OVrOEhcRUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0NjowNlrOEhxBXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTAxNjUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/areas/WaterAreaCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo1Mjo0OVrOHOwnig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo1Mjo0OVrOHOwnig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzODY2Ng==", "bodyText": "Nit: extra line", "url": "https://github.com/osmlab/atlas-checks/pull/346#discussion_r485238666", "createdAt": "2020-09-08T22:52:49Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/areas/WaterAreaCheck.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.openstreetmap.atlas.checks.validation.areas;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.IntersectionUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Polygon;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This checks water areas for overlaps and missing waterways (where appropriate).\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterAreaCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -2567398383133412329L;\n+\n+    private static final List<String> WATER_FILTERS = Arrays\n+            .asList(\"natural->water&water->*|waterway->riverbank\");\n+    private static final List<String> WATER_FILTERS_WATERWAY = Arrays\n+            .asList(\"natural->water&water->river,stream_pool,canal,lock|waterway->riverbank\");\n+    private static final List<String> WATERWAY_FILTERS = Arrays.asList(\"waterway->*\");\n+\n+    // https://wiki.openstreetmap.org/wiki/Tag:waterway%3Ddam specifies that dams\n+    // may cross other waterways\n+    // Probably should not cross other waterways with the same tag though.\n+    private static final List<String> WATERWAY_CROSSING_IGNORE = Arrays.asList(\"waterway->dam\");\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            \"Waterway area (id={0,number,#}) is missing a waterway way.\",\n+            \"Waterway area (id={0,number,#}) has a waterway way, but there are none entering/exiting.\",\n+            \"Waterway area (id={0,number,#}) intersects with at least one other waterway area (id={1}).\");\n+\n+    private static final double MINIMUM_PROPORTION_DEFAULT = 0.01;\n+\n+    private final double minimumIntersect;\n+\n+    // List of TaggableFilters where each filter represents all tags for water areas\n+    // that\n+    // should not overlap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2148e21aaf15e86298fd96af1088eb945c660561"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTAyMjU0OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo1NTozMFrOHOwq-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo1NTozMFrOHOwq-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzOTU0NA==", "bodyText": "Please add the configurable items with their default values here.", "url": "https://github.com/osmlab/atlas-checks/pull/346#discussion_r485239544", "createdAt": "2020-09-08T22:55:30Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -1068,5 +1068,13 @@\n       \"difficulty\": \"EASY\",\n       \"defaultPriority\": \"LOW\"\n     }\n+  },\n+  \"WaterAreaCheck\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2148e21aaf15e86298fd96af1088eb945c660561"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODQxNjMxOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/areas/WaterAreaCheckTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0NjowNlrOHPQ04Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNzozNzoyMVrOHPS2dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2NjM2OQ==", "bodyText": "Is this going to be addressed in this PR?", "url": "https://github.com/osmlab/atlas-checks/pull/346#discussion_r485766369", "createdAt": "2020-09-09T16:46:06Z", "author": {"login": "sayas01"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/areas/WaterAreaCheckTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package org.openstreetmap.atlas.checks.validation.areas;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Tests for WaterAreaCheck\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterAreaCheckTest\n+{\n+    @Rule\n+    public WaterAreaCheckTestRule setup = new WaterAreaCheckTestRule();\n+\n+    @Rule\n+    public ConsumerBasedExpectedCheckVerifier verifier = new ConsumerBasedExpectedCheckVerifier();\n+\n+    /**\n+     * This was a test for a false-false positive. The false positive occurred due to the age of the\n+     * Belize pbf, where a waterway was drawn in April 2019 was not present.\n+     */\n+    @Test\n+    public void testBrazilRiverFalsePositive()\n+    {\n+        this.verifier.actual(this.setup.getBrazilRiverFalsePositive(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testMangoCreekAndUnnamedWaterwayBad()\n+    {\n+        this.verifier.actual(this.setup.getMangoCreekAtlasBad(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyExpectedSize(1);\n+        this.verifier.verify(f -> assertTrue(f.getFlaggedObjects().parallelStream()\n+                .filter(i -> i.getProperties().containsKey(\"identifier\"))\n+                .allMatch(i -> Arrays.asList(\"601378260\", \"265672061\")\n+                        .contains(i.getProperties().get(\"identifier\")))));\n+    }\n+\n+    @Test\n+    public void testMangoCreekAndUnnamedWaterwayGood()\n+    {\n+        this.verifier.actual(this.setup.getMangoCreekAtlasGood(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testMangoCreekAndUnnamedWaterwayMissingWaterwayLineBad()\n+    {\n+        this.verifier.actual(this.setup.getMangoCreekAtlasBadWaterway(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyExpectedSize(1);\n+        this.verifier.verify(f -> assertTrue(f.getFlaggedObjects().parallelStream()\n+                .allMatch(p -> \"601378260\".equals(p.getProperties().get(\"identifier\")))));\n+    }\n+\n+    @Test\n+    public void testMopanRiverFalsePositive()\n+    {\n+        this.verifier.actual(this.setup.getMopanRiverFalsePositive(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testOverlappingPonds()\n+    {\n+        this.verifier.actual(this.setup.getOverlappingPonds(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyExpectedSize(1);\n+        // TODO verify actual check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5be2474bf21b5248aa656569750b7714690cc28"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc5OTU0MA==", "bodyText": "I was intending to go and verify that I got one of the expected objects, but the flagged objects don't (currently) allow me to get the original AtlasObject back out. I could do some reflection to get it working, but I'd prefer to avoid that when I'm not unit testing that specific class.", "url": "https://github.com/osmlab/atlas-checks/pull/346#discussion_r485799540", "createdAt": "2020-09-09T17:37:21Z", "author": {"login": "tsmock"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/areas/WaterAreaCheckTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package org.openstreetmap.atlas.checks.validation.areas;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Tests for WaterAreaCheck\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterAreaCheckTest\n+{\n+    @Rule\n+    public WaterAreaCheckTestRule setup = new WaterAreaCheckTestRule();\n+\n+    @Rule\n+    public ConsumerBasedExpectedCheckVerifier verifier = new ConsumerBasedExpectedCheckVerifier();\n+\n+    /**\n+     * This was a test for a false-false positive. The false positive occurred due to the age of the\n+     * Belize pbf, where a waterway was drawn in April 2019 was not present.\n+     */\n+    @Test\n+    public void testBrazilRiverFalsePositive()\n+    {\n+        this.verifier.actual(this.setup.getBrazilRiverFalsePositive(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testMangoCreekAndUnnamedWaterwayBad()\n+    {\n+        this.verifier.actual(this.setup.getMangoCreekAtlasBad(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyExpectedSize(1);\n+        this.verifier.verify(f -> assertTrue(f.getFlaggedObjects().parallelStream()\n+                .filter(i -> i.getProperties().containsKey(\"identifier\"))\n+                .allMatch(i -> Arrays.asList(\"601378260\", \"265672061\")\n+                        .contains(i.getProperties().get(\"identifier\")))));\n+    }\n+\n+    @Test\n+    public void testMangoCreekAndUnnamedWaterwayGood()\n+    {\n+        this.verifier.actual(this.setup.getMangoCreekAtlasGood(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testMangoCreekAndUnnamedWaterwayMissingWaterwayLineBad()\n+    {\n+        this.verifier.actual(this.setup.getMangoCreekAtlasBadWaterway(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyExpectedSize(1);\n+        this.verifier.verify(f -> assertTrue(f.getFlaggedObjects().parallelStream()\n+                .allMatch(p -> \"601378260\".equals(p.getProperties().get(\"identifier\")))));\n+    }\n+\n+    @Test\n+    public void testMopanRiverFalsePositive()\n+    {\n+        this.verifier.actual(this.setup.getMopanRiverFalsePositive(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testOverlappingPonds()\n+    {\n+        this.verifier.actual(this.setup.getOverlappingPonds(),\n+                new WaterAreaCheck(ConfigurationResolver.emptyConfiguration()));\n+        this.verifier.verifyExpectedSize(1);\n+        // TODO verify actual check", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2NjM2OQ=="}, "originalCommit": {"oid": "f5be2474bf21b5248aa656569750b7714690cc28"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3152, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}