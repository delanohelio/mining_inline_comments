{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MDIxOTEw", "number": 297, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyMjoxOFrOD8OT8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjowNTowMFrOD8QLnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc1NjM1OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyMjoxOFrOGVCJkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyMjoxOFrOGVCJkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwODQ5Nw==", "bodyText": "I can see this expanding in the future:\nignore: {\ncase1\ncase2\ncase3\n}", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424708497", "createdAt": "2020-05-13T20:22:18Z", "author": {"login": "danielduhh"}, "path": "config/configuration.json", "diffHunk": "@@ -374,7 +374,15 @@\n       \"difficulty\":\"NORMAL\"\n     }\n   },\n-  \"InvalidMultiPolygonRelationCheck\": {},\n+  \"InvalidMultiPolygonRelationCheck\": {\n+    \"members.one.ignore\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTAxODI2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0ODoxOVrOGVEuYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0ODoxOVrOGVEuYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MDY4OQ==", "bodyText": "nit: Could be outerToInners.forEach((key, value) -> {}))", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424750689", "createdAt": "2020-05-13T21:48:19Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))\n+            {\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(\n+                                this.getLocalizedInstruction(MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                        Collections.emptySet()));\n             }\n+            // Catch inner members that are not inside an outer member\n+            if (exception.getMessage().contains(\"Malformed MultiPolygon: inner has no outer host\"))\n+            {\n+                return Optional\n+                        .of(Tuple.createTuple(\n+                                Collections.singleton(this.getLocalizedInstruction(\n+                                        INNER_MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                                Collections.emptySet()));\n+            }\n+\n+            // Ignore other core exceptions\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n         catch (final Exception exception)\n         {\n-            logger.warn(\"Unable to convert relation {}. {}\", relation.getOsmIdentifier(),\n-                    exception.getMessage());\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n \n         return Optional.empty();\n     }\n \n+    /**\n+     * Check that inner polygons do not intersect any outers and do not overlap other inners. Inners\n+     * are allowed to touch other inners.\n+     *\n+     * @param outerToInners\n+     *            {@link MultiMap} of outer {@link Polygon}s to inner {@link Polygon}s\n+     * @return a {@link Set} of {@link Tuple}s containing {@link Polygon}s that invalidly overlap\n+     */\n+    private Set<Tuple<Polygon, Polygon>> checkInnerOverlap(\n+            final MultiMap<Polygon, Polygon> outerToInners)\n+    {\n+        final Set<Tuple<Polygon, Polygon>> problematicPolygons = new HashSet<>();\n+\n+        outerToInners.entrySet().forEach(entry ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 326}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTAzNTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo1NDo0MlrOGVE5Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjozOToxMFrOGVF9fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MzQyNw==", "bodyText": "Should this come with a general flag indicating misplaced relation members?", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424753427", "createdAt": "2020-05-13T21:54:42Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MDk0MQ==", "bodyText": "This was just part of the refactor, not a new addition, so I had not really looked into that. I think you're right that it probably should be flagged. However, I would need to do some investigation to make sure it was not done like this to ignore atlas data errors, or something of that sort. I think that might be good to investigate outside this PR.", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424770941", "createdAt": "2020-05-13T22:39:10Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MzQyNw=="}, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTA1MDQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjowMDowOVrOGVFCCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjowMDowOVrOGVFCCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1NTcyMw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424755723", "createdAt": "2020-05-13T22:00:09Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))\n+            {\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(\n+                                this.getLocalizedInstruction(MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                        Collections.emptySet()));\n             }\n+            // Catch inner members that are not inside an outer member\n+            if (exception.getMessage().contains(\"Malformed MultiPolygon: inner has no outer host\"))\n+            {\n+                return Optional\n+                        .of(Tuple.createTuple(\n+                                Collections.singleton(this.getLocalizedInstruction(\n+                                        INNER_MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                                Collections.emptySet()));\n+            }\n+\n+            // Ignore other core exceptions\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n         catch (final Exception exception)\n         {\n-            logger.warn(\"Unable to convert relation {}. {}\", relation.getOsmIdentifier(),\n-                    exception.getMessage());\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n \n         return Optional.empty();\n     }\n \n+    /**\n+     * Check that inner polygons do not intersect any outers and do not overlap other inners. Inners\n+     * are allowed to touch other inners.\n+     *\n+     * @param outerToInners\n+     *            {@link MultiMap} of outer {@link Polygon}s to inner {@link Polygon}s\n+     * @return a {@link Set} of {@link Tuple}s containing {@link Polygon}s that invalidly overlap\n+     */\n+    private Set<Tuple<Polygon, Polygon>> checkInnerOverlap(\n+            final MultiMap<Polygon, Polygon> outerToInners)\n+    {\n+        final Set<Tuple<Polygon, Polygon>> problematicPolygons = new HashSet<>();\n+\n+        outerToInners.entrySet().forEach(entry ->\n+        {\n+            // Loop through each combination of inner polygons only once to check for overlap\n+            for (int index1 = 0; index1 < entry.getValue().size() - 1; index1++)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 329}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTA2MjcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjowNTowMFrOGVFKEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjozOTowOFrOGVF9ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1Nzc3Ng==", "bodyText": "Not sure if this is the best way to assign instructions for the different cases. The instructions could get changed in the future. Something to look out for.", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424757776", "createdAt": "2020-05-13T22:05:00Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MDkxNg==", "bodyText": "It's not ideal, but if it does change it should be caught by the unit tests.", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424770916", "createdAt": "2020-05-13T22:39:08Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1Nzc3Ng=="}, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 279}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3312, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}