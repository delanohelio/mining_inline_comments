{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MDIxOTEw", "number": 297, "title": "InvalidMultiPolygonRelationCheck Geometry Enhancement", "bodyText": "Description:\nThis adds a number of new possible conditions to InvalidMultiPolygonRelationCheck  for flagging a feature.\nAll of the new conditions are to check for invalid geometry combinations:\n\nHas any inner members that are not contained by an outer member\nHas any outer members that overlap\nHas any inner members that overlap with another inner member, but just touching is fine\nHas any inner relations that intersect an outer member\n\nThese combinations are all defined as invalid by the OSM Wiki\nTwo other smaller changes are also included.\nA configurable switch has been added to exclude one member relations from this check. This is meant to be used when running this check with OneMemberRelationCheck to prevent duplicate flags.\nThe flag method has been heavily refactored to reduce the cognitive complexity, as sonar was complaining.\nPotential Impact:\nFlags for this check are expected to fluctuate. There are large drops when the new switch is active, and lower numbers of additions from the new conditions.\nUnit Test Approach:\nAdded new unit test for all the new conditions and the new switch.\nTest Results:\nSampled flags from 7 countries. All results were as expected.", "createdAt": "2020-05-12T23:12:30Z", "url": "https://github.com/osmlab/atlas-checks/pull/297", "merged": true, "mergeCommit": {"oid": "d4637c480020263e4521e99586ef6f77c59fa438"}, "closed": true, "closedAt": "2020-05-13T23:44:32Z", "author": {"login": "Bentleysb"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYShaVgH2gAyNDE3MDIxOTEwOmU5NWQzYzNiNmEzMzNiZTc0NDljN2FhNDVmZWIwMWUxMzBjYWIzOGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchBghwgFqTQxMTI3MDY2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e95d3c3b6a333be7449c7aa45feb01e130cab38e", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/e95d3c3b6a333be7449c7aa45feb01e130cab38e", "committedDate": "2020-04-16T20:15:03Z", "message": "geometry check; refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce677f2ac01f884d1e97f7683409d51770bec05a", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/ce677f2ac01f884d1e97f7683409d51770bec05a", "committedDate": "2020-04-21T17:25:46Z", "message": "ignore one member"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fc4def677c92a254fd0bd77151b5a3bc51316a3", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3fc4def677c92a254fd0bd77151b5a3bc51316a3", "committedDate": "2020-05-01T18:48:32Z", "message": "ignore country slicing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/dc8d91fa5597f6303c09e146d5d88ddac9c171d4", "committedDate": "2020-05-13T15:23:16Z", "message": "Merge branch 'dev' into dev-multiPolyGeomCheck"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzIzODA0", "url": "https://github.com/osmlab/atlas-checks/pull/297#pullrequestreview-411323804", "createdAt": "2020-05-13T21:48:19Z", "commit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "state": "DISMISSED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo0ODoxOVrOGVEuYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjowNTowMFrOGVFKEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MDY4OQ==", "bodyText": "nit: Could be outerToInners.forEach((key, value) -> {}))", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424750689", "createdAt": "2020-05-13T21:48:19Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))\n+            {\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(\n+                                this.getLocalizedInstruction(MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                        Collections.emptySet()));\n             }\n+            // Catch inner members that are not inside an outer member\n+            if (exception.getMessage().contains(\"Malformed MultiPolygon: inner has no outer host\"))\n+            {\n+                return Optional\n+                        .of(Tuple.createTuple(\n+                                Collections.singleton(this.getLocalizedInstruction(\n+                                        INNER_MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                                Collections.emptySet()));\n+            }\n+\n+            // Ignore other core exceptions\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n         catch (final Exception exception)\n         {\n-            logger.warn(\"Unable to convert relation {}. {}\", relation.getOsmIdentifier(),\n-                    exception.getMessage());\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n \n         return Optional.empty();\n     }\n \n+    /**\n+     * Check that inner polygons do not intersect any outers and do not overlap other inners. Inners\n+     * are allowed to touch other inners.\n+     *\n+     * @param outerToInners\n+     *            {@link MultiMap} of outer {@link Polygon}s to inner {@link Polygon}s\n+     * @return a {@link Set} of {@link Tuple}s containing {@link Polygon}s that invalidly overlap\n+     */\n+    private Set<Tuple<Polygon, Polygon>> checkInnerOverlap(\n+            final MultiMap<Polygon, Polygon> outerToInners)\n+    {\n+        final Set<Tuple<Polygon, Polygon>> problematicPolygons = new HashSet<>();\n+\n+        outerToInners.entrySet().forEach(entry ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1Nzc3Ng==", "bodyText": "Not sure if this is the best way to assign instructions for the different cases. The instructions could get changed in the future. Something to look out for.", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424757776", "createdAt": "2020-05-13T22:05:00Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzI3MTEx", "url": "https://github.com/osmlab/atlas-checks/pull/297#pullrequestreview-411327111", "createdAt": "2020-05-13T21:54:42Z", "commit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo1NDo0MlrOGVE5Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjowMDowOVrOGVFCCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MzQyNw==", "bodyText": "Should this come with a general flag indicating misplaced relation members?", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424753427", "createdAt": "2020-05-13T21:54:42Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1NTcyMw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424755723", "createdAt": "2020-05-13T22:00:09Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/relations/InvalidMultiPolygonRelationCheck.java", "diffHunk": "@@ -185,43 +161,254 @@ else if (!relationMember.getRole().equals(RelationTypeTag.MULTIPOLYGON_ROLE_INNE\n         return FALLBACK_INSTRUCTIONS;\n     }\n \n-    private Optional<String> checkClosedLoop(final Relation relation)\n+    /**\n+     * Check that a multipolygon {@link Relation} has valid geometry.\n+     *\n+     * @param multipolygonRelation\n+     *            {@link Relation} of type multipolygon\n+     * @return an Optional containing a {@link Tuple} containing a {@link Set} of {@link String}\n+     *         instructions for invalid geometries and a {@link Set} of {@link Location}s marking\n+     *         the invalid geometries\n+     */\n+    private Optional<Tuple<Set<String>, Set<Location>>> checkGeometry(\n+            final Relation multipolygonRelation)\n     {\n+        // Try converting the Relation to a MultiPolygon. If it works check that the geometries\n+        // don't overlap.\n         try\n         {\n-            RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(relation);\n+            return Optional.of(checkOverlap(\n+                    RELATION_OR_AREA_TO_MULTI_POLYGON_CONVERTER.convert(multipolygonRelation),\n+                    multipolygonRelation.getOsmIdentifier()));\n         }\n+        // Catch open polygons and mark the broken locations\n         catch (final MultiplePolyLineToPolygonsConverter.OpenPolygonException exception)\n         {\n             final List<Location> openLocations = exception.getOpenLocations();\n             final Set<AtlasObject> objects = openLocations.stream()\n-                    .flatMap(location -> this.filterMembers(relation, location))\n+                    .flatMap(location -> this.filterMembers(multipolygonRelation, location))\n                     .collect(Collectors.toSet());\n-            final Set<Long> memberIds = relation.members().stream()\n+            final Set<Long> memberIds = multipolygonRelation.members().stream()\n                     .map(member -> member.getEntity().getOsmIdentifier())\n                     .collect(Collectors.toSet());\n \n             if (!objects.isEmpty() && !memberIds.isEmpty())\n             {\n-                return Optional\n-                        .of(this.getLocalizedInstruction(CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n-                                relation.getOsmIdentifier(), memberIds, openLocations));\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(this.getLocalizedInstruction(\n+                                CLOSED_LOOP_INSTRUCTION_FORMAT_INDEX,\n+                                multipolygonRelation.getOsmIdentifier(), memberIds, openLocations)),\n+                        new HashSet<>(openLocations)));\n             }\n             else\n             {\n-                logger.warn(\"Unable to find members in relation {} containing the locations : {}\",\n-                        relation, openLocations);\n+                logger.warn(\n+                        \"Unable to find members in multipolygonRelation {} containing the locations : {}\",\n+                        multipolygonRelation, openLocations);\n+            }\n+        }\n+        catch (final CoreException exception)\n+        {\n+            // Catch multipolygon relations with no outer members\n+            if (exception.getMessage().equals(\"Unable to find outer polygon.\"))\n+            {\n+                return Optional.of(Tuple.createTuple(\n+                        Collections.singleton(\n+                                this.getLocalizedInstruction(MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                        Collections.emptySet()));\n             }\n+            // Catch inner members that are not inside an outer member\n+            if (exception.getMessage().contains(\"Malformed MultiPolygon: inner has no outer host\"))\n+            {\n+                return Optional\n+                        .of(Tuple.createTuple(\n+                                Collections.singleton(this.getLocalizedInstruction(\n+                                        INNER_MISSING_OUTER_INSTRUCTION_FORMAT_INDEX,\n+                                        multipolygonRelation.getOsmIdentifier())),\n+                                Collections.emptySet()));\n+            }\n+\n+            // Ignore other core exceptions\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n         catch (final Exception exception)\n         {\n-            logger.warn(\"Unable to convert relation {}. {}\", relation.getOsmIdentifier(),\n-                    exception.getMessage());\n+            logger.warn(\"Unable to convert multipolygonRelation {}. {}\",\n+                    multipolygonRelation.getOsmIdentifier(), exception.getMessage());\n         }\n \n         return Optional.empty();\n     }\n \n+    /**\n+     * Check that inner polygons do not intersect any outers and do not overlap other inners. Inners\n+     * are allowed to touch other inners.\n+     *\n+     * @param outerToInners\n+     *            {@link MultiMap} of outer {@link Polygon}s to inner {@link Polygon}s\n+     * @return a {@link Set} of {@link Tuple}s containing {@link Polygon}s that invalidly overlap\n+     */\n+    private Set<Tuple<Polygon, Polygon>> checkInnerOverlap(\n+            final MultiMap<Polygon, Polygon> outerToInners)\n+    {\n+        final Set<Tuple<Polygon, Polygon>> problematicPolygons = new HashSet<>();\n+\n+        outerToInners.entrySet().forEach(entry ->\n+        {\n+            // Loop through each combination of inner polygons only once to check for overlap\n+            for (int index1 = 0; index1 < entry.getValue().size() - 1; index1++)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 329}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f8fe9049ee2c6aaf9d6637425ae73968afe6a4e", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/6f8fe9049ee2c6aaf9d6637425ae73968afe6a4e", "committedDate": "2020-05-13T22:44:35Z", "message": "better forEach"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzU5OTQ1", "url": "https://github.com/osmlab/atlas-checks/pull/297#pullrequestreview-411359945", "createdAt": "2020-05-13T23:08:43Z", "commit": {"oid": "6f8fe9049ee2c6aaf9d6637425ae73968afe6a4e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzYwMjY2", "url": "https://github.com/osmlab/atlas-checks/pull/297#pullrequestreview-411360266", "createdAt": "2020-05-13T23:09:37Z", "commit": {"oid": "6f8fe9049ee2c6aaf9d6637425ae73968afe6a4e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjcwNjYz", "url": "https://github.com/osmlab/atlas-checks/pull/297#pullrequestreview-411270663", "createdAt": "2020-05-13T20:22:18Z", "commit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyMjoxOFrOGVCJkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyMjoxOFrOGVCJkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwODQ5Nw==", "bodyText": "I can see this expanding in the future:\nignore: {\ncase1\ncase2\ncase3\n}", "url": "https://github.com/osmlab/atlas-checks/pull/297#discussion_r424708497", "createdAt": "2020-05-13T20:22:18Z", "author": {"login": "danielduhh"}, "path": "config/configuration.json", "diffHunk": "@@ -374,7 +374,15 @@\n       \"difficulty\":\"NORMAL\"\n     }\n   },\n-  \"InvalidMultiPolygonRelationCheck\": {},\n+  \"InvalidMultiPolygonRelationCheck\": {\n+    \"members.one.ignore\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc8d91fa5597f6303c09e146d5d88ddac9c171d4"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3336, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}