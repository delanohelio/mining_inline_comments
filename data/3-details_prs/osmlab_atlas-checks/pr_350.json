{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczMjM1ODYy", "number": 350, "title": "New check: TunnelBridgeHeightLimitCheck (#343)", "bodyText": "Description:\nPort of Osmose check #7130. Flags tunnels, covered roads and roads crossing bridges, for which maxheight or maxheight:physical tag is not provided.\nIssue #343\nPotential Impact:\nNone.\nUnit Test Approach:\nUnit tests created for each of the three positive scenarios (a tunnel, a covered road and a road which passes under a bridge) and several negative scenarios (when some of the preconditions or check criteria are not met). Tests use local mini-atlases with artificial data.\nTest Results:\n\n\n\nISO\nTotal Flags\nSampled\nSampling %\nTP\nFP\nFalse Positive Rate\n\n\n\n\nNZL\n307\n77\n25%\n77\n0\n0%\n\n\nDNK\n568\n127\n22%\n127\n0\n0%\n\n\nARG\n734\n110\n15%\n110\n0\n0%\n\n\nLUX\n199\n50\n25%\n50\n0\n0%\n\n\nVNM\n772\n80\n10%\n80\n0\n0%", "createdAt": "2020-08-25T14:17:17Z", "url": "https://github.com/osmlab/atlas-checks/pull/350", "merged": true, "mergeCommit": {"oid": "6c987dd8bb0e87df4900e9a7a605f6a13ecfce7d"}, "closed": true, "closedAt": "2020-10-07T21:36:13Z", "author": {"login": "ladwlo"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCdqOTgBqjM2OTE5MDc2NTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQTjF6gFqTUwNDI2NzQ3Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "56854c3b27d87826e6072f403a900693490219f4", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/56854c3b27d87826e6072f403a900693490219f4", "committedDate": "2020-08-25T20:47:16Z", "message": "Test coverage + minor bug fix"}, "afterCommit": {"oid": "c0db02a919861fca0d06e569a85392fddbb61671", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c0db02a919861fca0d06e569a85392fddbb61671", "committedDate": "2020-08-25T20:57:52Z", "message": "New check: TunnelBridgeHeightLimitCheck (#343)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d22712d99568f935a21da620153da18dc70ac1bb", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d22712d99568f935a21da620153da18dc70ac1bb", "committedDate": "2020-08-26T09:29:57Z", "message": "Minor fix (missing diamond operator)"}, "afterCommit": {"oid": "2c9ad6302705b92637e1fe2bf09ca0ba8a03eeed", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2c9ad6302705b92637e1fe2bf09ca0ba8a03eeed", "committedDate": "2020-08-26T09:49:42Z", "message": "New check: TunnelBridgeHeightLimitCheck"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c9ad6302705b92637e1fe2bf09ca0ba8a03eeed", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2c9ad6302705b92637e1fe2bf09ca0ba8a03eeed", "committedDate": "2020-08-26T09:49:42Z", "message": "New check: TunnelBridgeHeightLimitCheck"}, "afterCommit": {"oid": "fd82582051d96ce48edff07066affea43eabd61c", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/fd82582051d96ce48edff07066affea43eabd61c", "committedDate": "2020-09-17T13:59:19Z", "message": "New check: TunnelBridgeHeightLimitCheck"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd82582051d96ce48edff07066affea43eabd61c", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/fd82582051d96ce48edff07066affea43eabd61c", "committedDate": "2020-09-17T13:59:19Z", "message": "New check: TunnelBridgeHeightLimitCheck"}, "afterCommit": {"oid": "b40201841647fc118f3a26d59db7a504cbf286fb", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b40201841647fc118f3a26d59db7a504cbf286fb", "committedDate": "2020-09-25T13:12:51Z", "message": "Replacing deprecated language"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1648c7f093e12c6542cb11ad6faa66c32ce63c5c", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/1648c7f093e12c6542cb11ad6faa66c32ce63c5c", "committedDate": "2020-09-25T13:15:41Z", "message": "New check: TunnelBridgeHeightLimitCheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0070b8b802c2b1a46a512369a53aeb2cc08d2be9", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/0070b8b802c2b1a46a512369a53aeb2cc08d2be9", "committedDate": "2020-09-25T13:15:41Z", "message": "Replacing deprecated language"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b40201841647fc118f3a26d59db7a504cbf286fb", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b40201841647fc118f3a26d59db7a504cbf286fb", "committedDate": "2020-09-25T13:12:51Z", "message": "Replacing deprecated language"}, "afterCommit": {"oid": "0070b8b802c2b1a46a512369a53aeb2cc08d2be9", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/0070b8b802c2b1a46a512369a53aeb2cc08d2be9", "committedDate": "2020-09-25T13:15:41Z", "message": "Replacing deprecated language"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22e42d35dbabe329426cd84b8c323152903ad66d", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/22e42d35dbabe329426cd84b8c323152903ad66d", "committedDate": "2020-09-25T13:25:35Z", "message": "CheckStyle fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODY3MDg1", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-500867085", "createdAt": "2020-10-02T05:28:35Z", "commit": {"oid": "22e42d35dbabe329426cd84b8c323152903ad66d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNToyODozNVrOHbhj9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNToyODozNVrOHbhj9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzQ3OA==", "bodyText": "We could use a highway tag configurable value here in case we'd ever want to change the list of acceptable highway tags.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r498623478", "createdAt": "2020-10-02T05:28:35Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes:</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author wlodarsk\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));\n+        }\n+        // case 3 (road passing under bridge)\n+        if (BridgeTag.isBridge(object))\n+        {\n+            final Edge bridge = (Edge) object;\n+            final PolyLine bridgeAsPolyLine = bridge.asPolyLine();\n+            final Set<Edge> edgesToFlag = new HashSet<>();\n+            Iterables.stream(bridge.getAtlas().edgesIntersecting(bridge.bounds()))\n+                    .filter(edge -> edge.isMainEdge()\n+                            && edge.getOsmIdentifier() != bridge.getOsmIdentifier()\n+                            && !isFlagged(edge.getOsmIdentifier())\n+                            && this.isHighwayWithoutMaxHeight(edge)\n+                            && this.edgeCrossesBridge(edge.asPolyLine(), bridgeAsPolyLine))\n+                    .forEach(edge ->\n+                    {\n+                        markAsFlagged(edge.getOsmIdentifier());\n+                        edgesToFlag.add(edge);\n+                    });\n+            if (!edgesToFlag.isEmpty())\n+            {\n+                final CheckFlag checkFlag = new CheckFlag(getTaskIdentifier(bridge));\n+                edgesToFlag.forEach(\n+                        edge -> checkFlag.addObject(edge, getLocalizedInstruction(BRIDGE_CASE_INDEX,\n+                                edge.getOsmIdentifier(), bridge.getOsmIdentifier())));\n+                return Optional.of(checkFlag);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    // check if the two polylines intersect at any location other than the bridge's endpoints\n+    private boolean edgeCrossesBridge(final PolyLine edge, final PolyLine bridge)\n+    {\n+        return edge.intersections(bridge).stream()\n+                .anyMatch(loc -> !loc.equals(bridge.first()) && !loc.equals(bridge.last()));\n+    }\n+\n+    private boolean isCovered(final AtlasObject object)\n+    {\n+        return Validators.isOfType(object, CoveredTag.class, CoveredTag.YES, CoveredTag.ARCADE,\n+                CoveredTag.COLONNADE);\n+    }\n+\n+    private boolean isHighwayWithoutMaxHeight(final AtlasObject object)\n+    {\n+        return Validators.isOfType(object, HighwayTag.class, HighwayTag.MOTORWAY_LINK,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22e42d35dbabe329426cd84b8c323152903ad66d"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34184a5e0ba293ab99df1271756dbf322e42172d", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/34184a5e0ba293ab99df1271756dbf322e42172d", "committedDate": "2020-10-02T10:27:43Z", "message": "Making highway type filter configurable (code review remark)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/fc3b1c5b00bb13f67f84237e59c58f19e09ef343", "committedDate": "2020-10-02T10:30:53Z", "message": "CheckStyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjIyNDc5", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-501222479", "createdAt": "2020-10-02T15:12:39Z", "commit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDQyNjk0", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-503442694", "createdAt": "2020-10-07T00:12:18Z", "commit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxMjoxOFrOHdeKng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxMjoyOVrOHdeKzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NDk5MA==", "bodyText": "When flagging an Edge we generally want to flag all of the main edges with that OSM ID. This makes it less confusing if the flags are used to create MapRoulette challenges. See InvalidTagsCheck for an example.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r500664990", "createdAt": "2020-10-07T00:12:18Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes (configurable):</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author ladwlo\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->motorway_link,trunk_link,primary,primary_link,secondary,secondary_link\";\n+\n+    private final TaggableFilter highwayFilter;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTAzNg==", "bodyText": "Same as above.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r500665036", "createdAt": "2020-10-07T00:12:29Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes (configurable):</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author ladwlo\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->motorway_link,trunk_link,primary,primary_link,secondary,secondary_link\";\n+\n+    private final TaggableFilter highwayFilter;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));\n+        }\n+        // case 3 (road passing under bridge)\n+        if (BridgeTag.isBridge(object))\n+        {\n+            final Edge bridge = (Edge) object;\n+            final PolyLine bridgeAsPolyLine = bridge.asPolyLine();\n+            final Set<Edge> edgesToFlag = new HashSet<>();\n+            Iterables.stream(bridge.getAtlas().edgesIntersecting(bridge.bounds()))\n+                    .filter(edge -> edge.isMainEdge()\n+                            && edge.getOsmIdentifier() != bridge.getOsmIdentifier()\n+                            && !isFlagged(edge.getOsmIdentifier())\n+                            && this.isHighwayWithoutMaxHeight(edge)\n+                            && this.edgeCrossesBridge(edge.asPolyLine(), bridgeAsPolyLine))\n+                    .forEach(edge ->\n+                    {\n+                        markAsFlagged(edge.getOsmIdentifier());\n+                        edgesToFlag.add(edge);\n+                    });\n+            if (!edgesToFlag.isEmpty())\n+            {\n+                final CheckFlag checkFlag = new CheckFlag(getTaskIdentifier(bridge));\n+                edgesToFlag.forEach(\n+                        edge -> checkFlag.addObject(edge, getLocalizedInstruction(BRIDGE_CASE_INDEX,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fa1c3fbdc05591dde896f0568cce68ee441f07e", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/0fa1c3fbdc05591dde896f0568cce68ee441f07e", "committedDate": "2020-10-07T09:03:57Z", "message": "Flagging all Edges of a related OSM Way (code review remark)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDc1MzM4", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-504075338", "createdAt": "2020-10-07T16:46:14Z", "commit": {"oid": "0fa1c3fbdc05591dde896f0568cce68ee441f07e"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDk1NTAz", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-504095503", "createdAt": "2020-10-07T17:10:37Z", "commit": {"oid": "0fa1c3fbdc05591dde896f0568cce68ee441f07e"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24082d20304a56067d0b15b949d11e5ed5170a80", "author": {"user": {"login": "ladwlo", "name": "\u0141adys\u0142aw W\u0142odarski"}}, "url": "https://github.com/osmlab/atlas-checks/commit/24082d20304a56067d0b15b949d11e5ed5170a80", "committedDate": "2020-10-07T20:42:42Z", "message": "Adding the tunnel/bridge maxheight check to the list of available checks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjUyNjU0", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-504252654", "createdAt": "2020-10-07T20:44:47Z", "commit": {"oid": "24082d20304a56067d0b15b949d11e5ed5170a80"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjY3MTIw", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-504267120", "createdAt": "2020-10-07T21:05:59Z", "commit": {"oid": "24082d20304a56067d0b15b949d11e5ed5170a80"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjY3NDcz", "url": "https://github.com/osmlab/atlas-checks/pull/350#pullrequestreview-504267473", "createdAt": "2020-10-07T21:06:33Z", "commit": {"oid": "24082d20304a56067d0b15b949d11e5ed5170a80"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3162, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}