{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MzAyMzU4", "number": 432, "title": "tollValidationCheck", "bodyText": "Description:\nThis check attempts to validate toll tags based on the scenarios listed below.\nStrategy\n\n\nCase 1: Intersects toll feature but missing toll tag.\n** Toll tag should be added for all ways that intersect toll features.\n\n\nCase 2: Inconsistent toll tags\n** Out of place way that is between 2 ways with toll=yes.\n** Toll tag should be added to way in question if modeling surrounding way in question is correct.\n\n\nCase 3: Escapable toll\n** Checks for toll tag modeling issues by recursively checking possible routes and if they require a toll. Surrounding ways' toll tags and nearby toll features, if applicable, need to be investigated for proper modeling.\n\n\nTest Results:\n\n\n\nISO\nCase 1 Sampled\nCase 1 FP\nCase 1 FPR\nCase 2 Sampled\nCase 2 FP\nCase 2 FPR\nCase 3 Sampled\nCase 3 FP\nCase 3 FPR\n\n\n\n\nARG\n104\n3\n2.84%\n5\n0\n0%\n10\n0\n0%\n\n\nAUS\n34\n3\n8.82%\n1\n0\n0%\n1\n0\n0%\n\n\nHUN\n7\n0\n0%\n3\n0\n0%\n7\n0\n0%\n\n\nTUR\n76\n2\n2.63%\n19\n0\n0%\n10\n0\n0%\n\n\nNOR\n85\n2\n2.35%\n16\n0\n0%\n10\n0\n0%", "createdAt": "2020-11-19T23:38:16Z", "url": "https://github.com/osmlab/atlas-checks/pull/432", "merged": true, "mergeCommit": {"oid": "e9d14f87365f3fe0230775b549d1de36427c6435"}, "closed": true, "closedAt": "2020-12-02T19:06:41Z", "author": {"login": "reichg"}, "timelineItems": {"totalCount": 40, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdU0tBzAH2gAyNTI0MzAyMzU4OmI4MTBlZDZiNzAxZDRkZTNlNTZhNDkxYTJiNjE0ZTQ3MmE3NmFiNTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdiTPJWAFqTU0MzE0MzQ4NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b810ed6b701d4de3e56a491a2b614e472a76ab59", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b810ed6b701d4de3e56a491a2b614e472a76ab59", "committedDate": "2020-10-21T21:59:58Z", "message": "new atlas check for tollescape"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9265e7d0ed3c80ac78c4f9bd6aef1f836ef5cee", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b9265e7d0ed3c80ac78c4f9bd6aef1f836ef5cee", "committedDate": "2020-10-23T21:03:22Z", "message": "merged dev"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c746a9ada8c1090b6d35d849eb329da4761ee568", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c746a9ada8c1090b6d35d849eb329da4761ee568", "committedDate": "2020-11-05T21:50:10Z", "message": "Merge branch 'dev' of https://github.com/reichg/atlas-checks into tollEscapeCheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7e3a35ec7a43db4861ff63818f14a69faf2d2a6", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c7e3a35ec7a43db4861ff63818f14a69faf2d2a6", "committedDate": "2020-11-05T21:53:12Z", "message": "tollEscapeCheck first iteration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c02c6fa18221b7637fe06933cec1ff83b4571d04", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c02c6fa18221b7637fe06933cec1ff83b4571d04", "committedDate": "2020-11-13T23:22:49Z", "message": "3 case toll validation check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10355af3da49f2f18c3941b766e64876605e6247", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/10355af3da49f2f18c3941b766e64876605e6247", "committedDate": "2020-11-18T20:25:57Z", "message": "3 case check, finishing unit tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "676db9e71fd0f0a496ae0b64eb6457ccf7809d6c", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/676db9e71fd0f0a496ae0b64eb6457ccf7809d6c", "committedDate": "2020-11-18T21:17:51Z", "message": "spotless apply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcda68babdb0ac477c16f531356e8705a01d897a", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/dcda68babdb0ac477c16f531356e8705a01d897a", "committedDate": "2020-11-18T21:20:53Z", "message": "Merge branch 'dev' of https://github.com/reichg/atlas-checks into tollEscapeCheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f75349184541d383da5d1b4200a4371980af3d5", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4f75349184541d383da5d1b4200a4371980af3d5", "committedDate": "2020-11-18T22:27:49Z", "message": "removing dockerfile to exclude it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cf3dbb4e0db99e2bd8c01f9ba5de17c85c83d1e", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3cf3dbb4e0db99e2bd8c01f9ba5de17c85c83d1e", "committedDate": "2020-11-19T01:44:45Z", "message": "updated instructions, status: in false positive analysis phase."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2802973d8a3541303193e0727f65a48783c187a0", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2802973d8a3541303193e0727f65a48783c187a0", "committedDate": "2020-11-19T23:18:23Z", "message": "Merge branch 'dev' of https://github.com/reichg/atlas-checks into tollEscapeCheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b09a476a023562658de08264a81b2a4fd71d0d5", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/8b09a476a023562658de08264a81b2a4fd71d0d5", "committedDate": "2020-11-20T19:15:16Z", "message": "integration test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2abf74f0b2c07d55f93da165d7d0df4e431a6ca8", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2abf74f0b2c07d55f93da165d7d0df4e431a6ca8", "committedDate": "2020-11-20T19:18:32Z", "message": "integration test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74a82a4b48091900d673285b7453593c200aaf3a", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/74a82a4b48091900d673285b7453593c200aaf3a", "committedDate": "2020-11-20T20:20:39Z", "message": "spotless apply and successful test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5f0c27279634b5153e9e6e067185bf50cf0e4e8", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c5f0c27279634b5153e9e6e067185bf50cf0e4e8", "committedDate": "2020-11-20T21:36:42Z", "message": "removing prints"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99a1f087a03d2bc7eb87d501da15db03235ede7b", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/99a1f087a03d2bc7eb87d501da15db03235ede7b", "committedDate": "2020-11-23T18:45:26Z", "message": "updating equals --> equalsIgnoreCase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7fd752871848d75b142c741194d1581fc654dec", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d7fd752871848d75b142c741194d1581fc654dec", "committedDate": "2020-11-23T22:06:25Z", "message": "code smell cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f52fbe761969c6e6cd925100b8f0860b83a5d80a", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/f52fbe761969c6e6cd925100b8f0860b83a5d80a", "committedDate": "2020-11-23T22:15:11Z", "message": "code smells continued"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45211cc75d873a6817c1a36fcdc6f7a002e1a45b", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/45211cc75d873a6817c1a36fcdc6f7a002e1a45b", "committedDate": "2020-11-23T22:17:54Z", "message": "code smells continued"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dccd71073a0dc73c22e38845673e80ad71a48b0", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3dccd71073a0dc73c22e38845673e80ad71a48b0", "committedDate": "2020-11-23T22:29:48Z", "message": "code smells continued"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c83e85439042423169968e5e73e055d61068377a", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c83e85439042423169968e5e73e055d61068377a", "committedDate": "2020-11-23T22:57:19Z", "message": "code smells continued"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41ad8693b92234f9ea06aca11346593522ec3b80", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/41ad8693b92234f9ea06aca11346593522ec3b80", "committedDate": "2020-11-23T23:01:13Z", "message": "code smells continued"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d68eeb455ee1efeb96f6bc1d731c0a8c9f7e760f", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d68eeb455ee1efeb96f6bc1d731c0a8c9f7e760f", "committedDate": "2020-11-24T09:20:36Z", "message": "code smells continued"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c442a120b7807b8f090efbd1619a6b9919ea3a8", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7c442a120b7807b8f090efbd1619a6b9919ea3a8", "committedDate": "2020-11-24T10:50:23Z", "message": "code smells continued"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d588d11b5ba91173571e464efe414419170a3708", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d588d11b5ba91173571e464efe414419170a3708", "committedDate": "2020-11-24T22:23:33Z", "message": "fixing config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/9abed075fa4b311df2d461081893ac474906c7ed", "committedDate": "2020-11-24T23:23:21Z", "message": "Merge branch 'dev' of https://github.com/reichg/atlas-checks into tollEscapeCheck"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Nzg1Mjc4", "url": "https://github.com/osmlab/atlas-checks/pull/432#pullrequestreview-538785278", "createdAt": "2020-11-25T19:14:36Z", "commit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOToxNDozN1rOH6A0aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDowMjoyM1rOH6CLiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5Mjg3Mg==", "bodyText": "This needs to be updated.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530592872", "createdAt": "2020-11-25T19:14:37Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5MzAyMA==", "bodyText": "This is still the default and needs to be regenerated.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530593020", "createdAt": "2020-11-25T19:15:01Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU5OTM4OA==", "bodyText": "I believe this can be simplified.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n          \n          \n            \n                            && HighwayTag.isCarNavigableHighway(object)\n          \n          \n            \n                            && !isFlagged(object.getOsmIdentifier()))\n          \n          \n            \n                    {\n          \n          \n            \n                        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n          \n          \n            \n                        final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n          \n          \n            \n                        return !this.isPrivateAccess(keySet)\n          \n          \n            \n                                && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n          \n          \n            \n                    }\n          \n          \n            \n                    return false;\n          \n          \n            \n                    return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n          \n          \n            \n                            && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n          \n          \n            \n                            && !isFlagged(object.getOsmIdentifier())\n          \n          \n            \n                            && !this.isPrivateAccess(((Edge) object).getOsmTags());", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530599388", "createdAt": "2020-11-25T19:28:50Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMDAwOA==", "bodyText": "abt?", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530600008", "createdAt": "2020-11-25T19:30:03Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNjg0MA==", "bodyText": "This can be simplified if you use the Atlas Heading and Angle classes. If you go with this it will require changing doubles to Angles in a few other places.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n          \n          \n            \n                {\n          \n          \n            \n                    final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n          \n          \n            \n                    final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n          \n          \n            \n                    final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n          \n          \n            \n                    final Segment edge2StartSeg = edge2Segments.get(0);\n          \n          \n            \n                    final double aLength = edge1EndSeg.length().asMeters();\n          \n          \n            \n                    final double bLength = edge2StartSeg.length().asMeters();\n          \n          \n            \n                    final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n          \n          \n            \n                            .asMeters();\n          \n          \n            \n                    return Math.toDegrees(Math.acos(\n          \n          \n            \n                            (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n          \n          \n            \n                }\n          \n          \n            \n                private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n          \n          \n            \n                {\n          \n          \n            \n                    final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n          \n          \n            \n                    final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n          \n          \n            \n                    if (edge1heading.isPresent() && edge2heading.isPresent()){\n          \n          \n            \n                        return edge1heading.get().difference(edge2heading.get());\n          \n          \n            \n                    }\n          \n          \n            \n                    return Angle.NONE;\n          \n          \n            \n                }", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530606840", "createdAt": "2020-11-25T19:44:41Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMTQ5MA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530611490", "createdAt": "2020-11-25T19:54:45Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMTU5OA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530611598", "createdAt": "2020-11-25T19:54:58Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjE1MA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530612150", "createdAt": "2020-11-25T19:56:05Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjYzMw==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530612633", "createdAt": "2020-11-25T19:57:00Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjkwOQ==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n          \n          \n            \n                    return edge.inEdges().stream().filter(someEdge -> someEdge.isMainEdge()", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530612909", "createdAt": "2020-11-25T19:57:37Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzE5OA==", "bodyText": "nit: it might be a bit cleaner for this function to return an optional.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530613198", "createdAt": "2020-11-25T19:58:17Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMzcwMw==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n          \n          \n            \n                    return edge.outEdges().stream().filter(someEdge -> someEdge.isMainEdge()", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530613703", "createdAt": "2020-11-25T19:59:27Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 442}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDI1Mw==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n          \n          \n            \n                                    && inEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(inEdge))", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530614253", "createdAt": "2020-11-25T20:00:29Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 455}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNDM4Mw==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n          \n          \n            \n                                    && outEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(outEdge))", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530614383", "createdAt": "2020-11-25T20:00:45Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 459}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTA0OA==", "bodyText": "It would be good to give a description of what this case covers here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530615048", "createdAt": "2020-11-25T20:02:07Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 538}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTExNw==", "bodyText": "It would be good to give a description of what this case covers here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530615117", "createdAt": "2020-11-25T20:02:17Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            the edge in question\n+     * @param edgeInQuestionTags\n+     *            tags of edge in question\n+     * @return boolean if is case one\n+     */\n+    private boolean isCaseOne(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags)\n+    {\n+        return !this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.markedIntersectingTollFeature.contains(edgeInQuestion.getOsmIdentifier())\n+                && this.edgeIntersectsTollFeature(edgeInQuestion);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 553}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxNTE3OQ==", "bodyText": "It would be good to give a description of what this case covers here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r530615179", "createdAt": "2020-11-25T20:02:23Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,601 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static java.lang.Math.pow;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    // You can use serialver to regenerate the serial UID.\n+    private static final long serialVersionUID = 1L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final double MIN_ANGLE_DEFAULT = 140.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double minAngleForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.minAngleForContiguousWays = this.configurationValue(configuration,\n+                \"minAngleForContiguousWays\", MIN_ANGLE_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && HighwayTag.isCarNavigableHighway(object)\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+            final Map<String, String> keySet = edgeInQuestion.getOsmTags();\n+            return !this.isPrivateAccess(keySet)\n+                    && edgeInQuestion.highwayTag().isMoreImportantThan(this.minHighwayType);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> abtNearbyTollEdges = new HashSet<>();\n+        final Set<Long> abtObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this.edgeProvingBackwardsIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+        final Edge escapableOutEdge = this.edgeProvingForwardIsEscapable(edgeInQuestion,\n+                abtObjectIds);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, abtNearbyTollEdges);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private double angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final List<Segment> edge1Segments = edge1.asPolyLine().segments();\n+        final List<Segment> edge2Segments = edge2.asPolyLine().segments();\n+        final Segment edge1EndSeg = edge1Segments.get(edge1Segments.size() - 1);\n+        final Segment edge2StartSeg = edge2Segments.get(0);\n+        final double aLength = edge1EndSeg.length().asMeters();\n+        final double bLength = edge2StartSeg.length().asMeters();\n+        final double cLength = new Segment(edge1EndSeg.start(), edge2StartSeg.end()).length()\n+                .asMeters();\n+        return Math.toDegrees(Math.acos(\n+                (pow(aLength, 2) + pow(bLength, 2) - pow(cLength, 2)) / (2 * aLength * bLength)));\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Edge edgeProvingBackwardsIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge)\n+                    && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return inEdge;\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param abtObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Edge edgeProvingForwardIsEscapable(final Edge edge, final Set<Long> abtObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !abtObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays)\n+            {\n+                abtObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return outEdge;\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, abtObjectIds);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param abtNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Long getAreaOrNodeIntersectionId(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        abtNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return area.getOsmIdentifier();\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return node.getOsmIdentifier();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Long getNearbyTollFeatureInEdgeSide(final Edge edge, final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, abtNearbyTollEdges);\n+            }\n+            if (inEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !abtNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(inEdge.getIdentifier());\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Long getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> abtNearbyTollEdges)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, abtNearbyTollEdges);\n+            }\n+            if (outEdges.size() >= this.minInAndOutEdges && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !abtNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                abtNearbyTollEdges.add(outEdge.getIdentifier());\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, abtNearbyTollEdges);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(someEdge -> someEdge.getIdentifier() > 0\n+                && HighwayTag.isCarNavigableHighway(someEdge)).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.getIdentifier() > 0 && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)\n+        {\n+            return this.inconsistentTollTagLogic(inEdges, outEdges, edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            some edge\n+     * @param edge2\n+     *            some other edge\n+     * @return boolean regarding if they have same highway tag?\\\n+     */\n+    private boolean hasSameHighwayTag(final Edge edge1, final Edge edge2)\n+    {\n+        if (HighwayTag.highwayTag(edge1).isPresent() && HighwayTag.highwayTag(edge2).isPresent())\n+        {\n+            return edge1.highwayTag().equals(edge2.highwayTag());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @return if tags contains toll=yes\n+     */\n+    private boolean hasTollYesTag(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream().anyMatch(tag -> tag.equals(TollTag.KEY))\n+                && tags.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString());\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean for if the highway tag contains 'toll'\n+     */\n+    private boolean highwayTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(HighwayTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param inEdges\n+     *            some inedges\n+     * @param outEdges\n+     *            some outedges\n+     * @param edge\n+     *            some edge\n+     * @return boolean for inconsistent tagging\n+     */\n+    private boolean inconsistentTollTagLogic(final Set<Edge> inEdges, final Set<Edge> outEdges,\n+            final Edge edge)\n+    {\n+        for (final Edge inEdge : inEdges)\n+        {\n+            for (final Edge outEdge : outEdges)\n+            {\n+                if (this.hasSameHighwayTag(edge, inEdge) && this.hasSameHighwayTag(edge, outEdge)\n+                        && this.angleBetweenEdges(edge, outEdge) >= this.minAngleForContiguousWays\n+                        && this.angleBetweenEdges(inEdge, edge) >= this.minAngleForContiguousWays)\n+                {\n+                    final Map<String, String> inEdgeOsmTags = inEdge.getOsmTags();\n+                    final Map<String, String> outEdgeOsmTags = outEdge.getOsmTags();\n+                    if (this.bothTollYesTag(inEdgeOsmTags, outEdgeOsmTags))\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            the edge in question\n+     * @param edgeInQuestionTags\n+     *            tags of edge in question\n+     * @return boolean if is case one\n+     */\n+    private boolean isCaseOne(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags)\n+    {\n+        return !this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.markedIntersectingTollFeature.contains(edgeInQuestion.getOsmIdentifier())\n+                && this.edgeIntersectsTollFeature(edgeInQuestion);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion\n+     *            edge in question\n+     * @param edgeInQuestionTags\n+     *            edge in question osm tags\n+     * @param escapableInEdge\n+     *            edge that proves edge in question is toll escapable\n+     * @param escapableOutEdge\n+     *            edge that proves edge in question is toll escapable\n+     * @return boolean if is case three\n+     */\n+    private boolean isCaseThree(final Edge edgeInQuestion,\n+            final Map<String, String> edgeInQuestionTags, final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return this.hasTollYesTag(edgeInQuestionTags)\n+                && !this.edgeIntersectsTollFeature(edgeInQuestion)\n+                && !this.hasInconsistentTollTag(escapableOutEdge)\n+                && !this.hasInconsistentTollTag(escapableInEdge);\n+    }\n+\n+    /**\n+     * @param edgeInQuestion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9abed075fa4b311df2d461081893ac474906c7ed"}, "originalPosition": 574}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3d430cc4183793940677b428c5925ac4601ab92", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c3d430cc4183793940677b428c5925ac4601ab92", "committedDate": "2020-12-01T00:12:02Z", "message": "addressed comments regarding tollValidationCheck and added serislVersionUID for suddenHighwayTypeChangeCheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1caa30a83cba7183d102b529ac9fc79c4e4670e", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b1caa30a83cba7183d102b529ac9fc79c4e4670e", "committedDate": "2020-12-01T10:10:23Z", "message": "applied all rcommendations successfully."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "502662c5f012cc5058010d99ed4d3c841d8a6b70", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/502662c5f012cc5058010d99ed4d3c841d8a6b70", "committedDate": "2020-12-01T10:30:49Z", "message": "updated naming convention for angle related variables."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/50f1def9cb3da543c38ec2a49757a41abfec6338", "committedDate": "2020-12-01T10:50:13Z", "message": "had to update config variable and test config value to reflect updated variable names."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMjkyODA3", "url": "https://github.com/osmlab/atlas-checks/pull/432#pullrequestreview-542292807", "createdAt": "2020-12-01T21:01:52Z", "commit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMTowMTo1MlrOH8_n0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMTowNTo1MFrOH8_vwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxODk5Mw==", "bodyText": "Is there any chance that this could end up taking a long time to complete, either because the closest toll feature is a long ways away or because this is a depth first search and it takes a while to get to the nearby toll feature.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533718993", "createdAt": "2020-12-01T21:01:52Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,609 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMTAyNA==", "bodyText": "It would be nice to have a description of the configurables here.", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533721024", "createdAt": "2020-12-01T21:05:50Z", "author": {"login": "Bentleysb"}, "path": "docs/checks/tollValidationCheck", "diffHunk": "@@ -0,0 +1,41 @@\n+# TollValidationCheck\n+\n+#### Description\n+\n+The purpose of this check is to identify ways that need to have their toll tags investigated/added/removed.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/740dc1f753b2cda6c9c377a636e4f6f9646ea244", "committedDate": "2020-12-01T23:25:16Z", "message": "new config value for limiting recursion while searching for nearby toll features and added more documentation for the config values.."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMzg0MzYz", "url": "https://github.com/osmlab/atlas-checks/pull/432#pullrequestreview-542384363", "createdAt": "2020-12-01T23:32:34Z", "commit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzozMjozNFrOH9EJTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzo1NjowM1rOH9Eq3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5MzEwMQ==", "bodyText": "Is it desired behavior to short circuit here with possibly returning false and not checking other areas/nodes?", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533793101", "createdAt": "2020-12-01T23:32:34Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NTM5Mw==", "bodyText": "Not a huge deal but we could rename this variable (especially in the config) as it seems to be functioning as an exact constraint, not a min", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533795393", "createdAt": "2020-12-01T23:38:52Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges, double recursionCount)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(inEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(inEdge, alreadyCheckedNearbyTollEdges);\n+            }\n+            if (recursionCount <= this.maxIterationForNearbySearch\n+                    && inEdges.size() >= this.minInAndOutEdges\n+                    && !this.edgeIntersectsTollFeature(inEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(inEdge.getIdentifier()))\n+            {\n+                alreadyCheckedNearbyTollEdges.add(inEdge.getIdentifier());\n+                recursionCount++;\n+                return this.getNearbyTollFeatureInEdgeSide(inEdge, alreadyCheckedNearbyTollEdges,\n+                        recursionCount);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the out edge side of the edge in question (downstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureOutEdgeSide(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges, double recursionCount)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges && this.edgeIntersectsTollFeature(outEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                return this.getAreaOrNodeIntersectionId(outEdge, alreadyCheckedNearbyTollEdges);\n+            }\n+            if (recursionCount <= this.maxIterationForNearbySearch\n+                    && outEdges.size() >= this.minInAndOutEdges\n+                    && !this.edgeIntersectsTollFeature(outEdge)\n+                    && !alreadyCheckedNearbyTollEdges.contains(outEdge.getIdentifier()))\n+            {\n+                alreadyCheckedNearbyTollEdges.add(outEdge.getIdentifier());\n+                recursionCount++;\n+                return this.getNearbyTollFeatureOutEdgeSide(outEdge, alreadyCheckedNearbyTollEdges,\n+                        recursionCount);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return out edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getOutEdges(final Edge edge)\n+    {\n+        return edge.outEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return tag inconsistencies between 3 consecutive edges.\n+     */\n+    private boolean hasInconsistentTollTag(final Edge edge)\n+    {\n+        final Set<Edge> inEdges = edge.inEdges().stream()\n+                .filter(inEdge -> inEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && inEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(inEdge))\n+                .collect(Collectors.toSet());\n+        final Set<Edge> outEdges = edge.outEdges().stream()\n+                .filter(outEdge -> outEdge.getOsmIdentifier() != edge.getOsmIdentifier()\n+                        && outEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(outEdge))\n+                .collect(Collectors.toSet());\n+        if (inEdges.size() == this.minInAndOutEdges && outEdges.size() == this.minInAndOutEdges)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5NjMxMg==", "bodyText": "I think we can use BaseCheck's markAsFlagged here instead of these Sets, just because it's more conventional and the memory should be allocated already", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533796312", "createdAt": "2020-12-01T23:41:18Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5ODU2OA==", "bodyText": "Could we combine this and edgeProvingForwardIsEscapable() into a new method where the params would just be Edge edge, Set<Edge> connectedEdges, Set<Long> alreadyCheckedObjectIds)?", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533798568", "createdAt": "2020-12-01T23:47:30Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMDA0MA==", "bodyText": "Actually I just noticed they call each other... if there's not already a stack overflow problem or anything I don't think my suggestion alone should cause that either", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533800040", "createdAt": "2020-12-01T23:51:37Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,624 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES_DEFAULT = 1.0;\n+    private static final double MAX_ITERATION_FOR_SEARCH_DEFAULT = 15.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+    private final double maxIterationForNearbySearch;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES_DEFAULT);\n+        this.maxIterationForNearbySearch = this.configurationValue(configuration,\n+                \"maxIterationForNearbySearch\", MAX_ITERATION_FOR_SEARCH_DEFAULT);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            double recursionCount = 0;\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges,\n+                            recursionCount)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc5ODU2OA=="}, "originalCommit": {"oid": "740dc1f753b2cda6c9c377a636e4f6f9646ea244"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzgwMTY5NQ==", "bodyText": "Same with my other comment about combing two similar methods into one -- I believe this and its outEdge counterpart can be combined", "url": "https://github.com/osmlab/atlas-checks/pull/432#discussion_r533801695", "createdAt": "2020-12-01T23:56:03Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TollValidationCheck.java", "diffHunk": "@@ -0,0 +1,609 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Heading;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.AccessTag;\n+import org.openstreetmap.atlas.tags.BarrierTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.TollTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+/**\n+ * This check attempts to validate toll tags based on 3 scenarios. 1. Edge intersects toll feature\n+ * but is missing toll tag 2. Edge has inconsistent toll tag compared to surrounding edges 3. Edge\n+ * has route that can escape toll feature so the toll tag is modeled incorrectly.\n+ *\n+ * @author greichenberger\n+ */\n+public class TollValidationCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -4286937145318778446L;\n+    private static final String INTERSECTS_TOLL_FEATURE = \"Way {0, number, #} intersects toll feature but is missing toll tag, please investigate toll tag addition.\";\n+    private static final String ESCAPABLE_TOLL = \"Toll tags need to be investigated for removal on way {0, number, #}. Please check ways {1, number, #} and {2, number, #} and affected nearby ways for modeling issues. Nearby toll features \"\n+            + \"that might be helpful are: upstream {3, number, #} and downstream {4, number, #}.\";\n+    private static final String INCONSISTENT_TOLL_TAGS = \"Way {0, number, #} has an inconsistent toll tag with its surrounding ways. Please check for proper toll tag modeling.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INTERSECTS_TOLL_FEATURE,\n+            ESCAPABLE_TOLL, INCONSISTENT_TOLL_TAGS);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private static final Double MAX_ANGLE_DIFF_DEFAULT = 40.0;\n+    private static final double MIN_IN_OUT_EDGES = 1.0;\n+    private final Set<Long> markedInconsistentToll = new HashSet<>();\n+    private final Set<Long> markedIntersectingTollFeature = new HashSet<>();\n+    private final HighwayTag minHighwayType;\n+    private final double minInAndOutEdges;\n+    private final double maxAngleDiffForContiguousWays;\n+\n+    /**\n+     * @param configuration\n+     *            config file params if any.\n+     */\n+    public TollValidationCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+        this.maxAngleDiffForContiguousWays = this.configurationValue(configuration,\n+                \"maxAngleDiffForContiguousWays\", MAX_ANGLE_DIFF_DEFAULT);\n+        this.minInAndOutEdges = this.configurationValue(configuration, \"minInAndOutEdges\",\n+                MIN_IN_OUT_EDGES);\n+    }\n+\n+    /**\n+     * @param object\n+     *            The {@link AtlasObject} you are checking\n+     * @return validation check\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && ((Edge) object).highwayTag().isMoreImportantThan(this.minHighwayType)\n+                && !isFlagged(object.getOsmIdentifier())\n+                && !this.isPrivateAccess(object.getOsmTags());\n+    }\n+\n+    /**\n+     * @param object\n+     *            object in question\n+     * @return flag\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeInQuestion = ((Edge) object).getMainEdge();\n+        final Map<String, String> edgeInQuestionTags = edgeInQuestion.getOsmTags();\n+        final Set<Long> alreadyCheckedNearbyTollEdges = new HashSet<>();\n+        final Set<Long> alreadyCheckedObjectIds = new HashSet<>();\n+\n+        // Case One: Edge intersects toll feature but is missing toll tag.\n+        if (this.isCaseOne(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedIntersectingTollFeature.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(0, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        // Case Two: Inconsistent toll tags on edge.\n+        if (this.isCaseTwo(edgeInQuestion, edgeInQuestionTags))\n+        {\n+            this.markedInconsistentToll.add(edgeInQuestion.getOsmIdentifier());\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(2, edgeInQuestion.getOsmIdentifier())));\n+        }\n+\n+        final Edge escapableInEdge = this\n+                .edgeProvingBackwardsIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+        final Edge escapableOutEdge = this\n+                .edgeProvingForwardIsEscapable(edgeInQuestion, alreadyCheckedObjectIds)\n+                .orElse(null);\n+\n+        // Case three: tag modeling needs to be investigate on and around edge in question/proved\n+        // escapable routes\n+        if (this.escapableEdgesNullChecker(escapableInEdge, escapableOutEdge) && this\n+                .isCaseThree(edgeInQuestion, edgeInQuestionTags, escapableInEdge, escapableOutEdge))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            final Long nearbyTollFeatureUpstream = this\n+                    .getNearbyTollFeatureInEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            final Long nearbyTollFeatureDownstream = this\n+                    .getNearbyTollFeatureOutEdgeSide(edgeInQuestion, alreadyCheckedNearbyTollEdges)\n+                    .orElse(null);\n+            return Optional.of(this.createFlag(object,\n+                    this.getLocalizedInstruction(1, edgeInQuestion.getOsmIdentifier(),\n+                            escapableInEdge.getOsmIdentifier(), escapableOutEdge.getOsmIdentifier(),\n+                            nearbyTollFeatureUpstream, nearbyTollFeatureDownstream)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * @param edge1\n+     *            just an edge\n+     * @param edge2\n+     *            just another edge\n+     * @return angle in degrees between edges (segments)\n+     */\n+    private Angle angleBetweenEdges(final Edge edge1, final Edge edge2)\n+    {\n+        final Optional<Heading> edge1heading = edge1.asPolyLine().finalHeading();\n+        final Optional<Heading> edge2heading = edge2.asPolyLine().initialHeading();\n+        if (edge1heading.isPresent() && edge2heading.isPresent())\n+        {\n+            return edge1heading.get().difference(edge2heading.get());\n+        }\n+        return Angle.NONE;\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if the barrier tag contains 'toll'\n+     */\n+    private boolean barrierTagContainsToll(final Map<String, String> tags)\n+    {\n+        return tags.get(BarrierTag.KEY).contains(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some edge tags\n+     * @param tags2\n+     *            some other edge tags\n+     * @return both sets of tags have toll=yes\n+     */\n+    private boolean bothTollYesTag(final Map<String, String> tags, final Map<String, String> tags2)\n+    {\n+        return this.hasTollYesTag(tags) && this.hasTollYesTag(tags2);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'barrier'\n+     */\n+    private boolean containsBarrierTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(BarrierTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'highway'\n+     */\n+    private boolean containsHighwayTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(HighwayTag.KEY);\n+    }\n+\n+    /**\n+     * @param tags\n+     *            some osm tags\n+     * @return boolean if tags contains key 'toll'\n+     */\n+    private boolean containsTollTag(final Map<String, String> tags)\n+    {\n+        return tags.containsKey(TollTag.KEY);\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return boolean if edge intersects toll feature\n+     */\n+    private boolean edgeIntersectsTollFeature(final Edge edge)\n+    {\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (!areaContainsPolyline)\n+            {\n+                continue;\n+            }\n+            return this.containsBarrierTag(areaTags) && this.barrierTagContainsToll(areaTags);\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched IDs\n+     * @return edge that proves backwards is escapable\n+     */\n+    private Optional<Edge> edgeProvingBackwardsIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> inEdges = this.getInEdges(edge);\n+\n+        for (final Edge inEdge : inEdges)\n+        {\n+            if (inEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(inEdge.getIdentifier())\n+                    && inEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, inEdge) && this.angleBetweenEdges(inEdge, edge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(inEdge.getIdentifier());\n+                final Map<String, String> keySet = inEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(inEdge);\n+                }\n+\n+                if (!this.edgeIntersectsTollFeature(inEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingBackwardsIsEscapable(inEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @param alreadyCheckedObjectIds\n+     *            already been touched Ids\n+     * @return edge proving forward is escapable.\n+     */\n+    private Optional<Edge> edgeProvingForwardIsEscapable(final Edge edge,\n+            final Set<Long> alreadyCheckedObjectIds)\n+    {\n+        final Set<Edge> outEdges = this.getOutEdges(edge);\n+        for (final Edge outEdge : outEdges)\n+        {\n+            if (outEdges.size() >= this.minInAndOutEdges\n+                    && !alreadyCheckedObjectIds.contains(outEdge.getIdentifier())\n+                    && outEdge.highwayTag().isMoreImportantThan(this.minHighwayType)\n+                    && this.hasSameHighwayTag(edge, outEdge)\n+                    && this.angleBetweenEdges(edge, outEdge)\n+                            .asDegrees() <= this.maxAngleDiffForContiguousWays)\n+            {\n+                alreadyCheckedObjectIds.add(outEdge.getIdentifier());\n+                final Map<String, String> keySet = outEdge.getOsmTags();\n+\n+                if ((!this.containsTollTag(keySet)) || (this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.NO.toString())))\n+                {\n+                    return Optional.of(outEdge);\n+                }\n+                if (!this.edgeIntersectsTollFeature(outEdge) && this.containsTollTag(keySet)\n+                        && keySet.get(TollTag.KEY).equalsIgnoreCase(TollTag.YES.toString()))\n+                {\n+                    return this.edgeProvingForwardIsEscapable(outEdge, alreadyCheckedObjectIds);\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param escapableInEdge\n+     *            escapable in edge\n+     * @param escapableOutEdge\n+     *            escapable out edge\n+     * @return boolean for if they are both null\n+     */\n+    private boolean escapableEdgesNullChecker(final Edge escapableInEdge,\n+            final Edge escapableOutEdge)\n+    {\n+        return escapableInEdge != null && escapableOutEdge != null;\n+    }\n+\n+    /**\n+     * @param edge\n+     *            an edge\n+     * @param alreadyCheckedNearbyTollEdges\n+     *            edge that have already been touched when recursing.\n+     * @return Id for intersecting toll feature.\n+     */\n+    private Optional<Long> getAreaOrNodeIntersectionId(final Edge edge,\n+            final Set<Long> alreadyCheckedNearbyTollEdges)\n+    {\n+        alreadyCheckedNearbyTollEdges.add(edge.getIdentifier());\n+        final Iterable<Area> intersectingAreas = edge.getAtlas().areasIntersecting(edge.bounds());\n+        final Iterable<Node> edgeNodes = edge.connectedNodes();\n+        for (final Area area : intersectingAreas)\n+        {\n+            final boolean areaContainsPolyline = area.asPolygon().overlaps(edge.asPolyLine());\n+            final Map<String, String> areaTags = area.getOsmTags();\n+            if (areaContainsPolyline && this.containsBarrierTag(areaTags)\n+                    && (this.barrierTagContainsToll(areaTags)))\n+            {\n+                return Optional.of(area.getOsmIdentifier());\n+            }\n+        }\n+\n+        for (final Node node : edgeNodes)\n+        {\n+            final Map<String, String> nodeTags = node.getOsmTags();\n+            if ((this.containsHighwayTag(nodeTags) && this.highwayTagContainsToll(nodeTags))\n+                    || (this.containsBarrierTag(nodeTags) && this.barrierTagContainsToll(nodeTags)))\n+            {\n+                return Optional.of(node.getOsmIdentifier());\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * @param edge\n+     *            some edge\n+     * @return in edges that are car navigable and positive (eliminates reverse edges)\n+     */\n+    private Set<Edge> getInEdges(final Edge edge)\n+    {\n+        return edge.inEdges().stream().filter(\n+                someEdge -> someEdge.isMainEdge() && HighwayTag.isCarNavigableHighway(someEdge))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * @param edge\n+     *            edge in question\n+     * @return nearby toll feature id on the in edge side of the edge in question (upstream)\n+     */\n+    private Optional<Long> getNearbyTollFeatureInEdgeSide(final Edge edge,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcxODk5Mw=="}, "originalCommit": {"oid": "50f1def9cb3da543c38ec2a49757a41abfec6338"}, "originalPosition": 388}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c00a41ace7033ff2e797720bf872be7f12f3f930", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c00a41ace7033ff2e797720bf872be7f12f3f930", "committedDate": "2020-12-02T02:53:16Z", "message": "Fixed naming of angle difference function and addressed comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34f5b507f0726bffac759ae9834d312b3c0e3152", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/34f5b507f0726bffac759ae9834d312b3c0e3152", "committedDate": "2020-12-02T02:58:10Z", "message": "spotless apply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dba83aee24d6f1b033390c9f3d6bc69b9c3930d", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4dba83aee24d6f1b033390c9f3d6bc69b9c3930d", "committedDate": "2020-12-02T07:30:23Z", "message": "Added auto fix suggestions for case 1 and 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea2a217925255ce26c5b22527d5a457361e3bc15", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/ea2a217925255ce26c5b22527d5a457361e3bc15", "committedDate": "2020-12-02T07:33:23Z", "message": "Merge branch 'dev' of https://github.com/reichg/atlas-checks into tollEscapeCheck"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMDM1NTE5", "url": "https://github.com/osmlab/atlas-checks/pull/432#pullrequestreview-543035519", "createdAt": "2020-12-02T16:49:17Z", "commit": {"oid": "ea2a217925255ce26c5b22527d5a457361e3bc15"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMTQzNDg1", "url": "https://github.com/osmlab/atlas-checks/pull/432#pullrequestreview-543143485", "createdAt": "2020-12-02T18:55:24Z", "commit": {"oid": "ea2a217925255ce26c5b22527d5a457361e3bc15"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3234, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}