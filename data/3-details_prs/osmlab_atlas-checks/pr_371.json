{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMTc0NDkx", "number": 371, "title": "Add LevelCrossingOnRailwayCheck", "bodyText": "Description:\nAdd level_crossing atlas check and unit tests. Resolves Issue: #369\nPotential Impact:\nOther than the time it will take to run the test - None - just a new Check\nUnit Test Approach:\nUnit test was designed to hit each of the possible flagged issues. Unit test \"Rule\" file was produced manually.\nTest Results:\n\n\n\nISO\nTotal Flags\nSampled\nSampling %\nTP\nFP\nFalse Positive Rate\n\n\n\n\nARM\n128\n128\n100%\n125\n2\n2%\n\n\nAFG\n4\n4\n100%\n4\n0\n0%\n\n\nNZL\n193\n193\n100%\n163\n27\n14%\n\n\nTHA\n213\n213\n100%\n189\n12\n6%\n\n\nVEN\n37\n37\n100%\n35\n0\n0%\n\n\nTOTAL\n575\n575\n100%\n516\n41\n7%\n\n\n\nMap Roulette Challenge:\nAFG\nARM\nTHA\nVEN\nNZL - V1 With full QA\nNZL - V3 after fixes addressed issues", "createdAt": "2020-09-22T20:22:41Z", "url": "https://github.com/osmlab/atlas-checks/pull/371", "merged": true, "mergeCommit": {"oid": "522cb004b78d9f4052a6bdfd3594693e6487d9ba"}, "closed": true, "closedAt": "2020-11-04T19:23:29Z", "author": {"login": "atiannicelli"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLdYajgH2gAyNDkxMTc0NDkxOjY3NzkxZjJlYTZjY2Y4YmZiNjNiMmM4YjViNTk0ODA3MTk2ZDgxNmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZSMXCAFqTUyMzYzNDE2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "67791f2ea6ccf8bfb63b2c8b5b594807196d816f", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/67791f2ea6ccf8bfb63b2c8b5b594807196d816f", "committedDate": "2020-09-22T19:44:19Z", "message": "Add railway level_crossing check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff115c10bfd5224f4aa8e3c4d983fbc30dee113a", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/ff115c10bfd5224f4aa8e3c4d983fbc30dee113a", "committedDate": "2020-09-23T15:18:10Z", "message": "Add documentation and fix bug found in first version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b37865a14d8be8e9691055fd82d949b6e9ca6d0e", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b37865a14d8be8e9691055fd82d949b6e9ca6d0e", "committedDate": "2020-09-23T17:29:57Z", "message": "Fix code smell issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e52c678da89d753165038fc4dd6fbbefd24d567", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/8e52c678da89d753165038fc4dd6fbbefd24d567", "committedDate": "2020-09-23T19:08:20Z", "message": "Fix code smell complexity issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cd71be669b22853696d17b7c76244b57e18053f", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3cd71be669b22853696d17b7c76244b57e18053f", "committedDate": "2020-09-23T20:02:59Z", "message": "Add levelcrossing doc to available checks doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "359bff9179c730e9cbc2725cbdaefa58ef9b9230", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/359bff9179c730e9cbc2725cbdaefa58ef9b9230", "committedDate": "2020-09-25T20:51:58Z", "message": "skipping rails that are also highways in some cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "872d82ced9403f140bd6104c836ff6cbdf8a3ceb", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/872d82ced9403f140bd6104c836ff6cbdf8a3ceb", "committedDate": "2020-09-30T01:01:47Z", "message": "fix spotlessJava failure."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "895acc9de82fb87d0a8bb63e1968c244ef7f50e9", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/895acc9de82fb87d0a8bb63e1968c244ef7f50e9", "committedDate": "2020-10-01T19:01:38Z", "message": "Merge branch 'dev' of github.com:/osmlab/atlas-checks into level_crossing-check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6a9d1c263fff9f5e5cf0cb6f0775e0ba0b826df", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b6a9d1c263fff9f5e5cf0cb6f0775e0ba0b826df", "committedDate": "2020-10-05T16:00:16Z", "message": "add fix suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b38a1529e5d54b6725bb7715789dfbf6c8bccadb", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b38a1529e5d54b6725bb7715789dfbf6c8bccadb", "committedDate": "2020-10-19T18:00:00Z", "message": "Merge branch 'dev' of github.com:atiannicelli/atlas-checks into level_crossing-check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c6b4ed7f03756b4f43ca67febf2d777b9c8696f", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2c6b4ed7f03756b4f43ca67febf2d777b9c8696f", "committedDate": "2020-10-22T00:47:24Z", "message": "Update to deal with layers better."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b803cabe2d59047b7e0884cbbb381ab1636e120c", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b803cabe2d59047b7e0884cbbb381ab1636e120c", "committedDate": "2020-10-23T17:54:45Z", "message": "Ignore construction and proposed rails."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47ac84ea32732f73b0b5db2187a81e04b83d4c2d", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/47ac84ea32732f73b0b5db2187a81e04b83d4c2d", "committedDate": "2020-10-23T18:30:08Z", "message": "Make it smell good."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d2d5fdaf0258663658217b58088eeda1828318d", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/8d2d5fdaf0258663658217b58088eeda1828318d", "committedDate": "2020-10-23T18:34:02Z", "message": "fix smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f9c950ea60e24e4c9a9c430d54986536a096cc3", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7f9c950ea60e24e4c9a9c430d54986536a096cc3", "committedDate": "2020-10-23T19:31:30Z", "message": "kick travis to retest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17099e4a36a1c6ef15b72d028e08576a0266f534", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/17099e4a36a1c6ef15b72d028e08576a0266f534", "committedDate": "2020-10-23T20:59:25Z", "message": "one more smell removed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b04f39cd9bfdb95120aae02296da81fce1126eb", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/5b04f39cd9bfdb95120aae02296da81fce1126eb", "committedDate": "2020-10-28T16:30:10Z", "message": "convert rail list to filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08f66b4f3263fd3e51badd50b9f140d728fe54e2", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/08f66b4f3263fd3e51badd50b9f140d728fe54e2", "committedDate": "2020-10-28T16:31:17Z", "message": "Add rail list to configuration file."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5OTMxNDQz", "url": "https://github.com/osmlab/atlas-checks/pull/371#pullrequestreview-519931443", "createdAt": "2020-10-29T17:54:14Z", "commit": {"oid": "08f66b4f3263fd3e51badd50b9f140d728fe54e2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNzo1NDoxNFrOHqn6Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODoxMzowNFrOHqopcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjE0Nw==", "bodyText": "Please add this to the configuration file. Otherwise it can be easy to forget it exists.", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514456147", "createdAt": "2020-10-29T17:54:14Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08f66b4f3263fd3e51badd50b9f140d728fe54e2"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MDgxMw==", "bodyText": "Nice!", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514460813", "createdAt": "2020-10-29T18:01:35Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)\n+            {\n+                // This is a node that is tagged with railway=level_crossing and is not a\n+                // railway/highway intersection\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(issueType, object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08f66b4f3263fd3e51badd50b9f140d728fe54e2"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzU1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!(object instanceof Node || object instanceof Point)\n          \n          \n            \n                    if (!(object instanceof LocationItem)", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514463556", "createdAt": "2020-10-29T18:05:49Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)\n+            {\n+                // This is a node that is tagged with railway=level_crossing and is not a\n+                // railway/highway intersection\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(issueType, object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(\n+                                (AtlasEntity) ((CompleteEntity) CompleteEntity\n+                                        .from((AtlasEntity) object)).withRemovedTag(RailwayTag.KEY),\n+                                object.getAtlas())));\n+            }\n+            if (!Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType == 0)\n+            {\n+                // This is a valid railway/highway intersect node that is not tagged with\n+                // railway=level_crossing\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(NODE_MISSING_LC_TAG_INDEX,\n+                                        object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(\n+                                (AtlasEntity) ((CompleteEntity) CompleteEntity\n+                                        .from((AtlasEntity) object)).withAddedTag(RailwayTag.KEY,\n+                                                RailwayTag.LEVEL_CROSSING.toString().toLowerCase()),\n+                                object.getAtlas())));\n+\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Flag all railway/highway intersections that are missing an intersection node\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagInvalidIntersections(final AtlasObject object)\n+    {\n+        if (object instanceof Line && this.railwayFilter.test(object))\n+        {\n+            final Line railway = (Line) object;\n+            final Atlas atlas = railway.getAtlas();\n+            final List<Location> badIntersectingHighways = new ArrayList<>();\n+\n+            Iterables.asList(atlas.edgesIntersecting(railway.bounds()))\n+                    .forEach(highway -> badIntersectingHighways\n+                            .addAll(this.missingNodesAtIntersectionOnSameLayer(railway, highway)));\n+            if (!badIntersectingHighways.isEmpty())\n+            {\n+                return Optional.of(this.createFlag(object,\n+                        this.getLocalizedInstruction(INTERSECTION_MISSING_NODE_INDEX,\n+                                railway.getOsmIdentifier()),\n+                        badIntersectingHighways));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Flag all objects that are not nodes or points that are tagged with railway=level_crossing\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagNonNodeTagged(final AtlasObject object)\n+    {\n+        if (!(object instanceof Node || object instanceof Point)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08f66b4f3263fd3e51badd50b9f140d728fe54e2"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2ODIxMA==", "bodyText": "Please add a some unit tests that use the ConfigurationResolver.inLineConfiguration() to check that the 2 configurables work as expected. And please test that the expected fix suggestions are created.", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514468210", "createdAt": "2020-10-29T18:13:04Z", "author": {"login": "Bentleysb"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheckTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Unit tests for {@link LevelCrossingOnRailwayCheck}.\n+ *\n+ * @author atiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheckTest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08f66b4f3263fd3e51badd50b9f140d728fe54e2"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b82641e0bdaba4bb163d601a3ad8eeb8c189fe25", "committedDate": "2020-10-29T20:56:19Z", "message": "Fix PR review requested changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTQ4MDM5", "url": "https://github.com/osmlab/atlas-checks/pull/371#pullrequestreview-520148039", "createdAt": "2020-10-29T23:02:24Z", "commit": {"oid": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTY1MDk5", "url": "https://github.com/osmlab/atlas-checks/pull/371#pullrequestreview-522965099", "createdAt": "2020-11-04T00:20:20Z", "commit": {"oid": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMDoyMDoyMFrOHtFBZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwMDoyMTo1MFrOHtFDCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMDI0Nw==", "bodyText": "nit: issueType could be better served as an Enum to avoid referencing docs for explanation", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r517030247", "createdAt": "2020-11-04T00:20:20Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMDY2Ng==", "bodyText": "just a thought. could the railway tag just have the wrong value, but the feature is still a legitimate \"railway\"? in which case we may want to not send up a fix suggestion", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r517030666", "createdAt": "2020-11-04T00:21:50Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)\n+            {\n+                // This is a node that is tagged with railway=level_crossing and is not a\n+                // railway/highway intersection\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(issueType, object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(\n+                                (AtlasEntity) ((CompleteEntity) CompleteEntity\n+                                        .from((AtlasEntity) object)).withRemovedTag(RailwayTag.KEY),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25"}, "originalPosition": 187}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b2631841aaf9ee775646651e095d496b937a329", "author": {"user": {"login": "atiannicelli", "name": "Alex Iannicelli"}}, "url": "https://github.com/osmlab/atlas-checks/commit/0b2631841aaf9ee775646651e095d496b937a329", "committedDate": "2020-11-04T15:01:43Z", "message": "Add enum for isValidLevelCrossingNode function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTQ1MTUy", "url": "https://github.com/osmlab/atlas-checks/pull/371#pullrequestreview-523545152", "createdAt": "2020-11-04T16:45:37Z", "commit": {"oid": "0b2631841aaf9ee775646651e095d496b937a329"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNjM0MTYy", "url": "https://github.com/osmlab/atlas-checks/pull/371#pullrequestreview-523634162", "createdAt": "2020-11-04T18:37:08Z", "commit": {"oid": "0b2631841aaf9ee775646651e095d496b937a329"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3188, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}