{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MTcyMjQ2", "number": 287, "title": "LCWB enhancement - borders,ferries,fords", "bodyText": "Description:\nThis PR has a few enhancements for LCWB:\n-- Fix flagging at border regions\n--Drop flagging for streets that cross waterbodies and have the FordTag\n--Drop flagging for streets that have nodes at the location of intersection with a waterbody AND the node has a tag specified by the configurable nodes.intersecting.non_offending\n--Add flagging for streets that end at waterbodies but are not marked by nodes at such endings, or the node is not one of the configurable tags specified by nodes.intersecting.non_offending\nFor the border region fix:\nAddresses an issue in LCWB where multipolygon relations at country borders were causing improper flagging. Specifically, in #282, we dropped flagging completely for multipolygon relations at borders, but this caused several true positive flag drops. So this PR aims to regain those TP while also keeping the false positive rate down by ensuring the intersecting street/railway/building feature intersects an outer polygon of the relation that was NOT created or edited by country slicing.\nTwo tags, IsoCountryTag and SyntheticNearestNeighborCountryCodeTag, are used to tell if the outer polygon was generated at country slicing time. these tags are synthetically added to atlas-generated features from country slicing. If an atlas feature has more than these two tags, it shouldn't have been created from country slicing. So only streets/buildings/railways that intersect features with more than the two tags should be flagged. If there is no such intersection, we can still flag the intersecting feature if it is entirely contained in the outer polygon, and does not intersect and is not contained by any inner member of the relation. Same IsoCountry/SyntheticNearestNeighborCountryCodeTag rules apply here as well\nPotential Impact:\nBetter flagging for LCWB on multipolygon relations at borders\nNo flagging for edges that end at OR cross (ford) waterbodies validly. Valid tags for streets that end at waterbodies defined in nodes.intersecting.non_offending.\nMore flags for edges that end at waterbodies but don't have proper tagging.\nUnit Test Approach:\nUpdated and added  unit tests\nTest Results:\npassing", "createdAt": "2020-04-23T20:22:31Z", "url": "https://github.com/osmlab/atlas-checks/pull/287", "merged": true, "mergeCommit": {"oid": "50748afb4af624c662efb0e9051fe1ad32536ca7"}, "closed": true, "closedAt": "2020-05-13T21:55:49Z", "author": {"login": "seancoulter"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaOs0IAH2gAyNDA4MTcyMjQ2OjE3NDBiMTE3MzM5OTA3NGZmODRhYzcxODk2MjQ5MzMzN2MwMWZjYjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcg_4N-gFqTQxMTMxNzYxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1740b1173399074ff84ac718962493337c01fcb9", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/1740b1173399074ff84ac718962493337c01fcb9", "committedDate": "2020-04-22T20:55:44Z", "message": "better border relation flagging"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaa9205645ea81794333a76f6dcb87d4c7253bdb", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/eaa9205645ea81794333a76f6dcb87d4c7253bdb", "committedDate": "2020-04-23T06:18:16Z", "message": "refine floating feature logix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b8eb3070500a376eb6a024e9a695414c9c17e08", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/5b8eb3070500a376eb6a024e9a695414c9c17e08", "committedDate": "2020-04-23T07:46:05Z", "message": "spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMTIzODAw", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-403123800", "createdAt": "2020-04-30T00:11:40Z", "commit": {"oid": "5b8eb3070500a376eb6a024e9a695414c9c17e08"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoxMTo0MFrOGOVayg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoxMTo0MFrOGOVayg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDE3MA==", "bodyText": "While this seems like it works -- this solution feels a bit hacky. We've ran into this issue before and proposed parsing the identifier to verify whether or not the feature has been sliced at the border -- this too felt like a hack.\nI would defer to atlas to provide a better (reusable) solution to verify if a feature has been country sliced -- as its shown to be useful in other checks.", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r417684170", "createdAt": "2020-04-30T00:11:40Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +335,61 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()\n+                .filter(member -> member.getRole().equals(\"outer\"))\n+                .map(member -> new Tuple<>(member.getEntity(),\n+                        new Polygon(member.getEntity() instanceof Area ? (Area) member.getEntity()\n+                                : (LineItem) member.getEntity())))\n+                .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                        || (intersectingFeature.within(member.getSecond())\n+                                && ((MultiPolygon) waterbody).inners().stream().noneMatch(\n+                                        innerMember -> intersectingFeature.intersects(innerMember)\n+                                                || intersectingFeature.within(innerMember))))\n+                        && member.getFirst().lastEdit().isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8eb3070500a376eb6a024e9a695414c9c17e08"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad94ce8feea8e6d4fd2b0ed704d6a21b6377e5b2", "author": {"user": {"login": "yiqingj", "name": null}}, "url": "https://github.com/osmlab/atlas-checks/commit/ad94ce8feea8e6d4fd2b0ed704d6a21b6377e5b2", "committedDate": "2020-05-04T16:59:57Z", "message": "Merge branch 'dev' into lcwbBorderRelationFix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca0158a32b0a9abdafa885548050102f3628942c", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/ca0158a32b0a9abdafa885548050102f3628942c", "committedDate": "2020-05-05T20:30:53Z", "message": "new border tag attempt 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28a3ce651b64e477b9b6e46a6868e0e78f273b64", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/28a3ce651b64e477b9b6e46a6868e0e78f273b64", "committedDate": "2020-05-08T20:29:18Z", "message": "allow fording/ferry roads; edit border relation logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/446221903b118ea099b5ef514c5d2232ef96de54", "committedDate": "2020-05-08T20:29:30Z", "message": "Merge branch 'lcwbBorderRelationFix' of https://github.com/seancoulter/atlas-checks into lcwbBorderRelationFix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzE1MDE2", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-409315016", "createdAt": "2020-05-11T16:05:13Z", "commit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzIxNjk0", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-409321694", "createdAt": "2020-05-11T16:13:28Z", "commit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxMzoyOFrOGTjUyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoyNTowNVrOGTjyJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NDg4OA==", "bodyText": "I believe this comment is out of date", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423154888", "createdAt": "2020-05-11T16:13:28Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NjY4OQ==", "bodyText": "Can the ford use case addition be added to the lines.non_offending configurable list?", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423156689", "createdAt": "2020-05-11T16:16:12Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -293,31 +302,61 @@ public boolean validCheckForObject(final AtlasObject object)\n      *            {@link AtlasItem} crossing\n      * @return whether given {@link AtlasItem} can cross a water body\n      */\n-    private boolean canCrossWaterBody(final AtlasItem crossingItem)\n+    private boolean canCrossWaterBody(final AtlasItem crossingItem,\n+            final GeometricSurface waterbody)\n     {\n-        // In the following cases, given item can cross a water body\n-\n-        return this.canCrossWaterBodyFilter.test(crossingItem)\n+        // In the following cases, given line can cross a water body\n+        if (this.canCrossWaterBodyFilter.test(crossingItem)\n                 // It has a tag starting with addr\n                 || crossingItem.containsKeyStartsWith(Collections.singleton(ADDRESS_PREFIX_KEY))\n                 // If crossing item is a line and meets the conditions for a boundary\n-                || crossingItem instanceof Line && isBoundary(crossingItem);\n+                || crossingItem instanceof Line && isBoundary(crossingItem))\n+        {\n+            return true;\n+        }\n+\n+        // Each intersection between the Edge & waterbody should have a Node in the atlas\n+        if (!(crossingItem instanceof Edge)\n+                || !this.intersectionsAreExplicit(waterbody, (Edge) crossingItem))\n+        {\n+            return false;\n+        }\n+\n+        // All intersections between the street and waterbody\n+        final Set<Location> intersections = waterbody instanceof Polygon\n+                ? ((Polygon) waterbody).intersections(((Edge) crossingItem).asPolyLine())\n+                : ((MultiPolygon) waterbody).outers().stream()\n+                        .flatMap(polygon -> polygon\n+                                .intersections(((Edge) crossingItem).asPolyLine()).stream())\n+                        .collect(Collectors.toSet());\n+        final Predicate<AtlasItem> hasFordTag = item -> !item.getTag(FordTag.KEY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MTgxNw==", "bodyText": "This could be updated to now check for\n\nsynthetic nearest neighbor tag\nmissing iso tag", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423161817", "createdAt": "2020-05-11T16:24:11Z", "author": {"login": "danielduhh"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheckTestRule.java", "diffHunk": "@@ -461,7 +461,8 @@\n             @Node(coordinates = @Loc(value = AREA_LOCATION_3)),\n             @Node(coordinates = @Loc(value = LOCATION_OUTSIDE_AREA_1)),\n             @Node(coordinates = @Loc(value = AREA_LOCATION_BETWEEN_2_AND_3)) }, areas = {\n-                    @Area(id = \"100\", coordinates = { @Loc(AREA_LOCATION_1), @Loc(AREA_LOCATION_2),\n+                    @Area(id = \"100\", tags = \"last_edit_time=20200422\", coordinates = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg==", "bodyText": "\ud83e\udd2f", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423162216", "createdAt": "2020-05-11T16:24:49Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjQwNA==", "bodyText": "I will leave this up to you but this is a bit hard to follow \ud83d\ude04", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423162404", "createdAt": "2020-05-11T16:25:05Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg=="}, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 184}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec536cc2f39f151ad87b4e767e0316fa5ba4818f", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/ec536cc2f39f151ad87b4e767e0316fa5ba4818f", "committedDate": "2020-05-11T23:12:03Z", "message": "address comments, unit tests, small fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTk2Mzgz", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-409596383", "createdAt": "2020-05-11T23:20:07Z", "commit": {"oid": "ec536cc2f39f151ad87b4e767e0316fa5ba4818f"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae54e77f93ff4f88a3db07dea74c203acc16350e", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/ae54e77f93ff4f88a3db07dea74c203acc16350e", "committedDate": "2020-05-12T02:40:37Z", "message": "add non offending nodes configurable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "741baa0c3cacd3b885710c9508c714c7e67c26df", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/741baa0c3cacd3b885710c9508c714c7e67c26df", "committedDate": "2020-05-12T16:45:59Z", "message": "Merge branch 'dev' into lcwbBorderRelationFix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe1d98f18b630b3394e93b3194bea6a823dacbcc", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/fe1d98f18b630b3394e93b3194bea6a823dacbcc", "committedDate": "2020-05-13T02:38:43Z", "message": "bump test coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/5b1c9b86181c6db585b998ffa6a8aeeb24eadd45", "committedDate": "2020-05-13T02:38:51Z", "message": "Merge branch 'lcwbBorderRelationFix' of https://github.com/seancoulter/atlas-checks into lcwbBorderRelationFix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTY0NDkx", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-410564491", "createdAt": "2020-05-13T03:33:54Z", "commit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMDY0NTAx", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-411064501", "createdAt": "2020-05-13T15:50:47Z", "commit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTo1MDo0N1rOGU4N8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTo1MDo0N1rOGU4N8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ==", "bodyText": "I think the use of SyntheticNearestNeighborCountryCodeTag in country slicing has been removed by osmlab/atlas#627.", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424545779", "createdAt": "2020-05-13T15:50:47Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdf234e039673b465e4d6366c2f8d8583019ef96", "author": {"user": null}, "url": "https://github.com/osmlab/atlas-checks/commit/bdf234e039673b465e4d6366c2f8d8583019ef96", "committedDate": "2020-05-13T21:32:31Z", "message": "add docs and take out nearest neighbor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzE2MjY0", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-411316264", "createdAt": "2020-05-13T21:34:37Z", "commit": {"oid": "bdf234e039673b465e4d6366c2f8d8583019ef96"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzE3NjE1", "url": "https://github.com/osmlab/atlas-checks/pull/287#pullrequestreview-411317615", "createdAt": "2020-05-13T21:37:05Z", "commit": {"oid": "bdf234e039673b465e4d6366c2f8d8583019ef96"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3317, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}