{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNDM3NDA1", "number": 258, "title": "Add new AtGradeSignPostCheck", "bodyText": "Description:\nThis PR adds new AtGradeSignPostCheck. The check flags any at-grade intersections that are not part of a destination_sign relation. An at-grade intersection is defined as an intersection of two or more edges with valid highway classification, all at the same z-level. The intersecting node can be part of multiple destination_sign relation. So even if the node is a member of a destination_sign relation, the check ensures to flag any missing destination_sign relation the node can be part of, based on the intersecting edges. The check also flags destination_relations of at-grade intersections that are missing destination_sign tag. If the intersection is an exit node of a roundabout, the entire roundabout is flagged in addition to the intersecting node and roundabout exit edge.\nExample: https://www.openstreetmap.org/node/892115562\n\nPotential Impact:\nNone. Just a new check to identify at-grade intersections with missing destination_sign tag.\nUnit Test Approach:\nAdded new unit tests.\nTest Results:\nAll tests passing.", "createdAt": "2020-02-11T01:41:56Z", "url": "https://github.com/osmlab/atlas-checks/pull/258", "merged": true, "mergeCommit": {"oid": "2fc5086545bebbe55500c9f79ab363c74915734a"}, "closed": true, "closedAt": "2020-02-19T22:54:19Z", "author": {"login": "sayas01"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABbvvr7EgH2gAyMzczNDM3NDA1OjY3ZTM4N2M4ZjBiNjQyYjMxZTMxODBhODc5MmNkY2IwNGViYmRmNDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcF-npDgFqTM2MTQ5ODgzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "67e387c8f0b642b31e3180a8792cdcb04ebbdf41", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/67e387c8f0b642b31e3180a8792cdcb04ebbdf41", "committedDate": "2019-12-12T21:02:53Z", "message": "Add check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff799ed2e133336896e01bdb1328a74809bba63a", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/ff799ed2e133336896e01bdb1328a74809bba63a", "committedDate": "2019-12-12T21:06:19Z", "message": "Fix merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5486d4bad61f3567abfd4be8bfaa1df70cfc7912", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/5486d4bad61f3567abfd4be8bfaa1df70cfc7912", "committedDate": "2019-12-30T15:42:05Z", "message": "Handle roundabouts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc4cf847871fa61fe29a76bfa0f19b7eae407d37", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/fc4cf847871fa61fe29a76bfa0f19b7eae407d37", "committedDate": "2019-12-30T16:02:00Z", "message": "spotless and checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec9ea3ead53da54baf749590de8ba27f49a3fc9b", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/ec9ea3ead53da54baf749590de8ba27f49a3fc9b", "committedDate": "2020-01-13T19:37:22Z", "message": "Update roundabout req"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f54200ef1370e830448f9a28037c2a388376fdaf", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/f54200ef1370e830448f9a28037c2a388376fdaf", "committedDate": "2020-01-27T15:48:53Z", "message": "Use edge direction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2884ff9bf62ae1e8415910075640e9cac74b20e6", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2884ff9bf62ae1e8415910075640e9cac74b20e6", "committedDate": "2020-01-27T15:53:26Z", "message": "Spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "509288f8288a8f20bb58d6947c8e4455c082adf1", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/509288f8288a8f20bb58d6947c8e4455c082adf1", "committedDate": "2020-02-10T18:23:21Z", "message": "Update java doc and spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e07b9dc729136d5a8fc3bd22a92b1b75a769ea7", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/5e07b9dc729136d5a8fc3bd22a92b1b75a769ea7", "committedDate": "2020-02-10T19:12:25Z", "message": "Add doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29281e60fefe5576b35e81d8e0772a50caf7bc61", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/29281e60fefe5576b35e81d8e0772a50caf7bc61", "committedDate": "2020-02-10T19:18:16Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f2239017f4951d2520044fe65dc0c14fed6adf8", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/6f2239017f4951d2520044fe65dc0c14fed6adf8", "committedDate": "2020-02-10T19:18:44Z", "message": "Merge branch 'dev' of https://github.com/osmlab/atlas-checks into at-grade"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a4ce050970fd521195a3b958f0d3473d016b486", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/8a4ce050970fd521195a3b958f0d3473d016b486", "committedDate": "2020-02-10T19:39:29Z", "message": "Fix checkstyle errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/db2251159588145501afe20f2f81706ba7dfb349", "committedDate": "2020-02-11T01:29:06Z", "message": "Clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTU3MDIz", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-359957023", "createdAt": "2020-02-17T20:41:02Z", "commit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDo0MTowMlrOFqvRiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMTowMTozOVrOFqvm7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1OTA0OA==", "bodyText": "It would be good to have a description of the connected highway types configurable here, as it is pretty complex.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380359048", "createdAt": "2020-02-17T20:41:02Z", "author": {"login": "Bentleysb"}, "path": "docs/checks/atGradeSignPostCheck.md", "diffHunk": "@@ -0,0 +1,29 @@\n+# AtGradeSignPostCheck\n+\n+#### Description\n+\n+This check identifies at-grade intersections that are not modeled into destination_sign relations. \n+An at-grade intersection is an intersection with two or more edges at the same level with valid \n+highway classifications.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MDAyNQ==", "bodyText": "Couldn't this just be done by using the keys from the connected highway types map? It looks like it would be a problem if the filter and map had different highway types, as the filter is used in populateInEdgeToOutEdgeMaps to check that the map will have the correct key.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380360025", "createdAt": "2020-02-17T20:44:53Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MTE1MQ==", "bodyText": "Old debug statement?", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380361151", "createdAt": "2020-02-17T20:48:42Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw==", "bodyText": "This description seems a little confusing,as it seems that the inputs are already filtered for items that aren't part of destination sign relations.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380364527", "createdAt": "2020-02-17T21:01:39Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getIntersectionsWithNoDestinationSignRelation(roundAboutInEdgeToOutEdgeMap,\n+                        inEdgeToOutEdgeMap, intersectingNode)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Get items part of intersection that is not part of any destination_sign relations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 427}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9242add79c0332241a77bfa90fc14f1806c14f2", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b9242add79c0332241a77bfa90fc14f1806c14f2", "committedDate": "2020-02-17T21:44:20Z", "message": "Address Pr comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2665d9daf49c32d4cc12bf542ad505b3362aa8f7", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2665d9daf49c32d4cc12bf542ad505b3362aa8f7", "committedDate": "2020-02-17T22:42:36Z", "message": "Rename method for clarity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fbcc941f882ff8dca54d269c4e6ff99635b504b", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7fbcc941f882ff8dca54d269c4e6ff99635b504b", "committedDate": "2020-02-17T22:45:07Z", "message": "Spotlessapply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/60a9a68b1ebe9c4e30cac68c0ade131804091085", "committedDate": "2020-02-18T23:24:34Z", "message": "Fix checkstyle and update doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/8035384cfe3212181922deb14c8aca5d7fce691e", "committedDate": "2020-02-19T19:31:13Z", "message": "Add challenge config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDE1Nzg0", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361415784", "createdAt": "2020-02-19T20:33:11Z", "commit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozMzoxMlrOFr2ndw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozMzoxMlrOFr2ndw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzkyNw==", "bodyText": "Why don't we put only the edges in filteredByHighways that are explicitly roundabouts in roundAboutInEdgeToOutEdgeMap? And the rest in inEdgeToOutEdgeMap", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381527927", "createdAt": "2020-02-19T20:33:12Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)\n+        {\n+            inEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                entitiesToBeFlagged.add(inEdge);\n+                entitiesToBeFlagged.addAll(setOfOutEdge);\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                //\n+                instructionIndex = INSTRUCTION_INDEX_ZERO;\n+            }\n+        }\n+        // Flag all roundabout edges\n+        else\n+        {\n+            roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                // Ideally there would only be one roundabout edge and one exit edge per node\n+                final Optional<AtlasEntity> roundaboutEdge = JunctionTag.isRoundabout(inEdge)\n+                        ? Optional.of(inEdge)\n+                        : setOfOutEdge.stream().filter(JunctionTag::isRoundabout).findFirst();\n+                final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                        .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+                if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+                {\n+                    entitiesToBeFlagged\n+                            .addAll(this.getRoundaboutEdges((Edge) roundaboutEdge.get()));\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                instructionIndex = INSTRUCTION_INDEX_THREE;\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collect all destination sign relations that the input atlas entity is member of.\n+     *\n+     * @param atlasEntity\n+     *            any {@link AtlasEntity}\n+     * @return Optional<Set<Relation>> that the atlasEntity is member of\n+     */\n+    private Optional<Set<Relation>> getParentDestinationSignRelations(final AtlasEntity atlasEntity)\n+    {\n+        final Set<Relation> setOfDestinationSignRelations = atlasEntity.relations().stream()\n+                .filter(relation -> RelationTypeTag.DESTINATION_SIGN.toString()\n+                        .equalsIgnoreCase(relation.tag(RelationTypeTag.KEY)))\n+                .collect(Collectors.toSet());\n+        return setOfDestinationSignRelations.isEmpty() ? Optional.empty()\n+                : Optional.of(setOfDestinationSignRelations);\n+    }\n+\n+    /**\n+     * Collects all destination sign relations with missing destination sign tag\n+     *\n+     * @param destinationSignRelations\n+     *            set of destination sign relations\n+     * @return set of relations with missing destination sign tag\n+     */\n+    private Set<Relation> getRelationsWithMissingDestinationTag(\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return destinationSignRelations.stream()\n+                .filter(relation -> relation.tag(DestinationTag.KEY) == null)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all roundabout edges starting with the given given\n+     *\n+     * @param startEdge\n+     *            {@link Edge}\n+     * @return Set of roundabout edges\n+     */\n+    private Set<AtlasEntity> getRoundaboutEdges(final Edge startEdge)\n+    {\n+        return new SimpleEdgeWalker(startEdge, this.isRoundaboutEdge()).collectEdges().stream()\n+                .map(AtlasEntity.class::cast).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Checks if given outEdge is at the same z level and in the same direction as that of the\n+     * inEdge\n+     *\n+     * @param inEdge\n+     *            inEdge\n+     * @param outEdge\n+     *            outEdge\n+     * @return true if the outEdge matches the above criteria for the given inEdge\n+     */\n+    private boolean isMatchingOutEdge(final Edge inEdge, final Edge outEdge)\n+    {\n+        return LevelTag.areOnSameLevel(inEdge, outEdge) && LayerTag.areOnSameLayer(inEdge, outEdge)\n+                && EDGE_DIRECTION_COMPARATOR.isSameDirection(inEdge, outEdge, true);\n+    }\n+\n+    /**\n+     * Checks if the edge is missing DestinationForwardTag if two way or is missing a destination\n+     * tag if one way\n+     *\n+     * @param edge\n+     *            any edge\n+     * @return true if the edge is missing the destination tags\n+     */\n+    private boolean isMissingDestinationTag(final Edge edge)\n+    {\n+        return (OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationForwardTag.KEY) == null)\n+                || (!OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationTag.KEY) == null);\n+    }\n+\n+    /**\n+     * Function for {@link SimpleEdgeWalker} that gathers connected edges that are part of a\n+     * roundabout.\n+     *\n+     * @return {@link Function} for {@link SimpleEdgeWalker}\n+     */\n+    private Function<Edge, Stream<Edge>> isRoundaboutEdge()\n+    {\n+        return edge -> edge.connectedEdges().stream()\n+                .filter(connected -> JunctionTag.isRoundabout(connected)\n+                        && HighwayTag.isCarNavigableHighway(connected));\n+    }\n+\n+    /**\n+     * Checks if given edge is a valid intersecting edge for an at-grade intersection\n+     *\n+     * @param edge\n+     *            edge\n+     * @return true if the edge is valid intersecting edge\n+     */\n+    private boolean isValidIntersectingEdge(final Edge edge)\n+    {\n+        return edge.isMasterEdge() && HighwayTag.highwayTag(edge).isPresent()\n+                && this.highwayFilter.contains(edge.highwayTag().getTagValue());\n+    }\n+\n+    /**\n+     * Collect matching out edges and corresponding in edge in a map. Store the roundabout edges and\n+     * non roundabout edges in separate maps.\n+     *\n+     * @param inEdges\n+     *            List<Edge> inEdges\n+     * @param outEdges\n+     *            Set<Edge> outEdges\n+     * @return Map<String, Map<AtlasEntity, Set<AtlasEntity>>> with Map of inEdge to outEdges for\n+     *         roundabout and non roundabout edges\n+     */\n+    private Map<String, Map<AtlasEntity, Set<AtlasEntity>>> populateInEdgeToOutEdgeMaps(\n+            final List<Edge> inEdges, final Set<Edge> outEdges)\n+    {\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = new HashMap<>();\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = new HashMap<>();\n+        inEdges.forEach(inEdge ->\n+        {\n+            final Optional<HighwayTag> highwayTag = HighwayTag.highwayTag(inEdge);\n+            if (highwayTag.isPresent()\n+                    && this.connectedHighwayTypes.containsKey(highwayTag.get().getTagValue()))\n+            {\n+                // Filter out edges based on level and layer tags and valid highway types\n+                final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                        .filter(outEdge -> this.isMatchingOutEdge(inEdge, outEdge))\n+                        .collect(Collectors.toSet());\n+                // There should be at least 2 valid outEdges\n+                if (filteredOutEdges.size() >= 2)\n+                {\n+                    final String inEdgeHighwayType = highwayTag.get().getTagValue();\n+                    final List<String> validHighwayTypesOfOutEdge = this.connectedHighwayTypes\n+                            .get(inEdgeHighwayType);\n+                    final Set<AtlasEntity> filteredByHighways = filteredOutEdges.stream()\n+                            .filter(atlasEntity ->\n+                            {\n+                                final Optional<HighwayTag> atlasEntityHighway = HighwayTag\n+                                        .highwayTag(atlasEntity);\n+                                return atlasEntityHighway.isPresent() && validHighwayTypesOfOutEdge\n+                                        .contains(atlasEntityHighway.get().getTagValue());\n+                            }).collect(Collectors.toSet());\n+                    // If any of the edges is a roundabout, add it to roundabout map\n+                    if (filteredByHighways.stream().anyMatch(JunctionTag::isRoundabout)\n+                            || JunctionTag.isRoundabout(inEdge))\n+                    {\n+                        roundAboutInEdgeToOutEdgeMap.put(inEdge, filteredByHighways);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 619}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDE3MDc4", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361417078", "createdAt": "2020-02-19T20:35:20Z", "commit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozNToyMVrOFr2rXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozNToyMVrOFr2rXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODkyNg==", "bodyText": "typo: given -> edge", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381528926", "createdAt": "2020-02-19T20:35:21Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)\n+        {\n+            inEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                entitiesToBeFlagged.add(inEdge);\n+                entitiesToBeFlagged.addAll(setOfOutEdge);\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                //\n+                instructionIndex = INSTRUCTION_INDEX_ZERO;\n+            }\n+        }\n+        // Flag all roundabout edges\n+        else\n+        {\n+            roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                // Ideally there would only be one roundabout edge and one exit edge per node\n+                final Optional<AtlasEntity> roundaboutEdge = JunctionTag.isRoundabout(inEdge)\n+                        ? Optional.of(inEdge)\n+                        : setOfOutEdge.stream().filter(JunctionTag::isRoundabout).findFirst();\n+                final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                        .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+                if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+                {\n+                    entitiesToBeFlagged\n+                            .addAll(this.getRoundaboutEdges((Edge) roundaboutEdge.get()));\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                instructionIndex = INSTRUCTION_INDEX_THREE;\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collect all destination sign relations that the input atlas entity is member of.\n+     *\n+     * @param atlasEntity\n+     *            any {@link AtlasEntity}\n+     * @return Optional<Set<Relation>> that the atlasEntity is member of\n+     */\n+    private Optional<Set<Relation>> getParentDestinationSignRelations(final AtlasEntity atlasEntity)\n+    {\n+        final Set<Relation> setOfDestinationSignRelations = atlasEntity.relations().stream()\n+                .filter(relation -> RelationTypeTag.DESTINATION_SIGN.toString()\n+                        .equalsIgnoreCase(relation.tag(RelationTypeTag.KEY)))\n+                .collect(Collectors.toSet());\n+        return setOfDestinationSignRelations.isEmpty() ? Optional.empty()\n+                : Optional.of(setOfDestinationSignRelations);\n+    }\n+\n+    /**\n+     * Collects all destination sign relations with missing destination sign tag\n+     *\n+     * @param destinationSignRelations\n+     *            set of destination sign relations\n+     * @return set of relations with missing destination sign tag\n+     */\n+    private Set<Relation> getRelationsWithMissingDestinationTag(\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return destinationSignRelations.stream()\n+                .filter(relation -> relation.tag(DestinationTag.KEY) == null)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all roundabout edges starting with the given given", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 507}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d97e797fe21d16c2d7faee68ec943e4a6e2b30cc", "committedDate": "2020-02-19T20:42:00Z", "message": "Typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDIyNzIw", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361422720", "createdAt": "2020-02-19T20:44:32Z", "commit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo0NDozMlrOFr284A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo0NDozMlrOFr284A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzQwOA==", "bodyText": "Is there any way we could have a nonempty roundAboutInEdgeToOutEdgeMap and inEdgeToOutEdgeMap? If so there should be a case to handle flagging both", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381533408", "createdAt": "2020-02-19T20:44:32Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 355}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDI2OTc3", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361426977", "createdAt": "2020-02-19T20:51:16Z", "commit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo1MToxNlrOFr3JqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxNDo0OFrOFr33Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjY4MA==", "bodyText": "Just wondering where we get these values from?", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381536680", "createdAt": "2020-02-19T20:51:16Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ==", "bodyText": "getOrDefault returns default value if no value is returned for a given key. I don't see the purpose of it since you are setting default value as null.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381537641", "createdAt": "2020-02-19T20:53:25Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ5NQ==", "bodyText": "Also, can we name the variable as nonRoundaboutInEdgeToOutEdgeMap instead of inEdgeToOutEdgeMap.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381543495", "createdAt": "2020-02-19T21:04:50Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ=="}, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ==", "bodyText": "Are we verifying that getFlaggedItems() is not null or not empty. Because, setOfFlaggedItems variable can be null.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381548295", "createdAt": "2020-02-19T21:14:48Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDQzOTc4", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361443978", "createdAt": "2020-02-19T21:18:12Z", "commit": {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60445867757e9fbeae497cf4bb26c8d800b954c1", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/60445867757e9fbeae497cf4bb26c8d800b954c1", "committedDate": "2020-02-19T21:33:37Z", "message": "Rename variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1143eb0de01bb6527871016d678b7a6821d146ae", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/1143eb0de01bb6527871016d678b7a6821d146ae", "committedDate": "2020-02-19T21:36:36Z", "message": "SpotlessApply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a52b6f9419860e2e14c775090c239b380470c97a", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/a52b6f9419860e2e14c775090c239b380470c97a", "committedDate": "2020-02-19T21:44:18Z", "message": "nit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d3213ca06635c3543d37032f05d7e78846c7219", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2d3213ca06635c3543d37032f05d7e78846c7219", "committedDate": "2020-02-19T21:55:50Z", "message": "Rename variable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efd0e4876faf58d471dc3b9e69f6015b1c6353ee", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/efd0e4876faf58d471dc3b9e69f6015b1c6353ee", "committedDate": "2020-02-19T21:59:25Z", "message": "Fix checkstyle issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDcxNTE3", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361471517", "createdAt": "2020-02-19T22:03:07Z", "commit": {"oid": "efd0e4876faf58d471dc3b9e69f6015b1c6353ee"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMzI4NzU4", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361328758", "createdAt": "2020-02-19T18:24:15Z", "commit": {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085"}, "state": "DISMISSED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODoyNDoxNVrOFryczA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODoyNDozMVrOFrydbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1OTY2MA==", "bodyText": "All checks are enabled by default in this config", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381459660", "createdAt": "2020-02-19T18:24:15Z", "author": {"login": "danielduhh"}, "path": "config/configuration.json", "diffHunk": "@@ -940,5 +940,13 @@\n       \"difficulty\": \"MEDIUM\",\n       \"defaultPriority\": \"MEDIUM\"\n     }\n+  },\n+  \"AtGradeSignPostCheck\": {\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1OTgyMg==", "bodyText": "Thanks for adding this!", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381459822", "createdAt": "2020-02-19T18:24:31Z", "author": {"login": "danielduhh"}, "path": "docs/available_checks.md", "diffHunk": "@@ -27,6 +27,7 @@ This document is a list of tables with a description and link to documentation f\n | [SinkIslandCheck](tutorials/tutorial3-SinkIslandCheck.md) | The purpose of this check is to identify whether a network of car-navigable Edges can be exited. |\n | [SnakeRoadCheck](checks/snakeRoadCheck.md) | The purpose of the SnakeRoad check is to identify roads that should be split into two or more roads. |\n | [InvalidPiersCheck](checks/invalidPiersCheck.md) | The purpose of this check is to identify piers(OSM Ways with man_made=pier tag) that are ingested in Atlas as edges with linear or polygonal geometry without an area=yes tag |\n+| [AtGradeSignPostCheck](checks/atGradeSignPostCheck.md) | The purpose of this check is to identify at-grade intersections that are not part of destination sign relations. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75471cb394c39464d1f55a89de9fae956dc75dc6", "author": {"user": {"login": "sayas01", "name": "Sayana Saithu"}}, "url": "https://github.com/osmlab/atlas-checks/commit/75471cb394c39464d1f55a89de9fae956dc75dc6", "committedDate": "2020-02-19T22:13:51Z", "message": "remove enabled config key"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDc4NTUw", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361478550", "createdAt": "2020-02-19T22:15:15Z", "commit": {"oid": "75471cb394c39464d1f55a89de9fae956dc75dc6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDc4ODgw", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361478880", "createdAt": "2020-02-19T22:15:49Z", "commit": {"oid": "75471cb394c39464d1f55a89de9fae956dc75dc6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02d68d19ae1d7b2eea65beeb38f1b7cefd157b4b", "author": {"user": {"login": "danielduhh", "name": "Daniel B"}}, "url": "https://github.com/osmlab/atlas-checks/commit/02d68d19ae1d7b2eea65beeb38f1b7cefd157b4b", "committedDate": "2020-02-19T22:17:28Z", "message": "Merge branch 'dev' into at-grade"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eb3056141fea7eef49aff35b81ed88d1c73a04c", "author": {"user": {"login": "danielduhh", "name": "Daniel B"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2eb3056141fea7eef49aff35b81ed88d1c73a04c", "committedDate": "2020-02-19T22:22:36Z", "message": "Merge branch 'dev' into at-grade"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDk4ODM1", "url": "https://github.com/osmlab/atlas-checks/pull/258#pullrequestreview-361498835", "createdAt": "2020-02-19T22:53:07Z", "commit": {"oid": "2eb3056141fea7eef49aff35b81ed88d1c73a04c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3276, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}