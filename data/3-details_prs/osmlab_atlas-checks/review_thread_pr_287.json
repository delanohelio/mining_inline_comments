{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MTcyMjQ2", "number": 287, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoxMTo0MFrOD32Hyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTo1MDo0N1rOD8IPYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODg1MDAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoxMTo0MFrOGOVayg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozNzoxM1rOGSy42w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDE3MA==", "bodyText": "While this seems like it works -- this solution feels a bit hacky. We've ran into this issue before and proposed parsing the identifier to verify whether or not the feature has been sliced at the border -- this too felt like a hack.\nI would defer to atlas to provide a better (reusable) solution to verify if a feature has been country sliced -- as its shown to be useful in other checks.", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r417684170", "createdAt": "2020-04-30T00:11:40Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +335,61 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()\n+                .filter(member -> member.getRole().equals(\"outer\"))\n+                .map(member -> new Tuple<>(member.getEntity(),\n+                        new Polygon(member.getEntity() instanceof Area ? (Area) member.getEntity()\n+                                : (LineItem) member.getEntity())))\n+                .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                        || (intersectingFeature.within(member.getSecond())\n+                                && ((MultiPolygon) waterbody).inners().stream().noneMatch(\n+                                        innerMember -> intersectingFeature.intersects(innerMember)\n+                                                || intersectingFeature.within(innerMember))))\n+                        && member.getFirst().lastEdit().isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b8eb3070500a376eb6a024e9a695414c9c17e08"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTMwNw==", "bodyText": "I agree that this should definitely be in Atlas. However, just to get a short term solution/discussion going, I did a minor change on this logic to be more in line with how country slicing works- we're now making sure the relation member has any tag other than the IsoCountryTag and SyntheticNearestNeighborCountryCodeTag. These two tags are synthetically added to a relation member that's been sliced at the border. The new logic should validate the same features as the previous method since all validated members should still have the LastEditTimeTag/other OSM specific tags.\nThis change is at 28a3ce6#diff-829f2e37322d264fb3b26e180abc731eR404", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r422361307", "createdAt": "2020-05-08T20:37:13Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +335,61 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()\n+                .filter(member -> member.getRole().equals(\"outer\"))\n+                .map(member -> new Tuple<>(member.getEntity(),\n+                        new Polygon(member.getEntity() instanceof Area ? (Area) member.getEntity()\n+                                : (LineItem) member.getEntity())))\n+                .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                        || (intersectingFeature.within(member.getSecond())\n+                                && ((MultiPolygon) waterbody).inners().stream().noneMatch(\n+                                        innerMember -> intersectingFeature.intersects(innerMember)\n+                                                || intersectingFeature.within(innerMember))))\n+                        && member.getFirst().lastEdit().isPresent());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDE3MA=="}, "originalCommit": {"oid": "5b8eb3070500a376eb6a024e9a695414c9c17e08"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTE1MzA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxMzoyOFrOGTjUyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxMzoyOFrOGTjUyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NDg4OA==", "bodyText": "I believe this comment is out of date", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423154888", "createdAt": "2020-05-11T16:13:28Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTE2NDAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxNjoxMlrOGTjb0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoxNjoxMlrOGTjb0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE1NjY4OQ==", "bodyText": "Can the ford use case addition be added to the lines.non_offending configurable list?", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423156689", "createdAt": "2020-05-11T16:16:12Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -293,31 +302,61 @@ public boolean validCheckForObject(final AtlasObject object)\n      *            {@link AtlasItem} crossing\n      * @return whether given {@link AtlasItem} can cross a water body\n      */\n-    private boolean canCrossWaterBody(final AtlasItem crossingItem)\n+    private boolean canCrossWaterBody(final AtlasItem crossingItem,\n+            final GeometricSurface waterbody)\n     {\n-        // In the following cases, given item can cross a water body\n-\n-        return this.canCrossWaterBodyFilter.test(crossingItem)\n+        // In the following cases, given line can cross a water body\n+        if (this.canCrossWaterBodyFilter.test(crossingItem)\n                 // It has a tag starting with addr\n                 || crossingItem.containsKeyStartsWith(Collections.singleton(ADDRESS_PREFIX_KEY))\n                 // If crossing item is a line and meets the conditions for a boundary\n-                || crossingItem instanceof Line && isBoundary(crossingItem);\n+                || crossingItem instanceof Line && isBoundary(crossingItem))\n+        {\n+            return true;\n+        }\n+\n+        // Each intersection between the Edge & waterbody should have a Node in the atlas\n+        if (!(crossingItem instanceof Edge)\n+                || !this.intersectionsAreExplicit(waterbody, (Edge) crossingItem))\n+        {\n+            return false;\n+        }\n+\n+        // All intersections between the street and waterbody\n+        final Set<Location> intersections = waterbody instanceof Polygon\n+                ? ((Polygon) waterbody).intersections(((Edge) crossingItem).asPolyLine())\n+                : ((MultiPolygon) waterbody).outers().stream()\n+                        .flatMap(polygon -> polygon\n+                                .intersections(((Edge) crossingItem).asPolyLine()).stream())\n+                        .collect(Collectors.toSet());\n+        final Predicate<AtlasItem> hasFordTag = item -> !item.getTag(FordTag.KEY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTE5NTg0OnYy", "diffSide": "RIGHT", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheckTestRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoyNDoxMVrOGTjv2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoyNDoxMVrOGTjv2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MTgxNw==", "bodyText": "This could be updated to now check for\n\nsynthetic nearest neighbor tag\nmissing iso tag", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423161817", "createdAt": "2020-05-11T16:24:11Z", "author": {"login": "danielduhh"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheckTestRule.java", "diffHunk": "@@ -461,7 +461,8 @@\n             @Node(coordinates = @Loc(value = AREA_LOCATION_3)),\n             @Node(coordinates = @Loc(value = LOCATION_OUTSIDE_AREA_1)),\n             @Node(coordinates = @Loc(value = AREA_LOCATION_BETWEEN_2_AND_3)) }, areas = {\n-                    @Area(id = \"100\", coordinates = { @Loc(AREA_LOCATION_1), @Loc(AREA_LOCATION_2),\n+                    @Area(id = \"100\", tags = \"last_edit_time=20200422\", coordinates = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTE5ODQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjoyNDo0OVrOGTjxaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMzoyMDowMFrOGTwr4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg==", "bodyText": "\ud83e\udd2f", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423162216", "createdAt": "2020-05-11T16:24:49Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjQwNA==", "bodyText": "I will leave this up to you but this is a bit hard to follow \ud83d\ude04", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423162404", "createdAt": "2020-05-11T16:25:05Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg=="}, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM3MTU2OA==", "bodyText": "Added some comments and some clarification in the method docstring.. ec536cc#diff-829f2e37322d264fb3b26e180abc731eR380", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423371568", "createdAt": "2020-05-11T23:13:28Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg=="}, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM3Mzc5Mw==", "bodyText": "Awesome! Thanks for the updates", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r423373793", "createdAt": "2020-05-11T23:20:00Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +368,63 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is valid. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member doesn't have the {@link LastEditTimeTag}, it likely\n+     * did not come from an OSM feature, which suggests it was created due to atlas slicing and\n+     * would therefore not be a geometrically accurate member of the relation. 2. The intersecting\n+     * feature is entirely floating in an outer member of the relation, and not\n+     * intersecting/floating in any of the inner members. The inner members are typically islands so\n+     * we avoid flagging in the latter scenario. The outer member must still have the LastEditTime\n+     * tag\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        return !(waterbody instanceof MultiPolygon) || ((Relation) object).members().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE2MjIxNg=="}, "originalCommit": {"oid": "446221903b118ea099b5ef514c5d2232ef96de54"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Mzc2MTYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNTo1MDo0N1rOGU4N8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTozNTowM1rOGVEW8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ==", "bodyText": "I think the use of SyntheticNearestNeighborCountryCodeTag in country slicing has been removed by osmlab/atlas#627.", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424545779", "createdAt": "2020-05-13T15:50:47Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczODI0OQ==", "bodyText": "Good catch. Taking that out so we now only check if the feature has a tag other than the IsoCountryTag", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424738249", "createdAt": "2020-05-13T21:21:08Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, "originalCommit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0MTczOQ==", "bodyText": "According to https://github.com/osmlab/atlas/blob/f9ebfa344fb5891e3a21a2e790ea3f153230d4ec/src/main/java/org/openstreetmap/atlas/geography/atlas/raw/slicing/RawAtlasSlicer.java#L442, synthetically added relation members at borders would only have the IsoCountryTag tag. So checking for any tag other than that is looking like a good/straightforward estimation for whether or not the feature was synthetically created, especially considering that features not synthetically created would have OSM tags as well.", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424741739", "createdAt": "2020-05-13T21:28:28Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, "originalCommit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0MjE3Mg==", "bodyText": "nice! thanks for looking into it", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424742172", "createdAt": "2020-05-13T21:29:26Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, "originalCommit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0Mjc0Mw==", "bodyText": "So to clarify.. if the feature only contains a iso country code, we can assume it was synthetically added.", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424742743", "createdAt": "2020-05-13T21:30:41Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, "originalCommit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc0NDY4OQ==", "bodyText": "as far as multipolygon relation members go, that's the idea.", "url": "https://github.com/osmlab/atlas-checks/pull/287#discussion_r424744689", "createdAt": "2020-05-13T21:35:03Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LineCrossingWaterBodyCheck.java", "diffHunk": "@@ -329,29 +380,72 @@ private boolean intersectionsAreExplicit(final GeometricSurface waterbody,\n                 .haveExplicitLocationsForIntersections(polygon, lineItem));\n     }\n \n+    /**\n+     * If the waterbody is an area, the intersection is flaggable. If it's not an area, it's a\n+     * multipolygon, and we make sure that either 1. The intersection is at an outer member of the\n+     * multipolygon and the outer member was not synthetically created by the atlas slicing process.\n+     * It's estimated that if the outer member only has the {@link ISOCountryTag} and\n+     * {@link SyntheticNearestNeighborCountryCodeTag}, it was created due to atlas slicing and would\n+     * therefore not be a geometrically accurate member of the relation. 2. The intersecting feature\n+     * is entirely floating in an outer member of the relation, and not intersecting/floating in any\n+     * of the inner members. The inner members are typically islands so we avoid flagging in the\n+     * latter scenario. The outer member must still have only the 2 tags mentioned above\n+     *\n+     * @param waterbody\n+     *            the GeometricSurface representation of the waterbody\n+     * @param object\n+     *            the AtlasEntity representation of the waterbody\n+     * @param intersectingFeature\n+     *            the intersecting building/road/line\n+     * @return true if either of the 2 above conditions are satisfied, false otherwise\n+     */\n+    private boolean intersectsValidPartOfWaterbody(final GeometricSurface waterbody,\n+            final AtlasObject object, final PolyLine intersectingFeature)\n+    {\n+        // The waterbody is not an area, or...\n+        return !(waterbody instanceof MultiPolygon)\n+                // Map all outer multipolygon members to a tuple of its AtlasEntity and the entity's\n+                // geometric Polygon, and check for appropriate intersection/containment/tagging\n+                || ((Relation) object).members().stream()\n+                        .flatMap(member -> member.getEntity() instanceof Relation\n+                                ? ((Relation) member.getEntity()).members().stream()\n+                                : Stream.of(member))\n+                        .filter(member -> member.getRole().equals(\"outer\"))\n+                        .map(member -> new Tuple<>(member.getEntity(),\n+                                new Polygon(member.getEntity() instanceof Area\n+                                        ? (Area) member.getEntity()\n+                                        : (LineItem) member.getEntity())))\n+                        .anyMatch(member -> (intersectingFeature.intersects(member.getSecond())\n+                                || (intersectingFeature.within(member.getSecond())\n+                                        && ((MultiPolygon) waterbody).inners().stream()\n+                                                .noneMatch(innerMember -> intersectingFeature\n+                                                        .intersects(innerMember)\n+                                                        || intersectingFeature\n+                                                                .within(innerMember))))\n+                                && (member.getFirst().getTags().keySet().stream().anyMatch(\n+                                        key -> !(key.equals(ISOCountryTag.KEY) || key.equals(\n+                                                SyntheticNearestNeighborCountryCodeTag.KEY)))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU0NTc3OQ=="}, "originalCommit": {"oid": "5b1c9b86181c6db585b998ffa6a8aeeb24eadd45"}, "originalPosition": 241}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3297, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}