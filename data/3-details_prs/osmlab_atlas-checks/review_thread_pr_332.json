{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzY4NTg3", "number": 332, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozNDoyNVrOEcuBlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTowMzo1OVrOEh0FUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTQ5NjUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozNDoyNVrOHHa0XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozNDoyNVrOHHa0XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0MTQ2OQ==", "bodyText": "nit: looks like we could move this check up a few lines before the elevation checks", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477541469", "createdAt": "2020-08-26T19:34:25Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 353}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTUxMjAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozODo1NVrOHHa93A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1OTozNVrOHHbpVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0MzkwMA==", "bodyText": "General question: is it possible to get a waterway that is an offender in multiple ways to this Check? E.g. a waterway that ends in a sink and crosses itself. If so we could append instructions together in one flag instead of returning only one instruction set per flag.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477543900", "createdAt": "2020-08-26T19:38:55Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTAzMQ==", "bodyText": "It is probably technically possible (so crossing waterways, waterway not properly connected to another waterway, and waterway going in the wrong direction).\nI'll look into appending instructions tomorrow.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477555031", "createdAt": "2020-08-26T19:59:35Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0MzkwMA=="}, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTUyMDc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo0MToxM1rOHHbC4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowMDoyM1rOHHbrIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NTE4Ng==", "bodyText": "nit: intersectingWaterways", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477545186", "createdAt": "2020-08-26T19:41:13Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        else if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(object, first);\n+        }\n+        else if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line))\n+        {\n+            if (uphill)\n+            {\n+                flag = createUphillFlag(object, first);\n+            }\n+            else if (!endsWithBoundaryNode(object))\n+            {\n+                flag = createFlag(object,\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK),\n+                                object.getOsmIdentifier()),\n+                        Collections.singletonList(last));\n+            }\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (flag == null && crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                flag = createFlag(Sets.hashSet(object, crossed),\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY),\n+                                object.getOsmIdentifier(), crossed.getOsmIdentifier()),\n+                        Arrays.asList(intersections.next()));\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final AtlasObject object, final Location first)\n+    {\n+        return createFlag(object,\n+                this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL),\n+                        object.getOsmIdentifier(),\n+                        this.elevationUtils.getResolution(first).asMeters()));\n+    }\n+\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    private LineItem intersectsAnotherWaterWay(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final Iterable<LineItem> intersectinWaterways = atlas.lineItemsIntersecting(line.bounds(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NTQ5MQ==", "bodyText": "pick: nit (I'll fix it, it would bug me as well if I didn't...)", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477555491", "createdAt": "2020-08-26T20:00:23Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        else if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(object, first);\n+        }\n+        else if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line))\n+        {\n+            if (uphill)\n+            {\n+                flag = createUphillFlag(object, first);\n+            }\n+            else if (!endsWithBoundaryNode(object))\n+            {\n+                flag = createFlag(object,\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK),\n+                                object.getOsmIdentifier()),\n+                        Collections.singletonList(last));\n+            }\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (flag == null && crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                flag = createFlag(Sets.hashSet(object, crossed),\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY),\n+                                object.getOsmIdentifier(), crossed.getOsmIdentifier()),\n+                        Arrays.asList(intersections.next()));\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final AtlasObject object, final Location first)\n+    {\n+        return createFlag(object,\n+                this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL),\n+                        object.getOsmIdentifier(),\n+                        this.elevationUtils.getResolution(first).asMeters()));\n+    }\n+\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    private LineItem intersectsAnotherWaterWay(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final Iterable<LineItem> intersectinWaterways = atlas.lineItemsIntersecting(line.bounds(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NTE4Ng=="}, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTU1OTA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1MjozMVrOHHbaYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowMTo0NFrOHHbt3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1MTIwMA==", "bodyText": "We probably want to add that this check flags uphill waterways as well (docs/javadoc)\nI noticed it in a couple places, but wasn't sure if it was consistently mentioned", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477551200", "createdAt": "2020-08-26T19:52:31Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        else if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(object, first);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1NjE4OQ==", "bodyText": "I'll do that (I wrote the docs, then wrote the test, then checked NZL, where there are many waterways that are going the wrong direction, and then wrote the elevation check code).", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477556189", "createdAt": "2020-08-26T20:01:44Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        else if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(object, first);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1MTIwMA=="}, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 363}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDkxMDM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjowODoyNlrOHOvpSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMzoyMzowOVrOHOxMuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjcyOQ==", "bodyText": "I think this would be more reusable if the 3 srtm values were given as the constructor parameters, instead of needing to be in a configuration.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485222729", "createdAt": "2020-09-08T22:08:26Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final int SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final int srtmExtent;\n+\n+    private final String srtmExt;\n+\n+    private final String srtmPath;\n+\n+    /**\n+     * Configuration Keys in the Integrity Framework are based on the check simple classname.\n+     *\n+     * @param key\n+     *            key part for a specific configuration item defined for this class\n+     * @return complete key for lookup\n+     */\n+    private static String configurationKey(final String key)\n+    {\n+        return formatKey(\"elevationutilities\", key);\n+    }\n+\n+    private static <U, V> V configurationValue(final Configuration configuration, final String key,\n+            final U defaultValue, final Function<U, V> transform)\n+    {\n+        return configuration.get(configurationKey(key), defaultValue, transform).value();\n+    }\n+\n+    private static String formatKey(final String name, final String key)\n+    {\n+        return String.format(\"%s.%s\", name, key);\n+    }\n+\n+    /**\n+     * Create a configured ElevationUtilities\n+     *\n+     * @param configuration\n+     *            A configuration which should (at a minimum) have a file path for elevation files.\n+     */\n+    public ElevationUtilities(final Configuration configuration)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNjg0MA==", "bodyText": "I'll go ahead and make another constructor (I'd like to leave the configuration option in).", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485236840", "createdAt": "2020-09-08T22:48:56Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final int SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final int srtmExtent;\n+\n+    private final String srtmExt;\n+\n+    private final String srtmPath;\n+\n+    /**\n+     * Configuration Keys in the Integrity Framework are based on the check simple classname.\n+     *\n+     * @param key\n+     *            key part for a specific configuration item defined for this class\n+     * @return complete key for lookup\n+     */\n+    private static String configurationKey(final String key)\n+    {\n+        return formatKey(\"elevationutilities\", key);\n+    }\n+\n+    private static <U, V> V configurationValue(final Configuration configuration, final String key,\n+            final U defaultValue, final Function<U, V> transform)\n+    {\n+        return configuration.get(configurationKey(key), defaultValue, transform).value();\n+    }\n+\n+    private static String formatKey(final String name, final String key)\n+    {\n+        return String.format(\"%s.%s\", name, key);\n+    }\n+\n+    /**\n+     * Create a configured ElevationUtilities\n+     *\n+     * @param configuration\n+     *            A configuration which should (at a minimum) have a file path for elevation files.\n+     */\n+    public ElevationUtilities(final Configuration configuration)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjcyOQ=="}, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0MjIyMQ==", "bodyText": "That sounds good.\nFor the configuration constructor, where in the configuration are you expecting the values to be? Are they part of a check object, their own object, or top level entities? It would also be good to have a unit test to make sure custom values are read in properly.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485242221", "createdAt": "2020-09-08T23:04:05Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final int SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final int srtmExtent;\n+\n+    private final String srtmExt;\n+\n+    private final String srtmPath;\n+\n+    /**\n+     * Configuration Keys in the Integrity Framework are based on the check simple classname.\n+     *\n+     * @param key\n+     *            key part for a specific configuration item defined for this class\n+     * @return complete key for lookup\n+     */\n+    private static String configurationKey(final String key)\n+    {\n+        return formatKey(\"elevationutilities\", key);\n+    }\n+\n+    private static <U, V> V configurationValue(final Configuration configuration, final String key,\n+            final U defaultValue, final Function<U, V> transform)\n+    {\n+        return configuration.get(configurationKey(key), defaultValue, transform).value();\n+    }\n+\n+    private static String formatKey(final String name, final String key)\n+    {\n+        return String.format(\"%s.%s\", name, key);\n+    }\n+\n+    /**\n+     * Create a configured ElevationUtilities\n+     *\n+     * @param configuration\n+     *            A configuration which should (at a minimum) have a file path for elevation files.\n+     */\n+    public ElevationUtilities(final Configuration configuration)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjcyOQ=="}, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0ODE4NQ==", "bodyText": "I'm expecting them to be part of their own configuration section, e.g.\n{\n    \"elevationutilities\": {\n        \"elevation.srtm_extent\": \"1\" (degree),\n        \"elevation.srtm_ext\": \"hgt\" (file extension),\n        \"elevation.path\": \"elevation\"\n    }\n}\n(I copied/pasted from docs/utilities/elevationUtilities).\nI'll see if I can make a specific test for it tomorrow (I thought I had one for that somewhere, but it doesn't look like it).", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485248185", "createdAt": "2020-09-08T23:23:09Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final int SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final int srtmExtent;\n+\n+    private final String srtmExt;\n+\n+    private final String srtmPath;\n+\n+    /**\n+     * Configuration Keys in the Integrity Framework are based on the check simple classname.\n+     *\n+     * @param key\n+     *            key part for a specific configuration item defined for this class\n+     * @return complete key for lookup\n+     */\n+    private static String configurationKey(final String key)\n+    {\n+        return formatKey(\"elevationutilities\", key);\n+    }\n+\n+    private static <U, V> V configurationValue(final Configuration configuration, final String key,\n+            final U defaultValue, final Function<U, V> transform)\n+    {\n+        return configuration.get(configurationKey(key), defaultValue, transform).value();\n+    }\n+\n+    private static String formatKey(final String name, final String key)\n+    {\n+        return String.format(\"%s.%s\", name, key);\n+    }\n+\n+    /**\n+     * Create a configured ElevationUtilities\n+     *\n+     * @param configuration\n+     *            A configuration which should (at a minimum) have a file path for elevation files.\n+     */\n+    public ElevationUtilities(final Configuration configuration)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjcyOQ=="}, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDkxNDg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoxMDoyMVrOHOvr5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0ODowNlrOHOwfXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzM5Nw==", "bodyText": "Nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String SRTM_EXT = \"hgt\";\n          \n          \n            \n                private static final String SRTM_EXTENTION = \"hgt\";", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485223397", "createdAt": "2020-09-08T22:10:21Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNjU3Mg==", "bodyText": "I've expanded EXT/Ext to the appropriately cased extension.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485236572", "createdAt": "2020-09-08T22:48:06Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzM5Nw=="}, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDkxNjIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoxMDo1NVrOHOvssw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoxMDo1NVrOHOvssw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzYwMw==", "bodyText": "Nit\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final String srtmExt;\n          \n          \n            \n                private final String srtmExtension;", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485223603", "createdAt": "2020-09-08T22:10:55Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final int SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final int srtmExtent;\n+\n+    private final String srtmExt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDkzNzg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoyMDozMFrOHOv5pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMzoyODoxNVrOHOxSrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyNjkxNg==", "bodyText": "I am a bit confused what is happening at this point (some comments throughout this method would help). Is this considering a polyline to end in the ocean if it is to the east of a coast?", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485226916", "createdAt": "2020-09-08T22:20:30Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,467 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0Mzk2MA==", "bodyText": "There are two assumptions at play here:\n\nnatural=coastline follows the specification, and the ocean is to the right of the coastline way.\nThe geometry isn't so complicated that the waterway loops around the coastline (I can make a contrived example, but I haven't seen any real-world examples that couldn't be more accurately modeled).\n\nI've gone ahead and added some documentation.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485243960", "createdAt": "2020-09-08T23:09:28Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,467 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyNjkxNg=="}, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0OTcwOQ==", "bodyText": "I see, thanks for the clarification and the docs. It might be worth it to add a note about the ocean specification assumption in either the flag instructions or the MapRoulette challenge instructions in the configuration. That way editors may be able to identify incorrectly modeled coastlines that are getting caught by this check.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485249709", "createdAt": "2020-09-08T23:28:15Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,467 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyNjkxNg=="}, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDk1MDI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoyNTozN1rOHOwAvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMzoxMToyM1rOHOw-pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyODczNQ==", "bodyText": "I think you can simplify this method by using Atlas.lineItemsContaining(Location), and filtering from there.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485228735", "createdAt": "2020-09-08T22:25:37Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,467 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0NDU4Mw==", "bodyText": "I didn't see that when I was coding. I probably have similar code in the other water check PR I made.\nThanks. :)", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485244583", "createdAt": "2020-09-08T23:11:23Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,467 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyODczNQ=="}, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTAwNTczOnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0OToyM1rOHOwhNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0OToyM1rOHOwhNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNzA0NA==", "bodyText": "This needs a challenge object with the MapRoulette information.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485237044", "createdAt": "2020-09-08T22:49:23Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -1068,5 +1068,13 @@\n       \"difficulty\": \"EASY\",\n       \"defaultPriority\": \"LOW\"\n     }\n+  },\n+  \"WaterWayCheck\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85289c0103464782c51f30a489463dc287840df6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODI5MDA1OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjoyMjo1M1rOHPPnTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjoyMjo1M1rOHPPnTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc0NjUxMA==", "bodyText": "You can simplify these configs with:\nocean: {\n  boundary: \"\",\n  valid: \"\"\n},\nwaterway: {\n elevation: {\n  distance.min.start.end: \"\",\n  resolution.min.uphill: \"\"\n },\n sink.tags.filters: \"\",\n tags.filters: \"\"\n\n}", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485746510", "createdAt": "2020-09-09T16:22:53Z", "author": {"login": "danielduhh"}, "path": "config/configuration.json", "diffHunk": "@@ -1068,5 +1068,20 @@\n       \"difficulty\": \"EASY\",\n       \"defaultPriority\": \"LOW\"\n     }\n+  },\n+  \"WaterWayCheck\": {\n+    \"ocean.boundary\": \"natural->coastline\",\n+    \"ocean.valid\": \"natural->strait,channel,fjord,sound,bay|harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\",\n+    \"waterway.elevation.distance.min.start.end\": 450.0,\n+    \"waterway.elevation.resolution.min.uphill\": 1.0,\n+    \"waterway.sink.tags.filters\": \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\",\n+    \"waterway.tags.filters\": \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODM2MjU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjozNjoxN1rOHPQUDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDozMTo1NVrOHPZQMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1Nzk2Ng==", "bodyText": "Is this copied from OceanBleedingCheck? https://github.com/osmlab/atlas-checks/blob/dev/src/main/java/org/openstreetmap/atlas/checks/validation/intersections/OceanBleedingCheck.java#L40\nIf so, lets pull them both out into a tag util that can be shared", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485757966", "createdAt": "2020-09-09T16:36:17Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwMjg1MQ==", "bodyText": "IIRC, it is. I think I copied it, with the intention of seeing if I would have to change it. I never did.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485802851", "createdAt": "2020-09-09T17:43:13Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1Nzk2Ng=="}, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkwNDQzMg==", "bodyText": "I created another Utility class specifically for common filters.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485904432", "createdAt": "2020-09-09T20:31:55Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1Nzk2Ng=="}, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODM2NDQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjozNjozN1rOHPQVNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjozNjozN1rOHPQVNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1ODI2Mw==", "bodyText": "nit: extra space", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485758263", "createdAt": "2020-09-09T16:36:37Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODM2NDg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjozNjo0MVrOHPQVfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjozNjo0MVrOHPQVfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1ODMzNQ==", "bodyText": "nit: extra space", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485758335", "createdAt": "2020-09-09T16:36:41Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODM4NjA4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0MDoyNlrOHPQiog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0MDoyNlrOHPQiog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2MTY5OA==", "bodyText": "Do you mind adding java docs here?", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485761698", "createdAt": "2020-09-09T16:40:26Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK), object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 421}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODM4OTI0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0MTowM1rOHPQkhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0MTowM1rOHPQkhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2MjE4Mw==", "bodyText": "Same comment here on documentation", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485762183", "createdAt": "2020-09-09T16:41:03Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK), object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (flag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        flag.addInstruction(instruction);\n+        return flag;\n+    }\n+\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    private LineItem intersectsAnotherWaterWay(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n+                this.waterwayTagFilter::test);\n+        final Set<LineItem> sameLayerWays = Iterables.stream(intersectingWaterways)\n+                .filter(potential -> LayerTag.areOnSameLayer(line, potential)\n+                        && !waterwayConnects(line, potential))\n+                .collectToSet();\n+        sameLayerWays.removeIf(line::equals);\n+        if (sameLayerWays.isEmpty())\n+        {\n+            return null;\n+        }\n+        return sameLayerWays.iterator().next();\n+    }\n+\n+    private boolean waterwayConnects(final LineItem line, final LineItem potential)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 457}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODM5MDE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0MToxMlrOHPQlBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0MToxMlrOHPQlBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2MjMwOA==", "bodyText": "Java docs here as well \ud83d\ude04", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485762308", "createdAt": "2020-09-09T16:41:12Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK), object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (flag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        flag.addInstruction(instruction);\n+        return flag;\n+    }\n+\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    private LineItem intersectsAnotherWaterWay(final LineItem line)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 440}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODQzMTAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0ODo1MlrOHPQ9cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo0ODo1MlrOHPQ9cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2ODU2MQ==", "bodyText": "getAtlas() can be an expensive operation. You should be able to store the atlas in the flag function in pass it to your helpers that need access to the entire atlas.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485768561", "createdAt": "2020-09-09T16:48:52Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,493 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af4e84e30b41cb62fea75c6ba32b61352aaa1ac"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODQzOTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo1MDozNlrOHPRC4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo1MDozNlrOHPRC4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2OTk1Mg==", "bodyText": "Please avoid single letter variables", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485769952", "createdAt": "2020-09-09T16:50:36Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXTENSION = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final double SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final double srtmExtent;\n+\n+    private final String srtmExtension;\n+\n+    private final String srtmPath;\n+\n+    /**\n+     * Configuration Keys in the Integrity Framework are based on the check simple classname.\n+     *\n+     * @param key\n+     *            key part for a specific configuration item defined for this class\n+     * @return complete key for lookup\n+     */\n+    private static String configurationKey(final String key)\n+    {\n+        return formatKey(ElevationUtilities.class.getSimpleName(), key);\n+    }\n+\n+    private static <U, V> V configurationValue(final Configuration configuration, final String key,\n+            final U defaultValue, final Function<U, V> transform)\n+    {\n+        return configuration.get(configurationKey(key), defaultValue, transform).value();\n+    }\n+\n+    private static String formatKey(final String name, final String key)\n+    {\n+        return String.format(\"%s.%s\", name, key);\n+    }\n+\n+    /**\n+     * Create a configured ElevationUtilities\n+     *\n+     * @param configuration\n+     *            A configuration which should (at a minimum) have a file path for elevation files.\n+     */\n+    public ElevationUtilities(final Configuration configuration)\n+    {\n+        this(configurationValue(configuration, \"elevation.srtm_extent\", SRTM_EXTENT, i -> i),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af4e84e30b41cb62fea75c6ba32b61352aaa1ac"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODQ0ODIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo1MjowNlrOHPRHyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo1MjowNlrOHPRHyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc3MTIxMQ==", "bodyText": "nit: please avoid single letter variables", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485771211", "createdAt": "2020-09-09T16:52:06Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,493 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af4e84e30b41cb62fea75c6ba32b61352aaa1ac"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODcwNTQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODowMToxMlrOHPTqjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODowMToxMlrOHPTqjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxMjg3Nw==", "bodyText": "Could be simplified as :  return difference != null && difference.asDegrees() > 0;", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485812877", "createdAt": "2020-09-09T18:01:12Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 339}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODcxMTIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODowMjo1M1rOHPTuNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMDowMDoyM1rOHPYMVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxMzgxMg==", "bodyText": "Same comment as https://github.com/osmlab/atlas-checks/pull/332/files#r485768561 on storing the atlas and passing it to helpers.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485813812", "createdAt": "2020-09-09T18:02:53Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4NzA2Mg==", "bodyText": "I was kind of surprised by this. I expected that call to be pretty cheap. :(", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485887062", "createdAt": "2020-09-09T20:00:23Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxMzgxMg=="}, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODcyNjI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODowNzoyNlrOHPT3qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwMTowMTo1OFrOHPfOTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxNjIzMg==", "bodyText": "Missing this keyword.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485816232", "createdAt": "2020-09-09T18:07:26Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 479}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3Mzc1Mw==", "bodyText": "That wasn't part of the style guide. (The guide being ./gradlew spotlessCheck). Should look into updating that to force methods to have this as a qualifier?", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485873753", "createdAt": "2020-09-09T19:44:55Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxNjIzMg=="}, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 479}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwMjI1Mg==", "bodyText": "I think it would be good to add it to spotlessCheck. @taylorsmock", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r486002252", "createdAt": "2020-09-10T01:01:58Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxNjIzMg=="}, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 479}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODgwNjQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODozMDozMlrOHPUo3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzoyODo1NFrOHPdpDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODgzMA==", "bodyText": "Should we pass the entire polyline as an argument to make sure there are no intermediate elevation changes? Might require a loop in getIncline() over all pairs of points in the polyline", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485828830", "createdAt": "2020-09-09T18:30:32Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzMTM3Mg==", "bodyText": "I see from the next few lines that this might complicate the existing logic. So just if you think it's best !", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485831372", "createdAt": "2020-09-09T18:35:23Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODgzMA=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3ODQ0NA==", "bodyText": "I elected to not do this for two reasons:\n\nThe elevation data may not be \"fine\" enough to determine elevation between two nearby points (and won't be, in most cases).\nThere may be a ditch that is lower than the surrounding terrain that is not accounted for in the elevation data (highly likely with SRTM data).\n\nBoth (1) and (2) would be ameliorated if the elevation data is sufficiently fine. However, public domain data from the SRTM NASA mission have ~30m resolution, at best. Other data sources may be in the public domain and may have sufficient resolution for this, but I was more focused on general incline for the line instead of specific incline between points. I suppose we could check that the incline between each point in the line is downwards, and then have a specific instruction set for that.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485878444", "createdAt": "2020-09-09T19:50:15Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODgzMA=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2Mjk2NA==", "bodyText": "That's fair! To avoid over complicating the elevation part of the check I think it's fine as is. If we ever come across a dataset with finer resolution we could pull this out into a new check to look at the problem more closely", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485962964", "createdAt": "2020-09-09T22:46:58Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODgzMA=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NjMzMg==", "bodyText": "I've added a comment to indicate that it can be expanded in the future, if it makes sense with available data sets.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485976332", "createdAt": "2020-09-09T23:28:54Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODgzMA=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODg1MTUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODo0NDowMlrOHPVE4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODo0NDowMlrOHPVE4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNjAwMQ==", "bodyText": "Since LineItem uses its underlying Polyline to create bounds via a Rectangle and not a line, we might pick up some waterways that do not intersect the param waterway but instead intersect its bounds. To avoid that we could say\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n          \n          \n            \n                            this.waterwayTagFilter::test);\n          \n          \n            \n                    final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(), incoming -> this.waterwayTagFilter.test(incoming) && incoming.asPolyLine().intersects(line.asPolyLine());", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485836001", "createdAt": "2020-09-09T18:44:02Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    /**\n+     * Get an intersecting waterway, if one exists.\n+     *\n+     * @param line\n+     *            The waterway to look for intersections for.\n+     * @return A crossing waterway, or {@code null} if no crossing waterway exists.\n+     */\n+    private LineItem intersectsAnotherWaterWay(final Atlas atlas, final LineItem line)\n+    {\n+        final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n+                this.waterwayTagFilter::test);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 489}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODg2MDg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODo0Njo1NlrOHPVKog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTo1MzoyMVrOHPX1ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNzQ3NA==", "bodyText": "Is there any reason why we only look at one intersecting waterway ?", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485837474", "createdAt": "2020-09-09T18:46:56Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    /**\n+     * Get an intersecting waterway, if one exists.\n+     *\n+     * @param line\n+     *            The waterway to look for intersections for.\n+     * @return A crossing waterway, or {@code null} if no crossing waterway exists.\n+     */\n+    private LineItem intersectsAnotherWaterWay(final Atlas atlas, final LineItem line)\n+    {\n+        final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n+                this.waterwayTagFilter::test);\n+        final Set<LineItem> sameLayerWays = Iterables.stream(intersectingWaterways)\n+                .filter(potential -> LayerTag.areOnSameLayer(line, potential)\n+                        && !waterwayConnects(line, potential))\n+                .collectToSet();\n+        sameLayerWays.removeIf(line::equals);\n+        if (sameLayerWays.isEmpty())\n+        {\n+            return null;\n+        }\n+        return sameLayerWays.iterator().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 499}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4MTIyNg==", "bodyText": "I was trying to \"flag\" each object as quickly as possible, to avoid significantly increasing processing times. Since then, I started working on a generic check for invalid tags (using TagInfo data and OSM Wiki Data items), and I learned a whole new meaning for \"long processing time\" (for reference, my 5 country test runs went from ~2 hours to 14+ hours, and in one case, almost 23 hours). I've gotten that back down to ~3 hours, and I'm looking for more optimizations for that, but this isn't in the same category at all.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485881226", "createdAt": "2020-09-09T19:53:21Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    /**\n+     * Get an intersecting waterway, if one exists.\n+     *\n+     * @param line\n+     *            The waterway to look for intersections for.\n+     * @return A crossing waterway, or {@code null} if no crossing waterway exists.\n+     */\n+    private LineItem intersectsAnotherWaterWay(final Atlas atlas, final LineItem line)\n+    {\n+        final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n+                this.waterwayTagFilter::test);\n+        final Set<LineItem> sameLayerWays = Iterables.stream(intersectingWaterways)\n+                .filter(potential -> LayerTag.areOnSameLayer(line, potential)\n+                        && !waterwayConnects(line, potential))\n+                .collectToSet();\n+        sameLayerWays.removeIf(line::equals);\n+        if (sameLayerWays.isEmpty())\n+        {\n+            return null;\n+        }\n+        return sameLayerWays.iterator().next();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNzQ3NA=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 499}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODg2NDAzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODo0Nzo1NVrOHPVMhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODo0Nzo1NVrOHPVMhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNzk1OQ==", "bodyText": "nit: could name this getIntersectingWaterway(s?)(...) as it's not returning a boolean", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485837959", "createdAt": "2020-09-09T18:47:55Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    /**\n+     * Get an intersecting waterway, if one exists.\n+     *\n+     * @param line\n+     *            The waterway to look for intersections for.\n+     * @return A crossing waterway, or {@code null} if no crossing waterway exists.\n+     */\n+    private LineItem intersectsAnotherWaterWay(final Atlas atlas, final LineItem line)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 486}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODg4NjM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODo1NDozNVrOHPVaVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMzoyMzowNlrOHPdiLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MTQ5Mw==", "bodyText": "if sonar is complaining about declaring a stream and not having a terminal operation applied, I think we can make this a one liner :)", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485841493", "createdAt": "2020-09-09T18:54:35Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4NDM2Ng==", "bodyText": "I'm not seeing this in sonar. Am I looking in the wrong place?\nhttps://sonarcloud.io/project/issues?id=org.openstreetmap.atlas%3Aatlas-checks&pullRequest=332&resolved=false", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485884366", "createdAt": "2020-09-09T19:56:56Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MTQ5Mw=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2MTU5Mw==", "bodyText": "Ah I misread -- your code is fine, Sonar would only complain if an operation was applied to the stream that wasn't a terminal operation. You've got the right place, and you should be able to integrate Sonar into your IDE as well depending on your IDE. check out this for IntelliJ if you haven't already - https://www.sonarlint.org/intellij/index.html", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485961593", "createdAt": "2020-09-09T22:43:05Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MTQ5Mw=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NDU3NA==", "bodyText": "I use Eclipse, and I do have it integrated.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485974574", "createdAt": "2020-09-09T23:23:06Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MTQ5Mw=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzODkxNzkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTowMzo1OVrOHPVt9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTo1OTowMVrOHPYIKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NjUxNw==", "bodyText": "I think we could have the same treatment of Lines and Edges here. If either feature has a node or point at its end that's a sink, return true", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485846517", "createdAt": "2020-09-09T19:03:59Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4NTk5NA==", "bodyText": "This goes back to trying to optimize to avoid significant increases in processing time. Again, compared to my latest in-progress check, this is peanuts. :)", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485885994", "createdAt": "2020-09-09T19:59:01Z", "author": {"login": "tsmock"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NjUxNw=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 256}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3140, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}