{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNDM3NDA1", "number": 258, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDo0MTowMlrODggALQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxNDo0OFrODhOXLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDA1MzU3OnYy", "diffSide": "RIGHT", "path": "docs/checks/atGradeSignPostCheck.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDo0MTowMlrOFqvRiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDo0MTowMlrOFqvRiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1OTA0OA==", "bodyText": "It would be good to have a description of the connected highway types configurable here, as it is pretty complex.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380359048", "createdAt": "2020-02-17T20:41:02Z", "author": {"login": "Bentleysb"}, "path": "docs/checks/atGradeSignPostCheck.md", "diffHunk": "@@ -0,0 +1,29 @@\n+# AtGradeSignPostCheck\n+\n+#### Description\n+\n+This check identifies at-grade intersections that are not modeled into destination_sign relations. \n+An at-grade intersection is an intersection with two or more edges at the same level with valid \n+highway classifications.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDA2MDEyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDo0NDo1M1rOFqvVWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDo0NDo1M1rOFqvVWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MDAyNQ==", "bodyText": "Couldn't this just be done by using the keys from the connected highway types map? It looks like it would be a problem if the filter and map had different highway types, as the filter is used in populateInEdgeToOutEdgeMaps to check that the map will have the correct key.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380360025", "createdAt": "2020-02-17T20:44:53Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDA2ODA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMDo0ODo0MlrOFqvZvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMTo0NzoxM1rOFqwTeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MTE1MQ==", "bodyText": "Old debug statement?", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380361151", "createdAt": "2020-02-17T20:48:42Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3NTkyOA==", "bodyText": "Yp! Removed it! :)", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380375928", "createdAt": "2020-02-17T21:47:13Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MTE1MQ=="}, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NDA5MDUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMTowMTozOVrOFqvm7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjo0NjoyMFrOFqxGsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw==", "bodyText": "This description seems a little confusing,as it seems that the inputs are already filtered for items that aren't part of destination sign relations.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380364527", "createdAt": "2020-02-17T21:01:39Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getIntersectionsWithNoDestinationSignRelation(roundAboutInEdgeToOutEdgeMap,\n+                        inEdgeToOutEdgeMap, intersectingNode)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Get items part of intersection that is not part of any destination_sign relations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3NTczMA==", "bodyText": "This method returns intersections that do not have destination sign relations. The params for this method are not filtered prior based on destination_sign relation. I have slightly updated the comment. Let me know if it is still unclear. I will be happy to be more descriptive.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380375730", "createdAt": "2020-02-17T21:46:20Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getIntersectionsWithNoDestinationSignRelation(roundAboutInEdgeToOutEdgeMap,\n+                        inEdgeToOutEdgeMap, intersectingNode)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Get items part of intersection that is not part of any destination_sign relations", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw=="}, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3ODg0Mw==", "bodyText": "Perhaps I am just missing something obvious here, but I am not seeing where the filtering for destination signs is happening. It looks the only filtering is for roundabout tags, and then everything gets added to the entitiesToBeFlagged set.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380378843", "createdAt": "2020-02-17T21:59:45Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getIntersectionsWithNoDestinationSignRelation(roundAboutInEdgeToOutEdgeMap,\n+                        inEdgeToOutEdgeMap, intersectingNode)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Get items part of intersection that is not part of any destination_sign relations", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw=="}, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4OTA0MQ==", "bodyText": "My bad! This method is called only if there is no destination_sign relation. This method simply flags the items in the input hashmaps. Since the flag method was getting long, I just pulled out the section that flags the items in the maps to this method. I have renamed the method and replaced the java doc for the method.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r380389041", "createdAt": "2020-02-17T22:46:20Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,644 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Valid highway types to be considered for the check\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->trunk,primary,secondary\";\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final TaggableFilter highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        if (String.valueOf(object.getOsmIdentifier()).equals(\"1720823768\"))\n+        {\n+            System.out.println(object);\n+        }\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getIntersectionsWithNoDestinationSignRelation(roundAboutInEdgeToOutEdgeMap,\n+                        inEdgeToOutEdgeMap, intersectingNode)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Get items part of intersection that is not part of any destination_sign relations", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2NDUyNw=="}, "originalCommit": {"oid": "db2251159588145501afe20f2f81706ba7dfb349"}, "originalPosition": 427}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTA5OTAwOnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODoyNDoxNVrOFryczA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMjoxNzoxM1rOFr5r5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1OTY2MA==", "bodyText": "All checks are enabled by default in this config", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381459660", "createdAt": "2020-02-19T18:24:15Z", "author": {"login": "danielduhh"}, "path": "config/configuration.json", "diffHunk": "@@ -940,5 +940,13 @@\n       \"difficulty\": \"MEDIUM\",\n       \"defaultPriority\": \"MEDIUM\"\n     }\n+  },\n+  \"AtGradeSignPostCheck\": {\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU3ODIxMg==", "bodyText": "Removed it!", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381578212", "createdAt": "2020-02-19T22:17:13Z", "author": {"login": "sayas01"}, "path": "config/configuration.json", "diffHunk": "@@ -940,5 +940,13 @@\n       \"difficulty\": \"MEDIUM\",\n       \"defaultPriority\": \"MEDIUM\"\n     }\n+  },\n+  \"AtGradeSignPostCheck\": {\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1OTY2MA=="}, "originalCommit": {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTEwMDA4OnYy", "diffSide": "RIGHT", "path": "docs/available_checks.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODoyNDozMVrOFrydbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODoyNDozMVrOFrydbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1OTgyMg==", "bodyText": "Thanks for adding this!", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381459822", "createdAt": "2020-02-19T18:24:31Z", "author": {"login": "danielduhh"}, "path": "docs/available_checks.md", "diffHunk": "@@ -27,6 +27,7 @@ This document is a list of tables with a description and link to documentation f\n | [SinkIslandCheck](tutorials/tutorial3-SinkIslandCheck.md) | The purpose of this check is to identify whether a network of car-navigable Edges can be exited. |\n | [SnakeRoadCheck](checks/snakeRoadCheck.md) | The purpose of the SnakeRoad check is to identify roads that should be split into two or more roads. |\n | [InvalidPiersCheck](checks/invalidPiersCheck.md) | The purpose of this check is to identify piers(OSM Ways with man_made=pier tag) that are ingested in Atlas as edges with linear or polygonal geometry without an area=yes tag |\n+| [AtGradeSignPostCheck](checks/atGradeSignPostCheck.md) | The purpose of this check is to identify at-grade intersections that are not part of destination sign relations. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60a9a68b1ebe9c4e30cac68c0ade131804091085"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTUyMDA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozMzoxMlrOFr2ndw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo0MDoyN1rOFr21LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzkyNw==", "bodyText": "Why don't we put only the edges in filteredByHighways that are explicitly roundabouts in roundAboutInEdgeToOutEdgeMap? And the rest in inEdgeToOutEdgeMap", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381527927", "createdAt": "2020-02-19T20:33:12Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)\n+        {\n+            inEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                entitiesToBeFlagged.add(inEdge);\n+                entitiesToBeFlagged.addAll(setOfOutEdge);\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                //\n+                instructionIndex = INSTRUCTION_INDEX_ZERO;\n+            }\n+        }\n+        // Flag all roundabout edges\n+        else\n+        {\n+            roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                // Ideally there would only be one roundabout edge and one exit edge per node\n+                final Optional<AtlasEntity> roundaboutEdge = JunctionTag.isRoundabout(inEdge)\n+                        ? Optional.of(inEdge)\n+                        : setOfOutEdge.stream().filter(JunctionTag::isRoundabout).findFirst();\n+                final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                        .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+                if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+                {\n+                    entitiesToBeFlagged\n+                            .addAll(this.getRoundaboutEdges((Edge) roundaboutEdge.get()));\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                instructionIndex = INSTRUCTION_INDEX_THREE;\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collect all destination sign relations that the input atlas entity is member of.\n+     *\n+     * @param atlasEntity\n+     *            any {@link AtlasEntity}\n+     * @return Optional<Set<Relation>> that the atlasEntity is member of\n+     */\n+    private Optional<Set<Relation>> getParentDestinationSignRelations(final AtlasEntity atlasEntity)\n+    {\n+        final Set<Relation> setOfDestinationSignRelations = atlasEntity.relations().stream()\n+                .filter(relation -> RelationTypeTag.DESTINATION_SIGN.toString()\n+                        .equalsIgnoreCase(relation.tag(RelationTypeTag.KEY)))\n+                .collect(Collectors.toSet());\n+        return setOfDestinationSignRelations.isEmpty() ? Optional.empty()\n+                : Optional.of(setOfDestinationSignRelations);\n+    }\n+\n+    /**\n+     * Collects all destination sign relations with missing destination sign tag\n+     *\n+     * @param destinationSignRelations\n+     *            set of destination sign relations\n+     * @return set of relations with missing destination sign tag\n+     */\n+    private Set<Relation> getRelationsWithMissingDestinationTag(\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return destinationSignRelations.stream()\n+                .filter(relation -> relation.tag(DestinationTag.KEY) == null)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all roundabout edges starting with the given given\n+     *\n+     * @param startEdge\n+     *            {@link Edge}\n+     * @return Set of roundabout edges\n+     */\n+    private Set<AtlasEntity> getRoundaboutEdges(final Edge startEdge)\n+    {\n+        return new SimpleEdgeWalker(startEdge, this.isRoundaboutEdge()).collectEdges().stream()\n+                .map(AtlasEntity.class::cast).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Checks if given outEdge is at the same z level and in the same direction as that of the\n+     * inEdge\n+     *\n+     * @param inEdge\n+     *            inEdge\n+     * @param outEdge\n+     *            outEdge\n+     * @return true if the outEdge matches the above criteria for the given inEdge\n+     */\n+    private boolean isMatchingOutEdge(final Edge inEdge, final Edge outEdge)\n+    {\n+        return LevelTag.areOnSameLevel(inEdge, outEdge) && LayerTag.areOnSameLayer(inEdge, outEdge)\n+                && EDGE_DIRECTION_COMPARATOR.isSameDirection(inEdge, outEdge, true);\n+    }\n+\n+    /**\n+     * Checks if the edge is missing DestinationForwardTag if two way or is missing a destination\n+     * tag if one way\n+     *\n+     * @param edge\n+     *            any edge\n+     * @return true if the edge is missing the destination tags\n+     */\n+    private boolean isMissingDestinationTag(final Edge edge)\n+    {\n+        return (OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationForwardTag.KEY) == null)\n+                || (!OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationTag.KEY) == null);\n+    }\n+\n+    /**\n+     * Function for {@link SimpleEdgeWalker} that gathers connected edges that are part of a\n+     * roundabout.\n+     *\n+     * @return {@link Function} for {@link SimpleEdgeWalker}\n+     */\n+    private Function<Edge, Stream<Edge>> isRoundaboutEdge()\n+    {\n+        return edge -> edge.connectedEdges().stream()\n+                .filter(connected -> JunctionTag.isRoundabout(connected)\n+                        && HighwayTag.isCarNavigableHighway(connected));\n+    }\n+\n+    /**\n+     * Checks if given edge is a valid intersecting edge for an at-grade intersection\n+     *\n+     * @param edge\n+     *            edge\n+     * @return true if the edge is valid intersecting edge\n+     */\n+    private boolean isValidIntersectingEdge(final Edge edge)\n+    {\n+        return edge.isMasterEdge() && HighwayTag.highwayTag(edge).isPresent()\n+                && this.highwayFilter.contains(edge.highwayTag().getTagValue());\n+    }\n+\n+    /**\n+     * Collect matching out edges and corresponding in edge in a map. Store the roundabout edges and\n+     * non roundabout edges in separate maps.\n+     *\n+     * @param inEdges\n+     *            List<Edge> inEdges\n+     * @param outEdges\n+     *            Set<Edge> outEdges\n+     * @return Map<String, Map<AtlasEntity, Set<AtlasEntity>>> with Map of inEdge to outEdges for\n+     *         roundabout and non roundabout edges\n+     */\n+    private Map<String, Map<AtlasEntity, Set<AtlasEntity>>> populateInEdgeToOutEdgeMaps(\n+            final List<Edge> inEdges, final Set<Edge> outEdges)\n+    {\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = new HashMap<>();\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = new HashMap<>();\n+        inEdges.forEach(inEdge ->\n+        {\n+            final Optional<HighwayTag> highwayTag = HighwayTag.highwayTag(inEdge);\n+            if (highwayTag.isPresent()\n+                    && this.connectedHighwayTypes.containsKey(highwayTag.get().getTagValue()))\n+            {\n+                // Filter out edges based on level and layer tags and valid highway types\n+                final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                        .filter(outEdge -> this.isMatchingOutEdge(inEdge, outEdge))\n+                        .collect(Collectors.toSet());\n+                // There should be at least 2 valid outEdges\n+                if (filteredOutEdges.size() >= 2)\n+                {\n+                    final String inEdgeHighwayType = highwayTag.get().getTagValue();\n+                    final List<String> validHighwayTypesOfOutEdge = this.connectedHighwayTypes\n+                            .get(inEdgeHighwayType);\n+                    final Set<AtlasEntity> filteredByHighways = filteredOutEdges.stream()\n+                            .filter(atlasEntity ->\n+                            {\n+                                final Optional<HighwayTag> atlasEntityHighway = HighwayTag\n+                                        .highwayTag(atlasEntity);\n+                                return atlasEntityHighway.isPresent() && validHighwayTypesOfOutEdge\n+                                        .contains(atlasEntityHighway.get().getTagValue());\n+                            }).collect(Collectors.toSet());\n+                    // If any of the edges is a roundabout, add it to roundabout map\n+                    if (filteredByHighways.stream().anyMatch(JunctionTag::isRoundabout)\n+                            || JunctionTag.isRoundabout(inEdge))\n+                    {\n+                        roundAboutInEdgeToOutEdgeMap.put(inEdge, filteredByHighways);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 619}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMTQzNw==", "bodyText": "So if there is at least one roundabout edge, then the intersection should be in roundAboutInEdgeToOutEdgeMap. If one of the inEdge is an entrance to a roundabout and outEdge is exit to a roundabout, there will not be a roundabout tag to these edges and I do not want them to be added to inEdgeToOutEdgeMap. This way, I can be sure to assign roundabout instruction to the intersection of these edges.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381531437", "createdAt": "2020-02-19T20:40:27Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)\n+        {\n+            inEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                entitiesToBeFlagged.add(inEdge);\n+                entitiesToBeFlagged.addAll(setOfOutEdge);\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                //\n+                instructionIndex = INSTRUCTION_INDEX_ZERO;\n+            }\n+        }\n+        // Flag all roundabout edges\n+        else\n+        {\n+            roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                // Ideally there would only be one roundabout edge and one exit edge per node\n+                final Optional<AtlasEntity> roundaboutEdge = JunctionTag.isRoundabout(inEdge)\n+                        ? Optional.of(inEdge)\n+                        : setOfOutEdge.stream().filter(JunctionTag::isRoundabout).findFirst();\n+                final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                        .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+                if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+                {\n+                    entitiesToBeFlagged\n+                            .addAll(this.getRoundaboutEdges((Edge) roundaboutEdge.get()));\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                instructionIndex = INSTRUCTION_INDEX_THREE;\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collect all destination sign relations that the input atlas entity is member of.\n+     *\n+     * @param atlasEntity\n+     *            any {@link AtlasEntity}\n+     * @return Optional<Set<Relation>> that the atlasEntity is member of\n+     */\n+    private Optional<Set<Relation>> getParentDestinationSignRelations(final AtlasEntity atlasEntity)\n+    {\n+        final Set<Relation> setOfDestinationSignRelations = atlasEntity.relations().stream()\n+                .filter(relation -> RelationTypeTag.DESTINATION_SIGN.toString()\n+                        .equalsIgnoreCase(relation.tag(RelationTypeTag.KEY)))\n+                .collect(Collectors.toSet());\n+        return setOfDestinationSignRelations.isEmpty() ? Optional.empty()\n+                : Optional.of(setOfDestinationSignRelations);\n+    }\n+\n+    /**\n+     * Collects all destination sign relations with missing destination sign tag\n+     *\n+     * @param destinationSignRelations\n+     *            set of destination sign relations\n+     * @return set of relations with missing destination sign tag\n+     */\n+    private Set<Relation> getRelationsWithMissingDestinationTag(\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return destinationSignRelations.stream()\n+                .filter(relation -> relation.tag(DestinationTag.KEY) == null)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all roundabout edges starting with the given given\n+     *\n+     * @param startEdge\n+     *            {@link Edge}\n+     * @return Set of roundabout edges\n+     */\n+    private Set<AtlasEntity> getRoundaboutEdges(final Edge startEdge)\n+    {\n+        return new SimpleEdgeWalker(startEdge, this.isRoundaboutEdge()).collectEdges().stream()\n+                .map(AtlasEntity.class::cast).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Checks if given outEdge is at the same z level and in the same direction as that of the\n+     * inEdge\n+     *\n+     * @param inEdge\n+     *            inEdge\n+     * @param outEdge\n+     *            outEdge\n+     * @return true if the outEdge matches the above criteria for the given inEdge\n+     */\n+    private boolean isMatchingOutEdge(final Edge inEdge, final Edge outEdge)\n+    {\n+        return LevelTag.areOnSameLevel(inEdge, outEdge) && LayerTag.areOnSameLayer(inEdge, outEdge)\n+                && EDGE_DIRECTION_COMPARATOR.isSameDirection(inEdge, outEdge, true);\n+    }\n+\n+    /**\n+     * Checks if the edge is missing DestinationForwardTag if two way or is missing a destination\n+     * tag if one way\n+     *\n+     * @param edge\n+     *            any edge\n+     * @return true if the edge is missing the destination tags\n+     */\n+    private boolean isMissingDestinationTag(final Edge edge)\n+    {\n+        return (OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationForwardTag.KEY) == null)\n+                || (!OneWayTag.isExplicitlyTwoWay(edge) && edge.tag(DestinationTag.KEY) == null);\n+    }\n+\n+    /**\n+     * Function for {@link SimpleEdgeWalker} that gathers connected edges that are part of a\n+     * roundabout.\n+     *\n+     * @return {@link Function} for {@link SimpleEdgeWalker}\n+     */\n+    private Function<Edge, Stream<Edge>> isRoundaboutEdge()\n+    {\n+        return edge -> edge.connectedEdges().stream()\n+                .filter(connected -> JunctionTag.isRoundabout(connected)\n+                        && HighwayTag.isCarNavigableHighway(connected));\n+    }\n+\n+    /**\n+     * Checks if given edge is a valid intersecting edge for an at-grade intersection\n+     *\n+     * @param edge\n+     *            edge\n+     * @return true if the edge is valid intersecting edge\n+     */\n+    private boolean isValidIntersectingEdge(final Edge edge)\n+    {\n+        return edge.isMasterEdge() && HighwayTag.highwayTag(edge).isPresent()\n+                && this.highwayFilter.contains(edge.highwayTag().getTagValue());\n+    }\n+\n+    /**\n+     * Collect matching out edges and corresponding in edge in a map. Store the roundabout edges and\n+     * non roundabout edges in separate maps.\n+     *\n+     * @param inEdges\n+     *            List<Edge> inEdges\n+     * @param outEdges\n+     *            Set<Edge> outEdges\n+     * @return Map<String, Map<AtlasEntity, Set<AtlasEntity>>> with Map of inEdge to outEdges for\n+     *         roundabout and non roundabout edges\n+     */\n+    private Map<String, Map<AtlasEntity, Set<AtlasEntity>>> populateInEdgeToOutEdgeMaps(\n+            final List<Edge> inEdges, final Set<Edge> outEdges)\n+    {\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = new HashMap<>();\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = new HashMap<>();\n+        inEdges.forEach(inEdge ->\n+        {\n+            final Optional<HighwayTag> highwayTag = HighwayTag.highwayTag(inEdge);\n+            if (highwayTag.isPresent()\n+                    && this.connectedHighwayTypes.containsKey(highwayTag.get().getTagValue()))\n+            {\n+                // Filter out edges based on level and layer tags and valid highway types\n+                final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                        .filter(outEdge -> this.isMatchingOutEdge(inEdge, outEdge))\n+                        .collect(Collectors.toSet());\n+                // There should be at least 2 valid outEdges\n+                if (filteredOutEdges.size() >= 2)\n+                {\n+                    final String inEdgeHighwayType = highwayTag.get().getTagValue();\n+                    final List<String> validHighwayTypesOfOutEdge = this.connectedHighwayTypes\n+                            .get(inEdgeHighwayType);\n+                    final Set<AtlasEntity> filteredByHighways = filteredOutEdges.stream()\n+                            .filter(atlasEntity ->\n+                            {\n+                                final Optional<HighwayTag> atlasEntityHighway = HighwayTag\n+                                        .highwayTag(atlasEntity);\n+                                return atlasEntityHighway.isPresent() && validHighwayTypesOfOutEdge\n+                                        .contains(atlasEntityHighway.get().getTagValue());\n+                            }).collect(Collectors.toSet());\n+                    // If any of the edges is a roundabout, add it to roundabout map\n+                    if (filteredByHighways.stream().anyMatch(JunctionTag::isRoundabout)\n+                            || JunctionTag.isRoundabout(inEdge))\n+                    {\n+                        roundAboutInEdgeToOutEdgeMap.put(inEdge, filteredByHighways);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzkyNw=="}, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 619}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTUyNjM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozNToyMVrOFr2rXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDozNToyMVrOFr2rXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODkyNg==", "bodyText": "typo: given -> edge", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381528926", "createdAt": "2020-02-19T20:35:21Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)\n+        {\n+            inEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                entitiesToBeFlagged.add(inEdge);\n+                entitiesToBeFlagged.addAll(setOfOutEdge);\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                //\n+                instructionIndex = INSTRUCTION_INDEX_ZERO;\n+            }\n+        }\n+        // Flag all roundabout edges\n+        else\n+        {\n+            roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+            {\n+                // Ideally there would only be one roundabout edge and one exit edge per node\n+                final Optional<AtlasEntity> roundaboutEdge = JunctionTag.isRoundabout(inEdge)\n+                        ? Optional.of(inEdge)\n+                        : setOfOutEdge.stream().filter(JunctionTag::isRoundabout).findFirst();\n+                final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                        .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+                if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+                {\n+                    entitiesToBeFlagged\n+                            .addAll(this.getRoundaboutEdges((Edge) roundaboutEdge.get()));\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+            });\n+            if (!entitiesToBeFlagged.isEmpty())\n+            {\n+                instructionIndex = INSTRUCTION_INDEX_THREE;\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collects all atlas identifiers of given set of {@link AtlasObject}s\n+     *\n+     * @param objects\n+     *            set of {@link AtlasObject}s\n+     * @return {@link Iterable<String>} containing the atlas identifiers of input objects\n+     */\n+    private List<String> getIdentifiers(final Set<AtlasEntity> objects)\n+    {\n+        return Iterables.stream(objects).map(AtlasEntity::getIdentifier).map(String::valueOf)\n+                .collectToList();\n+    }\n+\n+    /**\n+     * Node could be part of multiple destination_sign relations. This method collect the\n+     * intersecting items that are not part of existing destination_sign relation of the node or if\n+     * the relations are missing a destination_sign tag.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @param intersectingNode\n+     *            {@link Node}\n+     * @param destinationSignRelations\n+     *            set of relations the node is a member of\n+     * @return FlaggedIntersection with instruction index and set of flagged items with incomplete\n+     *         destination_sign relation\n+     */\n+    private FlaggedIntersection getIntersectionsWithIncompleteDestinationSignRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Node intersectingNode, final Set<Relation> destinationSignRelations)\n+    {\n+        // If the node is part of destination sign relation, check if destination tag of the\n+        // relation is missing or if there are any missing relations that the node could be part of\n+        // based on from and to edges\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all roundabout edges that are missing destination sign relations or missing\n+        // destination sign tags for existing relations\n+        if (!roundAboutInEdgeToOutEdgeMap.isEmpty())\n+        {\n+            final Set<AtlasEntity> allRoundaboutEdgesMissingTagsOrRelations = this\n+                    .getAllRoundaboutEdgesMissingTagsOrRelations(roundAboutInEdgeToOutEdgeMap,\n+                            destinationSignRelations);\n+            if (!allRoundaboutEdgesMissingTagsOrRelations.isEmpty())\n+            {\n+                entitiesToBeFlagged.addAll(allRoundaboutEdgesMissingTagsOrRelations);\n+                instructionIndex = INSTRUCTION_INDEX_FOUR;\n+            }\n+        }\n+        else\n+        {\n+            final Set<Relation> destinationSignRelationsMissingTag = this\n+                    .getRelationsWithMissingDestinationTag(destinationSignRelations);\n+            // Flag if destination sign tag is missing\n+            if (!destinationSignRelationsMissingTag.isEmpty())\n+            {\n+                this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+                instructionIndex = INSTRUCTION_INDEX_ONE;\n+                entitiesToBeFlagged.addAll(destinationSignRelationsMissingTag);\n+            }\n+            else if (inEdgeToOutEdgeMap != null)\n+            {\n+                // If there are any missing destination sign relation that the node should be\n+                // part of, flag it\n+                final Set<AtlasEntity> connectedEdgesNotFormDestinationRelation = this\n+                        .getConnectedEdgesNotFormDestinationRelation(inEdgeToOutEdgeMap,\n+                                destinationSignRelations);\n+                if (!connectedEdgesNotFormDestinationRelation.isEmpty())\n+                {\n+                    instructionIndex = INSTRUCTION_INDEX_TWO;\n+                    entitiesToBeFlagged.addAll(connectedEdgesNotFormDestinationRelation);\n+                }\n+            }\n+        }\n+        return new FlaggedIntersection(instructionIndex, entitiesToBeFlagged);\n+    }\n+\n+    /**\n+     * Collect all destination sign relations that the input atlas entity is member of.\n+     *\n+     * @param atlasEntity\n+     *            any {@link AtlasEntity}\n+     * @return Optional<Set<Relation>> that the atlasEntity is member of\n+     */\n+    private Optional<Set<Relation>> getParentDestinationSignRelations(final AtlasEntity atlasEntity)\n+    {\n+        final Set<Relation> setOfDestinationSignRelations = atlasEntity.relations().stream()\n+                .filter(relation -> RelationTypeTag.DESTINATION_SIGN.toString()\n+                        .equalsIgnoreCase(relation.tag(RelationTypeTag.KEY)))\n+                .collect(Collectors.toSet());\n+        return setOfDestinationSignRelations.isEmpty() ? Optional.empty()\n+                : Optional.of(setOfDestinationSignRelations);\n+    }\n+\n+    /**\n+     * Collects all destination sign relations with missing destination sign tag\n+     *\n+     * @param destinationSignRelations\n+     *            set of destination sign relations\n+     * @return set of relations with missing destination sign tag\n+     */\n+    private Set<Relation> getRelationsWithMissingDestinationTag(\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return destinationSignRelations.stream()\n+                .filter(relation -> relation.tag(DestinationTag.KEY) == null)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Collects all roundabout edges starting with the given given", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 507}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTU1NDcxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo0NDozMlrOFr284A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo1Mjo1N1rOFr3Mjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzQwOA==", "bodyText": "Is there any way we could have a nonempty roundAboutInEdgeToOutEdgeMap and inEdgeToOutEdgeMap? If so there should be a case to handle flagging both", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381533408", "createdAt": "2020-02-19T20:44:32Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzQyMg==", "bodyText": "No there will not be because populateInEdgeToOutEdgeMaps method populates either roundAboutInEdgeToOutEdgeMap or inEdgeToOutEdgeMap based on presence of roundabout edges in the output.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381537422", "createdAt": "2020-02-19T20:52:57Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();\n+        if (instructionIndex == -1)\n+        {\n+            return Optional.empty();\n+        }\n+        final List<String> identifiers = this.getIdentifiers(entitiesToBeFlagged);\n+        entitiesToBeFlagged.add(intersectingNode);\n+        this.markAsFlagged(String.valueOf(intersectingNode.getIdentifier()));\n+        return Optional.of(\n+                this.createFlag(entitiesToBeFlagged, this.getLocalizedInstruction(instructionIndex,\n+                        intersectingNode.getIdentifier(), new StringList(identifiers).join(\", \"))));\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Collects all edges that are not part of a relation\n+     *\n+     * @param fromEdge\n+     *            inEdge\n+     * @param toEdges\n+     *            set of out edges\n+     * @param destinationSignRelations\n+     *            set of existing destination sign relations\n+     * @return Optional<Set<AtlasEntity>> if there are edges that are not part of destination sign\n+     *         relations\n+     */\n+    private Optional<Set<AtlasEntity>> connectedEdgesNotPartOfRelation(final AtlasEntity fromEdge,\n+            final Set<AtlasEntity> toEdges, final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> outEdges = new HashSet<>(toEdges);\n+        final Set<AtlasEntity> filteredOutEdges = outEdges.stream()\n+                .filter(outEdge -> this.isMissingDestinationTag((Edge) outEdge))\n+                .collect(Collectors.toSet());\n+        final Set<AtlasEntity> allRelationMembers = destinationSignRelations.stream()\n+                .flatMap(destinationSignRelation ->\n+                {\n+                    final RelationMemberList relationMembers = destinationSignRelation\n+                            .allKnownOsmMembers();\n+                    return relationMembers.stream().map(RelationMember::getEntity);\n+                }).collect(Collectors.toSet());\n+        if (!allRelationMembers.contains(fromEdge))\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        allRelationMembers.forEach(filteredOutEdges::remove);\n+        if (!filteredOutEdges.isEmpty())\n+        {\n+            filteredOutEdges.add(fromEdge);\n+            return Optional.of(filteredOutEdges);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Collect all roundabout edges and exit edges that are missing destination sign relations or\n+     * missing destination sign tags\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            Map<AtlasEntity, Set<AtlasEntity>> where key is inEdge and value is set of\n+     *            outEdges of the rounabout\n+     * @param destinationSignRelations\n+     *            set of existing destoination sign relations\n+     * @return set of edges that meet the above criteria\n+     */\n+    private Set<AtlasEntity> getAllRoundaboutEdgesMissingTagsOrRelations(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        roundAboutInEdgeToOutEdgeMap.forEach((inEdge, setOfOutEdge) ->\n+        {\n+            final Optional<AtlasEntity> roundaboutEdge = setOfOutEdge.stream()\n+                    .filter(JunctionTag::isRoundabout).findFirst();\n+            final Optional<AtlasEntity> roundaboutExitEdge = setOfOutEdge.stream()\n+                    .filter(outEdge -> !JunctionTag.isRoundabout(outEdge)).findFirst();\n+            if (roundaboutEdge.isPresent() && roundaboutExitEdge.isPresent())\n+            {\n+                final Set<AtlasEntity> roundaboutEdges = this\n+                        .getRoundaboutEdges((Edge) roundaboutEdge.get());\n+                final AtlasEntity exitEdge = roundaboutExitEdge.get();\n+                // If the destination sign relation is missing destination tag, flag it\n+                if (this.isMissingDestinationTag((Edge) exitEdge))\n+                {\n+                    entitiesToBeFlagged.addAll(roundaboutEdges);\n+                    entitiesToBeFlagged.add(roundaboutExitEdge.get());\n+                }\n+                final Optional<Set<AtlasEntity>> roundAboutEdgesNotPartOfRelations = this\n+                        .connectedEdgesNotPartOfRelation(exitEdge, roundaboutEdges,\n+                                destinationSignRelations);\n+                // If there are missing destination sign relations, flag it\n+                roundAboutEdgesNotPartOfRelations.ifPresent(entitiesToBeFlagged::addAll);\n+            }\n+        });\n+        return entitiesToBeFlagged;\n+    }\n+\n+    /**\n+     * @param inEdgeToOutEdgeMap\n+     *            inEdge to outEdge map\n+     * @param destinationSignRelations\n+     *            destinationSignRelations\n+     * @return\n+     */\n+    private Set<AtlasEntity> getConnectedEdgesNotFormDestinationRelation(\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap,\n+            final Set<Relation> destinationSignRelations)\n+    {\n+        return inEdgeToOutEdgeMap.entrySet().stream().flatMap(atlasEntitySetEntry ->\n+        {\n+            final AtlasEntity key = atlasEntitySetEntry.getKey();\n+            return this.connectedEdgesNotPartOfRelation(key, inEdgeToOutEdgeMap.get(key),\n+                    destinationSignRelations).stream();\n+        }).flatMap(Collection::stream).collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Return a FlaggedIntersection with the items in the input params and appropriate instruction\n+     * index based on the input params.\n+     *\n+     * @param roundAboutInEdgeToOutEdgeMap\n+     *            map with roundabout inEdge and outEdges\n+     * @param inEdgeToOutEdgeMap\n+     *            map with non-roundabout inEdge and outEdges\n+     * @return FlaggedIntersection with instruction index and set of flagged items based on the\n+     *         input params\n+     */\n+    private FlaggedIntersection getFlaggedIntersection(\n+            final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap,\n+            final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap)\n+    {\n+        final Set<AtlasEntity> entitiesToBeFlagged = new HashSet<>();\n+        int instructionIndex = -1;\n+        // Flag all in and out edges\n+        if (roundAboutInEdgeToOutEdgeMap.isEmpty() && inEdgeToOutEdgeMap != null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzQwOA=="}, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTU3NTU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo1MToxNlrOFr3JqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyMTo0NlrOFr4DyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjY4MA==", "bodyText": "Just wondering where we get these values from?", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381536680", "createdAt": "2020-02-19T20:51:16Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MTU2MA==", "bodyText": "The default values used in the edge direction comparator class was giving FPs. So I used custom angles based on the analysis of outputs for various angles.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381551560", "createdAt": "2020-02-19T21:21:46Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjY4MA=="}, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTU4MTk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo1MzoyNVrOFr3NaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyODozN1rOFr4ROQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ==", "bodyText": "getOrDefault returns default value if no value is returned for a given key. I don't see the purpose of it since you are setting default value as null.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381537641", "createdAt": "2020-02-19T20:53:25Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ5NQ==", "bodyText": "Also, can we name the variable as nonRoundaboutInEdgeToOutEdgeMap instead of inEdgeToOutEdgeMap.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381543495", "createdAt": "2020-02-19T21:04:50Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ=="}, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NTAwMQ==", "bodyText": "done!", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381555001", "createdAt": "2020-02-19T21:28:37Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzY0MQ=="}, "originalCommit": {"oid": "8035384cfe3212181922deb14c8aca5d7fce691e"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTY0OTA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxNDo0OFrOFr33Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTo0Nzo1NlrOFr41tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ==", "bodyText": "Are we verifying that getFlaggedItems() is not null or not empty. Because, setOfFlaggedItems variable can be null.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381548295", "createdAt": "2020-02-19T21:14:48Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NzA2Mw==", "bodyText": "he instructionIndex is updated only if there is some item to be flagged and the line 217 ensures that Optional.empty() is returned if there are no flaggedItems.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381557063", "createdAt": "2020-02-19T21:32:58Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ=="}, "originalCommit": {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2MDcwMQ==", "bodyText": "Yes, you are right. instructionIndex will be -1 if no items to be flagged and also getFlaggedItems() can be null because setOfFlaggedItems is not set anywhere. So, please move the if condition above this line.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381560701", "createdAt": "2020-02-19T21:40:33Z", "author": {"login": "smaheshwaram"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ=="}, "originalCommit": {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2NDM0Mw==", "bodyText": "flaggedIntersection.getFlaggedItems() wouldn't be null in any case. It would be an empty set. But if instructionIndex =-1, flaggedIntersection.getFlaggedItems() need not be called and so I moved the line as requested.", "url": "https://github.com/osmlab/atlas-checks/pull/258#discussion_r381564343", "createdAt": "2020-02-19T21:47:56Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/AtGradeSignPostCheck.java", "diffHunk": "@@ -0,0 +1,634 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMember;\n+import org.openstreetmap.atlas.geography.atlas.items.RelationMemberList;\n+import org.openstreetmap.atlas.geography.atlas.walker.SimpleEdgeWalker;\n+import org.openstreetmap.atlas.tags.DestinationForwardTag;\n+import org.openstreetmap.atlas.tags.DestinationTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.LevelTag;\n+import org.openstreetmap.atlas.tags.OneWayTag;\n+import org.openstreetmap.atlas.tags.RelationTypeTag;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.StringList;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.direction.EdgeDirectionComparator;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * Check flags at-grade intersections with missing destination_sign tags or destinations_sign\n+ * relations. An at-grade intersection is an intersection between two edges at the same z-level. In\n+ * case of roundabout edges, intersection between exit edge and roundabout edge are checked for\n+ * either destination_sign relation or destination:forward tag, in case of bi-directional exit edge,\n+ * or destination tag, in case of unidirectional exit edge.\n+ *\n+ * @author sayas01\n+ */\n+public class AtGradeSignPostCheck extends BaseCheck<String>\n+{\n+    /**\n+     * A class for holding flagged intersection items and corresponding flag instruction index\n+     */\n+    private class FlaggedIntersection\n+    {\n+        private int instructionIndex;\n+        private Set<AtlasEntity> setOfFlaggedItems;\n+\n+        FlaggedIntersection(final int instructionIndex, final Set<AtlasEntity> setOfFlaggedItems)\n+        {\n+            this.instructionIndex = instructionIndex;\n+            this.setOfFlaggedItems = setOfFlaggedItems;\n+        }\n+\n+        private Set<AtlasEntity> getFlaggedItems()\n+        {\n+            return this.setOfFlaggedItems;\n+        }\n+\n+        private Integer getInstructionIndex()\n+        {\n+            return this.instructionIndex;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = -7428641176420422187L;\n+    // Primary road (inEdge) connected to trunk, primary, secondary roads (outEdges) are treated as\n+    // valid intersection\n+    private static final List<String> CONNECTIONS_TO_PRIMARY = Arrays.asList(\"trunk\", \"primary\",\n+            \"secondary\");\n+    // Trunk road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_TRUNK = Collections.singletonList(\"primary\");\n+    // Secondary road (inEdge) connected to primary road (outEdge) is treated as valid intersection\n+    private static final List<String> CONNECTIONS_TO_SECONDARY = Collections\n+            .singletonList(\"primary\");\n+    private static final ImmutableMap<String, List<String>> CONNECTED_HIGHWAY_TYPES_MAP = ImmutableMap\n+            .of(\"primary\", CONNECTIONS_TO_PRIMARY, \"trunk\", CONNECTIONS_TO_TRUNK, \"secondary\",\n+                    CONNECTIONS_TO_SECONDARY);\n+    private static final String NO_DESTINATION_SIGN_RELATION_INSTRUCTION = \"Node {0,number,#} forms an at-grade junction but is not part of \"\n+            + \"a destination sign relation. Verify and create a destination sign relation with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, \" + \"as \\\"to\\\" and \\\"from\\\" members.\";\n+    private static final String DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION = \"Node {0,number,#} form an at-grade junction. It is part of destination sign relation(s): \"\n+            + \"{1}\" + \"but the relation(s) are missing \\\"destination\\\" tags.\";\n+    private static final String INCOMPLETE_DESTINATION_RELATION_INSTRUCTION = \"Node {0,number,#} forms an \"\n+            + \"at-grade junction and is part of destination sign relation(s). But the following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction with connected edges. Add destination sign relations with the node as \\\"intersection\\\" member and following \"\n+            + \"connected edges {1}, as \\\"to\\\" and \\\"from\\\" members and add destination sign tag to the connected edges.\";\n+    private static final String ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION = \"Node {0,number,#} is part of a roundabout and forms an \"\n+            + \"at-grade junction. It is part of destination sign relation(s). Either the existing relations are missing destination sign tag or following connected edges {1} \"\n+            + \"could also form destination sign relations with this node. Either add destination tags to existing relations or create new destination sign relation \"\n+            + \"with these edges and the node.\";\n+    private static final String NON_ROUNDABOUT_INTERSECTION_MAP = \"nonRoundaboutMatchingEdgesMap\";\n+    private static final String ROUNDABOUT_INTERSECTION_MAP = \"roundaboutMatchingEdgesMap\";\n+\n+    private static final int INSTRUCTION_INDEX_ZERO = 0;\n+    private static final int INSTRUCTION_INDEX_ONE = 1;\n+    private static final int INSTRUCTION_INDEX_TWO = 2;\n+    private static final int INSTRUCTION_INDEX_THREE = 3;\n+    private static final int INSTRUCTION_INDEX_FOUR = 4;\n+\n+    private static final int MINIMUM_NODE_VALENCE = 3;\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT = Angle.degrees(171);\n+    private static final Angle DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT = Angle.degrees(-171);\n+    private static final Angle DEFAULT_SAME_DIRECTION_LOWER_LIMIT = Angle.degrees(-100);\n+    private static final Angle DEFAULT_SAME_DIRECTION_UPPER_LIMIT = Angle.degrees(9);\n+    private static final EdgeDirectionComparator EDGE_DIRECTION_COMPARATOR = new EdgeDirectionComparator(\n+            DEFAULT_OPPOSITE_DIRECTION_LOWER_LIMIT, DEFAULT_OPPOSITE_DIRECTION_UPPER_LIMIT,\n+            DEFAULT_SAME_DIRECTION_LOWER_LIMIT, DEFAULT_SAME_DIRECTION_UPPER_LIMIT);\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            NO_DESTINATION_SIGN_RELATION_INSTRUCTION,\n+            DESTINATION_SIGN_RELATION_MISSING_DESTINATION_TAG_INSTRUCTION,\n+            INCOMPLETE_DESTINATION_RELATION_INSTRUCTION,\n+            ROUNDABOUT_EDGE_MISSING_DESTINATION_SIGN_RELATION,\n+            ROUNDABOUT_EDGE_INCOMPLETE_DESTINATION_SIGN_RELATION);\n+\n+    private final Set<String> highwayFilter;\n+    private Map<String, List<String>> connectedHighwayTypes;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public AtGradeSignPostCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.connectedHighwayTypes = this.configurationValue(configuration,\n+                \"connected.highway.types\", CONNECTED_HIGHWAY_TYPES_MAP);\n+        this.highwayFilter = new HashSet<>(this.connectedHighwayTypes.keySet());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Node && ((Node) object).valence() >= MINIMUM_NODE_VALENCE\n+                && !this.isFlagged(String.valueOf(object.getIdentifier()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Node intersectingNode = (Node) object;\n+        // Filter and sort all in edges that have valid highway types\n+        final List<Edge> inEdges = intersectingNode.inEdges().stream()\n+                .filter(this::isValidIntersectingEdge)\n+                .sorted(Comparator.comparingLong(AtlasObject::getIdentifier))\n+                .collect(Collectors.toList());\n+        // Filter all out edges that have valid highway types\n+        final Set<Edge> outEdges = intersectingNode.outEdges().stream()\n+                .filter(this::isValidIntersectingEdge).collect(Collectors.toSet());\n+        // Terminate if there isn't at least one inEdge or two out edges with valid highway types\n+        if (inEdges.isEmpty() || outEdges.size() < 2)\n+        {\n+            return Optional.empty();\n+        }\n+        // For each inEdge, get the list of potentially matching out edges\n+        // Matching out edges are based on z level and highway type.\n+        // For each inEdge, store the inEdge and corresponding outEdges in inEdgeToOutEdgeMap\n+        // If any of the out edge is a roundabout edge, store the roundabout edges and the inEdge in\n+        // roundAboutInEdgeToOutEdgeMap\n+        final Map<String, Map<AtlasEntity, Set<AtlasEntity>>> mapOfMatchingInAndOutEdges = this\n+                .populateInEdgeToOutEdgeMaps(inEdges, outEdges);\n+        final Map<AtlasEntity, Set<AtlasEntity>> inEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(NON_ROUNDABOUT_INTERSECTION_MAP, null);\n+        final Map<AtlasEntity, Set<AtlasEntity>> roundAboutInEdgeToOutEdgeMap = mapOfMatchingInAndOutEdges\n+                .getOrDefault(ROUNDABOUT_INTERSECTION_MAP, null);\n+        // If there are no valid intersection, return Optional.empty()\n+        if ((inEdgeToOutEdgeMap == null || inEdgeToOutEdgeMap.isEmpty())\n+                && (roundAboutInEdgeToOutEdgeMap == null || roundAboutInEdgeToOutEdgeMap.isEmpty()))\n+        {\n+            return Optional.empty();\n+        }\n+        // Collect all destination sign relations, the node is a member of\n+        final Optional<Set<Relation>> destinationSignRelations = this\n+                .getParentDestinationSignRelations(intersectingNode);\n+        final FlaggedIntersection flaggedIntersection = destinationSignRelations.isEmpty()\n+                ? this.getFlaggedIntersection(roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap)\n+                : this.getIntersectionsWithIncompleteDestinationSignRelation(\n+                        roundAboutInEdgeToOutEdgeMap, inEdgeToOutEdgeMap, intersectingNode,\n+                        destinationSignRelations.get());\n+        final int instructionIndex = flaggedIntersection.getInstructionIndex();\n+        final Set<AtlasEntity> entitiesToBeFlagged = flaggedIntersection.getFlaggedItems();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODI5NQ=="}, "originalCommit": {"oid": "d97e797fe21d16c2d7faee68ec943e4a6e2b30cc"}, "originalPosition": 216}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3260, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}