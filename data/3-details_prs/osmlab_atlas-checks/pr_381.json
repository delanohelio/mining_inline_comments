{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NjI1NTY3", "number": 381, "title": "Suddenhighwaytypechange", "bodyText": "Description:\nThis check identifies roads that have suspiciously large highway tag jumps.\nTest Results:\nVery low FP rate on this check!\n\n\n\nISO\nSampled\nFP\nFalse Positive Rate\n\n\n\n\nAUS\n140\n2\n1.43%\n\n\nARG\n140\n0\n0%\n\n\nCHL\n100\n0\n0%\n\n\nHUN\n97\n0\n0%\n\n\nNZL\n140\n0\n0%\n\n\nTUR\n120\n4\n3.33\n\n\n\nResolves #344", "createdAt": "2020-10-08T03:05:45Z", "url": "https://github.com/osmlab/atlas-checks/pull/381", "merged": true, "mergeCommit": {"oid": "05112bdeaadff621f6aa6073ce27cea976514da2"}, "closed": true, "closedAt": "2020-10-23T20:42:03Z", "author": {"login": "reichg"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdNmozugH2gAyNDk5NjI1NTY3OmQwZWY1M2E3ZDk0ZDgwMGY0MmIyYWM4MGFjMTNjNWFlODA4NmNmZmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVcFuBAFqTUxNTk3MTQ2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d0ef53a7d94d800f42b2ac80ac13c5ae8086cfff", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d0ef53a7d94d800f42b2ac80ac13c5ae8086cfff", "committedDate": "2020-09-29T11:39:13Z", "message": "new suddenhighwaytypechangecheck with simplified logic and more inline with osmose issue 1090."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "855df26dd723d04515c096b26182e7ee7bffcdf3", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/855df26dd723d04515c096b26182e7ee7bffcdf3", "committedDate": "2020-10-07T18:32:49Z", "message": "Updated check and required documents"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91fb0f15c734bdc9d609a439e36eaac72af4535c", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/91fb0f15c734bdc9d609a439e36eaac72af4535c", "committedDate": "2020-10-07T19:00:36Z", "message": "Fixed test issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad9255764ce04849a1ea1c82f1e24acf93dd8cdd", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/ad9255764ce04849a1ea1c82f1e24acf93dd8cdd", "committedDate": "2020-10-07T20:01:14Z", "message": "Replacing strings with HighwayType."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a73e25c24729c7ef9cab1746a90a16c038510c16", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/a73e25c24729c7ef9cab1746a90a16c038510c16", "committedDate": "2020-10-08T02:24:23Z", "message": "Merge branch 'dev' of https://github.com/osmlab/atlas-checks into suddenhighwaytypechange"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d1ffedc32e6560ebf4931aac252ebe0b134777b", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4d1ffedc32e6560ebf4931aac252ebe0b134777b", "committedDate": "2020-10-08T02:26:24Z", "message": "removing config default value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "611f5206c455406e618cc4028959ae0afc72173a", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/611f5206c455406e618cc4028959ae0afc72173a", "committedDate": "2020-10-08T02:43:30Z", "message": "updating documentation regarding the suddenhighwaytypechangecheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2384e77448ea6a27a896584f944c6ac4caf9be68", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2384e77448ea6a27a896584f944c6ac4caf9be68", "committedDate": "2020-10-08T03:10:14Z", "message": "spotless apply"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "307f7c487adac64da39b7182aab9b5bb69a8a547", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/307f7c487adac64da39b7182aab9b5bb69a8a547", "committedDate": "2020-10-08T03:34:29Z", "message": "fixing sonar cloud errors and spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "576ed3978119f9cf89079802ba051bae4053f368", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/576ed3978119f9cf89079802ba051bae4053f368", "committedDate": "2020-10-08T04:00:18Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3465eb10499fe62684837db7eefb646f32d8db3f", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3465eb10499fe62684837db7eefb646f32d8db3f", "committedDate": "2020-10-08T04:10:15Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76a2e278cf73adc74b2934256ccb033f35f752e6", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/76a2e278cf73adc74b2934256ccb033f35f752e6", "committedDate": "2020-10-08T04:29:28Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cd288b4027e6dc4c380356e054e72ef42c2d895", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4cd288b4027e6dc4c380356e054e72ef42c2d895", "committedDate": "2020-10-08T04:30:36Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a5ddf96ffe6bc5b09137d997ba56a767c8cbb34", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4a5ddf96ffe6bc5b09137d997ba56a767c8cbb34", "committedDate": "2020-10-08T04:38:35Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fd0adfeb1430af5b30ccf8f8947e63f9a5200d3", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3fd0adfeb1430af5b30ccf8f8947e63f9a5200d3", "committedDate": "2020-10-08T05:08:39Z", "message": "consolidated conditionals to simplify final method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21b9bb7faa6100d6756be5c21abc125663b2b779", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/21b9bb7faa6100d6756be5c21abc125663b2b779", "committedDate": "2020-10-08T05:11:46Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4a73f5841b873943b8c96799c459896abb788c4", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b4a73f5841b873943b8c96799c459896abb788c4", "committedDate": "2020-10-08T05:17:21Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe336dff3d5fac8a806da4210bd4108d3d962ba5", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/fe336dff3d5fac8a806da4210bd4108d3d962ba5", "committedDate": "2020-10-08T06:09:44Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4a3aca11a35c5dd1fc45feb2150acf197487be2", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/a4a3aca11a35c5dd1fc45feb2150acf197487be2", "committedDate": "2020-10-08T06:13:50Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d10b0f71b167cf9bd528e2a7979ec1fe69ea516", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4d10b0f71b167cf9bd528e2a7979ec1fe69ea516", "committedDate": "2020-10-08T06:35:37Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f809e8d93172aa13dadb6b2184baf3529825bdfe", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/f809e8d93172aa13dadb6b2184baf3529825bdfe", "committedDate": "2020-10-08T08:36:51Z", "message": "removing marking connected edges as flagged to maximize detections."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b145c7ae978794d317fab0edcd2c693f2460175e", "committedDate": "2020-10-08T08:41:57Z", "message": "Update SuddenHighwayTypeChangeCheck.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDIxMjQw", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-513021240", "createdAt": "2020-10-20T18:32:50Z", "commit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozMjo1MFrOHlLoxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1MDo1NlrOHlMdhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDAyMw==", "bodyText": "Could we have some documentation here? Even if it's just something  copy pasted from the check's readme -- makes it easier to know what the check does without searching for docs", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508750023", "createdAt": "2020-10-20T18:32:50Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDkxOQ==", "bodyText": "Hate to be a stickler, but some method docs would be helpful, if not actually the standard for new checks", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508750919", "createdAt": "2020-10-20T18:34:23Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)\n+        {\n+            final Optional<HighwayTag> lastEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(lastEdgeEdge);\n+            if (lastEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !lastEdgeEndNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(lastEdgeEdge))\n+            {\n+                final HighwayTag lastEdgeEdgeHighwayTag = lastEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzQwNQ==", "bodyText": "HighwayTag.highwayTag(edge).isPresent() would be redundant after HighwayTag.isCarNavigableHighway(edge)", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508753405", "createdAt": "2020-10-20T18:37:28Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1OTc4NQ==", "bodyText": "This should be doable just by:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n          \n          \n            \n                    final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n          \n          \n            \n                            .highwayTag(edgeBeingVerified);\n          \n          \n            \n                    if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n          \n          \n            \n                    {\n          \n          \n            \n                        edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n          \n          \n            \n                    }\n          \n          \n            \n                    final HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.highwayTag(edgeBeingVerified).orElse(HighwayTag.NO);\n          \n      \n    \n    \n  \n\nthanks to built-ins", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508759785", "createdAt": "2020-10-20T18:44:57Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjE5Mg==", "bodyText": "this might need to be changed if you use the suggestion I made last ^\n&& !edgeBeingVerifiedHighwayTag.equals(HighwayTag.NO)", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508762192", "createdAt": "2020-10-20T18:48:33Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MzUyNQ==", "bodyText": "do you think this loop and the one prior could be put into a method, and parameterized with firstEdgeStartNodeEdgesHighwayTags and then lastEdgeEndNodeEdgesHighwayTags ?", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508763525", "createdAt": "2020-10-20T18:50:56Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTAzMzQ0", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-513103344", "createdAt": "2020-10-20T20:23:32Z", "commit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMzozM1rOHlPlgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDozNjo0M1rOHlQFUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDcyMA==", "bodyText": "We don't want to change this.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508814720", "createdAt": "2020-10-20T20:23:33Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -4,7 +4,7 @@\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n     \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true\n+    \"enabled.value.default\": false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNjUwOQ==", "bodyText": "I don't think this should be changed.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508816509", "createdAt": "2020-10-20T20:26:00Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNjkzNg==", "bodyText": "This is not necessary, as it will be enabled by default.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508816936", "createdAt": "2020-10-20T20:26:35Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},\n       \"tags\":\"highway\"\n-    }\n+  },\n+  \"SuddenHighwayTypeChangeCheck\":{\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNzUxOA==", "bodyText": "Looks like this needs to be updated.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508817518", "createdAt": "2020-10-20T20:27:25Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},\n       \"tags\":\"highway\"\n-    }\n+  },\n+  \"SuddenHighwayTypeChangeCheck\":{\n+    \"enabled\": true,\n+    \"challenge\": {\n+      \"description\": \"Tasks will include ways that are drawn as a single way, when in reality they should be two or more distinct ways\",\n+      \"blurb\": \"Snake Roads\",\n+      \"instruction\": \"Open your favorite editor and split the snake road into two or more distinct ways. You can do this by splitting or separating the existing way at an intersection or where you think a road should end. This check also flags roundabouts that aren\u2019t properly tagged. If you see that\u2019s the case - add a junction=roundabout tag when needed.\",\n+      \"difficulty\": \"MEDIUM\",\n+      \"defaultPriority\": \"LOW\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMjg2Ng==", "bodyText": "It would be good to have a true positive tests for each of the 3 cases.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508822866", "createdAt": "2020-10-20T20:36:43Z", "author": {"login": "Bentleysb"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheckTest.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Tests for {@link SuddenHighwayTypeChangeCheck}\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheckTest\n+{\n+\n+    @Rule\n+    public SuddenHighwayTypeChangeCheckTestRule setup = new SuddenHighwayTypeChangeCheckTestRule();\n+\n+    @Rule\n+    public ConsumerBasedExpectedCheckVerifier verifier = new ConsumerBasedExpectedCheckVerifier();\n+\n+    private final SuddenHighwayTypeChangeCheck check = new SuddenHighwayTypeChangeCheck(\n+            ConfigurationResolver.inlineConfiguration(\n+                    \"{\\\"SuddenHighwayTypeChangeCheck\\\": {\\\"minHighwayType\\\": \\\"tertiary\\\"}}\"));\n+\n+    @Test\n+    public void testFalsePositiveSuddenHighwayTypeChangeCheck()\n+    {\n+        this.verifier.actual(this.setup.falsePositiveSuddenHighwayTypeChangeCheck(), this.check);\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testTruePositiveSuddenHighwayTypeChangeCheck()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64a896df16c342500a852cbabda5aea658ba5235", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/64a896df16c342500a852cbabda5aea658ba5235", "committedDate": "2020-10-21T22:05:59Z", "message": "Merge branch 'dev' of https://github.com/reichg/atlas-checks into suddenhighwaytypechange"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjM1MzUz", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-514235353", "createdAt": "2020-10-21T22:30:22Z", "commit": {"oid": "64a896df16c342500a852cbabda5aea658ba5235"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f05399c46b97df296b43651f7b0d18717041222", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7f05399c46b97df296b43651f7b0d18717041222", "committedDate": "2020-10-22T16:25:39Z", "message": "fixing change requests from pull request."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffe4f2fb3f34b83f6eb7d23dfd5329558d68a3de", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/ffe4f2fb3f34b83f6eb7d23dfd5329558d68a3de", "committedDate": "2020-10-22T22:56:48Z", "message": "updated test checks for cases and addressed comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7c091748d14eff77ffed2832480727b5308373f", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b7c091748d14eff77ffed2832480727b5308373f", "committedDate": "2020-10-22T23:08:41Z", "message": "fixed config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a14362b32236bf65a5b26eec00446d99206648cb", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/a14362b32236bf65a5b26eec00446d99206648cb", "committedDate": "2020-10-23T05:02:09Z", "message": "fixing code smells"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b77dcdf8a1622e52230bcad10eee2d12c4c50e0a", "committedDate": "2020-10-23T05:05:44Z", "message": "hopefully last spotless apply"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODUyMDIz", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-515852023", "createdAt": "2020-10-23T17:05:12Z", "commit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODU1MzMw", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-515855330", "createdAt": "2020-10-23T17:10:04Z", "commit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzoxMDowNFrOHnWY-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzoxMDowNFrOHnWY-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzM1Mw==", "bodyText": "This needs to be reverted.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511023353", "createdAt": "2020-10-23T17:10:04Z", "author": {"login": "sayas01"}, "path": "config/configuration.json", "diffHunk": "@@ -3,8 +3,7 @@\n     \"scanUrls\": [\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n-    \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODkzMjA3", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-515893207", "createdAt": "2020-10-23T18:05:26Z", "commit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTA2ODYy", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-515906862", "createdAt": "2020-10-23T18:26:31Z", "commit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxODoyNjozMVrOHnY2uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxODoyNjozMVrOHnY2uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MzczNw==", "bodyText": "nit: I think you can return true here", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511063737", "createdAt": "2020-10-23T18:26:31Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check identifies ways that make suspiciously large jumps in highway classification\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     * \n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge)\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        final HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.highwayTag(edgeBeingVerified)\n+                .orElse(HighwayTag.NO);\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first and last edge's connected edges for suspiciously large highway tag\n+        // jumps.\n+        if (this.firstEdgeStartNodeEdgesHighwayTags(edgeBeingVerifiedHighwayTag,\n+                firstEdgeStartNodeEdges, firstEdgeStartNodeEdgesHighwayTags)\n+                || this.lastEdgeEndNodeEdgesHighwayTage(edgeBeingVerifiedHighwayTag,\n+                        lastEdgeEndNodeEdges, lastEdgeEndNodeEdgesHighwayTags))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(\n+                    createFlag(object, this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+        }\n+\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Case one: edge being verified is motorway, primary, trunk\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * Case three: edge being verified is tertiary or tertiary_link\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.TERTIARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge being verified is any link but tertiary.\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case one: edge checked against is tertiary, residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case three: edge checked against is living_Street, service, or track\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.LIVING_STREET.equals(edgeHighwayTag)\n+                || HighwayTag.TRACK.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge checked against is residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * checks if edge is roundabout or circular\n+     * \n+     * @param edge\n+     *            edge to check if roundabout or circular\n+     * @return boolean\n+     */\n+    private boolean edgeIsRoundaboutOrCircular(final Edge edge)\n+    {\n+        return JunctionTag.isCircular(edge) || JunctionTag.isRoundabout(edge);\n+    }\n+\n+    /**\n+     * checks if edge being verified's first edge start node connected edges make suspicious jumps\n+     * \n+     * @param edgeBeingVerifiedHighwayTag\n+     *            edge being verified highway tag\n+     * @param firstEdgeStartNodeEdges\n+     *            first edge start node edges\n+     * @param firstEdgeStartNodeEdgesHighwayTags\n+     *            first edge start node edge highway tags\n+     * @return boolean\n+     */\n+    private boolean firstEdgeStartNodeEdgesHighwayTags(final HighwayTag edgeBeingVerifiedHighwayTag,\n+            final Set<Edge> firstEdgeStartNodeEdges,\n+            final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags)\n+    {\n+        boolean suspiciousJump = false;\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final HighwayTag firstEdgeEdgeHighwayTag = HighwayTag.highwayTag(firstEdgeEdge)\n+                    .orElse(HighwayTag.NO);\n+            if ((!edgeBeingVerifiedHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeEdgeHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+                    && (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseThree(edgeBeingVerifiedHighwayTag,\n+                                    firstEdgeEdgeHighwayTag)))\n+            {\n+                suspiciousJump = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 253}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ecb1b47fe06b2aa8319ea8f7bf9f8aa601efdd2", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7ecb1b47fe06b2aa8319ea8f7bf9f8aa601efdd2", "committedDate": "2020-10-23T18:38:44Z", "message": "fixed config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "739c72cef66ba6023ae084d778ed6006d9adad58", "author": {"user": {"login": "reichg", "name": "Gabe Reichenberger"}}, "url": "https://github.com/osmlab/atlas-checks/commit/739c72cef66ba6023ae084d778ed6006d9adad58", "committedDate": "2020-10-23T18:55:28Z", "message": "siplified the main functions with return true or false"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTY5Mzkz", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-515969393", "createdAt": "2020-10-23T19:49:46Z", "commit": {"oid": "739c72cef66ba6023ae084d778ed6006d9adad58"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTcxNDYz", "url": "https://github.com/osmlab/atlas-checks/pull/381#pullrequestreview-515971463", "createdAt": "2020-10-23T19:53:14Z", "commit": {"oid": "739c72cef66ba6023ae084d778ed6006d9adad58"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3198, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}