{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1MTMwMDQw", "number": 385, "title": "CheckFlag Deserializer and OpenStreetMapCheckFlagConverter", "bodyText": "Description:\nThis is part two of changes to integrate fix suggestions into the atlas checks framework. Part one added the ability to add fix suggestions to CheckFlags as FeatureChanges, and added the suggestions to the output logs in the form of feature change descriptors. This builds on that by adding utilities that lay the ground work for being able to export flags and suggestions into OSM like formats.\nThere are two utilities that are the main focus of this PR. The first is the CheckFlagDeserializer, which is updated to fully deserialize a check flag, whereas previously it only rebuilt a minimal version of the flag. The second is the new OpenStreetMapCheckFlagConverter, which converts the flagged objects and fix suggestions of a CheckFlag into a more OSM compliant format.\nCheckFlagDeserializer\nThe CheckFlagDeserializer now full deserializes CheckFlags in line delimited geojson format (the flag output). The flag identifier, instructions, and challenge name (check name) are all simply re-added to the new flag. The flagged objects are reconstructed as CompleteEntities using the new GeoJsonFeatureToAtlasEntityConverter, and added to the new flag. The fix suggestions are rebuilt by using the CompleteEntities from the deserialized flagged objects as before views, and applying the change descriptors to that to create after views. This does mean that fix suggestions must have a matching flagged object in the flag to b deserialized.\nOpenStreetMapCheckFlagConverter\nThis is a new utility class that can can be used to make a CheckFlag more OSM compliant. It does this by removing Points that are also flagged as Nodes, and Merging Edges that share an OSM ID. This is done for both the flagged objects and the fix suggestions. When merging Edges it is assumed that everything other than the geometry is identical. It is expect this utility will be used as part of the process of converting CheckFlags into MapRoulette and OSM formats.\nOther Changes\nCheckFlagEvent:\nMade some constants public for use in both utilities.\nCheckFlag:\nMade the null identifiers constant public\nAdded an overloaded addObject method to allow direct adding of FlaggedObjects\nAdded the getRawInstructions method to allow access to the list of instructions without extra formating\nRefactored a bit of code into the new FlaggedObject.getUniqueIdentifier method\nFlaggedPoint/PolyLine/Relation:\nFixed a bug that was causing meta tags to get added to AtlasObjects instead of just Flagged Objects\nPotential Impact:\nAnything that relies on the current version of the CheckFlagDeserializer may get more information that it was expecting.\nUnit Test Approach:\nAdded new unit test for the CheckFlagDeserializer that cover all types of FlaggedObejcts and most varieties of fix suggestions.\nAdded unit tests for the OpenStreetMapCheckFlagConverter that cover a variety of checkflags, especially those containing points, nodes, and edges to be merged.\nAdded a missing unit test for CheckFlagEvent to ensure REMOVE suggestions work properly.\nTest Results:\nGenerated check results for a number of checks in a small country. Deserialized and reserialized the flags, and sampled through the results. Comparing the de/reserialized flags to the originals they appeared to all be the same.", "createdAt": "2020-10-16T22:25:48Z", "url": "https://github.com/osmlab/atlas-checks/pull/385", "merged": true, "mergeCommit": {"oid": "116ad106b55dc88eac29b07fafe246283401e789"}, "closed": true, "closedAt": "2020-11-03T23:47:15Z", "author": {"login": "Bentleysb"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTMU9YgH2gAyNTA1MTMwMDQwOjEyYThiYWI1ZTI3ZjhjNGY4OGQxNzVkNDQ2ZWMxN2VjNDliZjk5YTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZBuloAFqTUyMjk0NjQzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "12a8bab5e27f8c4f88d175d446ec17ec49bf99a2", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/12a8bab5e27f8c4f88d175d446ec17ec49bf99a2", "committedDate": "2020-10-16T20:23:33Z", "message": "full flag deserializer & OSMify CheckFlag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "127870375b8abe78679c3c387f2d99215353a870", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/127870375b8abe78679c3c387f2d99215353a870", "committedDate": "2020-10-16T20:25:27Z", "message": "merge latest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "789a32e85da5dbff2d833d3918111f36c041f487", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/789a32e85da5dbff2d833d3918111f36c041f487", "committedDate": "2020-10-16T22:03:55Z", "message": "revert generator change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "662516af576cb2b127b29a3a93143fa564c7c2de", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/662516af576cb2b127b29a3a93143fa564c7c2de", "committedDate": "2020-10-16T22:07:48Z", "message": "revert basecheck change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c", "committedDate": "2020-10-23T20:03:18Z", "message": "merge latest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDc5NDU1", "url": "https://github.com/osmlab/atlas-checks/pull/385#pullrequestreview-518079455", "createdAt": "2020-10-27T19:39:04Z", "commit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTozOTowNFrOHpNryw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjoyMzozNlrOHpTOOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3Nzg2Nw==", "bodyText": "Would this sort order be useful outside of this method's context, for example as a public method? in case other tools need to use this", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r512977867", "createdAt": "2020-10-27T19:39:04Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,303 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null\n-                ? properties.get(ID).getAsString()\n-                // Convert array of ids into comma delimited string\n-                : parseIdentifiers((JsonArray) properties.get(IDENTIFIERS));\n+        // Split the instructions using the new line character and remove the prepended instruction\n+        // number\n+        final List<String> instructions = Arrays\n+                .stream(properties.get(INSTRUCTIONS).getAsString().split(\"\\n\"))\n+                .map(instruction -> instruction.replaceAll(\"^\\\\d+\\\\. \",\n+                        CommonConstants.EMPTY_STRING))\n+                .collect(Collectors.toList());\n+        final String flagIdentifier = properties.get(ID).getAsString();\n         final CheckFlag flag = new CheckFlag(flagIdentifier);\n-        flag.addInstruction(instruction);\n+        flag.addInstructions(instructions);\n         flag.setChallengeName(checkName);\n \n+        final GeoJsonItem geojsonItem = GEOJSON_PARSER_GSON.deserialize(GSON.toJson(json));\n+\n+        // This should never be the case\n+        if (!(geojsonItem instanceof FeatureCollection))\n+        {\n+            return flag;\n+        }\n+\n+        // Deserialize all features and their fix suggestions\n+        ((FeatureCollection) geojsonItem).getFeatures().forEach(feature ->\n+        {\n+            // If the feature is a synthetic point just add its geometry\n+            if (feature.getProperties().asMap().containsKey(SyntheticHighlightPointTag.KEY)\n+                    && feature.getGeometry() instanceof Point)\n+            {\n+                flag.addPoint(((Point) feature.getGeometry()).toAtlasGeometry());\n+            }\n+            else\n+            {\n+                // Convert the geojson feature into and AtlasEntity and add it to the flag\n+                GeoJsonFeatureToAtlasEntityConverter.convert(feature).ifPresent(entity ->\n+                {\n+                    // If it is a relation, we need to add its geometry separately\n+                    if (entity instanceof Relation)\n+                    {\n+                        flag.addObject(new FlaggedRelation((Relation) entity,\n+                                ((MultiPolygon) feature.getGeometry()).toAtlasGeometry()));\n+                    }\n+                    else\n+                    {\n+                        flag.addObject(entity);\n+                    }\n+                    // If there is a fix suggestion for the object, reconstruct it to a\n+                    // FeatureChange and add it to the flag\n+                    if (full.has(FIX_SUGGESTIONS))\n+                    {\n+                        this.getFixSuggestion(entity, full.get(FIX_SUGGESTIONS).getAsJsonObject())\n+                                .ifPresent(flag::addFixSuggestion);\n+                    }\n+                });\n+            }\n+        });\n+\n         return flag;\n     }\n+\n+    /**\n+     * Apply geometry change descriptors to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity} to apply the change to\n+     * @param descriptors\n+     *            {@link Lists}\n+     */\n+    private void applyGeometryChanges(final CompleteEntity afterView,\n+            final List<JsonObject> descriptors)\n+    {\n+        // Copy the geometry to apply the changes to\n+        final List<Location> newGeometry = Lists.newArrayList(afterView.getGeometry());\n+\n+        // Sort the geometry changes by position and type, as order of application matters\n+        descriptors.stream()\n+                .sorted(Comparator.comparingInt(descriptor -> Integer\n+                        .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0])))\n+                .sorted(Comparator.comparing(descriptor -> ChangeDescriptorType.valueOf(\n+                        descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODA5OA==", "bodyText": "any potential side effects if the remove operation leaves the relation bean empty?", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513038098", "createdAt": "2020-10-27T21:17:20Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,303 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null\n-                ? properties.get(ID).getAsString()\n-                // Convert array of ids into comma delimited string\n-                : parseIdentifiers((JsonArray) properties.get(IDENTIFIERS));\n+        // Split the instructions using the new line character and remove the prepended instruction\n+        // number\n+        final List<String> instructions = Arrays\n+                .stream(properties.get(INSTRUCTIONS).getAsString().split(\"\\n\"))\n+                .map(instruction -> instruction.replaceAll(\"^\\\\d+\\\\. \",\n+                        CommonConstants.EMPTY_STRING))\n+                .collect(Collectors.toList());\n+        final String flagIdentifier = properties.get(ID).getAsString();\n         final CheckFlag flag = new CheckFlag(flagIdentifier);\n-        flag.addInstruction(instruction);\n+        flag.addInstructions(instructions);\n         flag.setChallengeName(checkName);\n \n+        final GeoJsonItem geojsonItem = GEOJSON_PARSER_GSON.deserialize(GSON.toJson(json));\n+\n+        // This should never be the case\n+        if (!(geojsonItem instanceof FeatureCollection))\n+        {\n+            return flag;\n+        }\n+\n+        // Deserialize all features and their fix suggestions\n+        ((FeatureCollection) geojsonItem).getFeatures().forEach(feature ->\n+        {\n+            // If the feature is a synthetic point just add its geometry\n+            if (feature.getProperties().asMap().containsKey(SyntheticHighlightPointTag.KEY)\n+                    && feature.getGeometry() instanceof Point)\n+            {\n+                flag.addPoint(((Point) feature.getGeometry()).toAtlasGeometry());\n+            }\n+            else\n+            {\n+                // Convert the geojson feature into and AtlasEntity and add it to the flag\n+                GeoJsonFeatureToAtlasEntityConverter.convert(feature).ifPresent(entity ->\n+                {\n+                    // If it is a relation, we need to add its geometry separately\n+                    if (entity instanceof Relation)\n+                    {\n+                        flag.addObject(new FlaggedRelation((Relation) entity,\n+                                ((MultiPolygon) feature.getGeometry()).toAtlasGeometry()));\n+                    }\n+                    else\n+                    {\n+                        flag.addObject(entity);\n+                    }\n+                    // If there is a fix suggestion for the object, reconstruct it to a\n+                    // FeatureChange and add it to the flag\n+                    if (full.has(FIX_SUGGESTIONS))\n+                    {\n+                        this.getFixSuggestion(entity, full.get(FIX_SUGGESTIONS).getAsJsonObject())\n+                                .ifPresent(flag::addFixSuggestion);\n+                    }\n+                });\n+            }\n+        });\n+\n         return flag;\n     }\n+\n+    /**\n+     * Apply geometry change descriptors to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity} to apply the change to\n+     * @param descriptors\n+     *            {@link Lists}\n+     */\n+    private void applyGeometryChanges(final CompleteEntity afterView,\n+            final List<JsonObject> descriptors)\n+    {\n+        // Copy the geometry to apply the changes to\n+        final List<Location> newGeometry = Lists.newArrayList(afterView.getGeometry());\n+\n+        // Sort the geometry changes by position and type, as order of application matters\n+        descriptors.stream()\n+                .sorted(Comparator.comparingInt(descriptor -> Integer\n+                        .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0])))\n+                .sorted(Comparator.comparing(descriptor -> ChangeDescriptorType.valueOf(\n+                        descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase())))\n+                // Apply each change\n+                .forEach(descriptor ->\n+                {\n+                    final Integer position = Integer\n+                            .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0]);\n+                    switch (ChangeDescriptorType.valueOf(\n+                            descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+                    {\n+                        // Apply added location in reverse order so that they push each other\n+                        // forward from the given position\n+                        case ADD:\n+                            Lists.reverse(this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString()))\n+                                    .forEach(location -> newGeometry.add(position, location));\n+                            break;\n+                        // Just remove the location at the position\n+                        case REMOVE:\n+                            newGeometry.remove(position.intValue());\n+                            break;\n+                        // Updates must override one existing location, but may add beyond the\n+                        // current length of the geometry\n+                        case UPDATE:\n+                            final List<Location> updateLocations = this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString());\n+                            for (int index = 0; index < updateLocations.size(); index++)\n+                            {\n+                                // If this is an existing position, replace it\n+                                if (newGeometry.size() > position + index)\n+                                {\n+                                    newGeometry.set(position + index, updateLocations.get(index));\n+                                }\n+                                // Else add to the end\n+                                else\n+                                {\n+                                    newGeometry.add(updateLocations.get(index));\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                });\n+\n+        afterView.withGeometry(newGeometry);\n+    }\n+\n+    /**\n+     * Apply a relation member change descriptor to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity}\n+     * @param descriptor\n+     *            {@link JsonObject} relation member change descriptor\n+     */\n+    private void applyRelationMemberChange(final CompleteEntity afterView,\n+            final JsonObject descriptor)\n+    {\n+        // Only apply to relations\n+        if (afterView instanceof CompleteRelation)\n+        {\n+            // Generate a bean item form the description\n+            final RelationBean.RelationBeanItem member = new RelationBean.RelationBeanItem(\n+                    descriptor.get(ID).getAsLong(), descriptor.get(ROLE).getAsString(),\n+                    ItemType.valueOf(descriptor.get(ITEM_TYPE).getAsString().toUpperCase()));\n+\n+            // Get the existing relation bean. A RelationBean must be used to apply the change\n+            // because the bounds of the member cannot be automatically calculated\n+            final RelationBean bean = ((CompleteRelation) afterView).getBean();\n+\n+            switch (ChangeDescriptorType\n+                    .valueOf(descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+            {\n+                // Add the new member to the bean and add the bean to the relation\n+                case ADD:\n+                    bean.add(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,\n+                            ((CompleteRelation) afterView).bounds());\n+                    break;\n+                // Remove the member from the bean and add the bean to the relation\n+                case REMOVE:\n+                    bean.removeItem(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODY4OQ==", "bodyText": "Might be useful to log the ParseException as well", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513038689", "createdAt": "2020-10-27T21:18:37Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,303 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null\n-                ? properties.get(ID).getAsString()\n-                // Convert array of ids into comma delimited string\n-                : parseIdentifiers((JsonArray) properties.get(IDENTIFIERS));\n+        // Split the instructions using the new line character and remove the prepended instruction\n+        // number\n+        final List<String> instructions = Arrays\n+                .stream(properties.get(INSTRUCTIONS).getAsString().split(\"\\n\"))\n+                .map(instruction -> instruction.replaceAll(\"^\\\\d+\\\\. \",\n+                        CommonConstants.EMPTY_STRING))\n+                .collect(Collectors.toList());\n+        final String flagIdentifier = properties.get(ID).getAsString();\n         final CheckFlag flag = new CheckFlag(flagIdentifier);\n-        flag.addInstruction(instruction);\n+        flag.addInstructions(instructions);\n         flag.setChallengeName(checkName);\n \n+        final GeoJsonItem geojsonItem = GEOJSON_PARSER_GSON.deserialize(GSON.toJson(json));\n+\n+        // This should never be the case\n+        if (!(geojsonItem instanceof FeatureCollection))\n+        {\n+            return flag;\n+        }\n+\n+        // Deserialize all features and their fix suggestions\n+        ((FeatureCollection) geojsonItem).getFeatures().forEach(feature ->\n+        {\n+            // If the feature is a synthetic point just add its geometry\n+            if (feature.getProperties().asMap().containsKey(SyntheticHighlightPointTag.KEY)\n+                    && feature.getGeometry() instanceof Point)\n+            {\n+                flag.addPoint(((Point) feature.getGeometry()).toAtlasGeometry());\n+            }\n+            else\n+            {\n+                // Convert the geojson feature into and AtlasEntity and add it to the flag\n+                GeoJsonFeatureToAtlasEntityConverter.convert(feature).ifPresent(entity ->\n+                {\n+                    // If it is a relation, we need to add its geometry separately\n+                    if (entity instanceof Relation)\n+                    {\n+                        flag.addObject(new FlaggedRelation((Relation) entity,\n+                                ((MultiPolygon) feature.getGeometry()).toAtlasGeometry()));\n+                    }\n+                    else\n+                    {\n+                        flag.addObject(entity);\n+                    }\n+                    // If there is a fix suggestion for the object, reconstruct it to a\n+                    // FeatureChange and add it to the flag\n+                    if (full.has(FIX_SUGGESTIONS))\n+                    {\n+                        this.getFixSuggestion(entity, full.get(FIX_SUGGESTIONS).getAsJsonObject())\n+                                .ifPresent(flag::addFixSuggestion);\n+                    }\n+                });\n+            }\n+        });\n+\n         return flag;\n     }\n+\n+    /**\n+     * Apply geometry change descriptors to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity} to apply the change to\n+     * @param descriptors\n+     *            {@link Lists}\n+     */\n+    private void applyGeometryChanges(final CompleteEntity afterView,\n+            final List<JsonObject> descriptors)\n+    {\n+        // Copy the geometry to apply the changes to\n+        final List<Location> newGeometry = Lists.newArrayList(afterView.getGeometry());\n+\n+        // Sort the geometry changes by position and type, as order of application matters\n+        descriptors.stream()\n+                .sorted(Comparator.comparingInt(descriptor -> Integer\n+                        .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0])))\n+                .sorted(Comparator.comparing(descriptor -> ChangeDescriptorType.valueOf(\n+                        descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase())))\n+                // Apply each change\n+                .forEach(descriptor ->\n+                {\n+                    final Integer position = Integer\n+                            .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0]);\n+                    switch (ChangeDescriptorType.valueOf(\n+                            descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+                    {\n+                        // Apply added location in reverse order so that they push each other\n+                        // forward from the given position\n+                        case ADD:\n+                            Lists.reverse(this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString()))\n+                                    .forEach(location -> newGeometry.add(position, location));\n+                            break;\n+                        // Just remove the location at the position\n+                        case REMOVE:\n+                            newGeometry.remove(position.intValue());\n+                            break;\n+                        // Updates must override one existing location, but may add beyond the\n+                        // current length of the geometry\n+                        case UPDATE:\n+                            final List<Location> updateLocations = this.convertWktToLocations(\n+                                    descriptor.get(AFTER_VIEW).getAsString());\n+                            for (int index = 0; index < updateLocations.size(); index++)\n+                            {\n+                                // If this is an existing position, replace it\n+                                if (newGeometry.size() > position + index)\n+                                {\n+                                    newGeometry.set(position + index, updateLocations.get(index));\n+                                }\n+                                // Else add to the end\n+                                else\n+                                {\n+                                    newGeometry.add(updateLocations.get(index));\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                });\n+\n+        afterView.withGeometry(newGeometry);\n+    }\n+\n+    /**\n+     * Apply a relation member change descriptor to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity}\n+     * @param descriptor\n+     *            {@link JsonObject} relation member change descriptor\n+     */\n+    private void applyRelationMemberChange(final CompleteEntity afterView,\n+            final JsonObject descriptor)\n+    {\n+        // Only apply to relations\n+        if (afterView instanceof CompleteRelation)\n+        {\n+            // Generate a bean item form the description\n+            final RelationBean.RelationBeanItem member = new RelationBean.RelationBeanItem(\n+                    descriptor.get(ID).getAsLong(), descriptor.get(ROLE).getAsString(),\n+                    ItemType.valueOf(descriptor.get(ITEM_TYPE).getAsString().toUpperCase()));\n+\n+            // Get the existing relation bean. A RelationBean must be used to apply the change\n+            // because the bounds of the member cannot be automatically calculated\n+            final RelationBean bean = ((CompleteRelation) afterView).getBean();\n+\n+            switch (ChangeDescriptorType\n+                    .valueOf(descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+            {\n+                // Add the new member to the bean and add the bean to the relation\n+                case ADD:\n+                    bean.add(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,\n+                            ((CompleteRelation) afterView).bounds());\n+                    break;\n+                // Remove the member from the bean and add the bean to the relation\n+                case REMOVE:\n+                    bean.removeItem(member);\n+                    ((CompleteRelation) afterView).withMembers(bean,\n+                            ((CompleteRelation) afterView).bounds());\n+                    break;\n+                default:\n+                    break;\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Apply a tag change descriptor to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity}\n+     * @param descriptor\n+     *            {@link JsonObject} tag change descriptor\n+     */\n+    private void applyTagChange(final CompleteEntity afterView, final JsonObject descriptor)\n+    {\n+        final String key = descriptor.get(\"key\").getAsString();\n+        final String value = descriptor.get(\"value\").getAsString();\n+\n+        switch (ChangeDescriptorType\n+                .valueOf(descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase()))\n+        {\n+            case ADD:\n+                afterView.withAddedTag(key, value);\n+                break;\n+            case REMOVE:\n+                afterView.withRemovedTag(key);\n+                break;\n+            case UPDATE:\n+                afterView.withReplacedTag(key, key, value);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Convert a WKT point, linestring, or polygon to a List of Locations\n+     *\n+     * @param wkt\n+     *            {@link String}\n+     * @return {@link List} of {@link Location}s\n+     */\n+    private List<Location> convertWktToLocations(final String wkt)\n+    {\n+        try\n+        {\n+            return Lists.newArrayList(COORDINATE_ARRAY_CONVERTER.backwardConvert(\n+                    new CoordinateArraySequence(WKT_READER.read(wkt).getCoordinates())));\n+        }\n+        catch (final ParseException parseException)\n+        {\n+            throw new CoreException(\"Cannot parse wkt : {}\", wkt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2Mjk0OA==", "bodyText": "\"concatenate\" when it comes to Polylines really means merging them together, correct?", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513062948", "createdAt": "2020-10-27T22:09:54Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/OpenStreetMapCheckFlagConverter.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import static org.openstreetmap.atlas.checks.flag.CheckFlag.NULL_IDENTIFIERS;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.openstreetmap.atlas.checks.constants.CommonConstants;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.flag.FlaggedObject;\n+import org.openstreetmap.atlas.checks.flag.FlaggedPolyline;\n+import org.openstreetmap.atlas.exception.CoreException;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEdge;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+\n+/**\n+ * Utility to convert a {@link CheckFlag} into an OpenStreetMap like {@link CheckFlag}. This\n+ * currently means removing {@link org.openstreetmap.atlas.geography.atlas.items.Point} based\n+ * {@link FlaggedObject}s and {@link FeatureChange} suggestions that are also flagged as a node, and\n+ * merging the geometries of {@link Edge} based {@link FlaggedObject}s and suggestions that share an\n+ * OSM ID.\n+ *\n+ * @author bbreithaupt\n+ */\n+public final class OpenStreetMapCheckFlagConverter\n+{\n+\n+    /**\n+     * Attempt to create an OpenStreetMap CheckFlag by removing\n+     * {@link org.openstreetmap.atlas.geography.atlas.items.Point}s duplicatly flagged as\n+     * {@link org.openstreetmap.atlas.geography.atlas.items.Node}s, and merging {@link Edge}s that\n+     * share an OSM ID.\n+     *\n+     * @param flag\n+     *            {@link CheckFlag}\n+     * @return {@link Optional} OSM {@link CheckFlag}\n+     */\n+    public static Optional<CheckFlag> openStreetMapify(final CheckFlag flag)\n+    {\n+        // Copy the identifier and instructions\n+        final CheckFlag newFlag = new CheckFlag(flag.getIdentifier());\n+        newFlag.addInstructions(flag.getRawInstructions());\n+\n+        // Map objects by their unique osm id\n+        final Map<String, Set<FlaggedObject>> objectsMap = new HashMap<>();\n+        flag.getFlaggedObjects().forEach(object ->\n+        {\n+            final String osmIdentifier = object.getUniqueIdentifier().replaceFirst(\"\\\\d{6}$\",\n+                    CommonConstants.EMPTY_STRING);\n+            objectsMap.putIfAbsent(osmIdentifier, new HashSet<>());\n+            objectsMap.get(osmIdentifier).add(object);\n+        });\n+\n+        // Map feature changes by their unique osm id\n+        final Map<String, Set<FeatureChange>> suggestionMap = new HashMap<>();\n+        flag.getFixSuggestions().forEach(suggestion ->\n+        {\n+            final String osmIdentifier = String.format(\"%s%s\",\n+                    StringUtils.capitalize(suggestion.getBeforeView().getType().toString()),\n+                    suggestion.getBeforeView().getOsmIdentifier());\n+            suggestionMap.putIfAbsent(osmIdentifier, new HashSet<>());\n+            suggestionMap.get(osmIdentifier).add(suggestion);\n+        });\n+\n+        try\n+        {\n+            // Re-add points\n+            objectsMap.entrySet().stream()\n+                    .filter(entry -> entry.getKey().equalsIgnoreCase(NULL_IDENTIFIERS))\n+                    .flatMap(entry -> entry.getValue().stream()).forEach(newFlag::addObject);\n+            // Convert and add atlas based features\n+            convertFlaggedObjects(objectsMap, newFlag);\n+            // Convert and add suggestions\n+            convertFixSuggestions(suggestionMap, newFlag);\n+        }\n+        catch (final CoreException exception)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(newFlag);\n+    }\n+\n+    /**\n+     * Merge {@link FeatureChange} fix suggestions to make them OSMified.\n+     *\n+     * @param suggestionMap\n+     *            {@link Map} of {@link FeatureChange}s by unique OSM ID\n+     * @param newFlag\n+     *            {@link CheckFlag} to add the converted suggestions to\n+     */\n+    private static void convertFixSuggestions(final Map<String, Set<FeatureChange>> suggestionMap,\n+            final CheckFlag newFlag)\n+    {\n+        // Go through each entry\n+        suggestionMap.entrySet().stream().flatMap(entry ->\n+        {\n+            // Use the first feature change as a base for the merged one\n+            final FeatureChange firstFeatureChange = entry.getValue().iterator().next();\n+            switch (entry.getValue().iterator().next().getBeforeView().getType())\n+            {\n+                // Merge edge FeatureChanges by concatenating the geometries of the before and after\n+                // views and applying them to a copy of the first feature change\n+                case EDGE:\n+                    // Sort the before views and concatenate their geometries\n+                    final Optional<PolyLine> concatenatedBeforePolyline = entry.getValue().stream()\n+                            .map(FeatureChange::getBeforeView)\n+                            .sorted(Comparator.comparing(AtlasEntity::getIdentifier))\n+                            .map(entity -> ((Edge) entity).asPolyLine()).reduce(PolyLine::append);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA2ODYwMw==", "bodyText": "Also I believe the current sorting scheme is only sorting by type (as it's the terminal operation)-- if we wanted to achieve sorting by position then type, we could use Comparator.thenComparing()", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513068603", "createdAt": "2020-10-27T22:23:36Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,303 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null\n-                ? properties.get(ID).getAsString()\n-                // Convert array of ids into comma delimited string\n-                : parseIdentifiers((JsonArray) properties.get(IDENTIFIERS));\n+        // Split the instructions using the new line character and remove the prepended instruction\n+        // number\n+        final List<String> instructions = Arrays\n+                .stream(properties.get(INSTRUCTIONS).getAsString().split(\"\\n\"))\n+                .map(instruction -> instruction.replaceAll(\"^\\\\d+\\\\. \",\n+                        CommonConstants.EMPTY_STRING))\n+                .collect(Collectors.toList());\n+        final String flagIdentifier = properties.get(ID).getAsString();\n         final CheckFlag flag = new CheckFlag(flagIdentifier);\n-        flag.addInstruction(instruction);\n+        flag.addInstructions(instructions);\n         flag.setChallengeName(checkName);\n \n+        final GeoJsonItem geojsonItem = GEOJSON_PARSER_GSON.deserialize(GSON.toJson(json));\n+\n+        // This should never be the case\n+        if (!(geojsonItem instanceof FeatureCollection))\n+        {\n+            return flag;\n+        }\n+\n+        // Deserialize all features and their fix suggestions\n+        ((FeatureCollection) geojsonItem).getFeatures().forEach(feature ->\n+        {\n+            // If the feature is a synthetic point just add its geometry\n+            if (feature.getProperties().asMap().containsKey(SyntheticHighlightPointTag.KEY)\n+                    && feature.getGeometry() instanceof Point)\n+            {\n+                flag.addPoint(((Point) feature.getGeometry()).toAtlasGeometry());\n+            }\n+            else\n+            {\n+                // Convert the geojson feature into and AtlasEntity and add it to the flag\n+                GeoJsonFeatureToAtlasEntityConverter.convert(feature).ifPresent(entity ->\n+                {\n+                    // If it is a relation, we need to add its geometry separately\n+                    if (entity instanceof Relation)\n+                    {\n+                        flag.addObject(new FlaggedRelation((Relation) entity,\n+                                ((MultiPolygon) feature.getGeometry()).toAtlasGeometry()));\n+                    }\n+                    else\n+                    {\n+                        flag.addObject(entity);\n+                    }\n+                    // If there is a fix suggestion for the object, reconstruct it to a\n+                    // FeatureChange and add it to the flag\n+                    if (full.has(FIX_SUGGESTIONS))\n+                    {\n+                        this.getFixSuggestion(entity, full.get(FIX_SUGGESTIONS).getAsJsonObject())\n+                                .ifPresent(flag::addFixSuggestion);\n+                    }\n+                });\n+            }\n+        });\n+\n         return flag;\n     }\n+\n+    /**\n+     * Apply geometry change descriptors to a CompleteEntity.\n+     *\n+     * @param afterView\n+     *            {@link CompleteEntity} to apply the change to\n+     * @param descriptors\n+     *            {@link Lists}\n+     */\n+    private void applyGeometryChanges(final CompleteEntity afterView,\n+            final List<JsonObject> descriptors)\n+    {\n+        // Copy the geometry to apply the changes to\n+        final List<Location> newGeometry = Lists.newArrayList(afterView.getGeometry());\n+\n+        // Sort the geometry changes by position and type, as order of application matters\n+        descriptors.stream()\n+                .sorted(Comparator.comparingInt(descriptor -> Integer\n+                        .valueOf(descriptor.get(POSITION).getAsString().split(\"/\")[0])))\n+                .sorted(Comparator.comparing(descriptor -> ChangeDescriptorType.valueOf(\n+                        descriptor.get(GeoJsonConstants.TYPE).getAsString().toUpperCase())))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3Nzg2Nw=="}, "originalCommit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjA2NDc0", "url": "https://github.com/osmlab/atlas-checks/pull/385#pullrequestreview-518206474", "createdAt": "2020-10-27T22:45:53Z", "commit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjo0NTo1M1rOHpTvbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMjo0NTo1M1rOHpTvbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3NzEwMQ==", "bodyText": "Just a thought-- since the flagged object conversion is lossy in terms of relation identifiers and other feature-dependent data, we might want to (if not already) have some way of recovering that or at least merging it with the existing feature when we're applying fix suggestions in MR", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r513077101", "createdAt": "2020-10-27T22:45:53Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/GeoJsonFeatureToAtlasEntityConverter.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.openstreetmap.atlas.checks.flag.serializer;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeSet;\n+\n+import org.openstreetmap.atlas.geography.Polygon;\n+import org.openstreetmap.atlas.geography.atlas.builder.RelationBean;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteArea;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEdge;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteLine;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteNode;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompletePoint;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteRelation;\n+import org.openstreetmap.atlas.geography.atlas.items.Area;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.ItemType;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Relation;\n+import org.openstreetmap.atlas.geography.geojson.GeoJsonUtils;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.feature.Feature;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.geometry.LineString;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.geometry.MultiPolygon;\n+import org.openstreetmap.atlas.geography.geojson.parser.domain.geometry.Point;\n+\n+/**\n+ * A GeoJson {@link Feature} to an {@link AtlasEntity} converter.\n+ *\n+ * @author bbreithaupt\n+ */\n+public final class GeoJsonFeatureToAtlasEntityConverter\n+{\n+    private static final List<String> metaProperties = Arrays.asList(GeoJsonUtils.ITEM_TYPE,\n+            GeoJsonUtils.IDENTIFIER, GeoJsonUtils.OSM_IDENTIFIER, \"relations\", \"members\", \"flag:id\",\n+            \"flag:type\");\n+    private static final Long DEFAULT_IDENTIFIER = 0L;\n+\n+    /**\n+     * Attempt to convert a GeoJson {@link Feature} to an {@link AtlasEntity}.\n+     *\n+     * @param feature\n+     *            {@link Feature}\n+     * @return an {@link Optional} {@link AtlasEntity}\n+     */\n+    public static Optional<AtlasEntity> convert(final Feature feature)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dbe9d5a70a5eec2cf4fc97ae9cfd18ed99df44c"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e09a1a488cd678cfdd9612b35526a59f58c3fab1", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/e09a1a488cd678cfdd9612b35526a59f58c3fab1", "committedDate": "2020-10-28T16:47:05Z", "message": "clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDU2MDg5", "url": "https://github.com/osmlab/atlas-checks/pull/385#pullrequestreview-521056089", "createdAt": "2020-10-30T21:51:44Z", "commit": {"oid": "e09a1a488cd678cfdd9612b35526a59f58c3fab1"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95ac132bcdc049442c36c34f6682f41c42e04e43", "author": {"user": {"login": "Bentleysb", "name": "Bentley Breithaupt"}}, "url": "https://github.com/osmlab/atlas-checks/commit/95ac132bcdc049442c36c34f6682f41c42e04e43", "committedDate": "2020-11-02T16:56:01Z", "message": "sonar"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODU5MjI2", "url": "https://github.com/osmlab/atlas-checks/pull/385#pullrequestreview-522859226", "createdAt": "2020-11-03T20:42:24Z", "commit": {"oid": "95ac132bcdc049442c36c34f6682f41c42e04e43"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODk5OTMw", "url": "https://github.com/osmlab/atlas-checks/pull/385#pullrequestreview-522899930", "createdAt": "2020-11-03T21:50:22Z", "commit": {"oid": "95ac132bcdc049442c36c34f6682f41c42e04e43"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTo1MDoyMlrOHtBs-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTo1MDoyMlrOHtBs-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3NTg2Nw==", "bodyText": "Why is the null check removed?", "url": "https://github.com/osmlab/atlas-checks/pull/385#discussion_r516975867", "createdAt": "2020-11-03T21:50:22Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/flag/serializer/CheckFlagDeserializer.java", "diffHunk": "@@ -51,15 +96,306 @@ public CheckFlag deserialize(final JsonElement json, final Type typeOfT,\n         final JsonObject full = json.getAsJsonObject();\n         final JsonObject properties = full.get(PROPERTIES).getAsJsonObject();\n         final String checkName = properties.get(GENERATOR).getAsString();\n-        final String instruction = properties.get(INSTRUCTIONS).getAsString();\n-        final String flagIdentifier = properties.get(IDENTIFIERS) == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95ac132bcdc049442c36c34f6682f41c42e04e43"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTQyMjYx", "url": "https://github.com/osmlab/atlas-checks/pull/385#pullrequestreview-522942261", "createdAt": "2020-11-03T23:15:27Z", "commit": {"oid": "95ac132bcdc049442c36c34f6682f41c42e04e43"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyOTQ2NDMy", "url": "https://github.com/osmlab/atlas-checks/pull/385#pullrequestreview-522946432", "createdAt": "2020-11-03T23:26:08Z", "commit": {"oid": "95ac132bcdc049442c36c34f6682f41c42e04e43"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3206, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}