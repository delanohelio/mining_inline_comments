{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczMjM1ODYy", "number": 350, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNToyODozNVrOEpsh7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxMjoyOVrOEq9uSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMTU2NjUzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQwNToyODozNVrOHbhj9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDozNToyNlrOHbo8_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzQ3OA==", "bodyText": "We could use a highway tag configurable value here in case we'd ever want to change the list of acceptable highway tags.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r498623478", "createdAt": "2020-10-02T05:28:35Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes:</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author wlodarsk\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));\n+        }\n+        // case 3 (road passing under bridge)\n+        if (BridgeTag.isBridge(object))\n+        {\n+            final Edge bridge = (Edge) object;\n+            final PolyLine bridgeAsPolyLine = bridge.asPolyLine();\n+            final Set<Edge> edgesToFlag = new HashSet<>();\n+            Iterables.stream(bridge.getAtlas().edgesIntersecting(bridge.bounds()))\n+                    .filter(edge -> edge.isMainEdge()\n+                            && edge.getOsmIdentifier() != bridge.getOsmIdentifier()\n+                            && !isFlagged(edge.getOsmIdentifier())\n+                            && this.isHighwayWithoutMaxHeight(edge)\n+                            && this.edgeCrossesBridge(edge.asPolyLine(), bridgeAsPolyLine))\n+                    .forEach(edge ->\n+                    {\n+                        markAsFlagged(edge.getOsmIdentifier());\n+                        edgesToFlag.add(edge);\n+                    });\n+            if (!edgesToFlag.isEmpty())\n+            {\n+                final CheckFlag checkFlag = new CheckFlag(getTaskIdentifier(bridge));\n+                edgesToFlag.forEach(\n+                        edge -> checkFlag.addObject(edge, getLocalizedInstruction(BRIDGE_CASE_INDEX,\n+                                edge.getOsmIdentifier(), bridge.getOsmIdentifier())));\n+                return Optional.of(checkFlag);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    // check if the two polylines intersect at any location other than the bridge's endpoints\n+    private boolean edgeCrossesBridge(final PolyLine edge, final PolyLine bridge)\n+    {\n+        return edge.intersections(bridge).stream()\n+                .anyMatch(loc -> !loc.equals(bridge.first()) && !loc.equals(bridge.last()));\n+    }\n+\n+    private boolean isCovered(final AtlasObject object)\n+    {\n+        return Validators.isOfType(object, CoveredTag.class, CoveredTag.YES, CoveredTag.ARCADE,\n+                CoveredTag.COLONNADE);\n+    }\n+\n+    private boolean isHighwayWithoutMaxHeight(final AtlasObject object)\n+    {\n+        return Validators.isOfType(object, HighwayTag.class, HighwayTag.MOTORWAY_LINK,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22e42d35dbabe329426cd84b8c323152903ad66d"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0NDU3NA==", "bodyText": "Thanks, Daniel. I have made the filter configurable.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r498744574", "createdAt": "2020-10-02T10:35:26Z", "author": {"login": "ladwlo"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes:</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author wlodarsk\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));\n+        }\n+        // case 3 (road passing under bridge)\n+        if (BridgeTag.isBridge(object))\n+        {\n+            final Edge bridge = (Edge) object;\n+            final PolyLine bridgeAsPolyLine = bridge.asPolyLine();\n+            final Set<Edge> edgesToFlag = new HashSet<>();\n+            Iterables.stream(bridge.getAtlas().edgesIntersecting(bridge.bounds()))\n+                    .filter(edge -> edge.isMainEdge()\n+                            && edge.getOsmIdentifier() != bridge.getOsmIdentifier()\n+                            && !isFlagged(edge.getOsmIdentifier())\n+                            && this.isHighwayWithoutMaxHeight(edge)\n+                            && this.edgeCrossesBridge(edge.asPolyLine(), bridgeAsPolyLine))\n+                    .forEach(edge ->\n+                    {\n+                        markAsFlagged(edge.getOsmIdentifier());\n+                        edgesToFlag.add(edge);\n+                    });\n+            if (!edgesToFlag.isEmpty())\n+            {\n+                final CheckFlag checkFlag = new CheckFlag(getTaskIdentifier(bridge));\n+                edgesToFlag.forEach(\n+                        edge -> checkFlag.addObject(edge, getLocalizedInstruction(BRIDGE_CASE_INDEX,\n+                                edge.getOsmIdentifier(), bridge.getOsmIdentifier())));\n+                return Optional.of(checkFlag);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    // check if the two polylines intersect at any location other than the bridge's endpoints\n+    private boolean edgeCrossesBridge(final PolyLine edge, final PolyLine bridge)\n+    {\n+        return edge.intersections(bridge).stream()\n+                .anyMatch(loc -> !loc.equals(bridge.first()) && !loc.equals(bridge.last()));\n+    }\n+\n+    private boolean isCovered(final AtlasObject object)\n+    {\n+        return Validators.isOfType(object, CoveredTag.class, CoveredTag.YES, CoveredTag.ARCADE,\n+                CoveredTag.COLONNADE);\n+    }\n+\n+    private boolean isHighwayWithoutMaxHeight(final AtlasObject object)\n+    {\n+        return Validators.isOfType(object, HighwayTag.class, HighwayTag.MOTORWAY_LINK,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzQ3OA=="}, "originalCommit": {"oid": "22e42d35dbabe329426cd84b8c323152903ad66d"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDg2OTAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxMjoxOFrOHdeKng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOToxMDozMFrOHdp6vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NDk5MA==", "bodyText": "When flagging an Edge we generally want to flag all of the main edges with that OSM ID. This makes it less confusing if the flags are used to create MapRoulette challenges. See InvalidTagsCheck for an example.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r500664990", "createdAt": "2020-10-07T00:12:18Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes (configurable):</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author ladwlo\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->motorway_link,trunk_link,primary,primary_link,secondary,secondary_link\";\n+\n+    private final TaggableFilter highwayFilter;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg1NzUzNA==", "bodyText": "Thanks Bentley for this suggestion!", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r500857534", "createdAt": "2020-10-07T09:10:30Z", "author": {"login": "ladwlo"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes (configurable):</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author ladwlo\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->motorway_link,trunk_link,primary,primary_link,secondary,secondary_link\";\n+\n+    private final TaggableFilter highwayFilter;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NDk5MA=="}, "originalCommit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDg2OTIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxMjoyOVrOHdeKzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOToxMTowNVrOHdp8RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTAzNg==", "bodyText": "Same as above.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r500665036", "createdAt": "2020-10-07T00:12:29Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes (configurable):</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author ladwlo\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->motorway_link,trunk_link,primary,primary_link,secondary,secondary_link\";\n+\n+    private final TaggableFilter highwayFilter;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));\n+        }\n+        // case 3 (road passing under bridge)\n+        if (BridgeTag.isBridge(object))\n+        {\n+            final Edge bridge = (Edge) object;\n+            final PolyLine bridgeAsPolyLine = bridge.asPolyLine();\n+            final Set<Edge> edgesToFlag = new HashSet<>();\n+            Iterables.stream(bridge.getAtlas().edgesIntersecting(bridge.bounds()))\n+                    .filter(edge -> edge.isMainEdge()\n+                            && edge.getOsmIdentifier() != bridge.getOsmIdentifier()\n+                            && !isFlagged(edge.getOsmIdentifier())\n+                            && this.isHighwayWithoutMaxHeight(edge)\n+                            && this.edgeCrossesBridge(edge.asPolyLine(), bridgeAsPolyLine))\n+                    .forEach(edge ->\n+                    {\n+                        markAsFlagged(edge.getOsmIdentifier());\n+                        edgesToFlag.add(edge);\n+                    });\n+            if (!edgesToFlag.isEmpty())\n+            {\n+                final CheckFlag checkFlag = new CheckFlag(getTaskIdentifier(bridge));\n+                edgesToFlag.forEach(\n+                        edge -> checkFlag.addObject(edge, getLocalizedInstruction(BRIDGE_CASE_INDEX,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg1NzkyNA==", "bodyText": "Done.", "url": "https://github.com/osmlab/atlas-checks/pull/350#discussion_r500857924", "createdAt": "2020-10-07T09:11:05Z", "author": {"login": "ladwlo"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/TunnelBridgeHeightLimitCheck.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.tags.BridgeTag;\n+import org.openstreetmap.atlas.tags.CoveredTag;\n+import org.openstreetmap.atlas.tags.MaxHeightTag;\n+import org.openstreetmap.atlas.tags.TunnelTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Flags highways (of certain classes) which should have a 'maxheight' or 'maxheight:*' tag but do\n+ * not have either. This is a port of Osmose check #7130.<br>\n+ * <b>Target objects:</b><br>\n+ * 1. Tunnels<br>\n+ * 2. Covered ways<br>\n+ * 3. Ways passing under bridges<br>\n+ * <b>Target highway classes (configurable):</b><br>\n+ * MOTORWAY_LINK, TRUNK_LINK, PRIMARY, PRIMARY_LINK, SECONDARY, SECONDARY_LINK\n+ *\n+ * @author ladwlo\n+ */\n+public class TunnelBridgeHeightLimitCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = 7912181047816225229L;\n+\n+    private static final String FALLBACK_INSTRUCTION_TEMPLATE = \"Way {0,number,#} %s but vehicle height limit is not specified. Add a 'maxheight' or 'maxheight:physical' tag according to an existing legal or physical restriction.\";\n+    private static final int TUNNEL_CASE_INDEX = 0;\n+    private static final int COVERED_CASE_INDEX = 1;\n+    private static final int BRIDGE_CASE_INDEX = 2;\n+    private static final List<String> FALLBACK_CASES = Arrays.asList(\"is a tunnel\", \"is covered\",\n+            \"passes under bridge ({1,number,#})\");\n+    private static final List<String> FALLBACK_INSTRUCTIONS = FALLBACK_CASES.stream()\n+            .map(caseDescription -> String.format(FALLBACK_INSTRUCTION_TEMPLATE, caseDescription))\n+            .collect(Collectors.toList());\n+    private static final String MAXHEIGHT_PHYSICAL = \"maxheight:physical\";\n+    private static final String HIGHWAY_FILTER_DEFAULT = \"highway->motorway_link,trunk_link,primary,primary_link,secondary,secondary_link\";\n+\n+    private final TaggableFilter highwayFilter;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public TunnelBridgeHeightLimitCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.highwayFilter = configurationValue(configuration, \"highway.filter\",\n+                HIGHWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return object instanceof Edge && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier());\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        // case 1 (tunnel) & 2 (covered highway)\n+        if ((TunnelTag.isTunnel(object) || this.isCovered(object))\n+                && this.isHighwayWithoutMaxHeight(object))\n+        {\n+            final Long osmId = object.getOsmIdentifier();\n+            markAsFlagged(osmId);\n+            final int instructionIndex = TunnelTag.isTunnel(object) ? TUNNEL_CASE_INDEX\n+                    : COVERED_CASE_INDEX;\n+            return Optional\n+                    .of(createFlag(object, getLocalizedInstruction(instructionIndex, osmId)));\n+        }\n+        // case 3 (road passing under bridge)\n+        if (BridgeTag.isBridge(object))\n+        {\n+            final Edge bridge = (Edge) object;\n+            final PolyLine bridgeAsPolyLine = bridge.asPolyLine();\n+            final Set<Edge> edgesToFlag = new HashSet<>();\n+            Iterables.stream(bridge.getAtlas().edgesIntersecting(bridge.bounds()))\n+                    .filter(edge -> edge.isMainEdge()\n+                            && edge.getOsmIdentifier() != bridge.getOsmIdentifier()\n+                            && !isFlagged(edge.getOsmIdentifier())\n+                            && this.isHighwayWithoutMaxHeight(edge)\n+                            && this.edgeCrossesBridge(edge.asPolyLine(), bridgeAsPolyLine))\n+                    .forEach(edge ->\n+                    {\n+                        markAsFlagged(edge.getOsmIdentifier());\n+                        edgesToFlag.add(edge);\n+                    });\n+            if (!edgesToFlag.isEmpty())\n+            {\n+                final CheckFlag checkFlag = new CheckFlag(getTaskIdentifier(bridge));\n+                edgesToFlag.forEach(\n+                        edge -> checkFlag.addObject(edge, getLocalizedInstruction(BRIDGE_CASE_INDEX,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTAzNg=="}, "originalCommit": {"oid": "fc3b1c5b00bb13f67f84237e59c58f19e09ef343"}, "originalPosition": 124}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3154, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}