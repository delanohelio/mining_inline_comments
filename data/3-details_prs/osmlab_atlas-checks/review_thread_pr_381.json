{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NjI1NTY3", "number": 381, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozMjo1MFrOEv7ELA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxODoyNjozMVrOExUJLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njg2MjUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozMjo1MFrOHlLoxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNzo0MlrOHm9xNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDAyMw==", "bodyText": "Could we have some documentation here? Even if it's just something  copy pasted from the check's readme -- makes it easier to know what the check does without searching for docs", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508750023", "createdAt": "2020-10-20T18:32:50Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxOTk1Ng==", "bodyText": "updated! Let me know if there should be more", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510619956", "createdAt": "2020-10-23T05:37:42Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDAyMw=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njg2ODA0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozNDoyM1rOHlLsRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNjo1MVrOHm9uew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDkxOQ==", "bodyText": "Hate to be a stickler, but some method docs would be helpful, if not actually the standard for new checks", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508750919", "createdAt": "2020-10-20T18:34:23Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)\n+        {\n+            final Optional<HighwayTag> lastEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(lastEdgeEdge);\n+            if (lastEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !lastEdgeEndNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(lastEdgeEdge))\n+            {\n+                final HighwayTag lastEdgeEdgeHighwayTag = lastEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxOTI1OQ==", "bodyText": "updated!", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510619259", "createdAt": "2020-10-23T05:36:51Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)\n+        {\n+            final Optional<HighwayTag> lastEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(lastEdgeEdge);\n+            if (lastEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !lastEdgeEndNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(lastEdgeEdge))\n+            {\n+                final HighwayTag lastEdgeEdgeHighwayTag = lastEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, lastEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MDkxOQ=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njg4MjY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODozNzoyOFrOHlL1_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNjozOVrOHm9ttA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzQwNQ==", "bodyText": "HighwayTag.highwayTag(edge).isPresent() would be redundant after HighwayTag.isCarNavigableHighway(edge)", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508753405", "createdAt": "2020-10-20T18:37:28Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxOTA2MA==", "bodyText": "updated!", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510619060", "createdAt": "2020-10-23T05:36:39Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzQwNQ=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjkyMjU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0NDo1N1rOHlMO6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNjoyNlrOHm9s3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1OTc4NQ==", "bodyText": "This should be doable just by:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n          \n          \n            \n                    final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n          \n          \n            \n                            .highwayTag(edgeBeingVerified);\n          \n          \n            \n                    if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n          \n          \n            \n                    {\n          \n          \n            \n                        edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n          \n          \n            \n                    }\n          \n          \n            \n                    final HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.highwayTag(edgeBeingVerified).orElse(HighwayTag.NO);\n          \n      \n    \n    \n  \n\nthanks to built-ins", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508759785", "createdAt": "2020-10-20T18:44:57Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxODg0NA==", "bodyText": "updated!", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510618844", "createdAt": "2020-10-23T05:36:26Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1OTc4NQ=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjkzNzgwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0ODozM1rOHlMYUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNjoxNlrOHm9sRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjE5Mg==", "bodyText": "this might need to be changed if you use the suggestion I made last ^\n&& !edgeBeingVerifiedHighwayTag.equals(HighwayTag.NO)", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508762192", "createdAt": "2020-10-20T18:48:33Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxODY5NA==", "bodyText": "updated", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510618694", "createdAt": "2020-10-23T05:36:16Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjE5Mg=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njk0NjQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1MDo1NlrOHlMdhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNjowOFrOHm9rxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MzUyNQ==", "bodyText": "do you think this loop and the one prior could be put into a method, and parameterized with firstEdgeStartNodeEdgesHighwayTags and then lastEdgeEndNodeEdgesHighwayTags ?", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508763525", "createdAt": "2020-10-20T18:50:56Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxODU2NA==", "bodyText": "Did my best to implement these in methods. I have it working with same results and eliminates code smell.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510618564", "createdAt": "2020-10-23T05:36:08Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * Auto generated Check template\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge) && HighwayTag.highwayTag(edge).isPresent()\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.NO;\n+        final Optional<HighwayTag> edgeBeingVerifiedHighwayTagOptional = HighwayTag\n+                .highwayTag(edgeBeingVerified);\n+        if (edgeBeingVerifiedHighwayTagOptional.isPresent())\n+        {\n+            edgeBeingVerifiedHighwayTag = edgeBeingVerifiedHighwayTagOptional.get();\n+        }\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first edge's connected edges for suspiciously large highway tag jumps.\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final Optional<HighwayTag> firstEdgeEdgeHighwayTagOptional = HighwayTag\n+                    .highwayTag(firstEdgeEdge);\n+            if (firstEdgeEdgeHighwayTagOptional.isPresent()\n+                    && edgeBeingVerifiedHighwayTagOptional.isPresent()\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+            {\n+                final HighwayTag firstEdgeEdgeHighwayTag = firstEdgeEdgeHighwayTagOptional.get();\n+\n+                // All cases\n+                if (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                        || this.isCaseThree(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag))\n+                {\n+                    markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+                }\n+            }\n+        }\n+\n+        // Check ways' last edge's connected edges for suspiciously large highway tag jumps\n+        for (final Edge lastEdgeEdge : lastEdgeEndNodeEdges)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MzUyNQ=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI3NDE1OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMzozM1rOHlPlgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNDoxOVrOHm9lUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDcyMA==", "bodyText": "We don't want to change this.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508814720", "createdAt": "2020-10-20T20:23:33Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -4,7 +4,7 @@\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n     \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true\n+    \"enabled.value.default\": false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNjkxMw==", "bodyText": "updated", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510616913", "createdAt": "2020-10-23T05:34:19Z", "author": {"login": "reichg"}, "path": "config/configuration.json", "diffHunk": "@@ -4,7 +4,7 @@\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n     \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true\n+    \"enabled.value.default\": false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDcyMA=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI4NTg2OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNjowMFrOHlPsfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozNDoxMVrOHm9k3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNjUwOQ==", "bodyText": "I don't think this should be changed.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508816509", "createdAt": "2020-10-20T20:26:00Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNjc5Nw==", "bodyText": "yeah this was accidental", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510616797", "createdAt": "2020-10-23T05:34:11Z", "author": {"login": "reichg"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNjUwOQ=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI4ODU2OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNjozNVrOHlPuKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozMzowMFrOHm9gqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNjkzNg==", "bodyText": "This is not necessary, as it will be enabled by default.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508816936", "createdAt": "2020-10-20T20:26:35Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},\n       \"tags\":\"highway\"\n-    }\n+  },\n+  \"SuddenHighwayTypeChangeCheck\":{\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNTcyMw==", "bodyText": "updated!", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510615723", "createdAt": "2020-10-23T05:33:00Z", "author": {"login": "reichg"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},\n       \"tags\":\"highway\"\n-    }\n+  },\n+  \"SuddenHighwayTypeChangeCheck\":{\n+    \"enabled\": true,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNjkzNg=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI5MjU2OnYy", "diffSide": "RIGHT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNzoyNVrOHlPwbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozMjo1MVrOHm9gHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNzUxOA==", "bodyText": "Looks like this needs to be updated.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508817518", "createdAt": "2020-10-20T20:27:25Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},\n       \"tags\":\"highway\"\n-    }\n+  },\n+  \"SuddenHighwayTypeChangeCheck\":{\n+    \"enabled\": true,\n+    \"challenge\": {\n+      \"description\": \"Tasks will include ways that are drawn as a single way, when in reality they should be two or more distinct ways\",\n+      \"blurb\": \"Snake Roads\",\n+      \"instruction\": \"Open your favorite editor and split the snake road into two or more distinct ways. You can do this by splitting or separating the existing way at an intersection or where you think a road should end. This check also flags roundabouts that aren\u2019t properly tagged. If you see that\u2019s the case - add a junction=roundabout tag when needed.\",\n+      \"difficulty\": \"MEDIUM\",\n+      \"defaultPriority\": \"LOW\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNTU4MA==", "bodyText": "updated MR challenge", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510615580", "createdAt": "2020-10-23T05:32:51Z", "author": {"login": "reichg"}, "path": "config/configuration.json", "diffHunk": "@@ -925,9 +925,19 @@\n       \"mediumPriorityRule\": {\n         \"condition\":\"OR\",\n         \"rules\":[\"highway=primary\",\"highway=primary_link\",\"highway=secondary\",\"highway=secondary_link\"]\n-      },\n+      }},\n       \"tags\":\"highway\"\n-    }\n+  },\n+  \"SuddenHighwayTypeChangeCheck\":{\n+    \"enabled\": true,\n+    \"challenge\": {\n+      \"description\": \"Tasks will include ways that are drawn as a single way, when in reality they should be two or more distinct ways\",\n+      \"blurb\": \"Snake Roads\",\n+      \"instruction\": \"Open your favorite editor and split the snake road into two or more distinct ways. You can do this by splitting or separating the existing way at an intersection or where you think a road should end. This check also flags roundabouts that aren\u2019t properly tagged. If you see that\u2019s the case - add a junction=roundabout tag when needed.\",\n+      \"difficulty\": \"MEDIUM\",\n+      \"defaultPriority\": \"LOW\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNzUxOA=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzMyNjcxOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheckTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDozNjo0M1rOHlQFUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNTozMjoxNlrOHm9eFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMjg2Ng==", "bodyText": "It would be good to have a true positive tests for each of the 3 cases.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r508822866", "createdAt": "2020-10-20T20:36:43Z", "author": {"login": "Bentleysb"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheckTest.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Tests for {@link SuddenHighwayTypeChangeCheck}\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheckTest\n+{\n+\n+    @Rule\n+    public SuddenHighwayTypeChangeCheckTestRule setup = new SuddenHighwayTypeChangeCheckTestRule();\n+\n+    @Rule\n+    public ConsumerBasedExpectedCheckVerifier verifier = new ConsumerBasedExpectedCheckVerifier();\n+\n+    private final SuddenHighwayTypeChangeCheck check = new SuddenHighwayTypeChangeCheck(\n+            ConfigurationResolver.inlineConfiguration(\n+                    \"{\\\"SuddenHighwayTypeChangeCheck\\\": {\\\"minHighwayType\\\": \\\"tertiary\\\"}}\"));\n+\n+    @Test\n+    public void testFalsePositiveSuddenHighwayTypeChangeCheck()\n+    {\n+        this.verifier.actual(this.setup.falsePositiveSuddenHighwayTypeChangeCheck(), this.check);\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testTruePositiveSuddenHighwayTypeChangeCheck()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDYxNTA2MA==", "bodyText": "each case has been added in test", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r510615060", "createdAt": "2020-10-23T05:32:16Z", "author": {"login": "reichg"}, "path": "src/test/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheckTest.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Tests for {@link SuddenHighwayTypeChangeCheck}\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheckTest\n+{\n+\n+    @Rule\n+    public SuddenHighwayTypeChangeCheckTestRule setup = new SuddenHighwayTypeChangeCheckTestRule();\n+\n+    @Rule\n+    public ConsumerBasedExpectedCheckVerifier verifier = new ConsumerBasedExpectedCheckVerifier();\n+\n+    private final SuddenHighwayTypeChangeCheck check = new SuddenHighwayTypeChangeCheck(\n+            ConfigurationResolver.inlineConfiguration(\n+                    \"{\\\"SuddenHighwayTypeChangeCheck\\\": {\\\"minHighwayType\\\": \\\"tertiary\\\"}}\"));\n+\n+    @Test\n+    public void testFalsePositiveSuddenHighwayTypeChangeCheck()\n+    {\n+        this.verifier.actual(this.setup.falsePositiveSuddenHighwayTypeChangeCheck(), this.check);\n+        this.verifier.verifyEmpty();\n+    }\n+\n+    @Test\n+    public void testTruePositiveSuddenHighwayTypeChangeCheck()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMjg2Ng=="}, "originalCommit": {"oid": "b145c7ae978794d317fab0edcd2c693f2460175e"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE5OTIxOnYy", "diffSide": "LEFT", "path": "config/configuration.json", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNzoxMDowNFrOHnWY-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxOTo0OTowOFrOHncYIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzM1Mw==", "bodyText": "This needs to be reverted.", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511023353", "createdAt": "2020-10-23T17:10:04Z", "author": {"login": "sayas01"}, "path": "config/configuration.json", "diffHunk": "@@ -3,8 +3,7 @@\n     \"scanUrls\": [\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n-    \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MTA0MQ==", "bodyText": "Can you check again for this? It looks like this was a part of one of my last commits", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511061041", "createdAt": "2020-10-23T18:21:06Z", "author": {"login": "reichg"}, "path": "config/configuration.json", "diffHunk": "@@ -3,8 +3,7 @@\n     \"scanUrls\": [\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n-    \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzM1Mw=="}, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2NDYzNQ==", "bodyText": "It does look like line 7 was removed @reichg", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511064635", "createdAt": "2020-10-23T18:28:16Z", "author": {"login": "sayas01"}, "path": "config/configuration.json", "diffHunk": "@@ -3,8 +3,7 @@\n     \"scanUrls\": [\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n-    \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzM1Mw=="}, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4NDE3OA==", "bodyText": "ah yes now I see, had to look at dev branch to see what it was supposed to look like haha", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511084178", "createdAt": "2020-10-23T18:55:56Z", "author": {"login": "reichg"}, "path": "config/configuration.json", "diffHunk": "@@ -3,8 +3,7 @@\n     \"scanUrls\": [\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n-    \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzM1Mw=="}, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyMTQ0MA==", "bodyText": "So if you look under the \"Files Changed\" in the PR, it shows the comparison of your branch with the dev branch. So anything in red is deleted from dev and anything in green is newly added. :)", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511121440", "createdAt": "2020-10-23T19:49:08Z", "author": {"login": "sayas01"}, "path": "config/configuration.json", "diffHunk": "@@ -3,8 +3,7 @@\n     \"scanUrls\": [\n       \"org.openstreetmap.atlas.checks.validation\"\n     ],\n-    \"type\": \"org.openstreetmap.atlas.checks.base.BaseCheck\",\n-    \"enabled.value.default\": true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMzM1Mw=="}, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTQ1NzEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxODoyNjozMVrOHnY2uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxODo1NDo0NFrOHnaEOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MzczNw==", "bodyText": "nit: I think you can return true here", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511063737", "createdAt": "2020-10-23T18:26:31Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check identifies ways that make suspiciously large jumps in highway classification\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     * \n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge)\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        final HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.highwayTag(edgeBeingVerified)\n+                .orElse(HighwayTag.NO);\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first and last edge's connected edges for suspiciously large highway tag\n+        // jumps.\n+        if (this.firstEdgeStartNodeEdgesHighwayTags(edgeBeingVerifiedHighwayTag,\n+                firstEdgeStartNodeEdges, firstEdgeStartNodeEdgesHighwayTags)\n+                || this.lastEdgeEndNodeEdgesHighwayTage(edgeBeingVerifiedHighwayTag,\n+                        lastEdgeEndNodeEdges, lastEdgeEndNodeEdgesHighwayTags))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(\n+                    createFlag(object, this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+        }\n+\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Case one: edge being verified is motorway, primary, trunk\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * Case three: edge being verified is tertiary or tertiary_link\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.TERTIARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge being verified is any link but tertiary.\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case one: edge checked against is tertiary, residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case three: edge checked against is living_Street, service, or track\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.LIVING_STREET.equals(edgeHighwayTag)\n+                || HighwayTag.TRACK.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge checked against is residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * checks if edge is roundabout or circular\n+     * \n+     * @param edge\n+     *            edge to check if roundabout or circular\n+     * @return boolean\n+     */\n+    private boolean edgeIsRoundaboutOrCircular(final Edge edge)\n+    {\n+        return JunctionTag.isCircular(edge) || JunctionTag.isRoundabout(edge);\n+    }\n+\n+    /**\n+     * checks if edge being verified's first edge start node connected edges make suspicious jumps\n+     * \n+     * @param edgeBeingVerifiedHighwayTag\n+     *            edge being verified highway tag\n+     * @param firstEdgeStartNodeEdges\n+     *            first edge start node edges\n+     * @param firstEdgeStartNodeEdgesHighwayTags\n+     *            first edge start node edge highway tags\n+     * @return boolean\n+     */\n+    private boolean firstEdgeStartNodeEdgesHighwayTags(final HighwayTag edgeBeingVerifiedHighwayTag,\n+            final Set<Edge> firstEdgeStartNodeEdges,\n+            final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags)\n+    {\n+        boolean suspiciousJump = false;\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final HighwayTag firstEdgeEdgeHighwayTag = HighwayTag.highwayTag(firstEdgeEdge)\n+                    .orElse(HighwayTag.NO);\n+            if ((!edgeBeingVerifiedHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeEdgeHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+                    && (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseThree(edgeBeingVerifiedHighwayTag,\n+                                    firstEdgeEdgeHighwayTag)))\n+            {\n+                suspiciousJump = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA4MzU3OQ==", "bodyText": "yup, agreed on this! fixed", "url": "https://github.com/osmlab/atlas-checks/pull/381#discussion_r511083579", "createdAt": "2020-10-23T18:54:44Z", "author": {"login": "reichg"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/edges/SuddenHighwayTypeChangeCheck.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.validation.linear.edges;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.openstreetmap.atlas.checks.atlas.predicates.TypePredicates;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.JunctionTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check identifies ways that make suspiciously large jumps in highway classification\n+ *\n+ * @author v-garei\n+ */\n+public class SuddenHighwayTypeChangeCheck extends BaseCheck<Long>\n+{\n+    private static final String SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION = \"Way {0,number,#} has a connected edge which jumps significantly in highway classification. Please make sure the highway tag is not suspicious.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Collections\n+            .singletonList(SUDDEN_HIGHWAY_TYPE_CHANGE_INSTRUCTION);\n+    private static final String HIGHWAY_MINIMUM_DEFAULT = HighwayTag.RESIDENTIAL.toString();\n+    private final HighwayTag minHighwayType;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     * \n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SuddenHighwayTypeChangeCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        final String highwayType = this.configurationValue(configuration, \"minHighwayType\",\n+                HIGHWAY_MINIMUM_DEFAULT);\n+        this.minHighwayType = Enum.valueOf(HighwayTag.class, highwayType.toUpperCase());\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        if (TypePredicates.IS_EDGE.test(object) && ((Edge) object).isMainEdge()\n+                && !isFlagged(object.getOsmIdentifier()))\n+        {\n+            final Edge edge = (Edge) object;\n+            return HighwayTag.isCarNavigableHighway(edge)\n+                    && edge.highwayTag().isMoreImportantThanOrEqualTo(this.minHighwayType)\n+                    && !JunctionTag.isRoundabout(edge) && !JunctionTag.isCircular(edge);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     * \n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Edge edgeBeingVerified = (Edge) object;\n+\n+        final List<Edge> completeWayEdges = new ArrayList<>(\n+                new OsmWayWalker(edgeBeingVerified).collectEdges());\n+\n+        final Node firstEdgeStartNode = completeWayEdges.get(0).start();\n+        final Node lastEdgeEndNode = completeWayEdges.get(completeWayEdges.size() - 1).end();\n+\n+        final Set<Edge> firstEdgeStartNodeEdges = firstEdgeStartNode.connectedEdges();\n+        firstEdgeStartNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+        final Set<Edge> lastEdgeEndNodeEdges = lastEdgeEndNode.connectedEdges();\n+        lastEdgeEndNodeEdges\n+                .removeIf(edge -> edge.getOsmIdentifier() == edgeBeingVerified.getOsmIdentifier());\n+\n+        final HighwayTag edgeBeingVerifiedHighwayTag = HighwayTag.highwayTag(edgeBeingVerified)\n+                .orElse(HighwayTag.NO);\n+\n+        final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags = this\n+                .getHighwayTags(firstEdgeStartNodeEdges);\n+        final Set<HighwayTag> lastEdgeEndNodeEdgesHighwayTags = this\n+                .getHighwayTags(lastEdgeEndNodeEdges);\n+\n+        // Check ways' first and last edge's connected edges for suspiciously large highway tag\n+        // jumps.\n+        if (this.firstEdgeStartNodeEdgesHighwayTags(edgeBeingVerifiedHighwayTag,\n+                firstEdgeStartNodeEdges, firstEdgeStartNodeEdgesHighwayTags)\n+                || this.lastEdgeEndNodeEdgesHighwayTage(edgeBeingVerifiedHighwayTag,\n+                        lastEdgeEndNodeEdges, lastEdgeEndNodeEdgesHighwayTags))\n+        {\n+            markAsFlagged(object.getOsmIdentifier());\n+            return Optional.of(\n+                    createFlag(object, this.getLocalizedInstruction(0, object.getOsmIdentifier())));\n+        }\n+\n+        markAsFlagged(edgeBeingVerified.getOsmIdentifier());\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Case one: edge being verified is motorway, primary, trunk\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * Case three: edge being verified is tertiary or tertiary_link\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.TERTIARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge being verified is any link but tertiary.\n+     * \n+     * @param edgeHighwayTag\n+     *            tag for edge being verified\n+     * @return boolean\n+     */\n+    private boolean edgeBeingVerifiedCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.MOTORWAY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.PRIMARY_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.TRUNK_LINK.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY.equals(edgeHighwayTag)\n+                || HighwayTag.SECONDARY_LINK.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case one: edge checked against is tertiary, residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseOne(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.TERTIARY.equals(edgeHighwayTag)\n+                || HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case three: edge checked against is living_Street, service, or track\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseThree(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.LIVING_STREET.equals(edgeHighwayTag)\n+                || HighwayTag.TRACK.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * case two: edge checked against is residential, service, or unclassified\n+     * \n+     * @param edgeHighwayTag\n+     *            connected edge highway tag\n+     * @return boolean\n+     */\n+    private boolean edgeCheckedAgainstCaseTwo(final HighwayTag edgeHighwayTag)\n+    {\n+        return HighwayTag.UNCLASSIFIED.equals(edgeHighwayTag)\n+                || HighwayTag.RESIDENTIAL.equals(edgeHighwayTag)\n+                || HighwayTag.SERVICE.equals(edgeHighwayTag);\n+    }\n+\n+    /**\n+     * checks if edge is roundabout or circular\n+     * \n+     * @param edge\n+     *            edge to check if roundabout or circular\n+     * @return boolean\n+     */\n+    private boolean edgeIsRoundaboutOrCircular(final Edge edge)\n+    {\n+        return JunctionTag.isCircular(edge) || JunctionTag.isRoundabout(edge);\n+    }\n+\n+    /**\n+     * checks if edge being verified's first edge start node connected edges make suspicious jumps\n+     * \n+     * @param edgeBeingVerifiedHighwayTag\n+     *            edge being verified highway tag\n+     * @param firstEdgeStartNodeEdges\n+     *            first edge start node edges\n+     * @param firstEdgeStartNodeEdgesHighwayTags\n+     *            first edge start node edge highway tags\n+     * @return boolean\n+     */\n+    private boolean firstEdgeStartNodeEdgesHighwayTags(final HighwayTag edgeBeingVerifiedHighwayTag,\n+            final Set<Edge> firstEdgeStartNodeEdges,\n+            final Set<HighwayTag> firstEdgeStartNodeEdgesHighwayTags)\n+    {\n+        boolean suspiciousJump = false;\n+        for (final Edge firstEdgeEdge : firstEdgeStartNodeEdges)\n+        {\n+            final HighwayTag firstEdgeEdgeHighwayTag = HighwayTag.highwayTag(firstEdgeEdge)\n+                    .orElse(HighwayTag.NO);\n+            if ((!edgeBeingVerifiedHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeEdgeHighwayTag.equals(HighwayTag.NO)\n+                    && !firstEdgeStartNodeEdgesHighwayTags.contains(edgeBeingVerifiedHighwayTag)\n+                    && !this.edgeIsRoundaboutOrCircular(firstEdgeEdge))\n+                    && (this.isCaseOne(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseTwo(edgeBeingVerifiedHighwayTag, firstEdgeEdgeHighwayTag)\n+                            || this.isCaseThree(edgeBeingVerifiedHighwayTag,\n+                                    firstEdgeEdgeHighwayTag)))\n+            {\n+                suspiciousJump = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MzczNw=="}, "originalCommit": {"oid": "b77dcdf8a1622e52230bcad10eee2d12c4c50e0a"}, "originalPosition": 253}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3188, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}