{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2ODkwOTgx", "number": 445, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyMDoyOVrOFIVLQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzoyMjoxOVrOFKMOzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0Mjc5ODcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyMDoyOVrOIKMA0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyMDoyOVrOIKMA0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1MzQ4OQ==", "bodyText": "This can be done using the built in countries.denylist configurable.", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r547553489", "createdAt": "2020-12-22T23:20:29Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(\n+            Arrays.asList(\"urban\", \"rural\", \"bicycle_road\", \"trunk\", \"motorway\", \"living_street\",\n+                    \"school\", \"pedestrian_zone\", \"urban_motorway\", \"urban_trunk\", \"nsl\", \"express\",\n+                    \"nsl_restricted\", \"nsl_dual\", \"nsl_single\", \"zone\"));\n+    // UK uses a different tag for this use case\n+    private static final List<String> DEFAULT_EXCEPTIONS = Collections.singletonList(\"UK\");\n+    // Belgium has these 3 regions that are accepted because they have a different default rural or\n+    // urban maxspeed\n+    private static final List<String> COUNTRY_EXCEPTIONS = Arrays.asList(\"BE-VLG\", \"BE-WAL\",\n+            \"BE-BRU\");\n+    // besides the default possible values, there are some accepted variations of \"zone\"\n+    private static final String ZONE = \"zone\";\n+    private static final int GENERAL_INSTRUCTION_INDEX = 0;\n+    private static final int VALUE_INSTRUCTION_INDEX = 1;\n+    private static final int COUNTRY_INSTRUCTION_INDEX = 2;\n+    private static final int CONTEXT_INSTRUCTION_INDEX = 3;\n+\n+    private final List<String> exceptedCountries;\n+\n+    /**\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SourceMaxspeedCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.exceptedCountries = this.configurationValue(configuration, \"excepted_countries\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjgwNjA2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNDoxNFrOIKME-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNDoxNFrOIKME-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NDU1NA==", "bodyText": "This would be good as a configurable.", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r547554554", "createdAt": "2020-12-22T23:24:14Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjgwNjIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNDoyMFrOIKMFFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNDoyMFrOIKMFFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NDU4MA==", "bodyText": "This would be good as a configurable.", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r547554580", "createdAt": "2020-12-22T23:24:20Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjgwNjQ5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNDoyN1rOIKMFRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzoyNDoyN1rOIKMFRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NDYzMA==", "bodyText": "This would be good as a configurable.", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r547554630", "createdAt": "2020-12-22T23:24:27Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(\n+            Arrays.asList(\"urban\", \"rural\", \"bicycle_road\", \"trunk\", \"motorway\", \"living_street\",\n+                    \"school\", \"pedestrian_zone\", \"urban_motorway\", \"urban_trunk\", \"nsl\", \"express\",\n+                    \"nsl_restricted\", \"nsl_dual\", \"nsl_single\", \"zone\"));\n+    // UK uses a different tag for this use case\n+    private static final List<String> DEFAULT_EXCEPTIONS = Collections.singletonList(\"UK\");\n+    // Belgium has these 3 regions that are accepted because they have a different default rural or\n+    // urban maxspeed\n+    private static final List<String> COUNTRY_EXCEPTIONS = Arrays.asList(\"BE-VLG\", \"BE-WAL\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjgyMDEwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMzozMToxM1rOIKMMxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMjoxNDozMFrOIRu-rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NjU1MQ==", "bodyText": "It would be great if edges that share an osm id could be grouped into one flag like here. For this to work properly it is also important to mark items as flagged by there osm ids.", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r547556551", "createdAt": "2020-12-22T23:31:13Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(\n+            Arrays.asList(\"urban\", \"rural\", \"bicycle_road\", \"trunk\", \"motorway\", \"living_street\",\n+                    \"school\", \"pedestrian_zone\", \"urban_motorway\", \"urban_trunk\", \"nsl\", \"express\",\n+                    \"nsl_restricted\", \"nsl_dual\", \"nsl_single\", \"zone\"));\n+    // UK uses a different tag for this use case\n+    private static final List<String> DEFAULT_EXCEPTIONS = Collections.singletonList(\"UK\");\n+    // Belgium has these 3 regions that are accepted because they have a different default rural or\n+    // urban maxspeed\n+    private static final List<String> COUNTRY_EXCEPTIONS = Arrays.asList(\"BE-VLG\", \"BE-WAL\",\n+            \"BE-BRU\");\n+    // besides the default possible values, there are some accepted variations of \"zone\"\n+    private static final String ZONE = \"zone\";\n+    private static final int GENERAL_INSTRUCTION_INDEX = 0;\n+    private static final int VALUE_INSTRUCTION_INDEX = 1;\n+    private static final int COUNTRY_INSTRUCTION_INDEX = 2;\n+    private static final int CONTEXT_INSTRUCTION_INDEX = 3;\n+\n+    private final List<String> exceptedCountries;\n+\n+    /**\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SourceMaxspeedCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.exceptedCountries = this.configurationValue(configuration, \"excepted_countries\",\n+                DEFAULT_EXCEPTIONS);\n+    }\n+\n+    /**\n+     * Valid objects for this check are Points and Edges with a source:maxspeed tag and are not part\n+     * of the excepted countries.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !this.isFlagged(object.getOsmIdentifier())\n+                && (object instanceof Edge || object instanceof Point)\n+                && this.hasSourceMaxspeed(object)\n+                && (object.getTags().containsKey(ISOCountryTag.KEY) && !this.exceptedCountries\n+                        .contains(object.tag(ISOCountryTag.KEY).toUpperCase()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Optional<String> sourceMaxspeed = object.getTag(SOURCE_MAXSPEED);\n+        if (sourceMaxspeed.isPresent())\n+        {\n+            final Set<String> instructions = new HashSet<>();\n+            final String sourceValue = sourceMaxspeed.get();\n+            final Matcher matcher = COUNTRY_CONTEXT_PATTERN.matcher(sourceValue);\n+            if (matcher.find())\n+            {\n+                final String[] parts = sourceValue.split(COLON);\n+                if (!this.isCountryValid(parts[0]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(COUNTRY_INSTRUCTION_INDEX, parts[0]));\n+                }\n+                if (!this.isContextValid(parts[1]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(CONTEXT_INSTRUCTION_INDEX, parts[1]));\n+                }\n+\n+            }\n+\n+            else if (!POSSIBLE_VALUES.contains(sourceValue) && !sourceValue.contains(ZONE))\n+            {\n+                instructions.add(this.getLocalizedInstruction(VALUE_INSTRUCTION_INDEX));\n+            }\n+            if (!instructions.isEmpty())\n+            {\n+                final CheckFlag flag = this.createFlag(object, this.getLocalizedInstruction(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NTA0NQ==", "bodyText": "Also what are your thoughts on embedding a fix suggestion here to convert the tag to sign or markings? @mm-ciub", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r550355045", "createdAt": "2020-12-30T23:26:31Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(\n+            Arrays.asList(\"urban\", \"rural\", \"bicycle_road\", \"trunk\", \"motorway\", \"living_street\",\n+                    \"school\", \"pedestrian_zone\", \"urban_motorway\", \"urban_trunk\", \"nsl\", \"express\",\n+                    \"nsl_restricted\", \"nsl_dual\", \"nsl_single\", \"zone\"));\n+    // UK uses a different tag for this use case\n+    private static final List<String> DEFAULT_EXCEPTIONS = Collections.singletonList(\"UK\");\n+    // Belgium has these 3 regions that are accepted because they have a different default rural or\n+    // urban maxspeed\n+    private static final List<String> COUNTRY_EXCEPTIONS = Arrays.asList(\"BE-VLG\", \"BE-WAL\",\n+            \"BE-BRU\");\n+    // besides the default possible values, there are some accepted variations of \"zone\"\n+    private static final String ZONE = \"zone\";\n+    private static final int GENERAL_INSTRUCTION_INDEX = 0;\n+    private static final int VALUE_INSTRUCTION_INDEX = 1;\n+    private static final int COUNTRY_INSTRUCTION_INDEX = 2;\n+    private static final int CONTEXT_INSTRUCTION_INDEX = 3;\n+\n+    private final List<String> exceptedCountries;\n+\n+    /**\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SourceMaxspeedCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.exceptedCountries = this.configurationValue(configuration, \"excepted_countries\",\n+                DEFAULT_EXCEPTIONS);\n+    }\n+\n+    /**\n+     * Valid objects for this check are Points and Edges with a source:maxspeed tag and are not part\n+     * of the excepted countries.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !this.isFlagged(object.getOsmIdentifier())\n+                && (object instanceof Edge || object instanceof Point)\n+                && this.hasSourceMaxspeed(object)\n+                && (object.getTags().containsKey(ISOCountryTag.KEY) && !this.exceptedCountries\n+                        .contains(object.tag(ISOCountryTag.KEY).toUpperCase()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Optional<String> sourceMaxspeed = object.getTag(SOURCE_MAXSPEED);\n+        if (sourceMaxspeed.isPresent())\n+        {\n+            final Set<String> instructions = new HashSet<>();\n+            final String sourceValue = sourceMaxspeed.get();\n+            final Matcher matcher = COUNTRY_CONTEXT_PATTERN.matcher(sourceValue);\n+            if (matcher.find())\n+            {\n+                final String[] parts = sourceValue.split(COLON);\n+                if (!this.isCountryValid(parts[0]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(COUNTRY_INSTRUCTION_INDEX, parts[0]));\n+                }\n+                if (!this.isContextValid(parts[1]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(CONTEXT_INSTRUCTION_INDEX, parts[1]));\n+                }\n+\n+            }\n+\n+            else if (!POSSIBLE_VALUES.contains(sourceValue) && !sourceValue.contains(ZONE))\n+            {\n+                instructions.add(this.getLocalizedInstruction(VALUE_INSTRUCTION_INDEX));\n+            }\n+            if (!instructions.isEmpty())\n+            {\n+                final CheckFlag flag = this.createFlag(object, this.getLocalizedInstruction(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NjU1MQ=="}, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwNzQ0OA==", "bodyText": "@Bentleysb I will start making the improvements, thank you.\n@seancoulter, looking over taginfo I see that most cases have the value 'sign' at 21.30% while 'markings' is at 0.01%.  So perhaps a fix suggestion for sign could be added, but the user should assure that there is a sign present. Otherwise it falls under the zone source requiring the country:context format.", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r551907448", "createdAt": "2021-01-05T12:40:48Z", "author": {"login": "mm-ciub"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(\n+            Arrays.asList(\"urban\", \"rural\", \"bicycle_road\", \"trunk\", \"motorway\", \"living_street\",\n+                    \"school\", \"pedestrian_zone\", \"urban_motorway\", \"urban_trunk\", \"nsl\", \"express\",\n+                    \"nsl_restricted\", \"nsl_dual\", \"nsl_single\", \"zone\"));\n+    // UK uses a different tag for this use case\n+    private static final List<String> DEFAULT_EXCEPTIONS = Collections.singletonList(\"UK\");\n+    // Belgium has these 3 regions that are accepted because they have a different default rural or\n+    // urban maxspeed\n+    private static final List<String> COUNTRY_EXCEPTIONS = Arrays.asList(\"BE-VLG\", \"BE-WAL\",\n+            \"BE-BRU\");\n+    // besides the default possible values, there are some accepted variations of \"zone\"\n+    private static final String ZONE = \"zone\";\n+    private static final int GENERAL_INSTRUCTION_INDEX = 0;\n+    private static final int VALUE_INSTRUCTION_INDEX = 1;\n+    private static final int COUNTRY_INSTRUCTION_INDEX = 2;\n+    private static final int CONTEXT_INSTRUCTION_INDEX = 3;\n+\n+    private final List<String> exceptedCountries;\n+\n+    /**\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SourceMaxspeedCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.exceptedCountries = this.configurationValue(configuration, \"excepted_countries\",\n+                DEFAULT_EXCEPTIONS);\n+    }\n+\n+    /**\n+     * Valid objects for this check are Points and Edges with a source:maxspeed tag and are not part\n+     * of the excepted countries.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !this.isFlagged(object.getOsmIdentifier())\n+                && (object instanceof Edge || object instanceof Point)\n+                && this.hasSourceMaxspeed(object)\n+                && (object.getTags().containsKey(ISOCountryTag.KEY) && !this.exceptedCountries\n+                        .contains(object.tag(ISOCountryTag.KEY).toUpperCase()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Optional<String> sourceMaxspeed = object.getTag(SOURCE_MAXSPEED);\n+        if (sourceMaxspeed.isPresent())\n+        {\n+            final Set<String> instructions = new HashSet<>();\n+            final String sourceValue = sourceMaxspeed.get();\n+            final Matcher matcher = COUNTRY_CONTEXT_PATTERN.matcher(sourceValue);\n+            if (matcher.find())\n+            {\n+                final String[] parts = sourceValue.split(COLON);\n+                if (!this.isCountryValid(parts[0]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(COUNTRY_INSTRUCTION_INDEX, parts[0]));\n+                }\n+                if (!this.isContextValid(parts[1]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(CONTEXT_INSTRUCTION_INDEX, parts[1]));\n+                }\n+\n+            }\n+\n+            else if (!POSSIBLE_VALUES.contains(sourceValue) && !sourceValue.contains(ZONE))\n+            {\n+                instructions.add(this.getLocalizedInstruction(VALUE_INSTRUCTION_INDEX));\n+            }\n+            if (!instructions.isEmpty())\n+            {\n+                final CheckFlag flag = this.createFlag(object, this.getLocalizedInstruction(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NjU1MQ=="}, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ2NjQxNA==", "bodyText": "Ok thanks for the explanation. sounds like this might involve more research, and then we can open up an Issue if fix suggestions are found to be suitable", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r555466414", "createdAt": "2021-01-12T02:14:30Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(\n+            Arrays.asList(\"urban\", \"rural\", \"bicycle_road\", \"trunk\", \"motorway\", \"living_street\",\n+                    \"school\", \"pedestrian_zone\", \"urban_motorway\", \"urban_trunk\", \"nsl\", \"express\",\n+                    \"nsl_restricted\", \"nsl_dual\", \"nsl_single\", \"zone\"));\n+    // UK uses a different tag for this use case\n+    private static final List<String> DEFAULT_EXCEPTIONS = Collections.singletonList(\"UK\");\n+    // Belgium has these 3 regions that are accepted because they have a different default rural or\n+    // urban maxspeed\n+    private static final List<String> COUNTRY_EXCEPTIONS = Arrays.asList(\"BE-VLG\", \"BE-WAL\",\n+            \"BE-BRU\");\n+    // besides the default possible values, there are some accepted variations of \"zone\"\n+    private static final String ZONE = \"zone\";\n+    private static final int GENERAL_INSTRUCTION_INDEX = 0;\n+    private static final int VALUE_INSTRUCTION_INDEX = 1;\n+    private static final int COUNTRY_INSTRUCTION_INDEX = 2;\n+    private static final int CONTEXT_INSTRUCTION_INDEX = 3;\n+\n+    private final List<String> exceptedCountries;\n+\n+    /**\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SourceMaxspeedCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.exceptedCountries = this.configurationValue(configuration, \"excepted_countries\",\n+                DEFAULT_EXCEPTIONS);\n+    }\n+\n+    /**\n+     * Valid objects for this check are Points and Edges with a source:maxspeed tag and are not part\n+     * of the excepted countries.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !this.isFlagged(object.getOsmIdentifier())\n+                && (object instanceof Edge || object instanceof Point)\n+                && this.hasSourceMaxspeed(object)\n+                && (object.getTags().containsKey(ISOCountryTag.KEY) && !this.exceptedCountries\n+                        .contains(object.tag(ISOCountryTag.KEY).toUpperCase()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Optional<String> sourceMaxspeed = object.getTag(SOURCE_MAXSPEED);\n+        if (sourceMaxspeed.isPresent())\n+        {\n+            final Set<String> instructions = new HashSet<>();\n+            final String sourceValue = sourceMaxspeed.get();\n+            final Matcher matcher = COUNTRY_CONTEXT_PATTERN.matcher(sourceValue);\n+            if (matcher.find())\n+            {\n+                final String[] parts = sourceValue.split(COLON);\n+                if (!this.isCountryValid(parts[0]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(COUNTRY_INSTRUCTION_INDEX, parts[0]));\n+                }\n+                if (!this.isContextValid(parts[1]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(CONTEXT_INSTRUCTION_INDEX, parts[1]));\n+                }\n+\n+            }\n+\n+            else if (!POSSIBLE_VALUES.contains(sourceValue) && !sourceValue.contains(ZONE))\n+            {\n+                instructions.add(this.getLocalizedInstruction(VALUE_INSTRUCTION_INDEX));\n+            }\n+            if (!instructions.isEmpty())\n+            {\n+                final CheckFlag flag = this.createFlag(object, this.getLocalizedInstruction(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NjU1MQ=="}, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2MjMwNDc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzoyMjoxOVrOIM29tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMzoyMjoxOVrOIM29tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NDM1OA==", "bodyText": "there's an extra ] here", "url": "https://github.com/osmlab/atlas-checks/pull/445#discussion_r550354358", "createdAt": "2020-12-30T23:22:19Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/SourceMaxspeedCheck.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import static org.openstreetmap.atlas.checks.constants.CommonConstants.COLON;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ISOCountryTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.ISO2CountryValidator;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check verifies that the source:maxspeed tag follows the official tagging rules.\n+ * https://wiki.openstreetmap.org/wiki/Key:source:maxspeed\n+ *\n+ * @author mm-ciub\n+ */\n+public class SourceMaxspeedCheck extends BaseCheck<Long>\n+{\n+\n+    private static final long serialVersionUID = -7004341564141771203L;\n+    private static final String GENERAL_INSTRUCTION = \"The element with id {0,number,#} does not follow the source:maxspeed tagging rules\";\n+    private static final String WRONG_VALUE_INSTRUCTION = \"The value must be 'sign', 'markings' or follow the country_code:context format.\";\n+    private static final String WRONG_COUNTRY_CODE_INSTRUCTION = \"{0} is not a valid country code.\";\n+    private static final String WRONG_CONTEXT_INSTRUCTION = \"{0} is not a valid context for the maxspeed source. (valid examples: urban, 30 etc.)\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(GENERAL_INSTRUCTION,\n+            WRONG_VALUE_INSTRUCTION, WRONG_COUNTRY_CODE_INSTRUCTION, WRONG_CONTEXT_INSTRUCTION);\n+    private static final String SOURCE_MAXSPEED = \"source:maxspeed\";\n+    private static final List<String> POSSIBLE_VALUES = Arrays.asList(\"sign\", \"markings\");\n+    private static final Pattern COUNTRY_CONTEXT_PATTERN = Pattern.compile(\"[a-zA-Z]{2}:.+\");\n+    private static final Set<String> EXPECTED_CONTEXT_VALUES = new HashSet<>(\n+            Arrays.asList(\"urban\", \"rural\", \"bicycle_road\", \"trunk\", \"motorway\", \"living_street\",\n+                    \"school\", \"pedestrian_zone\", \"urban_motorway\", \"urban_trunk\", \"nsl\", \"express\",\n+                    \"nsl_restricted\", \"nsl_dual\", \"nsl_single\", \"zone\"));\n+    // UK uses a different tag for this use case\n+    private static final List<String> DEFAULT_EXCEPTIONS = Collections.singletonList(\"UK\");\n+    // Belgium has these 3 regions that are accepted because they have a different default rural or\n+    // urban maxspeed\n+    private static final List<String> COUNTRY_EXCEPTIONS = Arrays.asList(\"BE-VLG\", \"BE-WAL\",\n+            \"BE-BRU\");\n+    // besides the default possible values, there are some accepted variations of \"zone\"\n+    private static final String ZONE = \"zone\";\n+    private static final int GENERAL_INSTRUCTION_INDEX = 0;\n+    private static final int VALUE_INSTRUCTION_INDEX = 1;\n+    private static final int COUNTRY_INSTRUCTION_INDEX = 2;\n+    private static final int CONTEXT_INSTRUCTION_INDEX = 3;\n+\n+    private final List<String> exceptedCountries;\n+\n+    /**\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public SourceMaxspeedCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.exceptedCountries = this.configurationValue(configuration, \"excepted_countries\",\n+                DEFAULT_EXCEPTIONS);\n+    }\n+\n+    /**\n+     * Valid objects for this check are Points and Edges with a source:maxspeed tag and are not part\n+     * of the excepted countries.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !this.isFlagged(object.getOsmIdentifier())\n+                && (object instanceof Edge || object instanceof Point)\n+                && this.hasSourceMaxspeed(object)\n+                && (object.getTags().containsKey(ISOCountryTag.KEY) && !this.exceptedCountries\n+                        .contains(object.tag(ISOCountryTag.KEY).toUpperCase()));\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final Optional<String> sourceMaxspeed = object.getTag(SOURCE_MAXSPEED);\n+        if (sourceMaxspeed.isPresent())\n+        {\n+            final Set<String> instructions = new HashSet<>();\n+            final String sourceValue = sourceMaxspeed.get();\n+            final Matcher matcher = COUNTRY_CONTEXT_PATTERN.matcher(sourceValue);\n+            if (matcher.find())\n+            {\n+                final String[] parts = sourceValue.split(COLON);\n+                if (!this.isCountryValid(parts[0]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(COUNTRY_INSTRUCTION_INDEX, parts[0]));\n+                }\n+                if (!this.isContextValid(parts[1]))\n+                {\n+                    instructions\n+                            .add(this.getLocalizedInstruction(CONTEXT_INSTRUCTION_INDEX, parts[1]));\n+                }\n+\n+            }\n+\n+            else if (!POSSIBLE_VALUES.contains(sourceValue) && !sourceValue.contains(ZONE))\n+            {\n+                instructions.add(this.getLocalizedInstruction(VALUE_INSTRUCTION_INDEX));\n+            }\n+            if (!instructions.isEmpty())\n+            {\n+                final CheckFlag flag = this.createFlag(object, this.getLocalizedInstruction(\n+                        GENERAL_INSTRUCTION_INDEX, object.getOsmIdentifier()));\n+                instructions.forEach(flag::addInstruction);\n+                return Optional.of(flag);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private boolean hasSourceMaxspeed(final AtlasObject object)\n+    {\n+        return object.getOsmTags().keySet().stream().anyMatch(key -> key.contains(SOURCE_MAXSPEED));\n+    }\n+\n+    private boolean isContextValid(final String context)\n+    {\n+        final boolean isNumber = context.matches(\"[0-9]].+\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98ab233360c9bd48274d5896cea591cb02e6c474"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3231, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}