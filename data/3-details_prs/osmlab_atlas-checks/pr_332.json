{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzY4NTg3", "number": 332, "title": "Basic waterway checks", "bodyText": "Description:\nThis does basic waterway checks (closed waterway, waterway does not end in sink, crossing waterway).\nSee #331.\nThere are also two new utility classes, ElevationUtilities and CompressionUtilities. The ElevationUtilities reads HGT files (for example, those provided by the SRTM NASA mission), and when given a point, returns the elevation for the appropriate location (only as accurate as the source data -- it should be able to take arbitrarily accurate HGT files). ElevationUtilities reads from elevation directory in the directory that the check run is started from. This can be customized. CompressionUtilities is used to decompress file streams, so that if a file is in a tar.gz, zip, gz, or isn't compressed at all, the user can be relatively certain that the stream is now usable if the file stream is passed into the utility method. This also helps reduce the size on disk for elevation files (i.e., if there is a high resolution HGT file that takes up 1 GiB uncompressed).\nTo support usage of SRTM elevation files, there is a script in scripts/elevationData called srtm-hgt.py. This file fetches the SRTM NASA files at a slow rate, so that the serving USGS servers are not significantly burdened by the download. The script tries to ensure that if it is killed, the appropriate actions are taken upon the next start (skip/restart/continue). These files have (at best) ~90m resolution, which means that they are not useful for short lengths, or any method which requires more precise locations. For these instances, more precise data may be provided manually.\nPotential Impact:\nBetter waterway navigation will be possible. Closed waterways can be very confusing to data consumers (how does it work?), waterways that don't end in a sink (so an ocean, drain, or sinkhole) may or may not be navigable, but it cannot be determined easily. Crossing waterways may allow navigation between them, but only if they are connected (what happens if one is in a tunnel?).\nUnit Test Approach:\nThe unit tests primarily test for potential false positives, along with some potential false negatives.\nTest Results:\n\n\n\nISO\nTotal Flags\nSampled\nSampling %\nTP\nFP\nFalse Positive Rate\n\n\n\n\nAIA\n0\n0\nn/a\nn/a\nn/a\nn/a\n\n\nBLZ\n311\n35\n11%\n35\n0\n0%\n\n\nDMA\n30\n30\n100%\n30\n0\n0%\n\n\nCYM\n7\n7\n100%\n7\n0\n0% [1]\n\n\nNZL[2]\n12182\n40\n0.3%\n38\n2\n5%\n\n\nNZL (second take, same challenge rebuilt)\n12191\n156\n1.2%\n132\n9\n5.7%\n\n\nSMR\n10\n10\n100%\n5\n5\n50%[3]\n\n\n\n[1] 3 of the TP detections were difficult to determine (e.g., waterway in wetland -- spec doesn't allow for them to end, but it makes sense, waterway may go multiple directions, etc.). However, the wiki specification does not allow for them. No actual waterway visible (still an issue).\n[2] NZL had an import of waterways (and other land cover information). Most of the issues found are waterways without sinks, and much of the time, there are multiple related issues (so a series of waterways may have the wrong direction). In the sample layer, 63 waterways were modified, so ~55 issues were actually fixed (some were crossing waterways, but very few were). If this were to be released publicly, it would be a good idea (tm) to update the MapRoulette task weekly (if people actually used it). A false positive is from a waterway ending on a lake where I was unable to find an outlet for the lake (there is probably one somewhere). Another false positive is from a waterway continuing through a coast and into the ocean a fair ways. I've linked to the MapRoulette challenge I used for the spot checking -- please don't use it for editing at this time.\n[3] The false positives can be categorized into two separate categories:\n\nBoundary issues (the atlas way appears cut at an administrative boundary in Atlas, 3/5 fp)\nLayer issues (layer=-1 -> no layer, 2/5 fp). Both issues could also be due to boundaries, since a specific test did not fail with layer issues. Having opened the source atlas file, both are valid detections (the connecting waterways do not appear in the file).\n\nFalse Negatives:\nWay 350806025: This way is not closed, but when taken with other ways, it forms a loop. Osmose does not find it either. This may be partially ameliorated by the addition of height data (e.g., from the SRTM Nasa mission).\nNotes\nThere is an ongoing discussion on the mailing lists about abruptly ending waterways. This test will probably need to be updated once a consensus is reached (i.e., tagging for when the waterway spreads out and is soaked up by the earth).\n\n\n\nbranch\ntime\nnotes\n\n\n\n\ndev\n2h 28m 26s\n./gradlew clean build run with AIA,CYM,DMA,NZL,SMR\n\n\nfeature/waterway-check\n2h 34m 2s\n./gradlew clean build run with AIA,CYM,DMA,NZL,SMR", "createdAt": "2020-07-23T14:52:58Z", "url": "https://github.com/osmlab/atlas-checks/pull/332", "merged": true, "mergeCommit": {"oid": "3a5c6f213f5a4ce1b95a68675c03e4c8a4b0b1ff"}, "closed": true, "closedAt": "2020-09-10T01:07:36Z", "author": {"login": "tsmock"}, "timelineItems": {"totalCount": 54, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7nMLmgBqjM2MjA0MTU2Njk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHWNF5gFqTQ4NTQ5ODkwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f09d8ef08af47320db5752f9f22b4bacc56f2900", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/f09d8ef08af47320db5752f9f22b4bacc56f2900", "committedDate": "2020-07-23T14:40:16Z", "message": "Standard waterway checks\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}, "afterCommit": {"oid": "5a2edb331e1f1b71aec88e6fa6260c65a1fec05d", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/5a2edb331e1f1b71aec88e6fa6260c65a1fec05d", "committedDate": "2020-08-04T14:07:04Z", "message": "Standard waterway checks\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a2edb331e1f1b71aec88e6fa6260c65a1fec05d", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/5a2edb331e1f1b71aec88e6fa6260c65a1fec05d", "committedDate": "2020-08-04T14:07:04Z", "message": "Standard waterway checks\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}, "afterCommit": {"oid": "1e7aff9029f667939b3735c8ced597f54e6f1aac", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/1e7aff9029f667939b3735c8ced597f54e6f1aac", "committedDate": "2020-08-11T20:27:02Z", "message": "WaterWayCheck: Use elevations for better instructions\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e3b245cbbda3ebb1b09d6a6ee57cb4968421c5a9", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/e3b245cbbda3ebb1b09d6a6ee57cb4968421c5a9", "committedDate": "2020-08-11T23:12:05Z", "message": "ElevationUtilities: Support more compression formats.\n\nThe additional compression formats should be useful for integrating\nthird party data (e.g., object detections). This is from the new\nCompressionUtilities class.\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}, "afterCommit": {"oid": "006d9481a99c8444f5fb445c0e13ed85c97af8ed", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/006d9481a99c8444f5fb445c0e13ed85c97af8ed", "committedDate": "2020-08-12T13:34:58Z", "message": "ElevationUtilities: Support more compression formats.\n\nThe additional compression formats should be useful for integrating\nthird party data (e.g., object detections). This is from the new\nCompressionUtilities class.\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eddf8939e101fd8b7a976d892f840847a700c849", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/eddf8939e101fd8b7a976d892f840847a700c849", "committedDate": "2020-08-12T22:17:11Z", "message": "WaterWayChecks: Add tests for differing elevations\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}, "afterCommit": {"oid": "4a630e08ed985011dc399267b2e5253c0cdb8fe0", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4a630e08ed985011dc399267b2e5253c0cdb8fe0", "committedDate": "2020-08-20T16:39:10Z", "message": "WaterWayChecks: Add tests for differing elevations\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3583cfabefac6e57431459c35a479dc00158b2ec", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3583cfabefac6e57431459c35a479dc00158b2ec", "committedDate": "2020-08-20T23:08:01Z", "message": "WaterWayChecks: Add documentation\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}, "afterCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/e691f4763f0ffb7eaf98350589a81aa8a028e0c3", "committedDate": "2020-08-24T19:02:11Z", "message": "WaterWayChecks: Add documentation\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1Nzk4NjYx", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-475798661", "createdAt": "2020-08-26T19:34:24Z", "commit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTozNDoyNVrOHHa0XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxOTo1MjozMVrOHHbaYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0MTQ2OQ==", "bodyText": "nit: looks like we could move this check up a few lines before the elevation checks", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477541469", "createdAt": "2020-08-26T19:34:25Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0MzkwMA==", "bodyText": "General question: is it possible to get a waterway that is an offender in multiple ways to this Check? E.g. a waterway that ends in a sink and crosses itself. If so we could append instructions together in one flag instead of returning only one instruction set per flag.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477543900", "createdAt": "2020-08-26T19:38:55Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NTE4Ng==", "bodyText": "nit: intersectingWaterways", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477545186", "createdAt": "2020-08-26T19:41:13Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        else if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(object, first);\n+        }\n+        else if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line))\n+        {\n+            if (uphill)\n+            {\n+                flag = createUphillFlag(object, first);\n+            }\n+            else if (!endsWithBoundaryNode(object))\n+            {\n+                flag = createFlag(object,\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK),\n+                                object.getOsmIdentifier()),\n+                        Collections.singletonList(last));\n+            }\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (flag == null && crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                flag = createFlag(Sets.hashSet(object, crossed),\n+                        this.getLocalizedInstruction(\n+                                FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY),\n+                                object.getOsmIdentifier(), crossed.getOsmIdentifier()),\n+                        Arrays.asList(intersections.next()));\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final AtlasObject object, final Location first)\n+    {\n+        return createFlag(object,\n+                this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL),\n+                        object.getOsmIdentifier(),\n+                        this.elevationUtils.getResolution(first).asMeters()));\n+    }\n+\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    private LineItem intersectsAnotherWaterWay(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final Iterable<LineItem> intersectinWaterways = atlas.lineItemsIntersecting(line.bounds(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1MTIwMA==", "bodyText": "We probably want to add that this check flags uphill waterways as well (docs/javadoc)\nI noticed it in a couple places, but wasn't sure if it was consistently mentioned", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r477551200", "createdAt": "2020-08-26T19:52:31Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,453 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer.\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),\n+                        this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        else if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(object, first);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e691f4763f0ffb7eaf98350589a81aa8a028e0c3"}, "originalPosition": 363}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7cee1b414dc04507a8d4253a7bf14464d9775c24", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7cee1b414dc04507a8d4253a7bf14464d9775c24", "committedDate": "2020-08-27T13:28:32Z", "message": "WaterWayCheck: Append instructions to flag, if one exists\n\n* For example,\n  1. The waterway <xxx> does not end in a sink\n  (ocean/sinkhole/waterway/drain)\n  2. The waterway <xxx> crosses the waterway <yyy>.\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}, "afterCommit": {"oid": "c0a8345c7fa4e2551cdd5cc7206eb2b9cc34091a", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/c0a8345c7fa4e2551cdd5cc7206eb2b9cc34091a", "committedDate": "2020-08-27T14:02:45Z", "message": "WaterWayCheck: Append instructions to flag, if one exists\n\n* For example,\n  1. The waterway <xxx> does not end in a sink\n  (ocean/sinkhole/waterway/drain)\n  2. The waterway <xxx> crosses the waterway <yyy>.\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "727544fcafd836ec531488bf8982fa426797439a", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/727544fcafd836ec531488bf8982fa426797439a", "committedDate": "2020-08-27T14:49:35Z", "message": "WaterWayCheck: FIXUP: Update docs to indicate that crossing waterways are found\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}, "afterCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/dedbee4bb1565e14c80a79c616219be14b5c50bc", "committedDate": "2020-09-08T13:11:31Z", "message": "WaterWayCheck: FIXUP: Update docs to indicate that crossing waterways are found\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTI0ODg4", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-484524888", "createdAt": "2020-09-08T22:08:26Z", "commit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjowODoyNlrOHOvpSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoyNTozN1rOHOwAvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjcyOQ==", "bodyText": "I think this would be more reusable if the 3 srtm values were given as the constructor parameters, instead of needing to be in a configuration.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485222729", "createdAt": "2020-09-08T22:08:26Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final int SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final int srtmExtent;\n+\n+    private final String srtmExt;\n+\n+    private final String srtmPath;\n+\n+    /**\n+     * Configuration Keys in the Integrity Framework are based on the check simple classname.\n+     *\n+     * @param key\n+     *            key part for a specific configuration item defined for this class\n+     * @return complete key for lookup\n+     */\n+    private static String configurationKey(final String key)\n+    {\n+        return formatKey(\"elevationutilities\", key);\n+    }\n+\n+    private static <U, V> V configurationValue(final Configuration configuration, final String key,\n+            final U defaultValue, final Function<U, V> transform)\n+    {\n+        return configuration.get(configurationKey(key), defaultValue, transform).value();\n+    }\n+\n+    private static String formatKey(final String name, final String key)\n+    {\n+        return String.format(\"%s.%s\", name, key);\n+    }\n+\n+    /**\n+     * Create a configured ElevationUtilities\n+     *\n+     * @param configuration\n+     *            A configuration which should (at a minimum) have a file path for elevation files.\n+     */\n+    public ElevationUtilities(final Configuration configuration)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzM5Nw==", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String SRTM_EXT = \"hgt\";\n          \n          \n            \n                private static final String SRTM_EXTENTION = \"hgt\";", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485223397", "createdAt": "2020-09-08T22:10:21Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMzYwMw==", "bodyText": "Nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final String srtmExt;\n          \n          \n            \n                private final String srtmExtension;", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485223603", "createdAt": "2020-09-08T22:10:55Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,361 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXT = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final int SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final int srtmExtent;\n+\n+    private final String srtmExt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyNjkxNg==", "bodyText": "I am a bit confused what is happening at this point (some comments throughout this method would help). Is this considering a polyline to end in the ocean if it is to the east of a coast?", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485226916", "createdAt": "2020-09-08T22:20:30Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,467 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyODczNQ==", "bodyText": "I think you can simplify this method by using Atlas.lineItemsContaining(Location), and filtering from there.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485228735", "createdAt": "2020-09-08T22:25:37Z", "author": {"login": "Bentleysb"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,467 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().last().boxAround(Distance.ONE_METER),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dedbee4bb1565e14c80a79c616219be14b5c50bc"}, "originalPosition": 285}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTQ2MTE0", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-484546114", "createdAt": "2020-09-08T22:49:23Z", "commit": {"oid": "85289c0103464782c51f30a489463dc287840df6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0OToyM1rOHOwhNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0OToyM1rOHOwhNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNzA0NA==", "bodyText": "This needs a challenge object with the MapRoulette information.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485237044", "createdAt": "2020-09-08T22:49:23Z", "author": {"login": "Bentleysb"}, "path": "config/configuration.json", "diffHunk": "@@ -1068,5 +1068,13 @@\n       \"difficulty\": \"EASY\",\n       \"defaultPriority\": \"LOW\"\n     }\n+  },\n+  \"WaterWayCheck\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85289c0103464782c51f30a489463dc287840df6"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7515b23ba18390adab8bc5a757d1a85eb2cab2c7", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7515b23ba18390adab8bc5a757d1a85eb2cab2c7", "committedDate": "2020-09-09T16:35:18Z", "message": "WaterWayCheck: Add additional information when a waterway crosses a coast but does NOT end in the ocean\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}, "afterCommit": {"oid": "7af4e84e30b41cb62fea75c6ba32b61352aaa1ac", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7af4e84e30b41cb62fea75c6ba32b61352aaa1ac", "committedDate": "2020-09-09T16:47:08Z", "message": "WaterWayCheck: Add additional information when a waterway crosses a coast but does NOT end in the ocean\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MTkwNTk2", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-485190596", "createdAt": "2020-09-09T16:22:53Z", "commit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjoyMjo1M1rOHPPnTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNjo1MjowNlrOHPRHyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc0NjUxMA==", "bodyText": "You can simplify these configs with:\nocean: {\n  boundary: \"\",\n  valid: \"\"\n},\nwaterway: {\n elevation: {\n  distance.min.start.end: \"\",\n  resolution.min.uphill: \"\"\n },\n sink.tags.filters: \"\",\n tags.filters: \"\"\n\n}", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485746510", "createdAt": "2020-09-09T16:22:53Z", "author": {"login": "danielduhh"}, "path": "config/configuration.json", "diffHunk": "@@ -1068,5 +1068,20 @@\n       \"difficulty\": \"EASY\",\n       \"defaultPriority\": \"LOW\"\n     }\n+  },\n+  \"WaterWayCheck\": {\n+    \"ocean.boundary\": \"natural->coastline\",\n+    \"ocean.valid\": \"natural->strait,channel,fjord,sound,bay|harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\",\n+    \"waterway.elevation.distance.min.start.end\": 450.0,\n+    \"waterway.elevation.resolution.min.uphill\": 1.0,\n+    \"waterway.sink.tags.filters\": \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\",\n+    \"waterway.tags.filters\": \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1Nzk2Ng==", "bodyText": "Is this copied from OceanBleedingCheck? https://github.com/osmlab/atlas-checks/blob/dev/src/main/java/org/openstreetmap/atlas/checks/validation/intersections/OceanBleedingCheck.java#L40\nIf so, lets pull them both out into a tag util that can be shared", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485757966", "createdAt": "2020-09-09T16:36:17Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1ODI2Mw==", "bodyText": "nit: extra space", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485758263", "createdAt": "2020-09-09T16:36:37Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1ODMzNQ==", "bodyText": "nit: extra space", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485758335", "createdAt": "2020-09-09T16:36:41Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2MTY5OA==", "bodyText": "Do you mind adding java docs here?", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485761698", "createdAt": "2020-09-09T16:40:26Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK), object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2MjE4Mw==", "bodyText": "Same comment here on documentation", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485762183", "createdAt": "2020-09-09T16:41:03Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK), object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (flag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        flag.addInstruction(instruction);\n+        return flag;\n+    }\n+\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    private LineItem intersectsAnotherWaterWay(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n+                this.waterwayTagFilter::test);\n+        final Set<LineItem> sameLayerWays = Iterables.stream(intersectingWaterways)\n+                .filter(potential -> LayerTag.areOnSameLayer(line, potential)\n+                        && !waterwayConnects(line, potential))\n+                .collectToSet();\n+        sameLayerWays.removeIf(line::equals);\n+        if (sameLayerWays.isEmpty())\n+        {\n+            return null;\n+        }\n+        return sameLayerWays.iterator().next();\n+    }\n+\n+    private boolean waterwayConnects(final LineItem line, final LineItem potential)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 457}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2MjMwOA==", "bodyText": "Java docs here as well \ud83d\ude04", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485762308", "createdAt": "2020-09-09T16:41:12Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,472 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain)\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(\n+                    FALLBACK_INSTRUCTIONS.indexOf(DOES_NOT_END_IN_SINK), object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (flag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        flag.addInstruction(instruction);\n+        return flag;\n+    }\n+\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    private LineItem intersectsAnotherWaterWay(final LineItem line)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0c1f526ecc4f0dec48be419c2159f377898c543"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2ODU2MQ==", "bodyText": "getAtlas() can be an expensive operation. You should be able to store the atlas in the flag function in pass it to your helpers that need access to the entire atlas.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485768561", "createdAt": "2020-09-09T16:48:52Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,493 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af4e84e30b41cb62fea75c6ba32b61352aaa1ac"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2OTk1Mg==", "bodyText": "Please avoid single letter variables", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485769952", "createdAt": "2020-09-09T16:50:36Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/utility/ElevationUtilities.java", "diffHunk": "@@ -0,0 +1,379 @@\n+package org.openstreetmap.atlas.checks.utility;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.Longitude;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * Used to determine assumed direction for some features (e.g. waterways). Assumptions are that any\n+ * SRTM file follows the specification here:\n+ * https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf\n+ *\n+ * @author Taylor Smock\n+ */\n+public final class ElevationUtilities implements Serializable\n+{\n+    private static final long serialVersionUID = -5929570973909280629L;\n+    /**\n+     * The assumed file extension\n+     */\n+    private static final String SRTM_EXTENSION = \"hgt\";\n+    /**\n+     * The assumed extent of a HGT SRTM file (lat/lon) in degrees\n+     */\n+    private static final double SRTM_EXTENT = 1;\n+    /**\n+     * A non-number when there is no elevation data available. This is currently returns\n+     * {@link Short#MIN_VALUE}.\n+     */\n+    public static final short NO_ELEVATION = Short.MIN_VALUE;\n+\n+    private static final short[][] EMPTY_MAP = new short[][] {};\n+\n+    /** Just an int for converting a decimal to a percentage */\n+    private static final int DECIMAL_TO_PERCENTAGE = 100;\n+\n+    /** A map of {lat, lon} pairs with a loaded srtm in a byte array */\n+    private final Map<Pair<Integer, Integer>, short[][]> loadedSrtm = new HashMap<>();\n+\n+    private final double srtmExtent;\n+\n+    private final String srtmExtension;\n+\n+    private final String srtmPath;\n+\n+    /**\n+     * Configuration Keys in the Integrity Framework are based on the check simple classname.\n+     *\n+     * @param key\n+     *            key part for a specific configuration item defined for this class\n+     * @return complete key for lookup\n+     */\n+    private static String configurationKey(final String key)\n+    {\n+        return formatKey(ElevationUtilities.class.getSimpleName(), key);\n+    }\n+\n+    private static <U, V> V configurationValue(final Configuration configuration, final String key,\n+            final U defaultValue, final Function<U, V> transform)\n+    {\n+        return configuration.get(configurationKey(key), defaultValue, transform).value();\n+    }\n+\n+    private static String formatKey(final String name, final String key)\n+    {\n+        return String.format(\"%s.%s\", name, key);\n+    }\n+\n+    /**\n+     * Create a configured ElevationUtilities\n+     *\n+     * @param configuration\n+     *            A configuration which should (at a minimum) have a file path for elevation files.\n+     */\n+    public ElevationUtilities(final Configuration configuration)\n+    {\n+        this(configurationValue(configuration, \"elevation.srtm_extent\", SRTM_EXTENT, i -> i),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af4e84e30b41cb62fea75c6ba32b61352aaa1ac"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc3MTIxMQ==", "bodyText": "nit: please avoid single letter variables", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485771211", "createdAt": "2020-09-09T16:52:06Z", "author": {"login": "danielduhh"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,493 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+\n+    private final TaggableFilter validOceanTags;\n+\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream().filter(p -> p.getLeft().equals(max))\n+                    .map(Pair::getValue).collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(crosses.stream()\n+                    .flatMap(c -> Stream.of(c.first(), c.last())).toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(\n+                l -> l.asPolyLine().contains(last) && !last.equals(l.asPolyLine().last()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af4e84e30b41cb62fea75c6ba32b61352aaa1ac"}, "originalPosition": 316}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MjY5MjQx", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-485269241", "createdAt": "2020-09-09T18:01:12Z", "commit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODowMToxMlrOHPTqjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODowNzoyNlrOHPT3qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxMjg3Nw==", "bodyText": "Could be simplified as :  return difference != null && difference.asDegrees() > 0;", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485812877", "createdAt": "2020-09-09T18:01:12Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxMzgxMg==", "bodyText": "Same comment as https://github.com/osmlab/atlas-checks/pull/332/files#r485768561 on storing the atlas and passing it to helpers.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485813812", "createdAt": "2020-09-09T18:02:53Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxNjIzMg==", "bodyText": "Missing this keyword.", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485816232", "createdAt": "2020-09-09T18:07:26Z", "author": {"login": "sayas01"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,529 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DEFAULT_VALID_OCEAN_TAGS = \"natural->strait,channel,fjord,sound,bay|\"\n+            + \"harbour->*&harbour->!no|estuary->*&estuary->!no|bay->*&bay->!no|place->sea|seamark:type->harbour,harbour_basin,sea_area|water->bay,cove,harbour|waterway->artificial,dock\";\n+\n+    private static final String DEFAULT_OCEAN_BOUNDARY_TAGS = \"natural->coastline\";\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(\n+                this.configurationValue(configuration, \"ocean.valid\", DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fc57250231ab7ed93ec58b98505453f3e17e8f1"}, "originalPosition": 479}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1Mjg5Nzk1", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-485289795", "createdAt": "2020-09-09T18:30:32Z", "commit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxODozMDozMlrOHPUo3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTowMzo1OVrOHPVt9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODgzMA==", "bodyText": "Should we pass the entire polyline as an argument to make sure there are no intermediate elevation changes? Might require a loop in getIncline() over all pairs of points in the polyline", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485828830", "createdAt": "2020-09-09T18:30:32Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzMTM3Mg==", "bodyText": "I see from the next few lines that this might complicate the existing logic. So just if you think it's best !", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485831372", "createdAt": "2020-09-09T18:35:23Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyODgzMA=="}, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNjAwMQ==", "bodyText": "Since LineItem uses its underlying Polyline to create bounds via a Rectangle and not a line, we might pick up some waterways that do not intersect the param waterway but instead intersect its bounds. To avoid that we could say\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n          \n          \n            \n                            this.waterwayTagFilter::test);\n          \n          \n            \n                    final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(), incoming -> this.waterwayTagFilter.test(incoming) && incoming.asPolyLine().intersects(line.asPolyLine());", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485836001", "createdAt": "2020-09-09T18:44:02Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    /**\n+     * Get an intersecting waterway, if one exists.\n+     *\n+     * @param line\n+     *            The waterway to look for intersections for.\n+     * @return A crossing waterway, or {@code null} if no crossing waterway exists.\n+     */\n+    private LineItem intersectsAnotherWaterWay(final Atlas atlas, final LineItem line)\n+    {\n+        final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n+                this.waterwayTagFilter::test);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNzQ3NA==", "bodyText": "Is there any reason why we only look at one intersecting waterway ?", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485837474", "createdAt": "2020-09-09T18:46:56Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    /**\n+     * Get an intersecting waterway, if one exists.\n+     *\n+     * @param line\n+     *            The waterway to look for intersections for.\n+     * @return A crossing waterway, or {@code null} if no crossing waterway exists.\n+     */\n+    private LineItem intersectsAnotherWaterWay(final Atlas atlas, final LineItem line)\n+    {\n+        final Iterable<LineItem> intersectingWaterways = atlas.lineItemsIntersecting(line.bounds(),\n+                this.waterwayTagFilter::test);\n+        final Set<LineItem> sameLayerWays = Iterables.stream(intersectingWaterways)\n+                .filter(potential -> LayerTag.areOnSameLayer(line, potential)\n+                        && !waterwayConnects(line, potential))\n+                .collectToSet();\n+        sameLayerWays.removeIf(line::equals);\n+        if (sameLayerWays.isEmpty())\n+        {\n+            return null;\n+        }\n+        return sameLayerWays.iterator().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 499}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNzk1OQ==", "bodyText": "nit: could name this getIntersectingWaterway(s?)(...) as it's not returning a boolean", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485837959", "createdAt": "2020-09-09T18:47:55Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)\n+        {\n+            final Line line = (Line) lineItem;\n+            final Location last = line.asPolyLine().last();\n+            final Set<LocationItem> one = Iterables.stream(line.getAtlas().nodesAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            final Set<LocationItem> two = Iterables.stream(line.getAtlas().pointsAt(last))\n+                    .filter(LocationItem.class::isInstance).map(LocationItem.class::cast)\n+                    .collectToSet();\n+            if (Stream.concat(one.stream(), two.stream())\n+                    .anyMatch(this.waterwaySinkTagFilter::test))\n+            {\n+                return true;\n+            }\n+        }\n+        else if (lineItem instanceof Edge)\n+        {\n+            return this.waterwaySinkTagFilter.test(((Edge) lineItem).end());\n+        }\n+        return lineItem.getAtlas()\n+                .areasCovering(lineItem.asPolyLine().last(), this.waterwaySinkTagFilter::test)\n+                .iterator().hasNext();\n+    }\n+\n+    /**\n+     * Check if the last location on a line also happens to be connected to a waterway.\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends on a waterway (the last node is part of a waterway)\n+     */\n+    public boolean doesLineEndOnWaterway(final LineItem line)\n+    {\n+        final List<LineItem> waterways = new ArrayList<>();\n+        line.getAtlas().lineItemsContaining(line.asPolyLine().last(), this.waterwayTagFilter::test)\n+                .forEach(waterways::add);\n+\n+        waterways.removeIf(line::equals);\n+        final Location last = line.asPolyLine().last();\n+        return waterways.stream().anyMatch(tLine -> tLine.asPolyLine().contains(last)\n+                && !last.equals(tLine.asPolyLine().last()));\n+    }\n+\n+    /**\n+     * Check if a location is to the right of a line (e.g., kerbs, cliffs, and oceans)\n+     *\n+     * @param line\n+     *            The line to compare the location to\n+     * @param location\n+     *            The location\n+     * @return {@code true} if the location is to the right of the line. If the location is on the\n+     *         line, or to the left of the line, we return {@code false}.\n+     */\n+    public boolean isRightOf(final PolyLine line, final Location location)\n+    {\n+        final PolyLine tLine = new PolyLine(location);\n+        final Segment closest = line.segments().stream()\n+                .min(Comparator.comparingDouble(s -> s.shortestDistanceTo(tLine).asMeters()))\n+                .orElse(null);\n+        if (closest != null)\n+        {\n+            final PolyLine testLine = new PolyLine(closest.first(), closest.last(), location);\n+            final Angle difference = testLine.headingDifference().orElse(null);\n+            if (difference != null && difference.asDegrees() > 0)\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a location is inside an atlas bounds\n+     *\n+     * @param atlas\n+     *            The atlas\n+     * @param location\n+     *            The location to check\n+     * @return {@code true} if the atlas contains the location inside its bounds\n+     */\n+    public boolean isValidEndToCheck(final Atlas atlas, final Location location)\n+    {\n+        return atlas.bounds().fullyGeometricallyEncloses(location);\n+    }\n+\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        return !isFlagged(object.getOsmIdentifier()) && object instanceof LineItem\n+                && this.waterwayTagFilter.test(object);\n+    }\n+\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        final LineItem line = (LineItem) object;\n+        final Location last = line.asPolyLine().last();\n+        final Location first = line.asPolyLine().first();\n+        final Atlas atlas = line.getAtlas();\n+        CheckFlag flag = null;\n+        if (line.isClosed())\n+        {\n+            flag = createFlag(object,\n+                    this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS.indexOf(CIRCULAR_WATERWAY),\n+                            object.getOsmIdentifier()),\n+                    Collections.singletonList(line.asPolyLine().first()));\n+        }\n+        final double incline = this.elevationUtils.getIncline(first, last);\n+        final boolean uphill = !Double.isNaN(incline) && incline > 0\n+                && last.distanceTo(first).isGreaterThan(this.minDistanceStartEndElevationUphill);\n+        if (uphill && this.minResolutionDistance\n+                .isGreaterThanOrEqualTo(this.elevationUtils.getResolution(first)))\n+        {\n+            flag = createUphillFlag(flag, object, first);\n+        }\n+        if (isValidEndToCheck(line.getAtlas(), last) && !doesWaterwayEndInSink(line)\n+                && !endsWithBoundaryNode(object))\n+        {\n+            final String instruction = this.getLocalizedInstruction(FALLBACK_INSTRUCTIONS\n+                    .indexOf(this.doesLineCrossCoast(line) ? DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN\n+                            : DOES_NOT_END_IN_SINK),\n+                    object.getOsmIdentifier());\n+            if (flag == null)\n+            {\n+                flag = createFlag(object, instruction, Collections.singletonList(last));\n+            }\n+            else\n+            {\n+                flag.addObject(object, last, instruction);\n+            }\n+\n+        }\n+        final LineItem crossed = intersectsAnotherWaterWay(atlas, line);\n+        if (crossed != null)\n+        {\n+            final Iterator<Location> intersections = crossed.asPolyLine()\n+                    .intersections(line.asPolyLine()).iterator();\n+            if (intersections.hasNext())\n+            {\n+                final String instruction = this.getLocalizedInstruction(\n+                        FALLBACK_INSTRUCTIONS.indexOf(CROSSES_WATERWAY), object.getOsmIdentifier(),\n+                        crossed.getOsmIdentifier());\n+                if (flag == null)\n+                {\n+                    flag = createFlag(Sets.hashSet(object, crossed), instruction,\n+                            Arrays.asList(intersections.next()));\n+                }\n+                else\n+                {\n+                    flag.addObject(crossed, intersections.next(), instruction);\n+                }\n+            }\n+        }\n+        if (flag == null)\n+        {\n+            return Optional.empty();\n+        }\n+        super.markAsFlagged(object.getOsmIdentifier());\n+        return Optional.of(flag);\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Create a flag for an object that goes uphill\n+     *\n+     * @param flag\n+     *            The flag to create/modify. May be {@code null}.\n+     * @param object\n+     *            The object to flag\n+     * @param first\n+     *            The first node of the way\n+     * @return The new CheckFlag (if the passed flag was {@code null}) or the modified CheckFlag.\n+     */\n+    private CheckFlag createUphillFlag(final CheckFlag flag, final AtlasObject object,\n+            final Location first)\n+    {\n+        final CheckFlag returnFlag = flag;\n+        final String instruction = this.getLocalizedInstruction(\n+                FALLBACK_INSTRUCTIONS.indexOf(GOES_UPHILL), object.getOsmIdentifier(),\n+                this.elevationUtils.getResolution(first).asMeters());\n+        if (returnFlag == null)\n+        {\n+            return createFlag(object, instruction);\n+        }\n+        returnFlag.addInstruction(instruction);\n+        return returnFlag;\n+    }\n+\n+    /**\n+     * Check if a line crosses an coastline line\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line crosses a coastline\n+     */\n+    private boolean doesLineCrossCoast(final LineItem line)\n+    {\n+        final List<LineItem> lines = new ArrayList<>();\n+        line.getAtlas()\n+                .lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        return !lines.isEmpty();\n+    }\n+\n+    /**\n+     * Check if the waterway ends in a sink (i.e., a location that can reasonably expected to have\n+     * no outflow).\n+     *\n+     * @param line\n+     *            The waterway item to check\n+     * @return {@code true} if the waterway ends in a sink.\n+     */\n+    private boolean doesWaterwayEndInSink(final LineItem line)\n+    {\n+        return doesLineEndOnWaterway(line) || doesLineEndInSink(line) || doesLineEndInOcean(line);\n+    }\n+\n+    /**\n+     * Get an intersecting waterway, if one exists.\n+     *\n+     * @param line\n+     *            The waterway to look for intersections for.\n+     * @return A crossing waterway, or {@code null} if no crossing waterway exists.\n+     */\n+    private LineItem intersectsAnotherWaterWay(final Atlas atlas, final LineItem line)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 486}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0MTQ5Mw==", "bodyText": "if sonar is complaining about declaring a stream and not having a terminal operation applied, I think we can make this a one liner :)", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485841493", "createdAt": "2020-09-09T18:54:35Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0NjUxNw==", "bodyText": "I think we could have the same treatment of Lines and Edges here. If either feature has a node or point at its end that's a sink, return true", "url": "https://github.com/osmlab/atlas-checks/pull/332#discussion_r485846517", "createdAt": "2020-09-09T19:03:59Z", "author": {"login": "seancoulter"}, "path": "src/main/java/org/openstreetmap/atlas/checks/validation/linear/lines/WaterWayCheck.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package org.openstreetmap.atlas.checks.validation.linear.lines;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.checks.utility.CommonTagFilters;\n+import org.openstreetmap.atlas.checks.utility.ElevationUtilities;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.PolyLine;\n+import org.openstreetmap.atlas.geography.Segment;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LineItem;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.SyntheticBoundaryNodeTag;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.collections.Sets;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+import org.openstreetmap.atlas.utilities.scalars.Angle;\n+import org.openstreetmap.atlas.utilities.scalars.Distance;\n+\n+/**\n+ * This check flags waterways that do not have a sink (i.e., are not connected to another waterway),\n+ * are circular (so first node and last node are the same), or cross another waterway with the same\n+ * layer. It also looks for ways that may be going uphill (requires elevation data, see\n+ * {@link ElevationUtilities}\n+ *\n+ * @author Taylor Smock\n+ */\n+public class WaterWayCheck extends BaseCheck<Long>\n+{\n+    /**\n+     * This comparator takes a polyline and segments, and compares the segments based off of the\n+     * location of the segment in the line.\n+     *\n+     * @author Taylor Smock\n+     */\n+    private static class SegmentIndexComparator implements Comparator<Segment>\n+    {\n+        private final List<Segment> lineSegments;\n+\n+        /**\n+         * Initialize with a specific polyline to check\n+         *\n+         * @param line\n+         *            The line to check the index of segments against\n+         */\n+        SegmentIndexComparator(final PolyLine line)\n+        {\n+            this.lineSegments = line.segments();\n+        }\n+\n+        @Override\n+        public int compare(final Segment segment1, final Segment segment2)\n+        {\n+            final Segment segment1real = this.lineSegments.stream().filter(segment1::equals)\n+                    .findFirst().orElse(null);\n+            final Segment segment2real = this.lineSegments.stream().filter(segment2::equals)\n+                    .findFirst().orElse(null);\n+            final int segment1index = this.lineSegments.indexOf(segment1real);\n+            final int segment2index = this.lineSegments.indexOf(segment2real);\n+            return segment1index - segment2index;\n+        }\n+    }\n+\n+    private static final long serialVersionUID = 2877101774578564205L;\n+    private static final String WATERWAY_SINK_TAG_FILTER_DEFAULT = \"natural->sinkhole|waterway->tidal_channel,drain|manhole->drain\";\n+    private static final String WATERWAY_TAG_FILTER_DEFAULT = \"waterway->river,stream,tidal_channel,canal,drain,ditch,pressurised\";\n+\n+    private static final String DOES_NOT_END_IN_SINK = \"The waterway {0} does not end in a sink (ocean/sinkhole/waterway/drain).\";\n+    private static final String DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN = DOES_NOT_END_IN_SINK\n+            + \"\\nThe waterway crosses a coastline, which means it is possible for the coastline to have an incorrect direction.\\nLand should be to the LEFT of the coastline and the ocean should be to the RIGHT of the coastline (for more information, see https://wiki.osm.org/Tag:natural=coastline).\";\n+    private static final String CIRCULAR_WATERWAY = \"The waterway {0} loops back on itself. This is typically impossible.\";\n+    private static final String CROSSES_WATERWAY = \"The waterway {0} crosses the waterway {1}.\";\n+    private static final String GOES_UPHILL = \"The waterway {0} probably does not go up hill.\\nPlease check (source elevation data resolution was about {1} meters).\";\n+    private static final Distance MIN_RESOLUTION_DISTANCE = Distance.ONE_METER;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(DOES_NOT_END_IN_SINK,\n+            CIRCULAR_WATERWAY, CROSSES_WATERWAY, GOES_UPHILL,\n+            DOES_NOT_END_IN_SINK_BUT_CROSSING_OCEAN);\n+\n+    private final TaggableFilter waterwaySinkTagFilter;\n+    private final TaggableFilter waterwayTagFilter;\n+    private final TaggableFilter validOceanTags;\n+    private final TaggableFilter oceanBoundaryTags;\n+    private final ElevationUtilities elevationUtils;\n+    private final Distance minResolutionDistance;\n+    private final Distance minDistanceStartEndElevationUphill;\n+\n+    /**\n+     * Get intersecting segments of two polylines\n+     *\n+     * @param left\n+     *            The polyline whose segments will go in the key/left side of the pair\n+     * @param right\n+     *            The polyline whose segments will go in the value/right side of the pair\n+     * @return A collection of segments intersecting other segments. A segment *may* appear more\n+     *         than once.\n+     */\n+    public static Collection<Pair<Segment, Segment>> getIntersectingSegments(final PolyLine left,\n+            final PolyLine right)\n+    {\n+        final Collection<Pair<Segment, Segment>> intersectingSegments = new HashSet<>();\n+        for (final Segment leftSegment : left.segments())\n+        {\n+            for (final Segment rightSegment : right.segments())\n+            {\n+                if (leftSegment.intersects(rightSegment))\n+                {\n+                    intersectingSegments.add(Pair.of(leftSegment, rightSegment));\n+                }\n+            }\n+        }\n+        return intersectingSegments;\n+    }\n+\n+    /**\n+     * Check the atlas object for boundary nodes at its end\n+     *\n+     * @param object\n+     *            The atlas object to check\n+     * @return {@code true} if the object ends on a boundary\n+     */\n+    private static boolean endsWithBoundaryNode(final AtlasObject object)\n+    {\n+        if (!(object instanceof LineItem))\n+        {\n+            return false;\n+        }\n+        final LineItem lineItem = (LineItem) object;\n+        final Atlas atlas = object.getAtlas();\n+        final Location last = lineItem.asPolyLine().last();\n+        final Stream<Point> points = Iterables.asList(atlas.pointsAt(last)).stream();\n+        final Stream<Node> nodes = Iterables.asList(atlas.nodesAt(last)).stream();\n+        return Stream.concat(points, nodes).anyMatch(SyntheticBoundaryNodeTag::isBoundaryNode);\n+    }\n+\n+    /**\n+     * Default constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public WaterWayCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.elevationUtils = new ElevationUtilities(configuration);\n+        this.waterwaySinkTagFilter = this.configurationValue(configuration,\n+                \"waterway.sink.tags.filters\", WATERWAY_SINK_TAG_FILTER_DEFAULT,\n+                TaggableFilter::forDefinition);\n+        this.waterwayTagFilter = this.configurationValue(configuration, \"waterway.tags.filters\",\n+                WATERWAY_TAG_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+\n+        /* Ocean data */\n+        this.validOceanTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.valid\", CommonTagFilters.DEFAULT_VALID_OCEAN_TAGS));\n+        this.oceanBoundaryTags = TaggableFilter.forDefinition(this.configurationValue(configuration,\n+                \"ocean.boundary\", CommonTagFilters.DEFAULT_OCEAN_BOUNDARY_TAGS));\n+\n+        /* End ocean data */\n+        /* Elevation settings */\n+        this.minResolutionDistance = this.configurationValue(configuration,\n+                \"waterway.elevation.resolution.min.uphill\", MIN_RESOLUTION_DISTANCE.asMeters(),\n+                Distance::meters);\n+        this.minDistanceStartEndElevationUphill = this.configurationValue(configuration,\n+                \"waterway.elevation.distance.min.start.end\",\n+                Distance.FIFTEEN_HUNDRED_FEET.asMeters(), Distance::meters);\n+        /* End elevation settings */\n+\n+    }\n+\n+    /**\n+     * Check if a line ends in an ocean\n+     *\n+     * @param line\n+     *            The line to check\n+     * @return {@code true} if the line ends in an ocean\n+     */\n+    public boolean doesLineEndInOcean(final LineItem line)\n+    {\n+        final Atlas atlas = line.getAtlas();\n+        final PolyLine linePolyline = line.asPolyLine();\n+        final Location last = linePolyline.last();\n+        if (atlas.areasCovering(last, this.validOceanTags::test).iterator().hasNext()\n+                || atlas.areasCovering(last, this.oceanBoundaryTags::test).iterator().hasNext())\n+        {\n+            return true;\n+        }\n+        final List<LineItem> lines = new ArrayList<>();\n+        atlas.lineItemsIntersecting(line.asPolyLine().bounds(), this.oceanBoundaryTags::test)\n+                .forEach(lines::add);\n+        final LineItem[] intersecting = lines.stream()\n+                .filter(l -> l.asPolyLine().intersects(linePolyline)).toArray(LineItem[]::new);\n+        final SegmentIndexComparator segmentComparator = new SegmentIndexComparator(linePolyline);\n+        for (final LineItem lineItem : intersecting)\n+        {\n+            // Get way segments from the two lines that intersect\n+            final Collection<Pair<Segment, Segment>> segs = getIntersectingSegments(linePolyline,\n+                    lineItem.asPolyLine());\n+            // Get the *latest* crossing segment of the waterway\n+            // (just in case the waterway crosses a coastline multiple times)\n+            final Segment max = segs.stream().map(Pair::getKey).distinct().max(segmentComparator)\n+                    .orElse(null);\n+            // Get the crossing segments of the coastline (probably just one)\n+            final Collection<Segment> crosses = segs.stream()\n+                    .filter(pair -> pair.getLeft().equals(max)).map(Pair::getValue)\n+                    .collect(Collectors.toSet());\n+            // Create a shortened coastline to use to check if the waterway ends inside the ocean\n+            final PolyLine coast = new PolyLine(\n+                    crosses.stream().flatMap(pCoast -> Stream.of(pCoast.first(), pCoast.last()))\n+                            .toArray(Location[]::new));\n+            // If the waterway ends to the right of the coastline, it ended in an ocean.\n+            // If the waterway ends on the coastline, it ended in an ocean.\n+            if (isRightOf(coast, linePolyline.last())\n+                    || lineItem.asPolyLine().contains(linePolyline.last()))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a line ends in a waterway sink\n+     *\n+     * @param lineItem\n+     *            The LineItem to check\n+     * @return {@code true} if the waterway can reasonably be expected to end\n+     */\n+    public boolean doesLineEndInSink(final LineItem lineItem)\n+    {\n+        // If the way is a sink, it obviously ends in a sink...\n+        if (this.waterwaySinkTagFilter.test(lineItem))\n+        {\n+            return true;\n+        }\n+        if (lineItem instanceof Line)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d58c977f649f8629f03b1aa2fe7d61fefa415e4"}, "originalPosition": 256}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dffafb5d6e74158230744f8d95f0e98d9c8dca4", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/9dffafb5d6e74158230744f8d95f0e98d9c8dca4", "committedDate": "2020-09-09T20:26:42Z", "message": "Standard waterway checks\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa066310907e4d83bb0a9b2902f2243a1d08d8aa", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/aa066310907e4d83bb0a9b2902f2243a1d08d8aa", "committedDate": "2020-09-09T20:26:42Z", "message": "WaterWayCheck: Add additional test for layer=-1 + no layer waterway connections\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e8a5563e5935dd33e84960298ffd92e9c96c758", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/9e8a5563e5935dd33e84960298ffd92e9c96c758", "committedDate": "2020-09-09T20:26:42Z", "message": "ElevationUtilities: Check elevations with third-party data\n\n* Currently supports HGT files (either uncompressed or in a zip archive)\n* Can be used to give better instructions (e.g., waterway goes up a\n  hill)\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56b371c8bb4101edf08ef9fe0f0880464c0e6c96", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/56b371c8bb4101edf08ef9fe0f0880464c0e6c96", "committedDate": "2020-09-09T20:26:42Z", "message": "WaterWayCheck: Use elevations for better instructions\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e75fb922f469cee7cf61f708d2a16d7ee59ed8b", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/8e75fb922f469cee7cf61f708d2a16d7ee59ed8b", "committedDate": "2020-09-09T20:26:42Z", "message": "WaterWayCheck: Check if the final node of a way is on a boundary.\n\nThis does not work with my sample files, since the waterways do not have\nthe synthetic tags, and sometimes a waterway that another waterway\nconnects to isn't in the atlas.\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3512ac213c958d0b6a2353b2a20b294c70d45d0a", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3512ac213c958d0b6a2353b2a20b294c70d45d0a", "committedDate": "2020-09-09T20:26:42Z", "message": "ElevationUtilities: Support more compression formats.\n\nThe additional compression formats should be useful for integrating\nthird party data (e.g., object detections). This is from the new\nCompressionUtilities class.\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13464ace4a4d40ce625324afe57aa1fe9966867e", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/13464ace4a4d40ce625324afe57aa1fe9966867e", "committedDate": "2020-09-09T20:26:42Z", "message": "FIXUP: ElevationUtilities: Sonar\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fbd52a57ddfaacb2147a3bf66579799b14f6cb69", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/fbd52a57ddfaacb2147a3bf66579799b14f6cb69", "committedDate": "2020-09-09T20:26:42Z", "message": "ElevationUtilities: FIXUP sonar issues\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d214aa8ec520bd15d4ab1a66646131bd684150ea", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d214aa8ec520bd15d4ab1a66646131bd684150ea", "committedDate": "2020-09-09T20:26:42Z", "message": "CompressionUtilities: Add tests\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6648695fa3ab49f43be0bdcb551f13ddbc8604c", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/f6648695fa3ab49f43be0bdcb551f13ddbc8604c", "committedDate": "2020-09-09T20:26:42Z", "message": "ElevationUtilities: Expand tests slightly\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eda4c566aa4621e8be1b624a32c264ca562a526", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/2eda4c566aa4621e8be1b624a32c264ca562a526", "committedDate": "2020-09-09T20:26:42Z", "message": "WaterWayChecks: Add tests for differing elevations\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3fa74c4da2d590554fdb90a13fca2798b8e670c", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/e3fa74c4da2d590554fdb90a13fca2798b8e670c", "committedDate": "2020-09-09T20:27:03Z", "message": "WaterWayChecks: Add documentation\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6c1d6d7f3dc6e53026279977fc91d78f6ca21e2", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/e6c1d6d7f3dc6e53026279977fc91d78f6ca21e2", "committedDate": "2020-09-09T20:27:04Z", "message": "WaterWayChecks: Update docs to include elevation check information\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eeac82805c10188cb9cc42baba7894229e11eef7", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/eeac82805c10188cb9cc42baba7894229e11eef7", "committedDate": "2020-09-09T20:27:04Z", "message": "WaterWayCheck: FIXUP: Typo (intersectinWaterways -> intersectingWaterways)\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf3afb1facbb63e3f3c565c3364e4be3d4de82a6", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/bf3afb1facbb63e3f3c565c3364e4be3d4de82a6", "committedDate": "2020-09-09T20:27:04Z", "message": "WaterWayCheck: Append instructions to flag, if one exists\n\n* For example,\n  1. The waterway <xxx> does not end in a sink\n  (ocean/sinkhole/waterway/drain)\n  2. The waterway <xxx> crosses the waterway <yyy>.\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9fd1df3ffc833dd93045b5f4ddebc3ba28d25ed", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/f9fd1df3ffc833dd93045b5f4ddebc3ba28d25ed", "committedDate": "2020-09-09T20:27:57Z", "message": "WaterWayCheck: Add sample configuration\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fe04d62c4fe963737a2b2f02bd20933e570b8ae", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/3fe04d62c4fe963737a2b2f02bd20933e570b8ae", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: FIXUP: Update docs to no longer indicate that a single issue ends the check\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6890eb4cda3dcc4c5cd9ba5d221b5cad50d79c1", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/b6890eb4cda3dcc4c5cd9ba5d221b5cad50d79c1", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: FIXUP: Update docs to indicate that crossing waterways are found\n\nSigned-off-by: Taylor Smock <taylor.smock@kaart.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "682912bd2f17d7edc570f4fffa3866f405ac7fd4", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/682912bd2f17d7edc570f4fffa3866f405ac7fd4", "committedDate": "2020-09-09T20:27:59Z", "message": "ElevationUtilities: Expand EXT/Ext to extension (appropriately capitalized)\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb6f80cd8f431816dc8218a566c04403a1436400", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/fb6f80cd8f431816dc8218a566c04403a1436400", "committedDate": "2020-09-09T20:27:59Z", "message": "ElevationUtilities: Add constructor for when a test wants to specify parameters manually\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51199cc8884bade7ed74c1ea8f152c294dcf660f", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/51199cc8884bade7ed74c1ea8f152c294dcf660f", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Improve documentation for a confusing code section\n\n* This mostly helps explain the coastline check.\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18f0120ee804ce484a24822e53eab32355d62893", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/18f0120ee804ce484a24822e53eab32355d62893", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Use Atlas.lineItemsContaining instead of Atlas.lineItemsIntersecting\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61c497ffc2e47db31201f3012da6f4835ed4bb25", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/61c497ffc2e47db31201f3012da6f4835ed4bb25", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck Configuration: Add challenge section\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a36dde90acd10f3e7d18cb2f8089637e820f1fa8", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/a36dde90acd10f3e7d18cb2f8089637e820f1fa8", "committedDate": "2020-09-09T20:27:59Z", "message": "ElevationUtilities: Add test for constructors\n\n* Also, modify so that the settings use the same casing as other\n  configuration settings\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "718a3aa6f7a600dc31328ebe8ca83850c8f7862d", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/718a3aa6f7a600dc31328ebe8ca83850c8f7862d", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Add additional information when a waterway crosses a coast but does NOT end in the ocean\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5056483de16491b53c20e5f4f5651e7f1e184719", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/5056483de16491b53c20e5f4f5651e7f1e184719", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Make configuration prettier\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4007aa9dfff7481cd99a91f0fb45f6a966f4689f", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/4007aa9dfff7481cd99a91f0fb45f6a966f4689f", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck, ElevationUtilities: Avoid single character variables\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a55a376921437371ccf1b7b98b1fb9faf1b8fc8b", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/a55a376921437371ccf1b7b98b1fb9faf1b8fc8b", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Spacing\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a6ca2e90647ad52086f6ae6ea8c200d87951400", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/7a6ca2e90647ad52086f6ae6ea8c200d87951400", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Get atlas in main check instead of submethod\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3c83a4b676b636fcf2b32c6bea9d5f4cc1adb1e", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/d3c83a4b676b636fcf2b32c6bea9d5f4cc1adb1e", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Add more documentation\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "956239bd345e25a8e2cbc907595b851af4f3e344", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/956239bd345e25a8e2cbc907595b851af4f3e344", "committedDate": "2020-09-09T20:27:59Z", "message": "CommonTagFilters: Move some filters OceanBleedingCheck and WaterWayCheck into a separate file for reuse\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "787c83639fe3deb7754b4bd3997e4e2bdc8b4766", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/787c83639fe3deb7754b4bd3997e4e2bdc8b4766", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: Formatting\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc7de20b6008f2f28a3288698d6e819d6058cc52", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/cc7de20b6008f2f28a3288698d6e819d6058cc52", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: FIXUP: Nitpicks and some simplifications\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acfdbbe60ce22943cb1252d493cbe3b05be77dcd", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/acfdbbe60ce22943cb1252d493cbe3b05be77dcd", "committedDate": "2020-09-09T20:25:29Z", "message": "WaterWayCheck: FIXUP: Nitpicks and some simplifications\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}, "afterCommit": {"oid": "cc7de20b6008f2f28a3288698d6e819d6058cc52", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/cc7de20b6008f2f28a3288698d6e819d6058cc52", "committedDate": "2020-09-09T20:27:59Z", "message": "WaterWayCheck: FIXUP: Nitpicks and some simplifications\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf5f60c31c6d37ea26a38afb727384f40526866a", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/cf5f60c31c6d37ea26a38afb727384f40526866a", "committedDate": "2020-09-09T20:40:54Z", "message": "WaterWayCheck: Ensure that intersecting waterways actually intersect\n\n* Originally, was just getting waterways based off of the bbox of the\n  original waterway\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bab9e932374ae7581a7a902163d73300ef050716", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/bab9e932374ae7581a7a902163d73300ef050716", "committedDate": "2020-09-09T21:18:45Z", "message": "WaterWayCheck: Move flagging logic into separate methods\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NDU4NzQ5", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-485458749", "createdAt": "2020-09-09T23:00:49Z", "commit": {"oid": "bab9e932374ae7581a7a902163d73300ef050716"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56c6042880cd9d65c6d09513adb6b9b85aede9cf", "author": {"user": {"login": "tsmock", "name": "Taylor Smock"}}, "url": "https://github.com/osmlab/atlas-checks/commit/56c6042880cd9d65c6d09513adb6b9b85aede9cf", "committedDate": "2020-09-09T23:28:10Z", "message": "WaterWayCheck: Add comment expounding upon incline check and resolution of data\n\nSigned-off-by: Taylor Smock <tsmock@fb.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NDcyMjAy", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-485472202", "createdAt": "2020-09-09T23:38:59Z", "commit": {"oid": "56c6042880cd9d65c6d09513adb6b9b85aede9cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NDk4OTA5", "url": "https://github.com/osmlab/atlas-checks/pull/332#pullrequestreview-485498909", "createdAt": "2020-09-10T01:06:55Z", "commit": {"oid": "56c6042880cd9d65c6d09513adb6b9b85aede9cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3146, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}