{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4MDQ1NjE1", "number": 5933, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQxMDo0Njo1MFrOEYsFiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQxMDo0Njo1MFrOEYsFiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MzIzNTkyOnYy", "diffSide": "RIGHT", "path": "frameworks/CSharp/aspnetcore/Benchmarks/Data/EfDb.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQxMDo0Njo1MFrOHBJaGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQxNTowNToxOVrOHBLe9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NDc2Mg==", "bodyText": "In this version, you have a couple of issues:\n\nno guarantee that enough distinct numbers will be created to satisfy count\nit does many allocations: some for the Set<T> in Distinct(), some for the temporary Buffer<T> in ToArray() and one for the final array (with a copy).\n\nThe previous implementation does have some allocations implied by OrderBy() but it also has the guarantee of having sufficient elements.\nThat said, both propositions do too many allocations and are not efficient. Instead we can use a simple Fisher-Yates to generate a randomize range in O(n) with only one allocation. See my own implementation as an example.\nvar ids = ShuffleUtility.RandomRange(1, 10000).Take(count);\n\nforeach (int id in ids)\n{\n    // etc.\n}", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5933#discussion_r470964762", "createdAt": "2020-08-15T10:46:50Z", "author": {"login": "Kryptos-FR"}, "path": "frameworks/CSharp/aspnetcore/Benchmarks/Data/EfDb.cs", "diffHunk": "@@ -54,26 +54,25 @@ public async Task<World[]> LoadMultipleQueriesRows(int count)\n         public async Task<World[]> LoadMultipleUpdatesRows(int count)\n         {\n             var results = new World[count];\n-            var random = new Random();\n-            int i = 0;\n+            int currentValue, newValue;\n \n-            var ids = Enumerable.Range(1, 10000).OrderBy(x => random.Next()).Take(count);\n+            var ids = Enumerable.Range(1, 10000).Select(x => _random.Next(1, 10001)).Distinct().Take(count).ToArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b02910cfbfd9760a57755a8a60091308d887cce8"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5ODc3Mg==", "bodyText": "count is 20 at most so enough distinct numbers should be generated, else there may be a problem with Random.Next(). All implementations are required to generate distinct Ids in order to pass test verification, I believe, though it may allow for a margin of error.\nRegarding allocations, there may be a few but I doubt it matters, the database is likely the performance bottleneck.\nFeel free to open a PR, if it really improves rps, great.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5933#discussion_r470998772", "createdAt": "2020-08-15T15:05:19Z", "author": {"login": "n-stefan"}, "path": "frameworks/CSharp/aspnetcore/Benchmarks/Data/EfDb.cs", "diffHunk": "@@ -54,26 +54,25 @@ public async Task<World[]> LoadMultipleQueriesRows(int count)\n         public async Task<World[]> LoadMultipleUpdatesRows(int count)\n         {\n             var results = new World[count];\n-            var random = new Random();\n-            int i = 0;\n+            int currentValue, newValue;\n \n-            var ids = Enumerable.Range(1, 10000).OrderBy(x => random.Next()).Take(count);\n+            var ids = Enumerable.Range(1, 10000).Select(x => _random.Next(1, 10001)).Distinct().Take(count).ToArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NDc2Mg=="}, "originalCommit": {"oid": "b02910cfbfd9760a57755a8a60091308d887cce8"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2596, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}