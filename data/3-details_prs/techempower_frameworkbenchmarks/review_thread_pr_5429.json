{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2ODc0NTc1", "number": 5429, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMzoxMlrODaiSFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjozNTowOFrODais3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTUxMjUyOnYy", "diffSide": "RIGHT", "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMzoxMlrOFhitPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjozMjoyNlrOFhjTSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNTk2NA==", "bodyText": "The JSON serialization needs to happen on every request for this endpoint. Here, it is being serialized when the server starts.\nhttps://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview#json-serialization", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370715964", "createdAt": "2020-01-24T16:13:12Z", "author": {"login": "nbrady-techempower"}, "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" as \"Hello, World!\".ok,\n+    GET / \"json\"      as JsonRouteMessage(\"Hello, World!\").ok,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a73cfb53db6eb6afc0a6652704ab68c214cd211"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNTcwNw==", "bodyText": "ah good catch.  Fixed it!", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370725707", "createdAt": "2020-01-24T16:32:26Z", "author": {"login": "DanSimon"}, "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" as \"Hello, World!\".ok,\n+    GET / \"json\"      as JsonRouteMessage(\"Hello, World!\").ok,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNTk2NA=="}, "originalCommit": {"oid": "0a73cfb53db6eb6afc0a6652704ab68c214cd211"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTU4MTEwOnYy", "diffSide": "RIGHT", "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjozNTowOFrOFhjYSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjo0MDoxNVrOFhjiWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNjk4Ng==", "bodyText": "For the record, this one was fine.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370726986", "createdAt": "2020-01-24T16:35:08Z", "author": {"login": "nbrady-techempower"}, "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" to {_ => \"Hello, World!\".ok},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40bffaa0eaf8d3630e070b7fb9ebe33926a50e42"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyOTU2Mw==", "bodyText": "Good to know, I'll leave it for now as I don't think it will make much of a difference anyway.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370729563", "createdAt": "2020-01-24T16:40:15Z", "author": {"login": "DanSimon"}, "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" to {_ => \"Hello, World!\".ok},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNjk4Ng=="}, "originalCommit": {"oid": "40bffaa0eaf8d3630e070b7fb9ebe33926a50e42"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2742, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}