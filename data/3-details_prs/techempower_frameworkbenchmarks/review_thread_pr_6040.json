{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNjQzMjQ4", "number": 6040, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwMDo1Mzo0NFrOEnygmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwMDo1Mzo0NFrOEnygmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMTU3NDY1OnYy", "diffSide": "RIGHT", "path": "frameworks/Scala/http4s/src/main/scala/http4s/techempower/benchmark/DatabaseService.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwMDo1Mzo0NVrOHYjnmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QxMToxOTozOVrOHYmttw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUxMTQ1MA==", "bodyText": "Shouldn't this be delay? You don't generally use fromFuture with pure", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/6040#discussion_r495511450", "createdAt": "2020-09-27T00:53:45Z", "author": {"login": "Daenyth"}, "path": "frameworks/Scala/http4s/src/main/scala/http4s/techempower/benchmark/DatabaseService.scala", "diffHunk": "@@ -0,0 +1,73 @@\n+package http4s.techempower.benchmark\n+\n+import java.util.concurrent.{Executor, ThreadLocalRandom}\n+\n+import scala.concurrent.{ExecutionContext, ExecutionContextExecutor}\n+import cats.effect.{ContextShift, IO => CatsIO}\n+import cats.syntax.all._\n+import io.getquill._\n+\n+class DatabaseService(ctx: PostgresJAsyncContext[LowerCase.type], executor: Executor)(implicit\n+    cs: ContextShift[CatsIO]\n+) {\n+  implicit val dbExecutionContext: ExecutionContextExecutor = ExecutionContext.fromExecutor(executor)\n+  import ctx._\n+\n+  def close(): CatsIO[Unit] = {\n+    CatsIO(ctx.close())\n+  }\n+\n+  // Provide a random number between 1 and 10000 (inclusive)\n+  private def randomWorldId() =\n+    CatsIO(ThreadLocalRandom.current().nextInt(1, 10001))\n+\n+  // Update the randomNumber field with a random number\n+  def updateRandomNumber(world: World): CatsIO[World] =\n+    for {\n+      randomId <- randomWorldId()\n+    } yield world.copy(randomNumber = randomId)\n+\n+  // Select a World object from the database by ID\n+  def selectWorld(id: Int): CatsIO[World] =\n+    CatsIO.fromFuture(\n+      CatsIO.pure(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e52f37932a02a82810e746941fa3c1b21492cf77"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU2MjE2Nw==", "bodyText": "I wanted the eager evaluation, but that was a bit of premature optimization. Using delay is more correct, as you say, and doesn't seem to make any difference for the benchmark results. Changed, thanks!", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/6040#discussion_r495562167", "createdAt": "2020-09-27T11:19:39Z", "author": {"login": "wjoel"}, "path": "frameworks/Scala/http4s/src/main/scala/http4s/techempower/benchmark/DatabaseService.scala", "diffHunk": "@@ -0,0 +1,73 @@\n+package http4s.techempower.benchmark\n+\n+import java.util.concurrent.{Executor, ThreadLocalRandom}\n+\n+import scala.concurrent.{ExecutionContext, ExecutionContextExecutor}\n+import cats.effect.{ContextShift, IO => CatsIO}\n+import cats.syntax.all._\n+import io.getquill._\n+\n+class DatabaseService(ctx: PostgresJAsyncContext[LowerCase.type], executor: Executor)(implicit\n+    cs: ContextShift[CatsIO]\n+) {\n+  implicit val dbExecutionContext: ExecutionContextExecutor = ExecutionContext.fromExecutor(executor)\n+  import ctx._\n+\n+  def close(): CatsIO[Unit] = {\n+    CatsIO(ctx.close())\n+  }\n+\n+  // Provide a random number between 1 and 10000 (inclusive)\n+  private def randomWorldId() =\n+    CatsIO(ThreadLocalRandom.current().nextInt(1, 10001))\n+\n+  // Update the randomNumber field with a random number\n+  def updateRandomNumber(world: World): CatsIO[World] =\n+    for {\n+      randomId <- randomWorldId()\n+    } yield world.copy(randomNumber = randomId)\n+\n+  // Select a World object from the database by ID\n+  def selectWorld(id: Int): CatsIO[World] =\n+    CatsIO.fromFuture(\n+      CatsIO.pure(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUxMTQ1MA=="}, "originalCommit": {"oid": "e52f37932a02a82810e746941fa3c1b21492cf77"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2566, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}