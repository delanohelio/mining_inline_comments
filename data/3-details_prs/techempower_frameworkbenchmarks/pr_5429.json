{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2ODc0NTc1", "number": 5429, "title": "Add Scala framework: Scalene", "bodyText": "Hi, this adds tests for the Scala framework Scalene.", "createdAt": "2020-01-24T14:55:21Z", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429", "merged": true, "mergeCommit": {"oid": "c116e31351dfe127e80184ac0e3612ca069269bb"}, "closed": true, "closedAt": "2020-01-24T17:57:57Z", "author": {"login": "DanSimon"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9gAbEAH2gAyMzY2ODc0NTc1OjBhNzNjZmI1M2RiNmViNmFmYzBhNjY1MjcwNGFiNjhjMjE0Y2QyMTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9hoPmAFqTM0ODA3NjE4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0a73cfb53db6eb6afc0a6652704ab68c214cd211", "author": {"user": {"login": "DanSimon", "name": "Dan Simon"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/0a73cfb53db6eb6afc0a6652704ab68c214cd211", "committedDate": "2020-01-24T14:41:44Z", "message": "adding scalene framework test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDYxNjE4", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#pullrequestreview-348061618", "createdAt": "2020-01-24T16:13:12Z", "commit": {"oid": "0a73cfb53db6eb6afc0a6652704ab68c214cd211"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMzoxMlrOFhitPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMzoxMlrOFhitPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNTk2NA==", "bodyText": "The JSON serialization needs to happen on every request for this endpoint. Here, it is being serialized when the server starts.\nhttps://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview#json-serialization", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370715964", "createdAt": "2020-01-24T16:13:12Z", "author": {"login": "nbrady-techempower"}, "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" as \"Hello, World!\".ok,\n+    GET / \"json\"      as JsonRouteMessage(\"Hello, World!\").ok,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a73cfb53db6eb6afc0a6652704ab68c214cd211"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40bffaa0eaf8d3630e070b7fb9ebe33926a50e42", "author": {"user": {"login": "DanSimon", "name": "Dan Simon"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/40bffaa0eaf8d3630e070b7fb9ebe33926a50e42", "committedDate": "2020-01-24T16:28:43Z", "message": "use function completion for all routes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDc2MTg3", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#pullrequestreview-348076187", "createdAt": "2020-01-24T16:35:08Z", "commit": {"oid": "40bffaa0eaf8d3630e070b7fb9ebe33926a50e42"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjozNTowOFrOFhjYSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjozNTowOFrOFhjYSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNjk4Ng==", "bodyText": "For the record, this one was fine.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370726986", "createdAt": "2020-01-24T16:35:08Z", "author": {"login": "nbrady-techempower"}, "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" to {_ => \"Hello, World!\".ok},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40bffaa0eaf8d3630e070b7fb9ebe33926a50e42"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3913, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}