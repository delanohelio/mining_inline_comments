{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMDQ0OTAw", "number": 5467, "title": "[add] Implementation of JSON/plaintext for Servicetalk", "bodyText": "Initial implementation of PlainText and JSON tests for Servicetalk framework.\nChanges to reflect Nitesh's implementation suggestions.", "createdAt": "2020-02-04T20:52:48Z", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467", "merged": true, "mergeCommit": {"oid": "81cab7cb586d3b52d61c2398dc43ffa937a7a4ff"}, "closed": true, "closedAt": "2020-02-05T19:55:25Z", "author": {"login": "arthur-techempower"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBHzG_AH2gAyMzcxMDQ0OTAwOjZlOTZjMzA4ZjhhOTY3ZTliMzg4ZGYwYTYxMjEwNTk4MDAwZjFhNmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBbN5EgFqTM1Mzk3NzUwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f", "author": {"user": {"login": "arthur-techempower", "name": "Arthur Ryabtsev"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/6e96c308f8a967e9b388df0a61210598000f1a6f", "committedDate": "2020-02-04T20:45:10Z", "message": "[add] Implementation of JSON/plaintext for Servicetalk"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzQ5MDY0", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353349064", "createdAt": "2020-02-04T22:30:36Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozMDozN1rOFllwXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozMDozN1rOFllwXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2MDIyMw==", "bodyText": "For comments within Java methods, use // comments like this or /* comments like this */, not /** javadoc like this */.  The double asterisk is for javadoc, which can be applied at the class level or member (field or method) level, but not within a method.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374960223", "createdAt": "2020-02-04T22:30:37Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzUwMDAw", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353350000", "createdAt": "2020-02-04T22:32:17Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozMjoxOFrOFllzaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozMjoxOFrOFllzaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2MTAwMA==", "bodyText": "You might as well not have the try and catch then.  Your main method declared throws Exception, so no good comes out of catching this.  The only thing it can do is hide errors from us.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374961000", "createdAt": "2020-02-04T22:32:18Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzUyMzI0", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353352324", "createdAt": "2020-02-04T22:36:32Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozNjozMlrOFll6wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozNjozMlrOFll6wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2Mjg4MA==", "bodyText": "This can return 10001, which is an invalid world id.  Also, you should use ThreadLocalRandom, which shares one Random instance with each thread instead of constructing a new Random instance for every number.  Do something like this instead:  \n  \n    \n      FrameworkBenchmarks/frameworks/Java/undertow/src/main/java/hello/HelloWebServer.java\n    \n    \n         Line 255\n      in\n      f510e94\n    \n    \n    \n    \n\n        \n          \n           return 1 + ThreadLocalRandom.current().nextInt(10000);", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374962880", "createdAt": "2020-02-04T22:36:32Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed\n+        }\n+    }\n+\n+    public static String GetCurrentTime() {\n+        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n+        Date date = new Date();\n+        return formatter.format(date);\n+    }\n+\n+    private static int GetRandomNumber() {\n+        Random random = new Random();\n+        return random.nextInt(10001) + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzUyODA1", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353352805", "createdAt": "2020-02-04T22:37:34Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozNzozNFrOFll8cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjozNzozNFrOFll8cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2MzMxNA==", "bodyText": "The near-universal convention in Java is that methods are lowerCamelCase, not UpperCamelCase.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374963314", "createdAt": "2020-02-04T22:37:34Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed\n+        }\n+    }\n+\n+    public static String GetCurrentTime() {\n+        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n+        Date date = new Date();\n+        return formatter.format(date);\n+    }\n+\n+    private static int GetRandomNumber() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzU2MzMw", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353356330", "createdAt": "2020-02-04T22:44:29Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo0NDoyOVrOFlmIIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo0NDoyOVrOFlmIIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NjMwNg==", "bodyText": "Date and SimpleDateFormat are part of the legacy Java time libraries, which were effectively replaced by the new java.time libraries in Java 8.  Here, what you're looking for is DateTimeFormatter.  Other frameworks show how to use it.  Example:  \n  \n    \n      FrameworkBenchmarks/frameworks/Java/armeria/src/main/java/hello/App.java\n    \n    \n        Lines 25 to 27\n      in\n      b843c9e\n    \n    \n    \n    \n\n        \n          \n           ctx.addAdditionalResponseHeader(HttpHeaderNames.DATE, \n        \n\n        \n          \n                                           DateTimeFormatter.RFC_1123_DATE_TIME.format( \n        \n\n        \n          \n                                                   ZonedDateTime.now(ZoneOffset.UTC))); \n        \n    \n  \n\n\nNote that DateTimeFormatter is immutable, so a single instance can be reused every time you want to format a date.  And luckily there is already a built-in DateTimeFormatter constant that has the format you want here.  One of SimpleDateFormat's problems is that it is mutable -- formatting a date modifies the SimpleDateFormat instance -- so you have to construct a new instance for each date like this.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374966306", "createdAt": "2020-02-04T22:44:29Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed\n+        }\n+    }\n+\n+    public static String GetCurrentTime() {\n+        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n+        Date date = new Date();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzU2OTE2", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353356916", "createdAt": "2020-02-04T22:45:38Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo0NTozOFrOFlmJ4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo0NTozOFrOFlmJ4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2Njc1Mw==", "bodyText": "\"TFB\" --> \"ServiceTalk\".  The convention we use is that theServer header contains the name of the framework.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374966753", "createdAt": "2020-02-04T22:45:38Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzU4NTUz", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353358553", "createdAt": "2020-02-04T22:49:01Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo0OTowMVrOFlmPWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo0OTowMVrOFlmPWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2ODE1NA==", "bodyText": "This <repositories> block looks unnecessary.  Does it build without this?  If so, please remove it.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374968154", "createdAt": "2020-02-04T22:49:01Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/pom.xml", "diffHunk": "@@ -0,0 +1,89 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>com.techempower</groupId>\n+    <artifactId>servicetalk</artifactId>\n+    <version>1.0-SNAPSHOT</version>\n+    <packaging>jar</packaging>\n+\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.servicetalk</groupId>\n+            <artifactId>servicetalk-serialization-api</artifactId>\n+            <version>0.20.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.servicetalk</groupId>\n+            <artifactId>servicetalk-http-api</artifactId>\n+            <version>0.20.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.servicetalk</groupId>\n+            <artifactId>servicetalk-http-netty</artifactId>\n+            <version>0.20.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.servicetalk</groupId>\n+            <artifactId>servicetalk-concurrent-api</artifactId>\n+            <version>0.20.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.servicetalk</groupId>\n+            <artifactId>servicetalk-data-jackson</artifactId>\n+            <version>0.20.0</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.servicetalk</groupId>\n+            <artifactId>servicetalk-transport-netty-internal</artifactId>\n+            <version>0.20.0</version>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <finalName>servicetalk</finalName>\n+        <plugins>\n+            <plugin>\n+                <inherited>true</inherited>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <version>3.8.1</version>\n+                <configuration>\n+                    <source>11</source>\n+                    <target>11</target>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-assembly-plugin</artifactId>\n+                <configuration>\n+                    <archive>\n+                        <manifest>\n+                            <mainClass>servicetalk.Server</mainClass>\n+                        </manifest>\n+                    </archive>\n+                    <descriptorRefs>\n+                        <descriptorRef>jar-with-dependencies</descriptorRef>\n+                    </descriptorRefs>\n+                </configuration>\n+                <executions>\n+                    <execution>\n+                        <id>make-assembly</id>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>single</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <repositories>\n+        <repository>\n+            <id>maven-central</id>\n+            <url>https://repo1.maven.org/maven2/</url>\n+        </repository>\n+    </repositories>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzYxMTIx", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353361121", "createdAt": "2020-02-04T22:54:28Z", "commit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo1NDoyOVrOFlmXcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjo1NDoyOVrOFlmXcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3MDIyNw==", "bodyText": "Usually when we have a bunch of related dependencies that are supposed to all have the same version like this, we extract that version number into a property. Please do that here.\n<properties>\n  <servicetalk.version>0.20.0</servicetalk.version>\n</properties>\n\n<dependencies>\n  <dependency>\n    <groupId>io.servicetalk</groupId>\n    <artifactId>servicetalk-http-api</artifactId>\n    <version>${servicetalk.version}</version>\n  </dependency>\n  ...\n</dependencies>\nOften times projects will extract all dependency version numbers into properties even if each of those version numbers is only referenced once in the pom file.", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374970227", "createdAt": "2020-02-04T22:54:29Z", "author": {"login": "michaelhixson"}, "path": "frameworks/Java/servicetalk/pom.xml", "diffHunk": "@@ -0,0 +1,89 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <groupId>com.techempower</groupId>\n+    <artifactId>servicetalk</artifactId>\n+    <version>1.0-SNAPSHOT</version>\n+    <packaging>jar</packaging>\n+\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.servicetalk</groupId>\n+            <artifactId>servicetalk-serialization-api</artifactId>\n+            <version>0.20.0</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e0ebe390c3d64389ac6234898b7c6c8e7d29d41", "author": {"user": {"login": "arthur-techempower", "name": "Arthur Ryabtsev"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/4e0ebe390c3d64389ac6234898b7c6c8e7d29d41", "committedDate": "2020-02-04T23:01:41Z", "message": "[fix] Comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61dc1f06dc978334168b83945d1f293461f77768", "author": {"user": {"login": "arthur-techempower", "name": "Arthur Ryabtsev"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/61dc1f06dc978334168b83945d1f293461f77768", "committedDate": "2020-02-04T23:02:36Z", "message": "[fix] Remove try/catch block"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "author": {"user": {"login": "arthur-techempower", "name": "Arthur Ryabtsev"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "committedDate": "2020-02-04T23:13:36Z", "message": "[fix] Naming convention + random number"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "author": {"user": {"login": "arthur-techempower", "name": "Arthur Ryabtsev"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/a96d5af23dcb07a109cebd7412efb3330da96fa0", "committedDate": "2020-02-05T00:52:13Z", "message": "[fix] Replace date libraries + Server name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3bb57cbdf65d8387e18d7777e13ece8db456ed5", "author": {"user": {"login": "arthur-techempower", "name": "Arthur Ryabtsev"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/e3bb57cbdf65d8387e18d7777e13ece8db456ed5", "committedDate": "2020-02-05T01:07:58Z", "message": "[fix] version numbers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a782d924b4bc5df0eacbca5e4a04efc18a9348f", "author": {"user": {"login": "arthur-techempower", "name": "Arthur Ryabtsev"}}, "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/6a782d924b4bc5df0eacbca5e4a04efc18a9348f", "committedDate": "2020-02-05T19:11:59Z", "message": "[fix] Clean pom.xml"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTc3NTA2", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#pullrequestreview-353977506", "createdAt": "2020-02-05T19:22:37Z", "commit": {"oid": "6a782d924b4bc5df0eacbca5e4a04efc18a9348f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3894, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}