{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNTc3MTY1", "number": 993, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1NToxOFrOE5Zu7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTowOTo1MFrOE6nLoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4NjI1OTAyOnYy", "diffSide": "RIGHT", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1NToxOFrOHz1oGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNlQxMDo1NToxOFrOHz1oGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExODA0MQ==", "bodyText": "Can extract this Math.min... to a new method:\ngetMaxParallelThreads(Collection servicesToHandle) {\nMath.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n}\nOr even add new method in ForkJoinPoolUtil that handles the collection, or refactor ParallelExecutor to not be so SLP specific", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r524118041", "createdAt": "2020-11-16T10:55:18Z", "author": {"login": "boyan-velinov"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -15,12 +25,42 @@\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n public class CheckServicesToDeleteStep extends CheckForOperationsInProgressStep {\n \n+    @Inject\n+    private ApplicationConfiguration applicationConfiguration;\n+\n     @Override\n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n+    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n-        return servicesToDelete.stream()\n-                               .map(this::buildCloudServiceExtended)\n-                               .collect(Collectors.toList());\n+        CloudControllerClient client = context.getControllerClient();\n+\n+        int maxParallelThreads = Math.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9452fe8f234b89deebc7f2c600837ad289bceab1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTM3Njc2OnYy", "diffSide": "RIGHT", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwNzo1ODoxNVrOH0oNpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwOTo1ODozN1rOH1l1XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0Njg1Mw==", "bodyText": "Instead of using a pair like this, I suggest to create the map of services to service operations first, then do\nmap.values().removeIf(this::isServiceOperationInProgress)\nThis will delete the entry for which the predicate returns true", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r524946853", "createdAt": "2020-11-17T07:58:15Z", "author": {"login": "radito3"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -15,12 +25,42 @@\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n public class CheckServicesToDeleteStep extends CheckForOperationsInProgressStep {\n \n+    @Inject\n+    private ApplicationConfiguration applicationConfiguration;\n+\n     @Override\n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n+    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n-        return servicesToDelete.stream()\n-                               .map(this::buildCloudServiceExtended)\n-                               .collect(Collectors.toList());\n+        CloudControllerClient client = context.getControllerClient();\n+\n+        int maxParallelThreads = Math.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServices(client, servicesToDelete));\n+    }\n+\n+    private Set<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient client, List<String> servicesToDelete) {\n+        return servicesToDelete.parallelStream()\n+                               .map(service -> getExistingService(client, buildCloudServiceExtended(service)))\n+                               .filter(Objects::nonNull)\n+                               .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressState(ProcessContext context, Set<CloudServiceInstanceExtended> existingServices) {\n+        CloudControllerClient client = context.getControllerClient();\n+        int maxParallelThreads = Math.min(existingServices.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () -> getServicesInProgressStateInternal(client, existingServices));\n+    }\n+\n+    private Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressStateInternal(CloudControllerClient client, Set<CloudServiceInstanceExtended> existingServices) {\n+        return existingServices.parallelStream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9452fe8f234b89deebc7f2c600837ad289bceab1"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkxODEzMA==", "bodyText": "I am not really sure this could happen because a map would require \"collecting\" the parallel stream. However, we need the ServiceOperation object to be be calculated in the stream in order to take advantage of the parallelism.", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r525918130", "createdAt": "2020-11-18T09:01:36Z", "author": {"login": "radoslav-d"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -15,12 +25,42 @@\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n public class CheckServicesToDeleteStep extends CheckForOperationsInProgressStep {\n \n+    @Inject\n+    private ApplicationConfiguration applicationConfiguration;\n+\n     @Override\n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n+    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n-        return servicesToDelete.stream()\n-                               .map(this::buildCloudServiceExtended)\n-                               .collect(Collectors.toList());\n+        CloudControllerClient client = context.getControllerClient();\n+\n+        int maxParallelThreads = Math.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServices(client, servicesToDelete));\n+    }\n+\n+    private Set<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient client, List<String> servicesToDelete) {\n+        return servicesToDelete.parallelStream()\n+                               .map(service -> getExistingService(client, buildCloudServiceExtended(service)))\n+                               .filter(Objects::nonNull)\n+                               .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressState(ProcessContext context, Set<CloudServiceInstanceExtended> existingServices) {\n+        CloudControllerClient client = context.getControllerClient();\n+        int maxParallelThreads = Math.min(existingServices.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () -> getServicesInProgressStateInternal(client, existingServices));\n+    }\n+\n+    private Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressStateInternal(CloudControllerClient client, Set<CloudServiceInstanceExtended> existingServices) {\n+        return existingServices.parallelStream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0Njg1Mw=="}, "originalCommit": {"oid": "9452fe8f234b89deebc7f2c600837ad289bceab1"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NjQ0NA==", "bodyText": "It will be collected in parallel", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r525956444", "createdAt": "2020-11-18T09:58:37Z", "author": {"login": "radito3"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -15,12 +25,42 @@\n @Scope(BeanDefinition.SCOPE_PROTOTYPE)\n public class CheckServicesToDeleteStep extends CheckForOperationsInProgressStep {\n \n+    @Inject\n+    private ApplicationConfiguration applicationConfiguration;\n+\n     @Override\n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n+    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n-        return servicesToDelete.stream()\n-                               .map(this::buildCloudServiceExtended)\n-                               .collect(Collectors.toList());\n+        CloudControllerClient client = context.getControllerClient();\n+\n+        int maxParallelThreads = Math.min(servicesToDelete.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServices(client, servicesToDelete));\n+    }\n+\n+    private Set<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient client, List<String> servicesToDelete) {\n+        return servicesToDelete.parallelStream()\n+                               .map(service -> getExistingService(client, buildCloudServiceExtended(service)))\n+                               .filter(Objects::nonNull)\n+                               .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressState(ProcessContext context, Set<CloudServiceInstanceExtended> existingServices) {\n+        CloudControllerClient client = context.getControllerClient();\n+        int maxParallelThreads = Math.min(existingServices.size(), applicationConfiguration.getServiceHandlingMaxParallelThreads());\n+\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () -> getServicesInProgressStateInternal(client, existingServices));\n+    }\n+\n+    private Map<CloudServiceInstanceExtended, ServiceOperation>\n+            getServicesInProgressStateInternal(CloudControllerClient client, Set<CloudServiceInstanceExtended> existingServices) {\n+        return existingServices.parallelStream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk0Njg1Mw=="}, "originalCommit": {"oid": "9452fe8f234b89deebc7f2c600837ad289bceab1"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODc4MzAyOnYy", "diffSide": "RIGHT", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDozNjoyM1rOH1wyJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNToxNjozNFrOH1yt5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNTg0Nw==", "bodyText": "This is intended, as I want to merge the data from both the cached service object and the one coming from CC.\nThe cached one is CloudServiceInstanceExtended and might have additional information than the one returned from CC (which is only CloudServiceInstance).", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526135847", "createdAt": "2020-11-18T14:36:23Z", "author": {"login": "radoslav-d"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "diffHunk": "@@ -30,89 +28,60 @@\n public class CheckForOperationsInProgressStep extends AsyncFlowableStep {\n \n     @Inject\n-    private ServiceOperationGetter serviceOperationGetter;\n+    protected ServiceOperationGetter serviceOperationGetter;\n     @Inject\n     private ServiceProgressReporter serviceProgressReporter;\n \n     @Override\n     protected StepPhase executeAsyncStep(ProcessContext context) {\n-        List<CloudServiceInstanceExtended> servicesToProcess = getServicesToProcess(context);\n-\n-        List<CloudServiceInstanceExtended> existingServices = getExistingServices(context.getControllerClient(), servicesToProcess);\n-        if (existingServices.isEmpty()) {\n-            return StepPhase.DONE;\n-        }\n-\n-        Map<CloudServiceInstanceExtended, ServiceOperation> servicesInProgressState = getServicesInProgressState(context, existingServices);\n-        if (servicesInProgressState.isEmpty()) {\n+        List<CloudServiceInstanceExtended> existingServicesInProgress = getExistingServiceInProgress(context);\n+        if (existingServicesInProgress.isEmpty()) {\n             return StepPhase.DONE;\n         }\n \n         getStepLogger().info(Messages.WAITING_PREVIOUS_OPERATIONS_TO_FINISH);\n \n-        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(servicesInProgressState);\n+        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(existingServicesInProgress);\n         getStepLogger().debug(Messages.SERVICES_IN_PROGRESS, JsonUtil.toJson(servicesOperationTypes, true));\n         context.setVariable(Variables.TRIGGERED_SERVICE_OPERATIONS, servicesOperationTypes);\n \n-        List<CloudServiceInstanceExtended> servicesWithData = getListOfServicesWithData(servicesInProgressState);\n-        context.setVariable(Variables.SERVICES_DATA, servicesWithData);\n+        context.setVariable(Variables.SERVICES_DATA, existingServicesInProgress);\n \n         return StepPhase.POLL;\n     }\n \n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n-        return Collections.singletonList(context.getVariable(Variables.SERVICE_TO_PROCESS));\n-    }\n-\n-    private List<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient cloudControllerClient,\n-                                                                   List<CloudServiceInstanceExtended> servicesToProcess) {\n-        return servicesToProcess.parallelStream()\n-                                .map(service -> getExistingService(cloudControllerClient, service))\n-                                .filter(Objects::nonNull)\n-                                .collect(Collectors.toList());\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {\n+        CloudControllerClient client = context.getControllerClient();\n+        CloudServiceInstanceExtended serviceToProcess = context.getVariable(Variables.SERVICE_TO_PROCESS);\n+        CloudServiceInstanceExtended existingServiceInstance = getExistingService(client, serviceToProcess);\n+        if (existingServiceInstance == null || !isServiceOperationInProgress(existingServiceInstance)) {\n+            return Collections.emptyList();\n+        }\n+        return List.of(existingServiceInstance);\n     }\n \n-    private CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n-                                                            CloudServiceInstanceExtended service) {\n+    protected CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n+                                                              CloudServiceInstanceExtended service) {\n         CloudServiceInstance existingService = cloudControllerClient.getServiceInstance(service.getName(), false);\n         if (existingService != null) {\n             return ImmutableCloudServiceInstanceExtended.builder()\n                                                         .from(service)\n+                                                        .from(existingService)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2MDc2Nw==", "bodyText": "Won't the data from service be overwritten with the data from existingService?", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526160767", "createdAt": "2020-11-18T15:08:05Z", "author": {"login": "radito3"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "diffHunk": "@@ -30,89 +28,60 @@\n public class CheckForOperationsInProgressStep extends AsyncFlowableStep {\n \n     @Inject\n-    private ServiceOperationGetter serviceOperationGetter;\n+    protected ServiceOperationGetter serviceOperationGetter;\n     @Inject\n     private ServiceProgressReporter serviceProgressReporter;\n \n     @Override\n     protected StepPhase executeAsyncStep(ProcessContext context) {\n-        List<CloudServiceInstanceExtended> servicesToProcess = getServicesToProcess(context);\n-\n-        List<CloudServiceInstanceExtended> existingServices = getExistingServices(context.getControllerClient(), servicesToProcess);\n-        if (existingServices.isEmpty()) {\n-            return StepPhase.DONE;\n-        }\n-\n-        Map<CloudServiceInstanceExtended, ServiceOperation> servicesInProgressState = getServicesInProgressState(context, existingServices);\n-        if (servicesInProgressState.isEmpty()) {\n+        List<CloudServiceInstanceExtended> existingServicesInProgress = getExistingServiceInProgress(context);\n+        if (existingServicesInProgress.isEmpty()) {\n             return StepPhase.DONE;\n         }\n \n         getStepLogger().info(Messages.WAITING_PREVIOUS_OPERATIONS_TO_FINISH);\n \n-        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(servicesInProgressState);\n+        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(existingServicesInProgress);\n         getStepLogger().debug(Messages.SERVICES_IN_PROGRESS, JsonUtil.toJson(servicesOperationTypes, true));\n         context.setVariable(Variables.TRIGGERED_SERVICE_OPERATIONS, servicesOperationTypes);\n \n-        List<CloudServiceInstanceExtended> servicesWithData = getListOfServicesWithData(servicesInProgressState);\n-        context.setVariable(Variables.SERVICES_DATA, servicesWithData);\n+        context.setVariable(Variables.SERVICES_DATA, existingServicesInProgress);\n \n         return StepPhase.POLL;\n     }\n \n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n-        return Collections.singletonList(context.getVariable(Variables.SERVICE_TO_PROCESS));\n-    }\n-\n-    private List<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient cloudControllerClient,\n-                                                                   List<CloudServiceInstanceExtended> servicesToProcess) {\n-        return servicesToProcess.parallelStream()\n-                                .map(service -> getExistingService(cloudControllerClient, service))\n-                                .filter(Objects::nonNull)\n-                                .collect(Collectors.toList());\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {\n+        CloudControllerClient client = context.getControllerClient();\n+        CloudServiceInstanceExtended serviceToProcess = context.getVariable(Variables.SERVICE_TO_PROCESS);\n+        CloudServiceInstanceExtended existingServiceInstance = getExistingService(client, serviceToProcess);\n+        if (existingServiceInstance == null || !isServiceOperationInProgress(existingServiceInstance)) {\n+            return Collections.emptyList();\n+        }\n+        return List.of(existingServiceInstance);\n     }\n \n-    private CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n-                                                            CloudServiceInstanceExtended service) {\n+    protected CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n+                                                              CloudServiceInstanceExtended service) {\n         CloudServiceInstance existingService = cloudControllerClient.getServiceInstance(service.getName(), false);\n         if (existingService != null) {\n             return ImmutableCloudServiceInstanceExtended.builder()\n                                                         .from(service)\n+                                                        .from(existingService)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNTg0Nw=="}, "originalCommit": {"oid": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2NzUyNQ==", "bodyText": "That is what is intended", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526167525", "createdAt": "2020-11-18T15:16:34Z", "author": {"login": "radoslav-d"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "diffHunk": "@@ -30,89 +28,60 @@\n public class CheckForOperationsInProgressStep extends AsyncFlowableStep {\n \n     @Inject\n-    private ServiceOperationGetter serviceOperationGetter;\n+    protected ServiceOperationGetter serviceOperationGetter;\n     @Inject\n     private ServiceProgressReporter serviceProgressReporter;\n \n     @Override\n     protected StepPhase executeAsyncStep(ProcessContext context) {\n-        List<CloudServiceInstanceExtended> servicesToProcess = getServicesToProcess(context);\n-\n-        List<CloudServiceInstanceExtended> existingServices = getExistingServices(context.getControllerClient(), servicesToProcess);\n-        if (existingServices.isEmpty()) {\n-            return StepPhase.DONE;\n-        }\n-\n-        Map<CloudServiceInstanceExtended, ServiceOperation> servicesInProgressState = getServicesInProgressState(context, existingServices);\n-        if (servicesInProgressState.isEmpty()) {\n+        List<CloudServiceInstanceExtended> existingServicesInProgress = getExistingServiceInProgress(context);\n+        if (existingServicesInProgress.isEmpty()) {\n             return StepPhase.DONE;\n         }\n \n         getStepLogger().info(Messages.WAITING_PREVIOUS_OPERATIONS_TO_FINISH);\n \n-        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(servicesInProgressState);\n+        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(existingServicesInProgress);\n         getStepLogger().debug(Messages.SERVICES_IN_PROGRESS, JsonUtil.toJson(servicesOperationTypes, true));\n         context.setVariable(Variables.TRIGGERED_SERVICE_OPERATIONS, servicesOperationTypes);\n \n-        List<CloudServiceInstanceExtended> servicesWithData = getListOfServicesWithData(servicesInProgressState);\n-        context.setVariable(Variables.SERVICES_DATA, servicesWithData);\n+        context.setVariable(Variables.SERVICES_DATA, existingServicesInProgress);\n \n         return StepPhase.POLL;\n     }\n \n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n-        return Collections.singletonList(context.getVariable(Variables.SERVICE_TO_PROCESS));\n-    }\n-\n-    private List<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient cloudControllerClient,\n-                                                                   List<CloudServiceInstanceExtended> servicesToProcess) {\n-        return servicesToProcess.parallelStream()\n-                                .map(service -> getExistingService(cloudControllerClient, service))\n-                                .filter(Objects::nonNull)\n-                                .collect(Collectors.toList());\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {\n+        CloudControllerClient client = context.getControllerClient();\n+        CloudServiceInstanceExtended serviceToProcess = context.getVariable(Variables.SERVICE_TO_PROCESS);\n+        CloudServiceInstanceExtended existingServiceInstance = getExistingService(client, serviceToProcess);\n+        if (existingServiceInstance == null || !isServiceOperationInProgress(existingServiceInstance)) {\n+            return Collections.emptyList();\n+        }\n+        return List.of(existingServiceInstance);\n     }\n \n-    private CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n-                                                            CloudServiceInstanceExtended service) {\n+    protected CloudServiceInstanceExtended getExistingService(CloudControllerClient cloudControllerClient,\n+                                                              CloudServiceInstanceExtended service) {\n         CloudServiceInstance existingService = cloudControllerClient.getServiceInstance(service.getName(), false);\n         if (existingService != null) {\n             return ImmutableCloudServiceInstanceExtended.builder()\n                                                         .from(service)\n+                                                        .from(existingService)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNTg0Nw=="}, "originalCommit": {"oid": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODg2Nzk5OnYy", "diffSide": "RIGHT", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo1NDoxMlrOH1xnOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNDo1NDoxMlrOH1xnOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE0OTQzMg==", "bodyText": "The function should be called getExistingServicesInProgress\nbecause it returns multiple services", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526149432", "createdAt": "2020-11-18T14:54:12Z", "author": {"login": "boyan-velinov"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckForOperationsInProgressStep.java", "diffHunk": "@@ -30,89 +28,60 @@\n public class CheckForOperationsInProgressStep extends AsyncFlowableStep {\n \n     @Inject\n-    private ServiceOperationGetter serviceOperationGetter;\n+    protected ServiceOperationGetter serviceOperationGetter;\n     @Inject\n     private ServiceProgressReporter serviceProgressReporter;\n \n     @Override\n     protected StepPhase executeAsyncStep(ProcessContext context) {\n-        List<CloudServiceInstanceExtended> servicesToProcess = getServicesToProcess(context);\n-\n-        List<CloudServiceInstanceExtended> existingServices = getExistingServices(context.getControllerClient(), servicesToProcess);\n-        if (existingServices.isEmpty()) {\n-            return StepPhase.DONE;\n-        }\n-\n-        Map<CloudServiceInstanceExtended, ServiceOperation> servicesInProgressState = getServicesInProgressState(context, existingServices);\n-        if (servicesInProgressState.isEmpty()) {\n+        List<CloudServiceInstanceExtended> existingServicesInProgress = getExistingServiceInProgress(context);\n+        if (existingServicesInProgress.isEmpty()) {\n             return StepPhase.DONE;\n         }\n \n         getStepLogger().info(Messages.WAITING_PREVIOUS_OPERATIONS_TO_FINISH);\n \n-        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(servicesInProgressState);\n+        Map<String, ServiceOperation.Type> servicesOperationTypes = getServicesOperationTypes(existingServicesInProgress);\n         getStepLogger().debug(Messages.SERVICES_IN_PROGRESS, JsonUtil.toJson(servicesOperationTypes, true));\n         context.setVariable(Variables.TRIGGERED_SERVICE_OPERATIONS, servicesOperationTypes);\n \n-        List<CloudServiceInstanceExtended> servicesWithData = getListOfServicesWithData(servicesInProgressState);\n-        context.setVariable(Variables.SERVICES_DATA, servicesWithData);\n+        context.setVariable(Variables.SERVICES_DATA, existingServicesInProgress);\n \n         return StepPhase.POLL;\n     }\n \n-    protected List<CloudServiceInstanceExtended> getServicesToProcess(ProcessContext context) {\n-        return Collections.singletonList(context.getVariable(Variables.SERVICE_TO_PROCESS));\n-    }\n-\n-    private List<CloudServiceInstanceExtended> getExistingServices(CloudControllerClient cloudControllerClient,\n-                                                                   List<CloudServiceInstanceExtended> servicesToProcess) {\n-        return servicesToProcess.parallelStream()\n-                                .map(service -> getExistingService(cloudControllerClient, service))\n-                                .filter(Objects::nonNull)\n-                                .collect(Collectors.toList());\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5ODk0ODE2OnYy", "diffSide": "RIGHT", "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTowOTo1MFrOH1yY_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNTowOTo1MFrOH1yY_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE2MjE3NQ==", "bodyText": "Either this name or doGetExistingServicesInProgress. Both are good but since the name is already long, why make it longer :D", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/993#discussion_r526162175", "createdAt": "2020-11-18T15:09:50Z", "author": {"login": "radito3"}, "path": "multiapps-controller-process/src/main/java/org/cloudfoundry/multiapps/controller/process/steps/CheckServicesToDeleteStep.java", "diffHunk": "@@ -30,35 +26,19 @@\n     private ApplicationConfiguration applicationConfiguration;\n \n     @Override\n-    protected Set<CloudServiceInstanceExtended> getExistingServicesToProcess(ProcessContext context) {\n+    protected List<CloudServiceInstanceExtended> getExistingServiceInProgress(ProcessContext context) {\n         List<String> servicesToDelete = context.getVariable(Variables.SERVICES_TO_DELETE);\n         CloudControllerClient client = context.getControllerClient();\n         int maxParallelThreads = getMaxParallelThreads(servicesToDelete);\n-        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServices(client, servicesToDelete));\n+        return ForkJoinPoolUtil.execute(maxParallelThreads, () ->  getExistingServicesInProgressInternal(client, servicesToDelete));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85de9f5d6f39c6cfc33ea7565c032dd250ca5cea"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 465, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}