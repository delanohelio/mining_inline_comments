{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0OTQ5Mjk5", "number": 909, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwODo0NTo1NlrOEQ84ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwODo0NTo1NlrOEQ84ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjEwMTQ5OnYy", "diffSide": "RIGHT", "path": "com.sap.cloud.lm.sl.cf.web/src/main/java/com/sap/cloud/lm/sl/cf/web/monitoring/FlowableJobExecutorInformation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwODo0NTo1NlrOG1Y3UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwODo1MjowNlrOG1ZGLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzNTA4OA==", "bodyText": "Is this operation expensive enough to justify the cache?", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/909#discussion_r458635088", "createdAt": "2020-07-22T08:45:56Z", "author": {"login": "nictas"}, "path": "com.sap.cloud.lm.sl.cf.web/src/main/java/com/sap/cloud/lm/sl/cf/web/monitoring/FlowableJobExecutorInformation.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.sap.cloud.lm.sl.cf.web.monitoring;\n+\n+import java.time.Instant;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.flowable.job.service.impl.asyncexecutor.DefaultAsyncJobExecutor;\n+\n+@Named\n+public class FlowableJobExecutorInformation {\n+\n+    private static final int CACHE_TIMEOUT_IN_SECONDS = 60;\n+\n+    protected Instant lastUpdateTime;\n+\n+    private DefaultAsyncJobExecutor jobExecutor;\n+\n+    private int currentJobExecutorQueueSize = 0;\n+\n+    @Inject\n+    public FlowableJobExecutorInformation(DefaultAsyncJobExecutor jobExecutor) {\n+        this.jobExecutor = jobExecutor;\n+    }\n+\n+    public int getCurrentJobExecutorQueueSize() {\n+        if (lastUpdateTime == null || isPastCacheTimeout()) {\n+            updateCurrentJobExecutorQueueSize();\n+        }\n+        return currentJobExecutorQueueSize;\n+    }\n+\n+    private boolean isPastCacheTimeout() {\n+        return Instant.now()\n+                      .minusSeconds(CACHE_TIMEOUT_IN_SECONDS)\n+                      .isAfter(lastUpdateTime);\n+    }\n+\n+    private void updateCurrentJobExecutorQueueSize() {\n+        currentJobExecutorQueueSize = jobExecutor.getThreadPoolQueue()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e688a9aa5b6ad9ac63ed48dd2ed523425aa6330"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzODg5NA==", "bodyText": "For every execution of size() method, it obtains lock over blocking queue and this could slow add/remove jobs from queue because of frequent polling of jmx beans from Dynatrace. I have already execute stress tests with cache mechanism and now I will execute without cache.", "url": "https://github.com/cloudfoundry-incubator/multiapps-controller/pull/909#discussion_r458638894", "createdAt": "2020-07-22T08:52:06Z", "author": {"login": "theghost5800"}, "path": "com.sap.cloud.lm.sl.cf.web/src/main/java/com/sap/cloud/lm/sl/cf/web/monitoring/FlowableJobExecutorInformation.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.sap.cloud.lm.sl.cf.web.monitoring;\n+\n+import java.time.Instant;\n+\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n+import org.flowable.job.service.impl.asyncexecutor.DefaultAsyncJobExecutor;\n+\n+@Named\n+public class FlowableJobExecutorInformation {\n+\n+    private static final int CACHE_TIMEOUT_IN_SECONDS = 60;\n+\n+    protected Instant lastUpdateTime;\n+\n+    private DefaultAsyncJobExecutor jobExecutor;\n+\n+    private int currentJobExecutorQueueSize = 0;\n+\n+    @Inject\n+    public FlowableJobExecutorInformation(DefaultAsyncJobExecutor jobExecutor) {\n+        this.jobExecutor = jobExecutor;\n+    }\n+\n+    public int getCurrentJobExecutorQueueSize() {\n+        if (lastUpdateTime == null || isPastCacheTimeout()) {\n+            updateCurrentJobExecutorQueueSize();\n+        }\n+        return currentJobExecutorQueueSize;\n+    }\n+\n+    private boolean isPastCacheTimeout() {\n+        return Instant.now()\n+                      .minusSeconds(CACHE_TIMEOUT_IN_SECONDS)\n+                      .isAfter(lastUpdateTime);\n+    }\n+\n+    private void updateCurrentJobExecutorQueueSize() {\n+        currentJobExecutorQueueSize = jobExecutor.getThreadPoolQueue()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzNTA4OA=="}, "originalCommit": {"oid": "0e688a9aa5b6ad9ac63ed48dd2ed523425aa6330"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 375, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}