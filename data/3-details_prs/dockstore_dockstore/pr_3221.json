{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMjQwNzY3", "number": 3221, "title": "Feature/more trs hookup", "bodyText": "hooked up most V2 final endpoints\n\nour data objects (the richest source of data) are converted to TRS V2 final objects (second richest) are converted to TRS V2 beta objects, are converted to V1 objects\nTODO: initial conversion will need to be more efficient\n\n\nadded tests for V2 final\n\nadded TODO tags where file checksums and Docker checksums should be hooked up\n\n\nclear some LGTM alerts\nremoved a regex on organizations that was breaking openapi validation #1444\n\n\nTODO:\n\nhook up checksums for files, images, some dates @NatalieEO\nrun TRS validator @garyluu\nswitch some UI code that needs to be high performance to GA4GHV20 endpoints", "createdAt": "2020-02-10T16:47:58Z", "url": "https://github.com/dockstore/dockstore/pull/3221", "merged": true, "mergeCommit": {"oid": "f5b29812305713f9074abe65ee492786351ca755"}, "closed": true, "closedAt": "2020-02-11T21:43:01Z", "author": {"login": "denis-yuen"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBtb9AAH2gAyMzczMjQwNzY3OjVjY2NiYWU2ZTBlYzhiYTE5M2UwNThlZGEyMDY2YjljMDdjM2JmNmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDYamjAFqTM1Njk5OTMwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5cccbae6e0ec8ba193e058eda2066b9c07c3bf6f", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/5cccbae6e0ec8ba193e058eda2066b9c07c3bf6f", "committedDate": "2020-02-06T16:36:16Z", "message": "Clear LGTM alerts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "573216f7b300b18c058f3af714b8634ad384f828", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/573216f7b300b18c058f3af714b8634ad384f828", "committedDate": "2020-02-07T20:11:20Z", "message": "Unit tests functional\n\n* Let's see how much is broken for integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b035265e90f337e2d08fd0bb66606c59dee947e7", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/b035265e90f337e2d08fd0bb66606c59dee947e7", "committedDate": "2020-02-07T20:19:50Z", "message": "Merge branch 'develop' into feature/more_trs_hookup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e4b63449f24bad2b7f279fec5d889e045c46d61", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/2e4b63449f24bad2b7f279fec5d889e045c46d61", "committedDate": "2020-02-07T21:07:59Z", "message": "seems to satisfy validator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32849990863a2acb72513a51aa874e77e6b14809", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/32849990863a2acb72513a51aa874e77e6b14809", "committedDate": "2020-02-07T22:54:19Z", "message": "Fix bunch of integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dadf066f977a8576aecea0a55c625b4a7f15c7b", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/7dadf066f977a8576aecea0a55c625b4a7f15c7b", "committedDate": "2020-02-10T16:45:42Z", "message": "Hook up basic tests and mock-out fields to pass\n\n* should pass basic validation with all required fields populated (with\nempty data\n* added lots of TODOs for where things should be hooked up for\nverification, checksums for Docker images, checksums for file\ndescriptors, etc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/6ddf94369d1fbb45b41e711854cd063e61ca91d1", "committedDate": "2020-02-10T19:58:39Z", "message": "Make codacy somewhat happier"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NzIwMDcy", "url": "https://github.com/dockstore/dockstore/pull/3221#pullrequestreview-356720072", "createdAt": "2020-02-11T14:52:35Z", "commit": {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1MjozNVrOFoL9FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNDo1MjozNVrOFoL9FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4MzIyMA==", "bodyText": "\ud83e\udd14", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377683220", "createdAt": "2020-02-11T14:52:35Z", "author": {"login": "agduncan94"}, "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- *    Copyright 2020 OICR\n+ *    Copyright 2017 OICR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b1d9adbdd1265ae97d904e10fb9ed17db5d69d3", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/2b1d9adbdd1265ae97d904e10fb9ed17db5d69d3", "committedDate": "2020-02-11T15:47:21Z", "message": "PR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODMxNDY0", "url": "https://github.com/dockstore/dockstore/pull/3221#pullrequestreview-356831464", "createdAt": "2020-02-11T17:02:09Z", "commit": {"oid": "2b1d9adbdd1265ae97d904e10fb9ed17db5d69d3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2NDI3MjU2", "url": "https://github.com/dockstore/dockstore/pull/3221#pullrequestreview-356427256", "createdAt": "2020-02-11T05:49:13Z", "commit": {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNTo0OToxNFrOFn9_Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQwNTo1NzoyNFrOFn-EsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1NDQwMw==", "bodyText": "I'm confused by this comment -- was expecting some sort of registration check the next line but it just returns unauthorized.", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377454403", "createdAt": "2020-02-11T05:49:14Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -67,58 +117,705 @@ public static void setConfig(DockstoreWebserviceConfiguration config) {\n         ToolsApiServiceImpl.config = config;\n     }\n \n-\n-    @SuppressWarnings(\"checkstyle:ParameterNumber\")\n-    @Override\n-    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n-        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n-        ContainerRequestContext value, Optional<User> user) throws NotFoundException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public Response toolsIdGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, false);\n     }\n \n     @Override\n     public Response toolsIdVersionsGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, true);\n+    }\n+\n+    private Response buildToolResponse(Entry<?, ?> container, String version, boolean returnJustVersions) {\n+        Response response;\n+        if (container == null) {\n+            response = Response.status(Status.NOT_FOUND).build();\n+        } else if (!container.getIsPublished()) {\n+            // check whether this is registered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1NTQxMA==", "bodyText": "Is it possible that more than one version can have the same name? If not, I feel it would a little simpler if if you just did a find on the version; it would be (insignificantly, probably) faster on average, and you wouldn't have to do the get(0) on line 150. OTOH, you'd have to deal with Optional.", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377455410", "createdAt": "2020-02-11T05:55:07Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -67,58 +117,705 @@ public static void setConfig(DockstoreWebserviceConfiguration config) {\n         ToolsApiServiceImpl.config = config;\n     }\n \n-\n-    @SuppressWarnings(\"checkstyle:ParameterNumber\")\n-    @Override\n-    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n-        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n-        ContainerRequestContext value, Optional<User> user) throws NotFoundException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public Response toolsIdGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, false);\n     }\n \n     @Override\n     public Response toolsIdVersionsGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, true);\n+    }\n+\n+    private Response buildToolResponse(Entry<?, ?> container, String version, boolean returnJustVersions) {\n+        Response response;\n+        if (container == null) {\n+            response = Response.status(Status.NOT_FOUND).build();\n+        } else if (!container.getIsPublished()) {\n+            // check whether this is registered\n+            response = Response.status(Status.UNAUTHORIZED).build();\n+        } else {\n+            io.openapi.model.Tool tool = ToolsImplCommon.convertEntryToTool(container, config);\n+            assert (tool != null);\n+            // filter out other versions if we're narrowing to a specific version\n+            if (version != null) {\n+                tool.getVersions().removeIf(v -> !v.getName().equals(version));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1NTc5Mw==", "bodyText": "neither...nor", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377455793", "createdAt": "2020-02-11T05:57:24Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -67,58 +117,705 @@ public static void setConfig(DockstoreWebserviceConfiguration config) {\n         ToolsApiServiceImpl.config = config;\n     }\n \n-\n-    @SuppressWarnings(\"checkstyle:ParameterNumber\")\n-    @Override\n-    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n-        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n-        ContainerRequestContext value, Optional<User> user) throws NotFoundException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public Response toolsIdGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, false);\n     }\n \n     @Override\n     public Response toolsIdVersionsGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, true);\n+    }\n+\n+    private Response buildToolResponse(Entry<?, ?> container, String version, boolean returnJustVersions) {\n+        Response response;\n+        if (container == null) {\n+            response = Response.status(Status.NOT_FOUND).build();\n+        } else if (!container.getIsPublished()) {\n+            // check whether this is registered\n+            response = Response.status(Status.UNAUTHORIZED).build();\n+        } else {\n+            io.openapi.model.Tool tool = ToolsImplCommon.convertEntryToTool(container, config);\n+            assert (tool != null);\n+            // filter out other versions if we're narrowing to a specific version\n+            if (version != null) {\n+                tool.getVersions().removeIf(v -> !v.getName().equals(version));\n+                if (tool.getVersions().size() != 1) {\n+                    response = Response.status(Status.NOT_FOUND).build();\n+                } else {\n+                    response = Response.ok(tool.getVersions().get(0)).build();\n+                }\n+            } else {\n+                if (returnJustVersions) {\n+                    response = Response.ok(tool.getVersions()).build();\n+                } else {\n+                    response = Response.ok(tool).build();\n+                }\n+            }\n+        }\n+        return response;\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdGet(String id, String versionId, SecurityContext securityContext, ContainerRequestContext value,\n         Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        String newVersionId;\n+        try {\n+            newVersionId = URLDecoder.decode(versionId, StandardCharsets.UTF_8.displayName());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(e);\n+        }\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, newVersionId, false);\n+    }\n+\n+    public Entry<?, ?> getEntry(ParsedRegistryID parsedID, Optional<User> user) {\n+        Entry<?, ?> entry;\n+        String entryPath = parsedID.getPath();\n+        String entryName = parsedID.getToolName().isEmpty() ? null : parsedID.getToolName();\n+        if (entryName != null) {\n+            entryPath += \"/\" + parsedID.getToolName();\n+        }\n+        if (parsedID.toolType() == ParsedRegistryID.ToolType.TOOL) {\n+            entry = toolDAO.findByPath(entryPath, user.isEmpty());\n+        } else if (parsedID.toolType() == ParsedRegistryID.ToolType.WORKFLOW) {\n+            entry = workflowDAO.findByPath(entryPath, user.isEmpty(), BioWorkflow.class).orElse(null);\n+        } else if (parsedID.toolType() == ParsedRegistryID.ToolType.SERVICE) {\n+            entry = workflowDAO.findByPath(entryPath, user.isEmpty(), Service.class).orElse(null);\n+        } else {\n+            throw new UnsupportedOperationException(\"Tool type that should not be present found:\" + parsedID.toolType());\n+        }\n+        if (entry != null && entry.getIsPublished()) {\n+            return entry;\n+        }\n+        if (entry != null && user.isPresent()) {\n+            checkUser(user.get(), entry);\n+            return entry;\n+        }\n+        return null;\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdTypeDescriptorGet(String type, String id, String versionId, SecurityContext securityContext,\n         ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        final Optional<DescriptorLanguage.FileType> fileType = DescriptorLanguage.getFileType(type);\n+        if (fileType.isEmpty()) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+        return getFileByToolVersionID(id, versionId, fileType.get(), null,\n+            contextContainsPlainText(value) || StringUtils.containsIgnoreCase(type, \"plain\"), user);\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdTypeDescriptorRelativePathGet(String type, String id, String versionId, String relativePath,\n         SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        if (type == null) {\n+            return Response.status(Status.BAD_REQUEST).build();\n+        }\n+        final Optional<DescriptorLanguage.FileType> fileType = DescriptorLanguage.getFileType(type);\n+        if (fileType.isEmpty()) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+        return getFileByToolVersionID(id, versionId, fileType.get(), relativePath,\n+            contextContainsPlainText(value) || StringUtils.containsIgnoreCase(type, \"plain\"), user);\n+    }\n+\n+    private boolean contextContainsPlainText(ContainerRequestContext value) {\n+        return value.getAcceptableMediaTypes().contains(MediaType.TEXT_PLAIN_TYPE);\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdTypeTestsGet(String type, String id, String versionId, SecurityContext securityContext,\n         ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        if (type == null) {\n+            return Response.status(Status.BAD_REQUEST).build();\n+        }\n+        final Optional<DescriptorLanguage.FileType> fileType = DescriptorLanguage.getFileType(type);\n+        if (fileType.isEmpty()) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+\n+        // The getFileType version never returns *TEST_JSON filetypes.  Linking CWL_TEST_JSON with DOCKSTORE_CWL and etc until solved.\n+        boolean plainTextResponse = contextContainsPlainText(value) || type.toLowerCase().contains(\"plain\");\n+        switch (fileType.get()) {\n+        case CWL_TEST_JSON:\n+        case DOCKSTORE_CWL:\n+            return getFileByToolVersionID(id, versionId, CWL_TEST_JSON, null, plainTextResponse, user);\n+        case WDL_TEST_JSON:\n+        case DOCKSTORE_WDL:\n+            return getFileByToolVersionID(id, versionId, WDL_TEST_JSON, null, plainTextResponse, user);\n+        case NEXTFLOW:\n+        case NEXTFLOW_CONFIG:\n+        case NEXTFLOW_TEST_PARAMS:\n+            return getFileByToolVersionID(id, versionId, NEXTFLOW_TEST_PARAMS, null, plainTextResponse, user);\n+        default:\n+            return Response.status(Status.BAD_REQUEST).build();\n+        }\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdContainerfileGet(String id, String versionId, SecurityContext securityContext,\n         ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        // matching behaviour of the descriptor endpoint\n+        return getFileByToolVersionID(id, versionId, DOCKERFILE, null, contextContainsPlainText(value), user);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:ParameterNumber\", \"checkstyle:MethodLength\"})\n+    @Override\n+    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n+        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n+        ContainerRequestContext value, Optional<User> user) {\n+\n+        final Integer hashcode = new HashCodeBuilder().append(id).append(alias).append(registry).append(organization).append(name)\n+            .append(toolname).append(description).append(author).append(checker).append(offset).append(limit)\n+            .append(user.orElseGet(User::new).getId()).build();\n+        final Optional<Response.ResponseBuilder> trsResponses = trsListener.getTrsResponse(hashcode);\n+        if (trsResponses.isPresent()) {\n+            return trsResponses.get().build();\n+        }\n+\n+        final List<Entry<?, ?>> all = new ArrayList<>();\n+\n+        // short circuit id and alias filters, these are a bit weird because they have a max of one result\n+        if (id != null) {\n+            ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+            Entry<?, ?> entry = getEntry(parsedID, user);\n+            all.add(entry);\n+        } else if (alias != null) {\n+            all.add(toolDAO.getGenericEntryByAlias(alias));\n+        } else {\n+            all.addAll(toolDAO.findAllPublished());\n+            all.addAll(workflowDAO.findAllPublished());\n+            all.sort(Comparator.comparing(Entry::getGitUrl));\n+        }\n+\n+        List<io.openapi.model.Tool> results = new ArrayList<>();\n+        for (Entry<?, ?> c : all) {\n+            // filters just for tools\n+            if (c instanceof Tool) {\n+                Tool tool = (Tool)c;\n+                // check each criteria. This sucks. Can we do this better with reflection? Or should we pre-convert?\n+                if (registry != null && tool.getRegistry() != null && !tool.getRegistry().contains(registry)) {\n+                    continue;\n+                }\n+                if (organization != null && tool.getNamespace() != null && !tool.getNamespace().contains(organization)) {\n+                    continue;\n+                }\n+                if (name != null && tool.getName() != null && !tool.getName().contains(name)) {\n+                    continue;\n+                }\n+                if (toolname != null && tool.getToolname() != null && !tool.getToolname().contains(toolname)) {\n+                    continue;\n+                }\n+                if (checker != null && checker) {\n+                    // tools are never checker workflows\n+                    continue;\n+                }\n+            }\n+            // filters just for tools\n+            if (c instanceof Workflow) {\n+                Workflow workflow = (Workflow)c;\n+                // check each criteria. This sucks. Can we do this better with reflection? Or should we pre-convert?\n+                if (registry != null && workflow.getSourceControl() != null && !workflow.getSourceControl().toString().contains(registry)) {\n+                    continue;\n+                }\n+                if (organization != null && workflow.getOrganization() != null && !workflow.getOrganization().contains(organization)) {\n+                    continue;\n+                }\n+                if (name != null && workflow.getRepository() != null && !workflow.getRepository().contains(name)) {\n+                    continue;\n+                }\n+                if (toolname != null && workflow.getWorkflowName() != null && !workflow.getWorkflowName().contains(toolname)) {\n+                    continue;\n+                }\n+                if (checker != null && workflow.isIsChecker() != checker) {\n+                    continue;\n+                }\n+            }\n+            // common filters between tools and workflows\n+            if (description != null && c.getDescription() != null && !c.getDescription().contains(description)) {\n+                continue;\n+            }\n+            if (author != null && c.getAuthor() != null && !c.getAuthor().contains(author)) {\n+                continue;\n+            }\n+            // if passing, for each container that matches the criteria, convert to standardised format and return\n+            io.openapi.model.Tool tool = ToolsImplCommon.convertEntryToTool(c, config);\n+            if (tool != null) {\n+                results.add(tool);\n+            }\n+        }\n+\n+        final int actualLimit = MoreObjects.firstNonNull(limit, DEFAULT_PAGE_SIZE);\n+\n+        List<List<io.openapi.model.Tool>> pagedResults = Lists.partition(results, actualLimit);\n+        int offsetInteger = 0;\n+        if (offset != null) {\n+            offsetInteger = Integer.parseInt(offset);\n+        }\n+        if (offsetInteger >= pagedResults.size()) {\n+            results = new ArrayList<>();\n+        } else {\n+            results = pagedResults.get(offsetInteger);\n+        }\n+        final Response.ResponseBuilder responseBuilder = Response.ok(results);\n+        responseBuilder.header(\"current_offset\", offset);\n+        responseBuilder.header(\"current_limit\", actualLimit);\n+        try {\n+            int port = config.getExternalConfig().getPort() == null ? -1 : Integer.parseInt(config.getExternalConfig().getPort());\n+            responseBuilder.header(\"self_link\",\n+                new URI(config.getExternalConfig().getScheme(), null, config.getExternalConfig().getHostname(), port,\n+                    ObjectUtils.firstNonNull(config.getExternalConfig().getBasePath(), \"\") + value.getUriInfo().getRequestUri().getPath(),\n+                    value.getUriInfo().getRequestUri().getQuery(), null).normalize().toURL().toString());\n+            // construct links to other pages\n+            List<String> filters = new ArrayList<>();\n+            handleParameter(id, \"id\", filters);\n+            handleParameter(organization, \"organization\", filters);\n+            handleParameter(name, \"name\", filters);\n+            handleParameter(toolname, \"toolname\", filters);\n+            handleParameter(description, \"description\", filters);\n+            handleParameter(author, \"author\", filters);\n+            handleParameter(registry, \"registry\", filters);\n+            handleParameter(String.valueOf(actualLimit), \"limit\", filters);\n+\n+            if (offsetInteger + 1 < pagedResults.size()) {\n+                URI nextPageURI = new URI(config.getExternalConfig().getScheme(), null, config.getExternalConfig().getHostname(), port,\n+                    ObjectUtils.firstNonNull(config.getExternalConfig().getBasePath(), \"\") + DockstoreWebserviceApplication.GA4GH_API_PATH_V2_BETA\n+                        + \"/tools\", Joiner.on('&').join(filters) + \"&offset=\" + (offsetInteger + 1), null).normalize();\n+                responseBuilder.header(\"next_page\", nextPageURI.toURL().toString());\n+            }\n+            URI lastPageURI = new URI(config.getExternalConfig().getScheme(), null, config.getExternalConfig().getHostname(), port,\n+                ObjectUtils.firstNonNull(config.getExternalConfig().getBasePath(), \"\") + DockstoreWebserviceApplication.GA4GH_API_PATH_V2_BETA\n+                    + \"/tools\", Joiner.on('&').join(filters) + \"&offset=\" + (pagedResults.size() - 1), null).normalize();\n+            responseBuilder.header(\"last_page\", lastPageURI.toURL().toString());\n+\n+        } catch (URISyntaxException | MalformedURLException e) {\n+            throw new CustomWebApplicationException(\"Could not construct page links\", HttpStatus.SC_BAD_REQUEST);\n+        }\n+        trsListener.loadTRSResponse(hashcode, responseBuilder);\n+        return responseBuilder.build();\n+    }\n+\n+    private void handleParameter(String parameter, String queryName, List<String> filters) {\n+        if (parameter != null) {\n+            filters.add(queryName + \"=\" + parameter);\n+        }\n+    }\n+\n+    /**\n+     * @param gitUrl       The git formatted url for the repo\n+     * @param reference    the git tag or branch\n+     * @param githubPrefix the prefix for the git formatted url to strip out\n+     * @param builtPrefix  the prefix to use to start the extracted prefix\n+     * @return the prefix to access these files\n+     */\n+    private static String extractHTTPPrefix(String gitUrl, String reference, String githubPrefix, String builtPrefix) {\n+        StringBuilder urlBuilder = new StringBuilder();\n+        urlBuilder.append(builtPrefix);\n+        final String substring = gitUrl.substring(githubPrefix.length(), gitUrl.lastIndexOf(\".git\"));\n+        urlBuilder.append(substring).append(builtPrefix.contains(\"bitbucket.org\") ? \"/raw/\" : '/').append(reference);\n+        return urlBuilder.toString();\n+    }\n+\n+    /**\n+     * @param registryId   registry id\n+     * @param versionIdParam    git reference\n+     * @param type         type of file\n+     * @param relativePath if null, return the primary descriptor, if not null, return a specific file\n+     * @param unwrap       unwrap the file and present the descriptor sans wrapper model\n+     * @return a specific file wrapped in a response\n+     */\n+    private Response getFileByToolVersionID(String registryId, String versionIdParam, DescriptorLanguage.FileType type, String relativePath,\n+        boolean unwrap, Optional<User> user) {\n+\n+        // if a version is provided, get that version, otherwise return the newest\n+        ParsedRegistryID parsedID = new ParsedRegistryID(registryId);\n+        String versionId;\n+        try {\n+            versionId = URLDecoder.decode(versionIdParam, StandardCharsets.UTF_8.displayName());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(e);\n+        }\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+\n+        // check whether this is registered\n+        if (entry == null) {\n+            Response.StatusType status = getExtendedStatus(Status.NOT_FOUND, \"incorrect id\");\n+            return Response.status(status).build();\n+        }\n+\n+        boolean showHiddenVersions = false;\n+        if (user.isPresent() && !AuthenticatedResourceInterface\n+                .userCannotRead(user.get(), entry)) {\n+            showHiddenVersions = true;\n+        }\n+\n+        final io.openapi.model.Tool convertedTool = ToolsImplCommon.convertEntryToTool(entry, config, showHiddenVersions);\n+\n+        String finalVersionId = versionId;\n+        if (convertedTool == null || convertedTool.getVersions() == null) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+        final Optional<ToolVersion> convertedToolVersion = convertedTool.getVersions().stream()\n+            .filter(toolVersion -> toolVersion.getName().equalsIgnoreCase(finalVersionId)).findFirst();\n+        Optional<? extends Version<?>> entryVersion;\n+        if (entry instanceof Tool) {\n+            Tool toolEntry = (Tool)entry;\n+            entryVersion = toolEntry.getWorkflowVersions().stream().filter(toolVersion -> toolVersion.getName().equalsIgnoreCase(finalVersionId))\n+                .findFirst();\n+        } else {\n+            Workflow workflowEntry = (Workflow)entry;\n+            entryVersion = workflowEntry.getWorkflowVersions().stream()\n+                .filter(toolVersion -> toolVersion.getName().equalsIgnoreCase(finalVersionId)).findFirst();\n+        }\n+\n+        if (entryVersion.isEmpty()) {\n+            Response.StatusType status = getExtendedStatus(Status.NOT_FOUND, \"version not found\");\n+            return Response.status(status).build();\n+        }\n+\n+        String urlBuilt;\n+        String gitUrl = entry.getGitUrl();\n+        if (gitUrl.startsWith(GITHUB_PREFIX)) {\n+            urlBuilt = extractHTTPPrefix(gitUrl, entryVersion.get().getReference(), GITHUB_PREFIX, \"https://raw.githubusercontent.com/\");\n+        } else if (gitUrl.startsWith(BITBUCKET_PREFIX)) {\n+            urlBuilt = extractHTTPPrefix(gitUrl, entryVersion.get().getReference(), BITBUCKET_PREFIX, \"https://bitbucket.org/\");\n+        } else {\n+            LOG.error(\"Found a git url neither from BitBucket or GitHub \" + gitUrl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1"}, "originalPosition": 479}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac7a71d3f923d516556327d8ef8628d055727c95", "author": {"user": {"login": "denis-yuen", "name": "Denis Yuen"}}, "url": "https://github.com/dockstore/dockstore/commit/ac7a71d3f923d516556327d8ef8628d055727c95", "committedDate": "2020-02-11T20:27:51Z", "message": "More PR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2OTk5MzA0", "url": "https://github.com/dockstore/dockstore/pull/3221#pullrequestreview-356999304", "createdAt": "2020-02-11T21:14:38Z", "commit": {"oid": "ac7a71d3f923d516556327d8ef8628d055727c95"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1892, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}