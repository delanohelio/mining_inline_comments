{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNzQ5MzAz", "number": 3339, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjoyOTo0MlrODq_rEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjozNzozMlrODq_ykA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDEwMDAxOnYy", "diffSide": "RIGHT", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjoyOTo0MlrOF7Fg2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjo1NjozMlrOF7GJ8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMDYzMw==", "bodyText": "I guess there are few enough services at this point where this is not an issue? I feel like it should eventually be tackled, but I believe you're rewriting the whole thing for 1.9?", "url": "https://github.com/dockstore/dockstore/pull/3339#discussion_r397500633", "createdAt": "2020-03-24T22:29:42Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "diffHunk": "@@ -228,16 +232,110 @@ private String getNDJSON(List<Entry> publishedEntries) {\n      * @return The Elasticsearch object string to be placed into the index\n      * @throws IOException  Mapper problems\n      */\n-    public static JsonNode dockstoreEntryToElasticSearchObject(Entry entry) throws IOException {\n+    public static JsonNode dockstoreEntryToElasticSearchObject(final Entry entry) throws IOException {\n         Set<Version> workflowVersions = entry.getWorkflowVersions();\n         boolean verified = workflowVersions.stream().anyMatch(Version::isVerified);\n         Set<String> verifiedPlatforms = getVerifiedPlatforms(workflowVersions);\n-        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(entry));\n+        Entry detachedEntry = removeIrrelevantProperties(entry);\n+        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(detachedEntry));\n         ((ObjectNode)jsonNode).put(\"verified\", verified);\n         ((ObjectNode)jsonNode).put(\"verified_platforms\", MAPPER.valueToTree(verifiedPlatforms));\n         return jsonNode;\n     }\n \n+    /**\n+     * Remove some stuff that should not be indexed by ES.\n+     * This is not ideal, we should be including things we want indexed, not removing.\n+     * @param entry\n+     */\n+    private static Entry removeIrrelevantProperties(final Entry entry) {\n+        Entry detachedEntry;\n+        if (entry instanceof Tool) {\n+            Tool tool = (Tool) entry;\n+            Tool detachedTool = new Tool();\n+            tool.getWorkflowVersions().forEach(version -> {\n+                Hibernate.initialize(version.getSourceFiles());\n+            });\n+\n+            // These are for facets\n+            detachedTool.setDefaultWdlPath(tool.getDefaultWdlPath());\n+            detachedTool.setDefaultCwlPath(tool.getDefaultCwlPath());\n+            detachedTool.setNamespace(tool.getNamespace());\n+            detachedTool.setRegistry(tool.getRegistry());\n+            detachedTool.setPrivateAccess(tool.isPrivateAccess());\n+\n+            // These are for table\n+            detachedTool.setGitUrl(tool.getGitUrl());\n+            detachedTool.setName(tool.getName());\n+            detachedTool.setToolname(tool.getToolname());\n+            detachedEntry = detachedTool;\n+        } else if (entry instanceof BioWorkflow) {\n+            BioWorkflow bioWorkflow = (BioWorkflow) entry;\n+            BioWorkflow detachedBioWorkflow = new BioWorkflow();\n+            // These are for facets\n+            detachedBioWorkflow.setDescriptorType(bioWorkflow.getDescriptorType());\n+            detachedBioWorkflow.setSourceControl(bioWorkflow.getSourceControl());\n+            detachedBioWorkflow.setOrganization(bioWorkflow.getOrganization());\n+\n+            // These are for table\n+            detachedBioWorkflow.setWorkflowName(bioWorkflow.getWorkflowName());\n+            detachedBioWorkflow.setRepository(bioWorkflow.getRepository());\n+            detachedBioWorkflow.setGitUrl(bioWorkflow.getGitUrl());\n+            detachedEntry = detachedBioWorkflow;\n+        } else {\n+            return entry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd69562caeae5a5fa05b22badbe3dec15438007b"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwNzA3Mw==", "bodyText": "Rewriting in the context of GitHub apps? I don't think that will affect this aspect of things", "url": "https://github.com/dockstore/dockstore/pull/3339#discussion_r397507073", "createdAt": "2020-03-24T22:46:14Z", "author": {"login": "denis-yuen"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "diffHunk": "@@ -228,16 +232,110 @@ private String getNDJSON(List<Entry> publishedEntries) {\n      * @return The Elasticsearch object string to be placed into the index\n      * @throws IOException  Mapper problems\n      */\n-    public static JsonNode dockstoreEntryToElasticSearchObject(Entry entry) throws IOException {\n+    public static JsonNode dockstoreEntryToElasticSearchObject(final Entry entry) throws IOException {\n         Set<Version> workflowVersions = entry.getWorkflowVersions();\n         boolean verified = workflowVersions.stream().anyMatch(Version::isVerified);\n         Set<String> verifiedPlatforms = getVerifiedPlatforms(workflowVersions);\n-        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(entry));\n+        Entry detachedEntry = removeIrrelevantProperties(entry);\n+        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(detachedEntry));\n         ((ObjectNode)jsonNode).put(\"verified\", verified);\n         ((ObjectNode)jsonNode).put(\"verified_platforms\", MAPPER.valueToTree(verifiedPlatforms));\n         return jsonNode;\n     }\n \n+    /**\n+     * Remove some stuff that should not be indexed by ES.\n+     * This is not ideal, we should be including things we want indexed, not removing.\n+     * @param entry\n+     */\n+    private static Entry removeIrrelevantProperties(final Entry entry) {\n+        Entry detachedEntry;\n+        if (entry instanceof Tool) {\n+            Tool tool = (Tool) entry;\n+            Tool detachedTool = new Tool();\n+            tool.getWorkflowVersions().forEach(version -> {\n+                Hibernate.initialize(version.getSourceFiles());\n+            });\n+\n+            // These are for facets\n+            detachedTool.setDefaultWdlPath(tool.getDefaultWdlPath());\n+            detachedTool.setDefaultCwlPath(tool.getDefaultCwlPath());\n+            detachedTool.setNamespace(tool.getNamespace());\n+            detachedTool.setRegistry(tool.getRegistry());\n+            detachedTool.setPrivateAccess(tool.isPrivateAccess());\n+\n+            // These are for table\n+            detachedTool.setGitUrl(tool.getGitUrl());\n+            detachedTool.setName(tool.getName());\n+            detachedTool.setToolname(tool.getToolname());\n+            detachedEntry = detachedTool;\n+        } else if (entry instanceof BioWorkflow) {\n+            BioWorkflow bioWorkflow = (BioWorkflow) entry;\n+            BioWorkflow detachedBioWorkflow = new BioWorkflow();\n+            // These are for facets\n+            detachedBioWorkflow.setDescriptorType(bioWorkflow.getDescriptorType());\n+            detachedBioWorkflow.setSourceControl(bioWorkflow.getSourceControl());\n+            detachedBioWorkflow.setOrganization(bioWorkflow.getOrganization());\n+\n+            // These are for table\n+            detachedBioWorkflow.setWorkflowName(bioWorkflow.getWorkflowName());\n+            detachedBioWorkflow.setRepository(bioWorkflow.getRepository());\n+            detachedBioWorkflow.setGitUrl(bioWorkflow.getGitUrl());\n+            detachedEntry = detachedBioWorkflow;\n+        } else {\n+            return entry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMDYzMw=="}, "originalCommit": {"oid": "fd69562caeae5a5fa05b22badbe3dec15438007b"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMTE1NQ==", "bodyText": "I meant for ES itself -- I thought @garyluu mentioned something about changing the index or indexes. I don't know ES API at all, but it seems like you should be able to index the source files and still not have a huge response when requests are made from the client.", "url": "https://github.com/dockstore/dockstore/pull/3339#discussion_r397511155", "createdAt": "2020-03-24T22:56:32Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "diffHunk": "@@ -228,16 +232,110 @@ private String getNDJSON(List<Entry> publishedEntries) {\n      * @return The Elasticsearch object string to be placed into the index\n      * @throws IOException  Mapper problems\n      */\n-    public static JsonNode dockstoreEntryToElasticSearchObject(Entry entry) throws IOException {\n+    public static JsonNode dockstoreEntryToElasticSearchObject(final Entry entry) throws IOException {\n         Set<Version> workflowVersions = entry.getWorkflowVersions();\n         boolean verified = workflowVersions.stream().anyMatch(Version::isVerified);\n         Set<String> verifiedPlatforms = getVerifiedPlatforms(workflowVersions);\n-        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(entry));\n+        Entry detachedEntry = removeIrrelevantProperties(entry);\n+        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(detachedEntry));\n         ((ObjectNode)jsonNode).put(\"verified\", verified);\n         ((ObjectNode)jsonNode).put(\"verified_platforms\", MAPPER.valueToTree(verifiedPlatforms));\n         return jsonNode;\n     }\n \n+    /**\n+     * Remove some stuff that should not be indexed by ES.\n+     * This is not ideal, we should be including things we want indexed, not removing.\n+     * @param entry\n+     */\n+    private static Entry removeIrrelevantProperties(final Entry entry) {\n+        Entry detachedEntry;\n+        if (entry instanceof Tool) {\n+            Tool tool = (Tool) entry;\n+            Tool detachedTool = new Tool();\n+            tool.getWorkflowVersions().forEach(version -> {\n+                Hibernate.initialize(version.getSourceFiles());\n+            });\n+\n+            // These are for facets\n+            detachedTool.setDefaultWdlPath(tool.getDefaultWdlPath());\n+            detachedTool.setDefaultCwlPath(tool.getDefaultCwlPath());\n+            detachedTool.setNamespace(tool.getNamespace());\n+            detachedTool.setRegistry(tool.getRegistry());\n+            detachedTool.setPrivateAccess(tool.isPrivateAccess());\n+\n+            // These are for table\n+            detachedTool.setGitUrl(tool.getGitUrl());\n+            detachedTool.setName(tool.getName());\n+            detachedTool.setToolname(tool.getToolname());\n+            detachedEntry = detachedTool;\n+        } else if (entry instanceof BioWorkflow) {\n+            BioWorkflow bioWorkflow = (BioWorkflow) entry;\n+            BioWorkflow detachedBioWorkflow = new BioWorkflow();\n+            // These are for facets\n+            detachedBioWorkflow.setDescriptorType(bioWorkflow.getDescriptorType());\n+            detachedBioWorkflow.setSourceControl(bioWorkflow.getSourceControl());\n+            detachedBioWorkflow.setOrganization(bioWorkflow.getOrganization());\n+\n+            // These are for table\n+            detachedBioWorkflow.setWorkflowName(bioWorkflow.getWorkflowName());\n+            detachedBioWorkflow.setRepository(bioWorkflow.getRepository());\n+            detachedBioWorkflow.setGitUrl(bioWorkflow.getGitUrl());\n+            detachedEntry = detachedBioWorkflow;\n+        } else {\n+            return entry;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMDYzMw=="}, "originalCommit": {"oid": "fd69562caeae5a5fa05b22badbe3dec15438007b"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDEwMzA1OnYy", "diffSide": "RIGHT", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjozMDo1OFrOF7Fiwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjo1OToyNlrOF7GOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMTEyMg==", "bodyText": "How many workflows/tools is this an issue for?", "url": "https://github.com/dockstore/dockstore/pull/3339#discussion_r397501122", "createdAt": "2020-03-24T22:30:58Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "diffHunk": "@@ -228,16 +232,110 @@ private String getNDJSON(List<Entry> publishedEntries) {\n      * @return The Elasticsearch object string to be placed into the index\n      * @throws IOException  Mapper problems\n      */\n-    public static JsonNode dockstoreEntryToElasticSearchObject(Entry entry) throws IOException {\n+    public static JsonNode dockstoreEntryToElasticSearchObject(final Entry entry) throws IOException {\n         Set<Version> workflowVersions = entry.getWorkflowVersions();\n         boolean verified = workflowVersions.stream().anyMatch(Version::isVerified);\n         Set<String> verifiedPlatforms = getVerifiedPlatforms(workflowVersions);\n-        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(entry));\n+        Entry detachedEntry = removeIrrelevantProperties(entry);\n+        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(detachedEntry));\n         ((ObjectNode)jsonNode).put(\"verified\", verified);\n         ((ObjectNode)jsonNode).put(\"verified_platforms\", MAPPER.valueToTree(verifiedPlatforms));\n         return jsonNode;\n     }\n \n+    /**\n+     * Remove some stuff that should not be indexed by ES.\n+     * This is not ideal, we should be including things we want indexed, not removing.\n+     * @param entry\n+     */\n+    private static Entry removeIrrelevantProperties(final Entry entry) {\n+        Entry detachedEntry;\n+        if (entry instanceof Tool) {\n+            Tool tool = (Tool) entry;\n+            Tool detachedTool = new Tool();\n+            tool.getWorkflowVersions().forEach(version -> {\n+                Hibernate.initialize(version.getSourceFiles());\n+            });\n+\n+            // These are for facets\n+            detachedTool.setDefaultWdlPath(tool.getDefaultWdlPath());\n+            detachedTool.setDefaultCwlPath(tool.getDefaultCwlPath());\n+            detachedTool.setNamespace(tool.getNamespace());\n+            detachedTool.setRegistry(tool.getRegistry());\n+            detachedTool.setPrivateAccess(tool.isPrivateAccess());\n+\n+            // These are for table\n+            detachedTool.setGitUrl(tool.getGitUrl());\n+            detachedTool.setName(tool.getName());\n+            detachedTool.setToolname(tool.getToolname());\n+            detachedEntry = detachedTool;\n+        } else if (entry instanceof BioWorkflow) {\n+            BioWorkflow bioWorkflow = (BioWorkflow) entry;\n+            BioWorkflow detachedBioWorkflow = new BioWorkflow();\n+            // These are for facets\n+            detachedBioWorkflow.setDescriptorType(bioWorkflow.getDescriptorType());\n+            detachedBioWorkflow.setSourceControl(bioWorkflow.getSourceControl());\n+            detachedBioWorkflow.setOrganization(bioWorkflow.getOrganization());\n+\n+            // These are for table\n+            detachedBioWorkflow.setWorkflowName(bioWorkflow.getWorkflowName());\n+            detachedBioWorkflow.setRepository(bioWorkflow.getRepository());\n+            detachedBioWorkflow.setGitUrl(bioWorkflow.getGitUrl());\n+            detachedEntry = detachedBioWorkflow;\n+        } else {\n+            return entry;\n+        }\n+        detachedEntry.setDescription(entry.getDescription());\n+        detachedEntry.setAuthor(entry.getAuthor());\n+        detachedEntry.setAliases(entry.getAliases());\n+        detachedEntry.setLabels((SortedSet<Label>)entry.getLabels());\n+        detachedEntry.setCheckerWorkflow(entry.getCheckerWorkflow());\n+        Set<Version> detachedVersions = cloneWorkflowVersion(entry.getWorkflowVersions());\n+        detachedEntry.setWorkflowVersions(detachedVersions);\n+        entry.getStarredUsers().forEach(user -> detachedEntry.addStarredUser((User)user));\n+        String defaultVersion = entry.getDefaultVersion();\n+        if (defaultVersion != null) {\n+            boolean saneDefaultVersion = detachedVersions.stream().anyMatch(version -> defaultVersion.equals(version.getName()) || defaultVersion.equals(version.getReference()));\n+            if (saneDefaultVersion) {\n+                // If the tool/workflow has a default version, only keep the default version (and its sourcefile contents and description)\n+                Set<Version> newWorkflowVersions = detachedEntry.getWorkflowVersions();\n+                newWorkflowVersions.forEach(version -> {\n+                    if (!defaultVersion.equals(version.getReference()) && !defaultVersion.equals(version.getName())) {\n+                        version.setDescriptionAndDescriptionSource(null, null);\n+                        SortedSet<SourceFile> sourceFiles = version.getSourceFiles();\n+                        sourceFiles.forEach(sourceFile -> sourceFile.setContent(\"\"));\n+                    }\n+                });\n+            } else {\n+                LOGGER.error(\"Entry has a default version that doesn't exist: \" + entry.getEntryPath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd69562caeae5a5fa05b22badbe3dec15438007b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMjI3Nw==", "bodyText": "an issue was made for this already", "url": "https://github.com/dockstore/dockstore/pull/3339#discussion_r397512277", "createdAt": "2020-03-24T22:59:26Z", "author": {"login": "garyluu"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "diffHunk": "@@ -228,16 +232,110 @@ private String getNDJSON(List<Entry> publishedEntries) {\n      * @return The Elasticsearch object string to be placed into the index\n      * @throws IOException  Mapper problems\n      */\n-    public static JsonNode dockstoreEntryToElasticSearchObject(Entry entry) throws IOException {\n+    public static JsonNode dockstoreEntryToElasticSearchObject(final Entry entry) throws IOException {\n         Set<Version> workflowVersions = entry.getWorkflowVersions();\n         boolean verified = workflowVersions.stream().anyMatch(Version::isVerified);\n         Set<String> verifiedPlatforms = getVerifiedPlatforms(workflowVersions);\n-        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(entry));\n+        Entry detachedEntry = removeIrrelevantProperties(entry);\n+        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(detachedEntry));\n         ((ObjectNode)jsonNode).put(\"verified\", verified);\n         ((ObjectNode)jsonNode).put(\"verified_platforms\", MAPPER.valueToTree(verifiedPlatforms));\n         return jsonNode;\n     }\n \n+    /**\n+     * Remove some stuff that should not be indexed by ES.\n+     * This is not ideal, we should be including things we want indexed, not removing.\n+     * @param entry\n+     */\n+    private static Entry removeIrrelevantProperties(final Entry entry) {\n+        Entry detachedEntry;\n+        if (entry instanceof Tool) {\n+            Tool tool = (Tool) entry;\n+            Tool detachedTool = new Tool();\n+            tool.getWorkflowVersions().forEach(version -> {\n+                Hibernate.initialize(version.getSourceFiles());\n+            });\n+\n+            // These are for facets\n+            detachedTool.setDefaultWdlPath(tool.getDefaultWdlPath());\n+            detachedTool.setDefaultCwlPath(tool.getDefaultCwlPath());\n+            detachedTool.setNamespace(tool.getNamespace());\n+            detachedTool.setRegistry(tool.getRegistry());\n+            detachedTool.setPrivateAccess(tool.isPrivateAccess());\n+\n+            // These are for table\n+            detachedTool.setGitUrl(tool.getGitUrl());\n+            detachedTool.setName(tool.getName());\n+            detachedTool.setToolname(tool.getToolname());\n+            detachedEntry = detachedTool;\n+        } else if (entry instanceof BioWorkflow) {\n+            BioWorkflow bioWorkflow = (BioWorkflow) entry;\n+            BioWorkflow detachedBioWorkflow = new BioWorkflow();\n+            // These are for facets\n+            detachedBioWorkflow.setDescriptorType(bioWorkflow.getDescriptorType());\n+            detachedBioWorkflow.setSourceControl(bioWorkflow.getSourceControl());\n+            detachedBioWorkflow.setOrganization(bioWorkflow.getOrganization());\n+\n+            // These are for table\n+            detachedBioWorkflow.setWorkflowName(bioWorkflow.getWorkflowName());\n+            detachedBioWorkflow.setRepository(bioWorkflow.getRepository());\n+            detachedBioWorkflow.setGitUrl(bioWorkflow.getGitUrl());\n+            detachedEntry = detachedBioWorkflow;\n+        } else {\n+            return entry;\n+        }\n+        detachedEntry.setDescription(entry.getDescription());\n+        detachedEntry.setAuthor(entry.getAuthor());\n+        detachedEntry.setAliases(entry.getAliases());\n+        detachedEntry.setLabels((SortedSet<Label>)entry.getLabels());\n+        detachedEntry.setCheckerWorkflow(entry.getCheckerWorkflow());\n+        Set<Version> detachedVersions = cloneWorkflowVersion(entry.getWorkflowVersions());\n+        detachedEntry.setWorkflowVersions(detachedVersions);\n+        entry.getStarredUsers().forEach(user -> detachedEntry.addStarredUser((User)user));\n+        String defaultVersion = entry.getDefaultVersion();\n+        if (defaultVersion != null) {\n+            boolean saneDefaultVersion = detachedVersions.stream().anyMatch(version -> defaultVersion.equals(version.getName()) || defaultVersion.equals(version.getReference()));\n+            if (saneDefaultVersion) {\n+                // If the tool/workflow has a default version, only keep the default version (and its sourcefile contents and description)\n+                Set<Version> newWorkflowVersions = detachedEntry.getWorkflowVersions();\n+                newWorkflowVersions.forEach(version -> {\n+                    if (!defaultVersion.equals(version.getReference()) && !defaultVersion.equals(version.getName())) {\n+                        version.setDescriptionAndDescriptionSource(null, null);\n+                        SortedSet<SourceFile> sourceFiles = version.getSourceFiles();\n+                        sourceFiles.forEach(sourceFile -> sourceFile.setContent(\"\"));\n+                    }\n+                });\n+            } else {\n+                LOGGER.error(\"Entry has a default version that doesn't exist: \" + entry.getEntryPath());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMTEyMg=="}, "originalCommit": {"oid": "fd69562caeae5a5fa05b22badbe3dec15438007b"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDExOTIwOnYy", "diffSide": "RIGHT", "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjozNzozMlrOF7FszQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjozNzozMlrOF7FszQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUwMzY5Mw==", "bodyText": "cloneWorkflowVersions (but don't change it)", "url": "https://github.com/dockstore/dockstore/pull/3339#discussion_r397503693", "createdAt": "2020-03-24T22:37:32Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/helpers/statelisteners/ElasticListener.java", "diffHunk": "@@ -228,16 +232,110 @@ private String getNDJSON(List<Entry> publishedEntries) {\n      * @return The Elasticsearch object string to be placed into the index\n      * @throws IOException  Mapper problems\n      */\n-    public static JsonNode dockstoreEntryToElasticSearchObject(Entry entry) throws IOException {\n+    public static JsonNode dockstoreEntryToElasticSearchObject(final Entry entry) throws IOException {\n         Set<Version> workflowVersions = entry.getWorkflowVersions();\n         boolean verified = workflowVersions.stream().anyMatch(Version::isVerified);\n         Set<String> verifiedPlatforms = getVerifiedPlatforms(workflowVersions);\n-        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(entry));\n+        Entry detachedEntry = removeIrrelevantProperties(entry);\n+        JsonNode jsonNode = MAPPER.readTree(MAPPER.writeValueAsString(detachedEntry));\n         ((ObjectNode)jsonNode).put(\"verified\", verified);\n         ((ObjectNode)jsonNode).put(\"verified_platforms\", MAPPER.valueToTree(verifiedPlatforms));\n         return jsonNode;\n     }\n \n+    /**\n+     * Remove some stuff that should not be indexed by ES.\n+     * This is not ideal, we should be including things we want indexed, not removing.\n+     * @param entry\n+     */\n+    private static Entry removeIrrelevantProperties(final Entry entry) {\n+        Entry detachedEntry;\n+        if (entry instanceof Tool) {\n+            Tool tool = (Tool) entry;\n+            Tool detachedTool = new Tool();\n+            tool.getWorkflowVersions().forEach(version -> {\n+                Hibernate.initialize(version.getSourceFiles());\n+            });\n+\n+            // These are for facets\n+            detachedTool.setDefaultWdlPath(tool.getDefaultWdlPath());\n+            detachedTool.setDefaultCwlPath(tool.getDefaultCwlPath());\n+            detachedTool.setNamespace(tool.getNamespace());\n+            detachedTool.setRegistry(tool.getRegistry());\n+            detachedTool.setPrivateAccess(tool.isPrivateAccess());\n+\n+            // These are for table\n+            detachedTool.setGitUrl(tool.getGitUrl());\n+            detachedTool.setName(tool.getName());\n+            detachedTool.setToolname(tool.getToolname());\n+            detachedEntry = detachedTool;\n+        } else if (entry instanceof BioWorkflow) {\n+            BioWorkflow bioWorkflow = (BioWorkflow) entry;\n+            BioWorkflow detachedBioWorkflow = new BioWorkflow();\n+            // These are for facets\n+            detachedBioWorkflow.setDescriptorType(bioWorkflow.getDescriptorType());\n+            detachedBioWorkflow.setSourceControl(bioWorkflow.getSourceControl());\n+            detachedBioWorkflow.setOrganization(bioWorkflow.getOrganization());\n+\n+            // These are for table\n+            detachedBioWorkflow.setWorkflowName(bioWorkflow.getWorkflowName());\n+            detachedBioWorkflow.setRepository(bioWorkflow.getRepository());\n+            detachedBioWorkflow.setGitUrl(bioWorkflow.getGitUrl());\n+            detachedEntry = detachedBioWorkflow;\n+        } else {\n+            return entry;\n+        }\n+        detachedEntry.setDescription(entry.getDescription());\n+        detachedEntry.setAuthor(entry.getAuthor());\n+        detachedEntry.setAliases(entry.getAliases());\n+        detachedEntry.setLabels((SortedSet<Label>)entry.getLabels());\n+        detachedEntry.setCheckerWorkflow(entry.getCheckerWorkflow());\n+        Set<Version> detachedVersions = cloneWorkflowVersion(entry.getWorkflowVersions());\n+        detachedEntry.setWorkflowVersions(detachedVersions);\n+        entry.getStarredUsers().forEach(user -> detachedEntry.addStarredUser((User)user));\n+        String defaultVersion = entry.getDefaultVersion();\n+        if (defaultVersion != null) {\n+            boolean saneDefaultVersion = detachedVersions.stream().anyMatch(version -> defaultVersion.equals(version.getName()) || defaultVersion.equals(version.getReference()));\n+            if (saneDefaultVersion) {\n+                // If the tool/workflow has a default version, only keep the default version (and its sourcefile contents and description)\n+                Set<Version> newWorkflowVersions = detachedEntry.getWorkflowVersions();\n+                newWorkflowVersions.forEach(version -> {\n+                    if (!defaultVersion.equals(version.getReference()) && !defaultVersion.equals(version.getName())) {\n+                        version.setDescriptionAndDescriptionSource(null, null);\n+                        SortedSet<SourceFile> sourceFiles = version.getSourceFiles();\n+                        sourceFiles.forEach(sourceFile -> sourceFile.setContent(\"\"));\n+                    }\n+                });\n+            } else {\n+                LOGGER.error(\"Entry has a default version that doesn't exist: \" + entry.getEntryPath());\n+            }\n+        }\n+        return detachedEntry;\n+    }\n+\n+    private static Set<Version> cloneWorkflowVersion(final Set<Version> originalWorkflowVersions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd69562caeae5a5fa05b22badbe3dec15438007b"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3069, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}