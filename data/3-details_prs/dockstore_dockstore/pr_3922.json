{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NjQ2ODcw", "number": 3922, "title": "Feature/3810/workflowToolList500", "bodyText": "Addresses:\nhttps://ucsc-cgl.atlassian.net/browse/DOCK-1582 (Caused by syntax error in WDL descriptor)\nhttps://ucsc-cgl.atlassian.net/browse/DOCK-1626 (Caused by syntax error in CWL descriptor)\nBoth 500s occurred when there was a syntax error in the provided workflow descriptors.\nNow throws 400s when syntax errors and/or invalid fields in descriptors are present. For CWL descriptors, the 400s are thrown in place of returning empty Optionals.\nReviewers: hiding whitespace changes is helpful.", "createdAt": "2020-11-10T17:25:03Z", "url": "https://github.com/dockstore/dockstore/pull/3922", "merged": true, "mergeCommit": {"oid": "1c37a87a93799d0dfa72bc0125fb9a5e2189e1c9"}, "closed": true, "closedAt": "2020-11-20T20:28:01Z", "author": {"login": "Richard-Hansen"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABda-TgOgH2gAyNTE4NjQ2ODcwOjhkMTlmZGRiZjY0Mzg1YzhlZWM2ZmY0NTY5NzJkM2FjMzEzMGRlMWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdedVsFAFqTUzNTc1MzA3Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8d19fddbf64385c8eec6ff456972d3ac3130de1d", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/8d19fddbf64385c8eec6ff456972d3ac3130de1d", "committedDate": "2020-11-10T00:34:41Z", "message": "workflow tools 500 errors due to parsing issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94ba5772dfc8184994d8726ebe6d92b54bedf280", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/94ba5772dfc8184994d8726ebe6d92b54bedf280", "committedDate": "2020-11-10T16:55:49Z", "message": "Updated comment to be more accurate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbcf1d0171a929a0938cdf8a0713be0897ade138", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/dbcf1d0171a929a0938cdf8a0713be0897ade138", "committedDate": "2020-11-10T17:56:13Z", "message": "Modified so CWL and WDL parsing errors are handled equivalently"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NTI3MjU3", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-527527257", "createdAt": "2020-11-10T19:13:27Z", "commit": {"oid": "dbcf1d0171a929a0938cdf8a0713be0897ade138"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxMzoyN1rOHwr0UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxMzoyN1rOHwr0UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYwMQ==", "bodyText": "As you suggested in your PR description, I think this should be a 400 error.", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r520811601", "createdAt": "2020-11-10T19:13:27Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +427,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError e) {\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbcf1d0171a929a0938cdf8a0713be0897ade138"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83dd20049283fbef0282a564f4369066c39c7ffc", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/83dd20049283fbef0282a564f4369066c39c7ffc", "committedDate": "2020-11-11T00:11:26Z", "message": "WDLhandler throws 400 when provided a descriptor with syntax errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b10140352b8ec791e84051ecaf5bc6378a2d428", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/7b10140352b8ec791e84051ecaf5bc6378a2d428", "committedDate": "2020-11-12T17:52:56Z", "message": "Added descriptive 400s to content parsing of CWL/WDL descriptors. Added testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a35ba1d6c4d3538479636d65c79d5d0cabbf486", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/6a35ba1d6c4d3538479636d65c79d5d0cabbf486", "committedDate": "2020-11-12T18:20:13Z", "message": "Moved testing resources to correct directory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33f9f15787b809228f22b7fa27720a4698d0a369", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/33f9f15787b809228f22b7fa27720a4698d0a369", "committedDate": "2020-11-12T19:19:24Z", "message": "style fixes, added newline to end of test files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c6faaea254c9d141b1bd28b235f559129bab58f", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/5c6faaea254c9d141b1bd28b235f559129bab58f", "committedDate": "2020-11-12T21:37:24Z", "message": "Added test case for invalid secondary file specification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/a2b130262fa7f033814d101bfe8573a4dc3f685e", "committedDate": "2020-11-12T21:52:32Z", "message": "Added newline to end of file"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NjA0MDE3", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-529604017", "createdAt": "2020-11-13T00:09:38Z", "commit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDowOTozOFrOHyUGgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxMTozOVrOHyUJBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDE5NA==", "bodyText": "put Assert.fail(\"blah blah\") under this to be certain it actually had an exception. same with other places", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522520194", "createdAt": "2020-11-13T00:09:38Z", "author": {"login": "garyluu"}, "path": "dockstore-webservice/src/test/java/io/dockstore/webservice/languages/CWLHandlerTest.java", "diffHunk": "@@ -101,4 +105,58 @@ public void testURLFromEntry() {\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar\", toolDAO));\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar:1\", toolDAO));\n     }\n+\n+    @Test\n+    public void testGetContentWithMalformedDescriptors() throws IOException {\n+        CWLHandler cwlHandler = new CWLHandler();\n+\n+        // create and mock parameters for getContent()\n+        final Set<SourceFile> emptySet = Collections.emptySet();\n+        final ToolDAO toolDAO = Mockito.mock(ToolDAO.class);\n+        when(toolDAO.findAllByPath(Mockito.anyString(), Mockito.anyBoolean())).thenReturn(null);\n+\n+        // expect parsing error\n+        File cwlFile = new File(ResourceHelpers.resourceFilePath(\"brokenCWL.cwl\"));\n+        try {\n+            cwlHandler.getContent(\"/brokenCWL.cwl\", FileUtils.readFileToString(cwlFile, StandardCharsets.UTF_8), emptySet,\n+                LanguageHandlerInterface.Type.TOOLS, toolDAO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDM0Nw==", "bodyText": "swap parameters, it's assertEquals(expected, actual).  Here and other places", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522520347", "createdAt": "2020-11-13T00:10:08Z", "author": {"login": "garyluu"}, "path": "dockstore-webservice/src/test/java/io/dockstore/webservice/languages/CWLHandlerTest.java", "diffHunk": "@@ -101,4 +105,58 @@ public void testURLFromEntry() {\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar\", toolDAO));\n         Assert.assertEquals(\"https://www.dockstore.org/containers/registry.hub.docker.com/foo/bar\", handler.getURLFromEntry(\"foo/bar:1\", toolDAO));\n     }\n+\n+    @Test\n+    public void testGetContentWithMalformedDescriptors() throws IOException {\n+        CWLHandler cwlHandler = new CWLHandler();\n+\n+        // create and mock parameters for getContent()\n+        final Set<SourceFile> emptySet = Collections.emptySet();\n+        final ToolDAO toolDAO = Mockito.mock(ToolDAO.class);\n+        when(toolDAO.findAllByPath(Mockito.anyString(), Mockito.anyBoolean())).thenReturn(null);\n+\n+        // expect parsing error\n+        File cwlFile = new File(ResourceHelpers.resourceFilePath(\"brokenCWL.cwl\"));\n+        try {\n+            cwlHandler.getContent(\"/brokenCWL.cwl\", FileUtils.readFileToString(cwlFile, StandardCharsets.UTF_8), emptySet,\n+                LanguageHandlerInterface.Type.TOOLS, toolDAO);\n+        } catch (CustomWebApplicationException e) {\n+            Assert.assertEquals(e.getResponse().getStatus(), 400);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDY0Nw==", "bodyText": "just in case, change to something more ridiculous like 9001.9001", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522520647", "createdAt": "2020-11-13T00:11:00Z", "author": {"login": "garyluu"}, "path": "dockstore-webservice/src/test/resources/badVersionCWL.cwl", "diffHunk": "@@ -0,0 +1,25 @@\n+cwlVersion: v2.7", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMDgzOA==", "bodyText": "AssertThat(blah blah).contains(blah blah)", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522520838", "createdAt": "2020-11-13T00:11:39Z", "author": {"login": "garyluu"}, "path": "dockstore-webservice/src/test/java/io/dockstore/webservice/languages/WDLHandlerTest.java", "diffHunk": "@@ -151,6 +152,27 @@ public void testGetToolsForComplexWorkflow() throws IOException {\n \n     }\n \n+    @Test\n+    public void testGetContentWithSyntaxErrors() throws IOException {\n+        final WDLHandler wdlHandler = new WDLHandler();\n+        final File wdlFile = new File(ResourceHelpers.resourceFilePath(\"brokenWDL.wdl\"));\n+        final Set<SourceFile> emptySet = Collections.emptySet();\n+\n+        // wdlHandler.getContent ultimately invokes toolDAO.findAllByPath from LanguageHandlerEntry.getURLFromEntry for look\n+        // up; just have it return null\n+        final ToolDAO toolDAO = Mockito.mock(ToolDAO.class);\n+        when(toolDAO.findAllByPath(Mockito.anyString(), Mockito.anyBoolean())).thenReturn(null);\n+\n+        // run test with a WDL descriptor with syntax errors\n+        try {\n+            wdlHandler.getContent(\"/brokenWDL.wdl\", FileUtils.readFileToString(wdlFile, StandardCharsets.UTF_8), emptySet,\n+                LanguageHandlerInterface.Type.TOOLS, toolDAO);\n+        } catch (CustomWebApplicationException e) {\n+            Assert.assertEquals(e.getResponse().getStatus(), 400);\n+            Assert.assertTrue(\"Should contain parsing error statement, found: \" + e.errorMessage, e.errorMessage.contains(WDLHandler.WDL_PARSE_ERROR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NjA3MzIw", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-529607320", "createdAt": "2020-11-13T00:18:11Z", "commit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxODoxMVrOHyURQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoyODo0NVrOHyUe0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjk0NA==", "bodyText": "Log the exception.", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522522944", "createdAt": "2020-11-13T00:18:11Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +428,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError e) {\n+            throw new CustomWebApplicationException(this.WDL_PARSE_ERROR + e.getMessage(), HttpStatus.SC_BAD_REQUEST);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjk5Mw==", "bodyText": "Log the exception", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522522993", "createdAt": "2020-11-13T00:18:20Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +428,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError e) {\n+            throw new CustomWebApplicationException(this.WDL_PARSE_ERROR + e.getMessage(), HttpStatus.SC_BAD_REQUEST);\n+        } catch (IOException | NoSuchElementException e) {\n+            throw new CustomWebApplicationException(\"Could not process request, \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjE3OA==", "bodyText": "Why aren't you using this any more? It still gets used in 2 other spots, and it looks like you duplicate the code on line 273. I guess because you're throwing exceptions here and don't want to otherwise. Still, it would be nice if there wasn't the duplication... What happens we we support v2 some day, if there ever is one? If we don't update in both places....", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522526178", "createdAt": "2020-11-13T00:27:59Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -249,7 +255,7 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n     public Optional<String> getContent(String mainDescriptorPath, String mainDescriptor, Set<SourceFile> secondarySourceFiles, LanguageHandlerInterface.Type type,\n         ToolDAO dao) {\n         Yaml yaml = new Yaml();\n-        if (isValidCwl(mainDescriptor, yaml)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyNjQxNg==", "bodyText": "Log the exception", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r522526416", "createdAt": "2020-11-13T00:28:45Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -274,177 +293,170 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n             String expressionToolType = \"expressionTool\";\n \n             // Set up GSON for JSON parsing\n-            Gson gson;\n-            try {\n-                gson = CWL.getTypeSafeCWLToolDocument();\n+            Gson gson = CWL.getTypeSafeCWLToolDocument();\n \n-                final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n+            final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n \n-                if (workflow == null) {\n-                    LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n-                    return Optional.empty();\n-                }\n+            if (workflow == null) {\n+                LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n+                return Optional.empty();\n+            }\n \n-                // Determine default docker path (Check requirement first and then hint)\n-                defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n-\n-                // Store workflow steps in json and then read it into map <String, WorkflowStep>\n-                Object steps = workflow.getSteps();\n-                String stepJson = gson.toJson(steps);\n-                Map<String, WorkflowStep> workflowStepMap;\n-                if (steps instanceof ArrayList) {\n-                    ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n-                    }.getType());\n-                    workflowStepMap = new LinkedTreeMap<>();\n-                    workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n-                } else {\n-                    workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n-                    }.getType());\n-                }\n+            // Determine default docker path (Check requirement first and then hint)\n+            defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n+\n+            // Store workflow steps in json and then read it into map <String, WorkflowStep>\n+            Object steps = workflow.getSteps();\n+            String stepJson = gson.toJson(steps);\n+            Map<String, WorkflowStep> workflowStepMap;\n+            if (steps instanceof ArrayList) {\n+                ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n+                }.getType());\n+                workflowStepMap = new LinkedTreeMap<>();\n+                workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n+            } else {\n+                workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n+                }.getType());\n+            }\n \n-                if (stepJson == null) {\n-                    LOG.error(\"Could not find any steps for the workflow.\");\n-                    return Optional.empty();\n-                }\n+            if (stepJson == null) {\n+                LOG.error(\"Could not find any steps for the workflow.\");\n+                return Optional.empty();\n+            }\n \n-                if (workflowStepMap == null) {\n-                    LOG.error(\"Error deserializing workflow steps\");\n-                    return Optional.empty();\n-                }\n+            if (workflowStepMap == null) {\n+                LOG.error(\"Error deserializing workflow steps\");\n+                return Optional.empty();\n+            }\n \n-                // Iterate through steps to find dependencies and docker requirements\n-                for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n-                    WorkflowStep workflowStep = entry.getValue();\n-                    String workflowStepId = nodePrefix + entry.getKey();\n+            // Iterate through steps to find dependencies and docker requirements\n+            for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n+                WorkflowStep workflowStep = entry.getValue();\n+                String workflowStepId = nodePrefix + entry.getKey();\n \n-                    ArrayList<String> stepDependencies = new ArrayList<>();\n+                ArrayList<String> stepDependencies = new ArrayList<>();\n \n-                    // Iterate over source and get the dependencies\n-                    if (workflowStep.getIn() != null) {\n-                        for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n-                            Object sources = workflowStepInput.getSource();\n+                // Iterate over source and get the dependencies\n+                if (workflowStep.getIn() != null) {\n+                    for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n+                        Object sources = workflowStepInput.getSource();\n \n-                            processDependencies(nodePrefix, stepDependencies, sources);\n-                        }\n-                        if (stepDependencies.size() > 0) {\n-                            toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n-                                toolInfo.toolDependencyList.addAll(stepDependencies);\n-                                return toolInfo;\n-                            });\n-                            toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n-                        }\n+                        processDependencies(nodePrefix, stepDependencies, sources);\n                     }\n-\n-                    // Check workflow step for docker requirement and hints\n-                    String stepDockerRequirement = defaultDockerPath;\n-                    stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n-                        stepDockerRequirement);\n-\n-                    // Check for docker requirement within workflow step file\n-                    String secondaryFile = null;\n-                    Object run = workflowStep.getRun();\n-                    String runAsJson = gson.toJson(gson.toJsonTree(run));\n-\n-                    if (run instanceof String) {\n-                        secondaryFile = (String)run;\n-                    } else if (isTool(runAsJson, yaml)) {\n-                        CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, toolType);\n-                    } else if (isWorkflow(runAsJson, yaml)) {\n-                        Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n-                        stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, workflowType);\n-                    } else if (isExpressionTool(runAsJson, yaml)) {\n-                        ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, expressionToolType);\n-                    } else if (run instanceof Map) {\n-                        // must be import or include\n-                        Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n-                        if (importVal != null) {\n-                            secondaryFile = importVal.toString();\n-                        }\n-\n-                        Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n-                        if (includeVal != null) {\n-                            secondaryFile = includeVal.toString();\n-                        }\n-\n-                        if (secondaryFile == null) {\n-                            LOG.error(\"Syntax incorrect. Could not ($)import or ($)include secondary file for run command: \" + run);\n-                            return Optional.empty();\n-                        }\n+                    if (stepDependencies.size() > 0) {\n+                        toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n+                            toolInfo.toolDependencyList.addAll(stepDependencies);\n+                            return toolInfo;\n+                        });\n+                        toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n                     }\n+                }\n \n-                    // Check secondary file for docker pull\n-                    if (secondaryFile != null) {\n-                        String finalSecondaryFile = secondaryFile;\n-                        final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n-                                .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n-                        final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n-                        stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n-                        if (isExpressionTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, expressionToolType);\n-                        } else if (isTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, toolType);\n-                        } else if (isWorkflow(content, yaml)) {\n-                            stepToType.put(workflowStepId, workflowType);\n-                        } else {\n-                            stepToType.put(workflowStepId, \"n/a\");\n-                        }\n+                // Check workflow step for docker requirement and hints\n+                String stepDockerRequirement = defaultDockerPath;\n+                stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n+                    stepDockerRequirement);\n+\n+                // Check for docker requirement within workflow step file\n+                String secondaryFile = null;\n+                Object run = workflowStep.getRun();\n+                String runAsJson = gson.toJson(gson.toJsonTree(run));\n+\n+                if (run instanceof String) {\n+                    secondaryFile = (String)run;\n+                } else if (isTool(runAsJson, yaml)) {\n+                    CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, toolType);\n+                } else if (isWorkflow(runAsJson, yaml)) {\n+                    Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n+                    stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, workflowType);\n+                } else if (isExpressionTool(runAsJson, yaml)) {\n+                    ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, expressionToolType);\n+                } else if (run instanceof Map) {\n+                    // must be import or include\n+                    Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n+                    if (importVal != null) {\n+                        secondaryFile = importVal.toString();\n                     }\n \n-                    String dockerUrl = null;\n-                    if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n-                        dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n+                    Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n+                    if (includeVal != null) {\n+                        secondaryFile = includeVal.toString();\n                     }\n \n-                    if (type == LanguageHandlerInterface.Type.DAG) {\n-                        nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                    if (secondaryFile == null) {\n+                        throw new CustomWebApplicationException(this.CWL_PARSE_SECONDARY_ERROR + run, HttpStatus.SC_BAD_REQUEST);\n                     }\n+                }\n \n-                    if (secondaryFile != null) {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                // Check secondary file for docker pull\n+                if (secondaryFile != null) {\n+                    String finalSecondaryFile = secondaryFile;\n+                    final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n+                            .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n+                    final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n+                    stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n+                    if (isExpressionTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, expressionToolType);\n+                    } else if (isTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, toolType);\n+                    } else if (isWorkflow(content, yaml)) {\n+                        stepToType.put(workflowStepId, workflowType);\n                     } else {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                        stepToType.put(workflowStepId, \"n/a\");\n                     }\n+                }\n \n+                String dockerUrl = null;\n+                if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n+                    dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n                 }\n \n                 if (type == LanguageHandlerInterface.Type.DAG) {\n-                    // Determine steps that point to end\n-                    List<String> endDependencies = new ArrayList<>();\n+                    nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                }\n \n-                    for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n-                        Object sources = workflowOutputParameter.getOutputSource();\n-                        processDependencies(nodePrefix, endDependencies, sources);\n-                    }\n+                if (secondaryFile != null) {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                } else {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                }\n \n-                    toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n-                    nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+            }\n \n-                    // connect start node with them\n-                    for (Pair<String, String> node : nodePairs) {\n-                        if (toolInfoMap.get(node.getLeft()) == null) {\n-                            toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n-                        }\n-                    }\n-                    nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+            if (type == LanguageHandlerInterface.Type.DAG) {\n+                // Determine steps that point to end\n+                List<String> endDependencies = new ArrayList<>();\n \n-                    return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n-                } else {\n-                    return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n+                for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n+                    Object sources = workflowOutputParameter.getOutputSource();\n+                    processDependencies(nodePrefix, endDependencies, sources);\n                 }\n-            } catch (JsonParseException ex) {\n-                LOG.error(\"The JSON file provided is invalid.\", ex);\n-                return Optional.empty();\n+\n+                toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n+                nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+\n+                // connect start node with them\n+                for (Pair<String, String> node : nodePairs) {\n+                    if (toolInfoMap.get(node.getLeft()) == null) {\n+                        toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n+                    }\n+                }\n+                nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+\n+                return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n+            } else {\n+                return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n             }\n-        } else {\n-            return Optional.empty();\n+        } catch (ClassCastException | YAMLException | JsonParseException ex) {\n+            throw new CustomWebApplicationException(this.CWL_PARSE_ERROR + ex.getMessage(), HttpStatus.SC_BAD_REQUEST);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "originalPosition": 364}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTg5NTEw", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-531589510", "createdAt": "2020-11-16T18:23:37Z", "commit": {"oid": "a2b130262fa7f033814d101bfe8573a4dc3f685e"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/c5277c33e2a3bf271f3be4e33b742fb646b1a076", "committedDate": "2020-11-16T22:38:23Z", "message": "PR suggestions. Modifed test assertions and logging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTk5MzYz", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-531999363", "createdAt": "2020-11-17T03:39:04Z", "commit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMzozOTowNFrOH0jK0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMzo0OTozOFrOH0jWDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NDIwOQ==", "bodyText": "Sorry, I didn't provide the right level of request to log the exception. Before the throw, LOG the error, making the exception the second parameter. Something like this:\nfinal String msg = WDLHandler.WDL_PARSE_ERROR + ex.getMessage();\nLOG.error(msg, ex);\nthrow new CustomWebApplicationException(msg, HttpStatus.SC_BAD_REQUEST);\n\nThe reason for this if this error starts happening in production, we can go look at the logs, and see what the actual error is.\nI don't think you need the 3rd parameter to CustomWebapplicationException.", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524864209", "createdAt": "2020-11-17T03:39:04Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/WDLHandler.java", "diffHunk": "@@ -427,10 +428,13 @@ public VersionTypeValidation validateTestParameterSet(Set<SourceFile> sourceFile\n             // Iterate over each call, determine dependencies\n             Map<String, List<String>> callsToDependencies = wdlBridge.getCallsToDependencies(tempMainDescriptor.getAbsolutePath(), mainDescName);\n             toolInfoMap = mapConverterToToolInfo(callsToDockerMap, callsToDependencies);\n+\n             // Get import files\n             namespaceToPath = wdlBridge.getImportMap(tempMainDescriptor.getAbsolutePath(), mainDescName);\n-        } catch (IOException | NoSuchElementException | WdlParser.SyntaxError e) {\n-            throw new CustomWebApplicationException(\"could not process wdl into DAG: \" + e.getMessage(), HttpStatus.SC_INTERNAL_SERVER_ERROR);\n+        } catch (WdlParser.SyntaxError ex) {\n+            throw new CustomWebApplicationException(WDLHandler.WDL_PARSE_ERROR + ex.getMessage(), HttpStatus.SC_BAD_REQUEST, ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTA1Ng==", "bodyText": "The variable name is equals, but you're not testing for equality, you're testing for startsWith. A little confusing, and I'm not sure which one you want.\nNvm, I see it was like this already.", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524865056", "createdAt": "2020-11-17T03:41:55Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -261,6 +268,21 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n \n             // Convert YAML to JSON\n             Map<String, Object> mapping = yaml.loadAs(mainDescriptor, Map.class);\n+\n+            // verify cwl version is correctly specified\n+            final Object cwlVersion = mapping.get(\"cwlVersion\");\n+            if (cwlVersion != null) {\n+                final boolean equals = cwlVersion.toString().startsWith(CWLHandler.CWL_VERSION_PREFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTUyOA==", "bodyText": "Log the exception (see my other comment)", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524865528", "createdAt": "2020-11-17T03:43:44Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -274,177 +296,171 @@ private void handlePotentialFormatEntry(Set<FileFormat> fileFormats, Object v) {\n             String expressionToolType = \"expressionTool\";\n \n             // Set up GSON for JSON parsing\n-            Gson gson;\n-            try {\n-                gson = CWL.getTypeSafeCWLToolDocument();\n+            Gson gson = CWL.getTypeSafeCWLToolDocument();\n \n-                final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n+            final Workflow workflow = gson.fromJson(cwlJson.toString(), Workflow.class);\n \n-                if (workflow == null) {\n-                    LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n-                    return Optional.empty();\n-                }\n+            if (workflow == null) {\n+                LOG.error(\"The workflow does not seem to conform to CWL specs.\");\n+                return Optional.empty();\n+            }\n \n-                // Determine default docker path (Check requirement first and then hint)\n-                defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n-\n-                // Store workflow steps in json and then read it into map <String, WorkflowStep>\n-                Object steps = workflow.getSteps();\n-                String stepJson = gson.toJson(steps);\n-                Map<String, WorkflowStep> workflowStepMap;\n-                if (steps instanceof ArrayList) {\n-                    ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n-                    }.getType());\n-                    workflowStepMap = new LinkedTreeMap<>();\n-                    workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n-                } else {\n-                    workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n-                    }.getType());\n-                }\n+            // Determine default docker path (Check requirement first and then hint)\n+            defaultDockerPath = getRequirementOrHint(workflow.getRequirements(), workflow.getHints(), defaultDockerPath);\n+\n+            // Store workflow steps in json and then read it into map <String, WorkflowStep>\n+            Object steps = workflow.getSteps();\n+            String stepJson = gson.toJson(steps);\n+            Map<String, WorkflowStep> workflowStepMap;\n+            if (steps instanceof ArrayList) {\n+                ArrayList<WorkflowStep> workflowStepList = gson.fromJson(stepJson, new TypeToken<ArrayList<WorkflowStep>>() {\n+                }.getType());\n+                workflowStepMap = new LinkedTreeMap<>();\n+                workflowStepList.forEach(workflowStep -> workflowStepMap.put(workflowStep.getId().toString(), workflowStep));\n+            } else {\n+                workflowStepMap = gson.fromJson(stepJson, new TypeToken<Map<String, WorkflowStep>>() {\n+                }.getType());\n+            }\n \n-                if (stepJson == null) {\n-                    LOG.error(\"Could not find any steps for the workflow.\");\n-                    return Optional.empty();\n-                }\n+            if (stepJson == null) {\n+                LOG.error(\"Could not find any steps for the workflow.\");\n+                return Optional.empty();\n+            }\n \n-                if (workflowStepMap == null) {\n-                    LOG.error(\"Error deserializing workflow steps\");\n-                    return Optional.empty();\n-                }\n+            if (workflowStepMap == null) {\n+                LOG.error(\"Error deserializing workflow steps\");\n+                return Optional.empty();\n+            }\n \n-                // Iterate through steps to find dependencies and docker requirements\n-                for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n-                    WorkflowStep workflowStep = entry.getValue();\n-                    String workflowStepId = nodePrefix + entry.getKey();\n+            // Iterate through steps to find dependencies and docker requirements\n+            for (Map.Entry<String, WorkflowStep> entry : workflowStepMap.entrySet()) {\n+                WorkflowStep workflowStep = entry.getValue();\n+                String workflowStepId = nodePrefix + entry.getKey();\n \n-                    ArrayList<String> stepDependencies = new ArrayList<>();\n+                ArrayList<String> stepDependencies = new ArrayList<>();\n \n-                    // Iterate over source and get the dependencies\n-                    if (workflowStep.getIn() != null) {\n-                        for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n-                            Object sources = workflowStepInput.getSource();\n+                // Iterate over source and get the dependencies\n+                if (workflowStep.getIn() != null) {\n+                    for (WorkflowStepInput workflowStepInput : workflowStep.getIn()) {\n+                        Object sources = workflowStepInput.getSource();\n \n-                            processDependencies(nodePrefix, stepDependencies, sources);\n-                        }\n-                        if (stepDependencies.size() > 0) {\n-                            toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n-                                toolInfo.toolDependencyList.addAll(stepDependencies);\n-                                return toolInfo;\n-                            });\n-                            toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n-                        }\n+                        processDependencies(nodePrefix, stepDependencies, sources);\n                     }\n-\n-                    // Check workflow step for docker requirement and hints\n-                    String stepDockerRequirement = defaultDockerPath;\n-                    stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n-                        stepDockerRequirement);\n-\n-                    // Check for docker requirement within workflow step file\n-                    String secondaryFile = null;\n-                    Object run = workflowStep.getRun();\n-                    String runAsJson = gson.toJson(gson.toJsonTree(run));\n-\n-                    if (run instanceof String) {\n-                        secondaryFile = (String)run;\n-                    } else if (isTool(runAsJson, yaml)) {\n-                        CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, toolType);\n-                    } else if (isWorkflow(runAsJson, yaml)) {\n-                        Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n-                        stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, workflowType);\n-                    } else if (isExpressionTool(runAsJson, yaml)) {\n-                        ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n-                        stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n-                            stepDockerRequirement);\n-                        stepToType.put(workflowStepId, expressionToolType);\n-                    } else if (run instanceof Map) {\n-                        // must be import or include\n-                        Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n-                        if (importVal != null) {\n-                            secondaryFile = importVal.toString();\n-                        }\n-\n-                        Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n-                        if (includeVal != null) {\n-                            secondaryFile = includeVal.toString();\n-                        }\n-\n-                        if (secondaryFile == null) {\n-                            LOG.error(\"Syntax incorrect. Could not ($)import or ($)include secondary file for run command: \" + run);\n-                            return Optional.empty();\n-                        }\n+                    if (stepDependencies.size() > 0) {\n+                        toolInfoMap.computeIfPresent(workflowStepId, (toolId, toolInfo) -> {\n+                            toolInfo.toolDependencyList.addAll(stepDependencies);\n+                            return toolInfo;\n+                        });\n+                        toolInfoMap.computeIfAbsent(workflowStepId, toolId -> new ToolInfo(null, stepDependencies));\n                     }\n+                }\n \n-                    // Check secondary file for docker pull\n-                    if (secondaryFile != null) {\n-                        String finalSecondaryFile = secondaryFile;\n-                        final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n-                                .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n-                        final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n-                        stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n-                        if (isExpressionTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, expressionToolType);\n-                        } else if (isTool(content, yaml)) {\n-                            stepToType.put(workflowStepId, toolType);\n-                        } else if (isWorkflow(content, yaml)) {\n-                            stepToType.put(workflowStepId, workflowType);\n-                        } else {\n-                            stepToType.put(workflowStepId, \"n/a\");\n-                        }\n+                // Check workflow step for docker requirement and hints\n+                String stepDockerRequirement = defaultDockerPath;\n+                stepDockerRequirement = getRequirementOrHint(workflowStep.getRequirements(), workflowStep.getHints(),\n+                    stepDockerRequirement);\n+\n+                // Check for docker requirement within workflow step file\n+                String secondaryFile = null;\n+                Object run = workflowStep.getRun();\n+                String runAsJson = gson.toJson(gson.toJsonTree(run));\n+\n+                if (run instanceof String) {\n+                    secondaryFile = (String)run;\n+                } else if (isTool(runAsJson, yaml)) {\n+                    CommandLineTool clTool = gson.fromJson(runAsJson, CommandLineTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(clTool.getRequirements(), clTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, toolType);\n+                } else if (isWorkflow(runAsJson, yaml)) {\n+                    Workflow stepWorkflow = gson.fromJson(runAsJson, Workflow.class);\n+                    stepDockerRequirement = getRequirementOrHint(stepWorkflow.getRequirements(), stepWorkflow.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, workflowType);\n+                } else if (isExpressionTool(runAsJson, yaml)) {\n+                    ExpressionTool expressionTool = gson.fromJson(runAsJson, ExpressionTool.class);\n+                    stepDockerRequirement = getRequirementOrHint(expressionTool.getRequirements(), expressionTool.getHints(),\n+                        stepDockerRequirement);\n+                    stepToType.put(workflowStepId, expressionToolType);\n+                } else if (run instanceof Map) {\n+                    // must be import or include\n+                    Object importVal = ((Map)run).containsKey(\"$import\") ? ((Map)run).get(\"$import\") : ((Map)run).get(\"import\");\n+                    if (importVal != null) {\n+                        secondaryFile = importVal.toString();\n                     }\n \n-                    String dockerUrl = null;\n-                    if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n-                        dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n+                    Object includeVal = ((Map)run).containsKey(\"$include\") ? ((Map)run).get(\"$include\") : ((Map)run).get(\"include\");\n+                    if (includeVal != null) {\n+                        secondaryFile = includeVal.toString();\n                     }\n \n-                    if (type == LanguageHandlerInterface.Type.DAG) {\n-                        nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                    if (secondaryFile == null) {\n+                        LOG.error(CWLHandler.CWL_PARSE_SECONDARY_ERROR + run);\n+                        throw new CustomWebApplicationException(CWLHandler.CWL_PARSE_SECONDARY_ERROR + run, HttpStatus.SC_BAD_REQUEST);\n                     }\n+                }\n \n-                    if (secondaryFile != null) {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                // Check secondary file for docker pull\n+                if (secondaryFile != null) {\n+                    String finalSecondaryFile = secondaryFile;\n+                    final Optional<SourceFile> sourceFileOptional = secondarySourceFiles.stream()\n+                            .filter(sf -> sf.getPath().equals(finalSecondaryFile)).findFirst();\n+                    final String content = sourceFileOptional.map(SourceFile::getContent).orElse(null);\n+                    stepDockerRequirement = parseSecondaryFile(stepDockerRequirement, content, gson, yaml);\n+                    if (isExpressionTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, expressionToolType);\n+                    } else if (isTool(content, yaml)) {\n+                        stepToType.put(workflowStepId, toolType);\n+                    } else if (isWorkflow(content, yaml)) {\n+                        stepToType.put(workflowStepId, workflowType);\n                     } else {\n-                        nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                        stepToType.put(workflowStepId, \"n/a\");\n                     }\n+                }\n \n+                String dockerUrl = null;\n+                if ((stepToType.get(workflowStepId).equals(workflowType) || stepToType.get(workflowStepId).equals(toolType)) && !Strings.isNullOrEmpty(stepDockerRequirement)) {\n+                    dockerUrl = getURLFromEntry(stepDockerRequirement, dao);\n                 }\n \n                 if (type == LanguageHandlerInterface.Type.DAG) {\n-                    // Determine steps that point to end\n-                    List<String> endDependencies = new ArrayList<>();\n+                    nodePairs.add(new MutablePair<>(workflowStepId, dockerUrl));\n+                }\n \n-                    for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n-                        Object sources = workflowOutputParameter.getOutputSource();\n-                        processDependencies(nodePrefix, endDependencies, sources);\n-                    }\n+                if (secondaryFile != null) {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(secondaryFile, stepDockerRequirement, dockerUrl));\n+                } else {\n+                    nodeDockerInfo.put(workflowStepId, new MutableTriple<>(mainDescriptorPath, stepDockerRequirement, dockerUrl));\n+                }\n \n-                    toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n-                    nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+            }\n \n-                    // connect start node with them\n-                    for (Pair<String, String> node : nodePairs) {\n-                        if (toolInfoMap.get(node.getLeft()) == null) {\n-                            toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n-                        }\n-                    }\n-                    nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+            if (type == LanguageHandlerInterface.Type.DAG) {\n+                // Determine steps that point to end\n+                List<String> endDependencies = new ArrayList<>();\n \n-                    return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n-                } else {\n-                    return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n+                for (WorkflowOutputParameter workflowOutputParameter : workflow.getOutputs()) {\n+                    Object sources = workflowOutputParameter.getOutputSource();\n+                    processDependencies(nodePrefix, endDependencies, sources);\n                 }\n-            } catch (JsonParseException ex) {\n-                LOG.error(\"The JSON file provided is invalid.\", ex);\n-                return Optional.empty();\n+\n+                toolInfoMap.put(\"UniqueEndKey\", new ToolInfo(null, endDependencies));\n+                nodePairs.add(new MutablePair<>(\"UniqueEndKey\", \"\"));\n+\n+                // connect start node with them\n+                for (Pair<String, String> node : nodePairs) {\n+                    if (toolInfoMap.get(node.getLeft()) == null) {\n+                        toolInfoMap.put(node.getLeft(), new ToolInfo(null, Lists.newArrayList(\"UniqueBeginKey\")));\n+                    }\n+                }\n+                nodePairs.add(new MutablePair<>(\"UniqueBeginKey\", \"\"));\n+\n+                return Optional.of(setupJSONDAG(nodePairs, toolInfoMap, stepToType, nodeDockerInfo));\n+            } else {\n+                return Optional.of(getJSONTableToolContent(nodeDockerInfo));\n             }\n-        } else {\n-            return Optional.empty();\n+        } catch (ClassCastException | YAMLException | JsonParseException ex) {\n+            throw new CustomWebApplicationException(CWLHandler.CWL_PARSE_ERROR + ex.getMessage(), HttpStatus.SC_BAD_REQUEST, ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NTYwOA==", "bodyText": "equals != startsWith", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524865608", "createdAt": "2020-11-17T03:44:02Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/languages/CWLHandler.java", "diffHunk": "@@ -725,7 +741,7 @@ private boolean isValidCwl(String content, Yaml yaml) {\n             final Object cwlVersion = mapping.get(\"cwlVersion\");\n \n             if (cwlVersion != null) {\n-                final boolean equals = cwlVersion.toString().startsWith(\"v1\");\n+                final boolean equals = cwlVersion.toString().startsWith(CWLHandler.CWL_VERSION_PREFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076"}, "originalPosition": 378}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2NzA4NQ==", "bodyText": "Not sure you need this (see my other comment)", "url": "https://github.com/dockstore/dockstore/pull/3922#discussion_r524867085", "createdAt": "2020-11-17T03:49:38Z", "author": {"login": "coverbeck"}, "path": "dockstore-webservice/src/main/java/io/dockstore/webservice/CustomWebApplicationException.java", "diffHunk": "@@ -31,6 +31,11 @@ public CustomWebApplicationException(String message, int status) {\n         this.errorMessage = message;\n     }\n \n+    public CustomWebApplicationException(String message, int status, Throwable ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTA0MDA5", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-532504009", "createdAt": "2020-11-17T15:42:08Z", "commit": {"oid": "c5277c33e2a3bf271f3be4e33b742fb646b1a076"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76d246baa2dabe6b004914606056c5645a7acb12", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/76d246baa2dabe6b004914606056c5645a7acb12", "committedDate": "2020-11-17T16:09:09Z", "message": "Fixed logging. Renamed variable to better represent its functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f183bbe170eb2515e6a04e8314ed040fb35d24ec", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/f183bbe170eb2515e6a04e8314ed040fb35d24ec", "committedDate": "2020-11-18T19:37:02Z", "message": "Merge branch 'develop' of https://github.com/dockstore/dockstore into feature/3810/WorkflowToolList500"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTYwMDg4", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-533960088", "createdAt": "2020-11-18T23:19:08Z", "commit": {"oid": "f183bbe170eb2515e6a04e8314ed040fb35d24ec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9787e01ee0b37d12109cd1accd2e8fb69770cec4", "author": {"user": null}, "url": "https://github.com/dockstore/dockstore/commit/9787e01ee0b37d12109cd1accd2e8fb69770cec4", "committedDate": "2020-11-20T16:41:19Z", "message": "Fixed test text assertion, syntax change for other tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzUxMzIz", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-535751323", "createdAt": "2020-11-20T20:22:50Z", "commit": {"oid": "9787e01ee0b37d12109cd1accd2e8fb69770cec4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzUzMDc2", "url": "https://github.com/dockstore/dockstore/pull/3922#pullrequestreview-535753076", "createdAt": "2020-11-20T20:25:54Z", "commit": {"oid": "9787e01ee0b37d12109cd1accd2e8fb69770cec4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1618, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}