{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMzY2NjIy", "number": 1228, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMzoxODo1MVrOEESmnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMzo1MzoxM1rOELh_qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTM0NTU5OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMzoxODo1MVrOGh0Ysg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNzowMjoxN1rOGkk3xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNDQ4Mg==", "bodyText": "Calling platformMXBean.getHeapMemoryUsage() returns a snapshot of the current usage. Calling java.lang.management.MemoryUsage#getUsed, for example, on the same instance will always return the same value.", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r438114482", "createdAt": "2020-06-10T13:18:51Z", "author": {"login": "felixbarny"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "diffHunk": "@@ -26,56 +26,91 @@\n \n import co.elastic.apm.agent.context.AbstractLifecycleListener;\n import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n import co.elastic.apm.agent.metrics.DoubleSupplier;\n import co.elastic.apm.agent.metrics.Labels;\n import co.elastic.apm.agent.metrics.MetricRegistry;\n \n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.MemoryType;\n+import java.lang.management.MemoryUsage;\n+import java.util.Arrays;\n+import java.util.List;\n \n public class JvmMemoryMetrics extends AbstractLifecycleListener {\n \n+    public static final List<WildcardMatcher> TENURED_POOL_WILDCARDS = Arrays.asList(\n+        WildcardMatcher.valueOf(\"CMS Old Gen\"),\n+        WildcardMatcher.valueOf(\"PS Old Gen\"),\n+        WildcardMatcher.valueOf(\"G1 Old Gen\"),\n+        WildcardMatcher.valueOf(\"Old Space\"),\n+        WildcardMatcher.valueOf(\"Tenured Gen\"),\n+        WildcardMatcher.valueOf(\"Java heap\"),\n+        WildcardMatcher.valueOf(\"GenPauseless Old Gen\"));\n+\n     @Override\n     public void start(ElasticApmTracer tracer) {\n         bindTo(tracer.getMetricRegistry());\n     }\n \n     void bindTo(final MetricRegistry registry) {\n         final MemoryMXBean platformMXBean = ManagementFactory.getPlatformMXBean(MemoryMXBean.class);\n-        registry.add(\"jvm.memory.heap.used\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getUsed();\n-            }\n-        });\n-        registry.add(\"jvm.memory.heap.committed\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getCommitted();\n+\n+        addUsedMetric(\"jvm.memory.heap.used\", registry, platformMXBean.getHeapMemoryUsage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f3635f6f16bbd40ccd53794bdf4acac9602d58"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAwNjAyMQ==", "bodyText": "fixed", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r441006021", "createdAt": "2020-06-16T17:02:17Z", "author": {"login": "kananindzya"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "diffHunk": "@@ -26,56 +26,91 @@\n \n import co.elastic.apm.agent.context.AbstractLifecycleListener;\n import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n import co.elastic.apm.agent.metrics.DoubleSupplier;\n import co.elastic.apm.agent.metrics.Labels;\n import co.elastic.apm.agent.metrics.MetricRegistry;\n \n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.MemoryType;\n+import java.lang.management.MemoryUsage;\n+import java.util.Arrays;\n+import java.util.List;\n \n public class JvmMemoryMetrics extends AbstractLifecycleListener {\n \n+    public static final List<WildcardMatcher> TENURED_POOL_WILDCARDS = Arrays.asList(\n+        WildcardMatcher.valueOf(\"CMS Old Gen\"),\n+        WildcardMatcher.valueOf(\"PS Old Gen\"),\n+        WildcardMatcher.valueOf(\"G1 Old Gen\"),\n+        WildcardMatcher.valueOf(\"Old Space\"),\n+        WildcardMatcher.valueOf(\"Tenured Gen\"),\n+        WildcardMatcher.valueOf(\"Java heap\"),\n+        WildcardMatcher.valueOf(\"GenPauseless Old Gen\"));\n+\n     @Override\n     public void start(ElasticApmTracer tracer) {\n         bindTo(tracer.getMetricRegistry());\n     }\n \n     void bindTo(final MetricRegistry registry) {\n         final MemoryMXBean platformMXBean = ManagementFactory.getPlatformMXBean(MemoryMXBean.class);\n-        registry.add(\"jvm.memory.heap.used\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getUsed();\n-            }\n-        });\n-        registry.add(\"jvm.memory.heap.committed\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getCommitted();\n+\n+        addUsedMetric(\"jvm.memory.heap.used\", registry, platformMXBean.getHeapMemoryUsage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNDQ4Mg=="}, "originalCommit": {"oid": "05f3635f6f16bbd40ccd53794bdf4acac9602d58"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTM2MTE2OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMzoyMjozNVrOGh0ixA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQyMDoxNzoxOVrOGjfKdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNzA2MA==", "bodyText": "What's the rationale behind splitting by eden/survivor/tenured?\nIt also looks like this adds multiple heap metrics with the same name and same labels which will override the previous metric. Did you mean to accumulate the values of all survivor spaces, for example? Or would they be reported separately but with different labels for the name?", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r438117060", "createdAt": "2020-06-10T13:22:35Z", "author": {"login": "felixbarny"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "diffHunk": "@@ -26,56 +26,91 @@\n \n import co.elastic.apm.agent.context.AbstractLifecycleListener;\n import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n import co.elastic.apm.agent.metrics.DoubleSupplier;\n import co.elastic.apm.agent.metrics.Labels;\n import co.elastic.apm.agent.metrics.MetricRegistry;\n \n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.MemoryType;\n+import java.lang.management.MemoryUsage;\n+import java.util.Arrays;\n+import java.util.List;\n \n public class JvmMemoryMetrics extends AbstractLifecycleListener {\n \n+    public static final List<WildcardMatcher> TENURED_POOL_WILDCARDS = Arrays.asList(\n+        WildcardMatcher.valueOf(\"CMS Old Gen\"),\n+        WildcardMatcher.valueOf(\"PS Old Gen\"),\n+        WildcardMatcher.valueOf(\"G1 Old Gen\"),\n+        WildcardMatcher.valueOf(\"Old Space\"),\n+        WildcardMatcher.valueOf(\"Tenured Gen\"),\n+        WildcardMatcher.valueOf(\"Java heap\"),\n+        WildcardMatcher.valueOf(\"GenPauseless Old Gen\"));\n+\n     @Override\n     public void start(ElasticApmTracer tracer) {\n         bindTo(tracer.getMetricRegistry());\n     }\n \n     void bindTo(final MetricRegistry registry) {\n         final MemoryMXBean platformMXBean = ManagementFactory.getPlatformMXBean(MemoryMXBean.class);\n-        registry.add(\"jvm.memory.heap.used\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getUsed();\n-            }\n-        });\n-        registry.add(\"jvm.memory.heap.committed\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getCommitted();\n+\n+        addUsedMetric(\"jvm.memory.heap.used\", registry, platformMXBean.getHeapMemoryUsage());\n+        addCommittedMetric(\"jvm.memory.heap.committed\", registry, platformMXBean.getHeapMemoryUsage());\n+        addMaxMetric(\"jvm.memory.heap.max\", registry, platformMXBean.getHeapMemoryUsage());\n+        addUsedMetric(\"jvm.memory.non_heap.used\", registry, platformMXBean.getNonHeapMemoryUsage());\n+        addCommittedMetric(\"jvm.memory.non_heap.committed\", registry, platformMXBean.getNonHeapMemoryUsage());\n+        addMaxMetric(\"jvm.memory.non_heap.max\", registry, platformMXBean.getNonHeapMemoryUsage());\n+\n+        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n+\n+        for (MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) {\n+            if (memoryPoolMXBean.getType() != MemoryType.HEAP) {\n+                continue;\n             }\n-        });\n-        registry.add(\"jvm.memory.heap.max\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getMax();\n+            if (memoryPoolMXBean.getName().contains(\"Eden\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05f3635f6f16bbd40ccd53794bdf4acac9602d58"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzkyNg==", "bodyText": "I think it will be more informative. And this detailed information can help to add specific alerts.\nYes, I mean that they will be reported separately but with different lables(I fixed it with last commit)", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r439863926", "createdAt": "2020-06-14T20:17:19Z", "author": {"login": "kananindzya"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "diffHunk": "@@ -26,56 +26,91 @@\n \n import co.elastic.apm.agent.context.AbstractLifecycleListener;\n import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n import co.elastic.apm.agent.metrics.DoubleSupplier;\n import co.elastic.apm.agent.metrics.Labels;\n import co.elastic.apm.agent.metrics.MetricRegistry;\n \n import java.lang.management.ManagementFactory;\n import java.lang.management.MemoryMXBean;\n+import java.lang.management.MemoryPoolMXBean;\n+import java.lang.management.MemoryType;\n+import java.lang.management.MemoryUsage;\n+import java.util.Arrays;\n+import java.util.List;\n \n public class JvmMemoryMetrics extends AbstractLifecycleListener {\n \n+    public static final List<WildcardMatcher> TENURED_POOL_WILDCARDS = Arrays.asList(\n+        WildcardMatcher.valueOf(\"CMS Old Gen\"),\n+        WildcardMatcher.valueOf(\"PS Old Gen\"),\n+        WildcardMatcher.valueOf(\"G1 Old Gen\"),\n+        WildcardMatcher.valueOf(\"Old Space\"),\n+        WildcardMatcher.valueOf(\"Tenured Gen\"),\n+        WildcardMatcher.valueOf(\"Java heap\"),\n+        WildcardMatcher.valueOf(\"GenPauseless Old Gen\"));\n+\n     @Override\n     public void start(ElasticApmTracer tracer) {\n         bindTo(tracer.getMetricRegistry());\n     }\n \n     void bindTo(final MetricRegistry registry) {\n         final MemoryMXBean platformMXBean = ManagementFactory.getPlatformMXBean(MemoryMXBean.class);\n-        registry.add(\"jvm.memory.heap.used\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getUsed();\n-            }\n-        });\n-        registry.add(\"jvm.memory.heap.committed\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getCommitted();\n+\n+        addUsedMetric(\"jvm.memory.heap.used\", registry, platformMXBean.getHeapMemoryUsage());\n+        addCommittedMetric(\"jvm.memory.heap.committed\", registry, platformMXBean.getHeapMemoryUsage());\n+        addMaxMetric(\"jvm.memory.heap.max\", registry, platformMXBean.getHeapMemoryUsage());\n+        addUsedMetric(\"jvm.memory.non_heap.used\", registry, platformMXBean.getNonHeapMemoryUsage());\n+        addCommittedMetric(\"jvm.memory.non_heap.committed\", registry, platformMXBean.getNonHeapMemoryUsage());\n+        addMaxMetric(\"jvm.memory.non_heap.max\", registry, platformMXBean.getNonHeapMemoryUsage());\n+\n+        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n+\n+        for (MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) {\n+            if (memoryPoolMXBean.getType() != MemoryType.HEAP) {\n+                continue;\n             }\n-        });\n-        registry.add(\"jvm.memory.heap.max\", Labels.EMPTY, new DoubleSupplier() {\n-            @Override\n-            public double get() {\n-                return platformMXBean.getHeapMemoryUsage().getMax();\n+            if (memoryPoolMXBean.getName().contains(\"Eden\")) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExNzA2MA=="}, "originalCommit": {"oid": "05f3635f6f16bbd40ccd53794bdf4acac9602d58"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDgzMDc1OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-grpc/apm-grpc-test-latest/src/test/java/co/elastic/apm/agent/grpc/latest/testapp/generated/HelloGrpc.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMjowNTozOVrOGlsQ4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoyMjo0OFrOGl7FhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE3NTcxNA==", "bodyText": "Why is that related?", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r442175714", "createdAt": "2020-06-18T12:05:39Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-grpc/apm-grpc-test-latest/src/test/java/co/elastic/apm/agent/grpc/latest/testapp/generated/HelloGrpc.java", "diffHunk": "@@ -42,7 +42,7 @@\n /**\n  */\n @javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.29.0)\",\n+    value = \"by gRPC proto compiler (version 1.30.0)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbdecc0ef4595f393ba31a14a12e9db11b327b78"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxODU2NQ==", "bodyText": "It's changed after running tests, I think. Now in the master branch the value is already \"1.30.0\"", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r442418565", "createdAt": "2020-06-18T18:22:48Z", "author": {"login": "kananindzya"}, "path": "apm-agent-plugins/apm-grpc/apm-grpc-test-latest/src/test/java/co/elastic/apm/agent/grpc/latest/testapp/generated/HelloGrpc.java", "diffHunk": "@@ -42,7 +42,7 @@\n /**\n  */\n @javax.annotation.Generated(\n-    value = \"by gRPC proto compiler (version 1.29.0)\",\n+    value = \"by gRPC proto compiler (version 1.30.0)\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE3NTcxNA=="}, "originalCommit": {"oid": "cbdecc0ef4595f393ba31a14a12e9db11b327b78"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDg2MDgxOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMjoxNToxMlrOGlsj3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoyMzowNlrOGl7GHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE4MDU3Mg==", "bodyText": "As these metrics nice-to-have, please surround with try/catch, and either log error on failure or debug on success. It will help us test that we don't break anything on all JVMs we use in the integration tests (including J9)", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r442180572", "createdAt": "2020-06-18T12:15:12Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "diffHunk": "@@ -78,5 +81,32 @@ public double get() {\n                 return platformMXBean.getNonHeapMemoryUsage().getMax();\n             }\n         });\n+\n+        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n+\n+        for (final MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) {\n+            if (memoryPoolMXBean.getType() != MemoryType.HEAP) {\n+                continue;\n+            }\n+            final Labels memoryPoolTags = Labels.Mutable.of(\"type\", memoryPoolMXBean.getName());\n+            registry.add(\"jvm.memory.heap.used\", memoryPoolTags, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    return memoryPoolMXBean.getUsage().getUsed();\n+                }\n+            });\n+            registry.add(\"jvm.memory.heap.committed\", memoryPoolTags, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    return memoryPoolMXBean.getUsage().getCommitted();\n+                }\n+            });\n+            registry.add(\"jvm.memory.heap.max\", memoryPoolTags, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    return memoryPoolMXBean.getUsage().getMax();\n+                }\n+            });\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbdecc0ef4595f393ba31a14a12e9db11b327b78"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxODcxOQ==", "bodyText": "added try/catch", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r442418719", "createdAt": "2020-06-18T18:23:06Z", "author": {"login": "kananindzya"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetrics.java", "diffHunk": "@@ -78,5 +81,32 @@ public double get() {\n                 return platformMXBean.getNonHeapMemoryUsage().getMax();\n             }\n         });\n+\n+        List<MemoryPoolMXBean> memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();\n+\n+        for (final MemoryPoolMXBean memoryPoolMXBean : memoryPoolMXBeans) {\n+            if (memoryPoolMXBean.getType() != MemoryType.HEAP) {\n+                continue;\n+            }\n+            final Labels memoryPoolTags = Labels.Mutable.of(\"type\", memoryPoolMXBean.getName());\n+            registry.add(\"jvm.memory.heap.used\", memoryPoolTags, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    return memoryPoolMXBean.getUsage().getUsed();\n+                }\n+            });\n+            registry.add(\"jvm.memory.heap.committed\", memoryPoolTags, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    return memoryPoolMXBean.getUsage().getCommitted();\n+                }\n+            });\n+            registry.add(\"jvm.memory.heap.max\", memoryPoolTags, new DoubleSupplier() {\n+                @Override\n+                public double get() {\n+                    return memoryPoolMXBean.getUsage().getMax();\n+                }\n+            });\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE4MDU3Mg=="}, "originalCommit": {"oid": "cbdecc0ef4595f393ba31a14a12e9db11b327b78"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNTI2NzYxOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetricsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMzo1MzoxM1rOGtIC0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNjo1OTowMVrOGtLBUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3MDg5OQ==", "bodyText": "Not added by you, but please remove", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r449970899", "createdAt": "2020-07-06T03:53:13Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetricsTest.java", "diffHunk": "@@ -47,7 +53,23 @@ void testMetrics() {\n         assertThat(registry.getGaugeValue(\"jvm.memory.non_heap.used\", Labels.EMPTY)).isNotZero();\n         assertThat(registry.getGaugeValue(\"jvm.memory.non_heap.committed\", Labels.EMPTY)).isNotZero();\n         assertThat(registry.getGaugeValue(\"jvm.memory.non_heap.max\", Labels.EMPTY)).isNotZero();\n+\n+        List<String> memoryPoolNames = getMemoryPoolNames();\n+        for (String memoryPoolName : memoryPoolNames) {\n+            final Labels spaceLabel = Labels.Mutable.of(\"name\", memoryPoolName);\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.used\", spaceLabel)).isNotZero();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.used\", spaceLabel)).isNotNaN();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.committed\", spaceLabel)).isNotZero();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.committed\", spaceLabel)).isNotNaN();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.max\", spaceLabel)).isNotZero();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.max\", spaceLabel)).isNotNaN();\n+        }\n         final long[] longs = new long[1000000];\n         System.out.println(registry.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "620008aafc9e16516e3960ae299579781551ee51"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDAxOTY2Ng==", "bodyText": "removed", "url": "https://github.com/elastic/apm-agent-java/pull/1228#discussion_r450019666", "createdAt": "2020-07-06T06:59:01Z", "author": {"login": "kananindzya"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/metrics/builtin/JvmMemoryMetricsTest.java", "diffHunk": "@@ -47,7 +53,23 @@ void testMetrics() {\n         assertThat(registry.getGaugeValue(\"jvm.memory.non_heap.used\", Labels.EMPTY)).isNotZero();\n         assertThat(registry.getGaugeValue(\"jvm.memory.non_heap.committed\", Labels.EMPTY)).isNotZero();\n         assertThat(registry.getGaugeValue(\"jvm.memory.non_heap.max\", Labels.EMPTY)).isNotZero();\n+\n+        List<String> memoryPoolNames = getMemoryPoolNames();\n+        for (String memoryPoolName : memoryPoolNames) {\n+            final Labels spaceLabel = Labels.Mutable.of(\"name\", memoryPoolName);\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.used\", spaceLabel)).isNotZero();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.used\", spaceLabel)).isNotNaN();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.committed\", spaceLabel)).isNotZero();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.committed\", spaceLabel)).isNotNaN();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.max\", spaceLabel)).isNotZero();\n+            assertThat(registry.getGaugeValue(\"jvm.memory.heap.pool.max\", spaceLabel)).isNotNaN();\n+        }\n         final long[] longs = new long[1000000];\n         System.out.println(registry.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3MDg5OQ=="}, "originalCommit": {"oid": "620008aafc9e16516e3960ae299579781551ee51"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 98, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}