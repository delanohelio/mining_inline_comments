{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MTYyNzQw", "number": 1303, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMDozNDozN1rOEVWxcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNDo1NjoyOFrOEW1D2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODI4NjU5OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMDozNDozN1rOG8D4oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToxMTowNVrOG8OJ_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzMTM5Mw==", "bodyText": "Why was it moved? So it will be invoked even when enabled == false?", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465631393", "createdAt": "2020-08-05T10:34:37Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -198,6 +199,7 @@ public boolean accept(File dir, String name) {\n \n     public static synchronized void initInstrumentation(final ElasticApmTracer tracer, Instrumentation instrumentation,\n                                                         Iterable<ElasticApmInstrumentation> instrumentations) {\n+        GlobalTracer.init(tracer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1be2b2f3a795794f1a5dd6aa3d5f509903c86cc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5OTY3Ng==", "bodyText": "This is to ensure that the global tracer is initialized before instantiating instrumentations. This allows them to call GlobalTracer.requireTracerImpl() on static field declarations. See also MicrometerInstrumentation.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465799676", "createdAt": "2020-08-05T15:11:05Z", "author": {"login": "felixbarny"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -198,6 +199,7 @@ public boolean accept(File dir, String name) {\n \n     public static synchronized void initInstrumentation(final ElasticApmTracer tracer, Instrumentation instrumentation,\n                                                         Iterable<ElasticApmInstrumentation> instrumentations) {\n+        GlobalTracer.init(tracer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzMTM5Mw=="}, "originalCommit": {"oid": "a1be2b2f3a795794f1a5dd6aa3d5f509903c86cc"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODMyOTU4OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/serialize/DslJsonSerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMDo0ODo0OVrOG8ETRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToxMTozNVrOG8OLPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzODIxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < bytes.length; i++) {\n          \n          \n            \n                        jw.writeByte(bytes[i]);\n          \n          \n            \n                    }\n          \n          \n            \n                    jw.writeAscii(bytes);", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465638215", "createdAt": "2020-08-05T10:48:49Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/serialize/DslJsonSerializer.java", "diffHunk": "@@ -256,6 +256,13 @@ public JsonWriter getJsonWriter() {\n         return jw;\n     }\n \n+    @Override\n+    public void writeBytes(byte[] bytes) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            jw.writeByte(bytes[i]);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1be2b2f3a795794f1a5dd6aa3d5f509903c86cc"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5OTk5Ng==", "bodyText": "Perfect, thanks!", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465799996", "createdAt": "2020-08-05T15:11:35Z", "author": {"login": "felixbarny"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/serialize/DslJsonSerializer.java", "diffHunk": "@@ -256,6 +256,13 @@ public JsonWriter getJsonWriter() {\n         return jw;\n     }\n \n+    @Override\n+    public void writeBytes(byte[] bytes) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            jw.writeByte(bytes[i]);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzODIxNQ=="}, "originalCommit": {"oid": "a1be2b2f3a795794f1a5dd6aa3d5f509903c86cc"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODgzNDI0OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMzoxNDo0N1rOG8JINQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToxNDo0NFrOG8OUeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNzMwMQ==", "bodyText": "I didn't understand this comment. Isn't this called for each instance of MeterRegistry?", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465717301", "createdAt": "2020-08-05T13:14:47Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMjM2Mg==", "bodyText": "Yes, but there will be multiple MicrometerMetricsReporters as well. One for each indy plugin class loader.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465802362", "createdAt": "2020-08-05T15:14:44Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNzMwMQ=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODg3MzcwOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMzoyNDozM1rOG8Jgcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMjo1MjozOVrOG8yIqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcyMzUwNg==", "bodyText": "I think the JsonWriter would fit in the serializer better", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465723506", "createdAt": "2020-08-05T13:24:33Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMTQ3Ng==", "bodyText": "Hm, good point. Currently, all methods are static which would need to change but that's not a bad thing.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465801476", "createdAt": "2020-08-05T15:13:32Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcyMzUwNg=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM4OTE2Mw==", "bodyText": "done", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466389163", "createdAt": "2020-08-06T12:52:39Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcyMzUwNg=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODk1Mjg3OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "isResolved": true, "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMzo0Mzo0OFrOG8KSvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMDoxNToyOVrOG-Iyfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA==", "bodyText": "If the JsonWriter is a field of the serializer, the serialize method can return the byte array.\nWhy did you decide to deviate from our usual reporting flow, where we serialize directly to the connection socket?", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465736380", "createdAt": "2020-08-05T13:43:48Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNjA0Nw==", "bodyText": "One reason is to make sure that metrics are serialized at a more consistent rate. Currently, the serialization is delayed until the event is consumed from the disruptor. That's something we have thought about doing for the our internal metrics registry as well.\nAnother reason is that I didn't want to add a micrometer specific event type for the disruptor. But we could introduce an interface that allows writing to the OutputStream.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465806047", "createdAt": "2020-08-05T15:19:46Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0NzgyNw==", "bodyText": "Yes, we discussed that and I actually think this approach is superior, it's just the inconsistency between the two registries. I would change the internal metrics to be done in this way as well (it even makes more sense there where we flip phase on the disruptor thread). With this new byte[] reporting event and API, it should be an easy change. Doesn't have to be in this PR though.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466147827", "createdAt": "2020-08-06T05:03:39Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI2MzA5Mw==", "bodyText": "do you think we should have a way to recycle these byte arrays or, as reporting happens at a fixed rate that's not dependant on the throughput of the app, it's fine to just allocate?", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466263093", "createdAt": "2020-08-06T09:15:38Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMxMDkzNA==", "bodyText": "As long as it is used for metrics, meaning allocated once per second or more, garbage collection will not be an issue. Keeping such an array we always hold the biggest array that was used so far and cannot be reclaimed (and now when we use if for Micrometer I guess it may have spikes).\nHaving said that, this is what the JsonWriter is doing already, so it does seem wasteful to duplicate. So it seems whatever we decide (allocate or recycle) should be done should be done through JsonWriter objects, eventually relying on the com.dslplatform.json.JsonWriter#toStream method to write directly to the connection socket, thus avoid additional allocation. WDYT?", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466310934", "createdAt": "2020-08-06T10:14:32Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyMTczMg==", "bodyText": "I'd expect the total size of the metrics to be relatively stable. JsonWriter#toStream sounds tempting but it would imply that you can't do another report before the bytes of the previous report have been written out. This can be problematic if APM Server is down for a couple of minutes. By copying the bytes via JsonWriter#toByteArray, all the data from the period where APM Server was down will be sent when it's back up again.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466321732", "createdAt": "2020-08-06T10:36:24Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyMzk2NA==", "bodyText": "What I was suggesting is to either create a new one every time (instead of byte[]) or recycle (instead of byte[])", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466323964", "createdAt": "2020-08-06T10:41:03Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjMyNTkyMA==", "bodyText": "I'd expect the total size of the metrics to be relatively stable\n\nBased on your docs, people may use it so report some high-cardinality metric keys", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466325920", "createdAt": "2020-08-06T10:44:54Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM4NjE4NA==", "bodyText": "Yup, high cardinality keys can be problematic but still, I think that the size of one report vs another one would be relatively stable.\n\nWhat I was suggesting is to either create a new one every time (instead of byte[]) or recycle (instead of byte[])\n\nI see what you're saying. One issue I see with the approach of using a new byte[] every time is that it'll have to discard lots of arrays when it resizes from the initial buffer size.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466386184", "createdAt": "2020-08-06T12:47:26Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxMzI0Mw==", "bodyText": "One issue I see with the approach of using a new byte[] every time is that it'll have to discard lots of arrays when it resizes from the initial buffer size.\n\nI think the eventual allocation and copy of the entire byte array is not necessary in any case, so I suggest one of two options:\n\nAllocate a JsonWriter every time, using the size from last time (or maximum size so far) as the initial capacity\nRecycle JsonWriters\n\nWould that work?", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466413243", "createdAt": "2020-08-06T13:30:32Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxNTQ3Mw==", "bodyText": "Thanks for switching the internal metrics to be the same! \u2764\ufe0f", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466415473", "createdAt": "2020-08-06T13:33:56Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwODYzMw==", "bodyText": "I went with option 1. I'm using the size of the previous serialization plus a buffer of 25%. This is to avoid situations where we have to resize just because the actual size requirement is slightly higher which may be just due to the fact that on one report the gauges have more floating points (like 1.0 vs 1.00000001).", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r467808633", "createdAt": "2020-08-10T10:14:56Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgwODg5NA==", "bodyText": "Option 2 can be implemented later on top of option 1 if needed.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r467808894", "createdAt": "2020-08-10T10:15:29Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/main/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.report.Reporter;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentSet;\n+import com.dslplatform.json.DslJson;\n+import com.dslplatform.json.JsonWriter;\n+import io.micrometer.core.instrument.Meter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+public class MicrometerMetricsReporter implements Runnable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MicrometerMetricsReporter.class);\n+\n+    private final WeakConcurrentSet<MeterRegistry> meterRegistries = WeakMapSupplier.createSet();\n+    private final StringBuilder replaceBuilder = new StringBuilder();\n+    private final JsonWriter jsonWriter = new DslJson<>(new DslJson.Settings<>()).newWriter();\n+    private final Reporter reporter;\n+    private final ElasticApmTracer tracer;\n+    private boolean scheduledReporting = false;\n+\n+    public MicrometerMetricsReporter(ElasticApmTracer tracer) {\n+        this.tracer = tracer;\n+        this.reporter = tracer.getReporter();\n+    }\n+\n+    public void registerMeterRegistry(MeterRegistry meterRegistry) {\n+        if (meterRegistry instanceof CompositeMeterRegistry) {\n+            return;\n+        }\n+        boolean added = meterRegistries.add(meterRegistry);\n+        if (added) {\n+            logger.info(\"Registering Micrometer MeterRegistry: {}\", meterRegistry);\n+            scheduleReporting();\n+        }\n+    }\n+\n+    private synchronized void scheduleReporting() {\n+        if (scheduledReporting) {\n+            return;\n+        }\n+        scheduledReporting = true;\n+        long metricsIntervalMs = tracer.getConfig(ReporterConfiguration.class).getMetricsIntervalMs();\n+        if (metricsIntervalMs > 0) {\n+            // called for every class loader that loaded micrometer\n+            tracer.getSharedSingleThreadedPool().scheduleAtFixedRate(this, metricsIntervalMs, metricsIntervalMs, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    // guaranteed to be invoked by a single thread\n+    @Override\n+    public void run() {\n+        if (tracer.getState() != Tracer.TracerState.RUNNING) {\n+            return;\n+        }\n+        final long timestamp = System.currentTimeMillis() * 1000;\n+        MeterMapConsumer meterConsumer = new MeterMapConsumer();\n+        for (MeterRegistry registry : meterRegistries) {\n+            registry.forEachMeter(meterConsumer);\n+        }\n+        logger.debug(\"Reporting {} meters\", meterConsumer.meters.size());\n+        MicrometerMeterRegistrySerializer.serialize(meterConsumer.meters, timestamp, replaceBuilder, jsonWriter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTczNjM4MA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTA0MjM4OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-micrometer-plugin/src/test/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporterTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDowNDozMlrOG8LLWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMjo1MjoyOFrOG8yIPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MDg3NA==", "bodyText": "Assert that only the non-composite was registered", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465750874", "createdAt": "2020-08-05T14:04:32Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/test/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporterTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.MockReporter;\n+import co.elastic.apm.agent.MockTracer;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.micrometer.core.instrument.Clock;\n+import io.micrometer.core.instrument.DistributionSummary;\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.FunctionTimer;\n+import io.micrometer.core.instrument.LongTaskTimer;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.MockClock;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Timer;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import io.micrometer.core.instrument.simple.CountingMode;\n+import io.micrometer.core.instrument.simple.SimpleConfig;\n+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.annotation.Nonnull;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+\n+class MicrometerMetricsReporterTest {\n+\n+    private MeterRegistry meterRegistry;\n+    private MicrometerMetricsReporter metricsReporter;\n+    private MockReporter reporter;\n+    private ObjectMapper objectMapper = new ObjectMapper();\n+\n+    @BeforeEach\n+    void setUp() {\n+        SimpleMeterRegistry simpleMeterRegistry = new SimpleMeterRegistry();\n+        CompositeMeterRegistry nestedCompositeMeterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(simpleMeterRegistry));\n+        meterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(nestedCompositeMeterRegistry));\n+        reporter = new MockReporter();\n+        ElasticApmTracer tracer = MockTracer.createRealTracer(reporter);\n+        doReturn(0L).when(tracer.getConfig(ReporterConfiguration.class)).getMetricsIntervalMs();\n+        metricsReporter = new MicrometerMetricsReporter(tracer);\n+        metricsReporter.registerMeterRegistry(meterRegistry);\n+        metricsReporter.registerMeterRegistry(nestedCompositeMeterRegistry);\n+        metricsReporter.registerMeterRegistry(simpleMeterRegistry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNzEwNg==", "bodyText": "The de-duplication doesn't rely on CompositeMeterRegistrys to be ignored. It's just a slight optimization. The deduplication happens by putting the metrics to a map with the Meter.Id as the key.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465807106", "createdAt": "2020-08-05T15:21:16Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/test/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporterTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.MockReporter;\n+import co.elastic.apm.agent.MockTracer;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.micrometer.core.instrument.Clock;\n+import io.micrometer.core.instrument.DistributionSummary;\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.FunctionTimer;\n+import io.micrometer.core.instrument.LongTaskTimer;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.MockClock;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Timer;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import io.micrometer.core.instrument.simple.CountingMode;\n+import io.micrometer.core.instrument.simple.SimpleConfig;\n+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.annotation.Nonnull;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+\n+class MicrometerMetricsReporterTest {\n+\n+    private MeterRegistry meterRegistry;\n+    private MicrometerMetricsReporter metricsReporter;\n+    private MockReporter reporter;\n+    private ObjectMapper objectMapper = new ObjectMapper();\n+\n+    @BeforeEach\n+    void setUp() {\n+        SimpleMeterRegistry simpleMeterRegistry = new SimpleMeterRegistry();\n+        CompositeMeterRegistry nestedCompositeMeterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(simpleMeterRegistry));\n+        meterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(nestedCompositeMeterRegistry));\n+        reporter = new MockReporter();\n+        ElasticApmTracer tracer = MockTracer.createRealTracer(reporter);\n+        doReturn(0L).when(tracer.getConfig(ReporterConfiguration.class)).getMetricsIntervalMs();\n+        metricsReporter = new MicrometerMetricsReporter(tracer);\n+        metricsReporter.registerMeterRegistry(meterRegistry);\n+        metricsReporter.registerMeterRegistry(nestedCompositeMeterRegistry);\n+        metricsReporter.registerMeterRegistry(simpleMeterRegistry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MDg3NA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0ODcyNQ==", "bodyText": "I generally like to assert on anything we have code for, just to know what we intend to happen actually happens, especially if it's real easy. Won't insist on it though \ud83d\ude42", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466148725", "createdAt": "2020-08-06T05:06:56Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/test/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporterTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.MockReporter;\n+import co.elastic.apm.agent.MockTracer;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.micrometer.core.instrument.Clock;\n+import io.micrometer.core.instrument.DistributionSummary;\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.FunctionTimer;\n+import io.micrometer.core.instrument.LongTaskTimer;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.MockClock;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Timer;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import io.micrometer.core.instrument.simple.CountingMode;\n+import io.micrometer.core.instrument.simple.SimpleConfig;\n+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.annotation.Nonnull;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+\n+class MicrometerMetricsReporterTest {\n+\n+    private MeterRegistry meterRegistry;\n+    private MicrometerMetricsReporter metricsReporter;\n+    private MockReporter reporter;\n+    private ObjectMapper objectMapper = new ObjectMapper();\n+\n+    @BeforeEach\n+    void setUp() {\n+        SimpleMeterRegistry simpleMeterRegistry = new SimpleMeterRegistry();\n+        CompositeMeterRegistry nestedCompositeMeterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(simpleMeterRegistry));\n+        meterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(nestedCompositeMeterRegistry));\n+        reporter = new MockReporter();\n+        ElasticApmTracer tracer = MockTracer.createRealTracer(reporter);\n+        doReturn(0L).when(tracer.getConfig(ReporterConfiguration.class)).getMetricsIntervalMs();\n+        metricsReporter = new MicrometerMetricsReporter(tracer);\n+        metricsReporter.registerMeterRegistry(meterRegistry);\n+        metricsReporter.registerMeterRegistry(nestedCompositeMeterRegistry);\n+        metricsReporter.registerMeterRegistry(simpleMeterRegistry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MDg3NA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM4OTA1NQ==", "bodyText": "done", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466389055", "createdAt": "2020-08-06T12:52:28Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-micrometer-plugin/src/test/java/co/elastic/apm/agent/micrometer/MicrometerMetricsReporterTest.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.micrometer;\n+\n+import co.elastic.apm.agent.MockReporter;\n+import co.elastic.apm.agent.MockTracer;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.report.ReporterConfiguration;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.micrometer.core.instrument.Clock;\n+import io.micrometer.core.instrument.DistributionSummary;\n+import io.micrometer.core.instrument.FunctionCounter;\n+import io.micrometer.core.instrument.FunctionTimer;\n+import io.micrometer.core.instrument.LongTaskTimer;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.MockClock;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Timer;\n+import io.micrometer.core.instrument.composite.CompositeMeterRegistry;\n+import io.micrometer.core.instrument.simple.CountingMode;\n+import io.micrometer.core.instrument.simple.SimpleConfig;\n+import io.micrometer.core.instrument.simple.SimpleMeterRegistry;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.annotation.Nonnull;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+\n+class MicrometerMetricsReporterTest {\n+\n+    private MeterRegistry meterRegistry;\n+    private MicrometerMetricsReporter metricsReporter;\n+    private MockReporter reporter;\n+    private ObjectMapper objectMapper = new ObjectMapper();\n+\n+    @BeforeEach\n+    void setUp() {\n+        SimpleMeterRegistry simpleMeterRegistry = new SimpleMeterRegistry();\n+        CompositeMeterRegistry nestedCompositeMeterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(simpleMeterRegistry));\n+        meterRegistry = new CompositeMeterRegistry(Clock.SYSTEM, List.of(nestedCompositeMeterRegistry));\n+        reporter = new MockReporter();\n+        ElasticApmTracer tracer = MockTracer.createRealTracer(reporter);\n+        doReturn(0L).when(tracer.getConfig(ReporterConfiguration.class)).getMetricsIntervalMs();\n+        metricsReporter = new MicrometerMetricsReporter(tracer);\n+        metricsReporter.registerMeterRegistry(meterRegistry);\n+        metricsReporter.registerMeterRegistry(nestedCompositeMeterRegistry);\n+        metricsReporter.registerMeterRegistry(simpleMeterRegistry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1MDg3NA=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTE0OTM4OnYy", "diffSide": "RIGHT", "path": "docs/metrics.asciidoc", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDoyNzoyN1rOG8MN4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMzozMjowOFrOG8zq8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NzkwNw==", "bodyText": "You mean- using the same labels for the event and the meter? Try to make it more explicit.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465767907", "createdAt": "2020-08-05T14:27:27Z", "author": {"login": "eyalkoren"}, "path": "docs/metrics.asciidoc", "diffHunk": "@@ -277,3 +282,173 @@ You can filter and group by these dimensions:\n * `span.subtype`: The sub-type of the span, for example `mysql` (optional)\n \n --\n+\n+\n+[float]\n+[[metrics-micrometer]]\n+=== Custom metrics using Micrometer\n+\n+The Elastic APM Java agent lets you use the popular metrics collection framework https://micrometer.io/[Micrometer] to track custom application metrics.\n+\n+Some use cases for tracking custom metrics from your application include monitoring performance-related things like cache statistics, thread pools, or page hits.\n+However, you can also track business-related metrics such as revenue and correlate them with performance metrics.\n+Metrics registered to a Micrometer `MeterRegistry` are aggregated in memory and reported every <<config-metrics-interval, `metrics_interval`>>.\n+Based on the metadata about the service and the timestamp, you can correlate metrics with traces.\n+However, you won't be able to attribute a value to a specific transaction or to a user.\n+If you'd like to do that, have a look at the <<api-transaction-add-tag>> API method instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwOTI3Mg==", "bodyText": "No, what I was trying to say is that if you want to correlate to individual events don't use metrics or micrometer at all. Instead, add labels to the transaction. But then you either have to do 100% sampling or account for the missing events.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r465809272", "createdAt": "2020-08-05T15:24:19Z", "author": {"login": "felixbarny"}, "path": "docs/metrics.asciidoc", "diffHunk": "@@ -277,3 +282,173 @@ You can filter and group by these dimensions:\n * `span.subtype`: The sub-type of the span, for example `mysql` (optional)\n \n --\n+\n+\n+[float]\n+[[metrics-micrometer]]\n+=== Custom metrics using Micrometer\n+\n+The Elastic APM Java agent lets you use the popular metrics collection framework https://micrometer.io/[Micrometer] to track custom application metrics.\n+\n+Some use cases for tracking custom metrics from your application include monitoring performance-related things like cache statistics, thread pools, or page hits.\n+However, you can also track business-related metrics such as revenue and correlate them with performance metrics.\n+Metrics registered to a Micrometer `MeterRegistry` are aggregated in memory and reported every <<config-metrics-interval, `metrics_interval`>>.\n+Based on the metadata about the service and the timestamp, you can correlate metrics with traces.\n+However, you won't be able to attribute a value to a specific transaction or to a user.\n+If you'd like to do that, have a look at the <<api-transaction-add-tag>> API method instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NzkwNw=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0OTE5Ng==", "bodyText": "Then I suggest explaining this a bit clearer.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466149196", "createdAt": "2020-08-06T05:08:55Z", "author": {"login": "eyalkoren"}, "path": "docs/metrics.asciidoc", "diffHunk": "@@ -277,3 +282,173 @@ You can filter and group by these dimensions:\n * `span.subtype`: The sub-type of the span, for example `mysql` (optional)\n \n --\n+\n+\n+[float]\n+[[metrics-micrometer]]\n+=== Custom metrics using Micrometer\n+\n+The Elastic APM Java agent lets you use the popular metrics collection framework https://micrometer.io/[Micrometer] to track custom application metrics.\n+\n+Some use cases for tracking custom metrics from your application include monitoring performance-related things like cache statistics, thread pools, or page hits.\n+However, you can also track business-related metrics such as revenue and correlate them with performance metrics.\n+Metrics registered to a Micrometer `MeterRegistry` are aggregated in memory and reported every <<config-metrics-interval, `metrics_interval`>>.\n+Based on the metadata about the service and the timestamp, you can correlate metrics with traces.\n+However, you won't be able to attribute a value to a specific transaction or to a user.\n+If you'd like to do that, have a look at the <<api-transaction-add-tag>> API method instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NzkwNw=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjM4ODk5Nw==", "bodyText": "I rephrased it. Hope it's clearer now.", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466388997", "createdAt": "2020-08-06T12:52:21Z", "author": {"login": "felixbarny"}, "path": "docs/metrics.asciidoc", "diffHunk": "@@ -277,3 +282,173 @@ You can filter and group by these dimensions:\n * `span.subtype`: The sub-type of the span, for example `mysql` (optional)\n \n --\n+\n+\n+[float]\n+[[metrics-micrometer]]\n+=== Custom metrics using Micrometer\n+\n+The Elastic APM Java agent lets you use the popular metrics collection framework https://micrometer.io/[Micrometer] to track custom application metrics.\n+\n+Some use cases for tracking custom metrics from your application include monitoring performance-related things like cache statistics, thread pools, or page hits.\n+However, you can also track business-related metrics such as revenue and correlate them with performance metrics.\n+Metrics registered to a Micrometer `MeterRegistry` are aggregated in memory and reported every <<config-metrics-interval, `metrics_interval`>>.\n+Based on the metadata about the service and the timestamp, you can correlate metrics with traces.\n+However, you won't be able to attribute a value to a specific transaction or to a user.\n+If you'd like to do that, have a look at the <<api-transaction-add-tag>> API method instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NzkwNw=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQxNDMyMg==", "bodyText": "It's perfect", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r466414322", "createdAt": "2020-08-06T13:32:08Z", "author": {"login": "eyalkoren"}, "path": "docs/metrics.asciidoc", "diffHunk": "@@ -277,3 +282,173 @@ You can filter and group by these dimensions:\n * `span.subtype`: The sub-type of the span, for example `mysql` (optional)\n \n --\n+\n+\n+[float]\n+[[metrics-micrometer]]\n+=== Custom metrics using Micrometer\n+\n+The Elastic APM Java agent lets you use the popular metrics collection framework https://micrometer.io/[Micrometer] to track custom application metrics.\n+\n+Some use cases for tracking custom metrics from your application include monitoring performance-related things like cache statistics, thread pools, or page hits.\n+However, you can also track business-related metrics such as revenue and correlate them with performance metrics.\n+Metrics registered to a Micrometer `MeterRegistry` are aggregated in memory and reported every <<config-metrics-interval, `metrics_interval`>>.\n+Based on the metadata about the service and the timestamp, you can correlate metrics with traces.\n+However, you won't be able to attribute a value to a specific transaction or to a user.\n+If you'd like to do that, have a look at the <<api-transaction-add-tag>> API method instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NzkwNw=="}, "originalCommit": {"oid": "e65cdfac0d284eb67a3675f07ff7e1c26ddceff9"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMzczNDY2OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/IntakeV2ReportingEventHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNDo1NjoyOFrOG-SMSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNDo1NjoyOFrOG-SMSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2Mjk1Mg==", "bodyText": "Ahh, getByteBuffer is good as well \ud83d\udc4d", "url": "https://github.com/elastic/apm-agent-java/pull/1303#discussion_r467962952", "createdAt": "2020-08-10T14:56:28Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/IntakeV2ReportingEventHandler.java", "diffHunk": "@@ -136,20 +135,8 @@ private void writeEvent(ReportingEvent event) {\n         } else if (event.getError() != null) {\n             currentlyTransmitting++;\n             payloadSerializer.serializeErrorNdJson(event.getError());\n-        } else if (event.getMetricRegistry() != null) {\n-            payloadSerializer.serializeMetrics(event.getMetricRegistry());\n-        }\n-    }\n-\n-    /**\n-     * Should be called whenever {@link IntakeV2ReportingEventHandler#writeEvent(ReportingEvent)} is not called for\n-     * an event that should normally be written.\n-     *\n-     * @param event the event to end\n-     */\n-    private void handleNonWrittenEvent(ReportingEvent event) {\n-        if (event.getMetricRegistry() != null) {\n-            event.getMetricRegistry().flipPhaseAndReport(null);\n+        } else if (event.getJsonWriter() != null) {\n+            payloadSerializer.writeBytes(event.getJsonWriter().getByteBuffer(), event.getJsonWriter().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d46724ec5c83bb51a83417b5d1794b44fea62da9"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 168, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}