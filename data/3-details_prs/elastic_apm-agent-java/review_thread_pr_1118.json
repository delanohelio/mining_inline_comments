{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NDc2NzI4", "number": 1118, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDowNzoyOVrODt4oVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDozMDoxOVrODt5GUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDQwMzQzOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDowNzoyOVrOF_kTRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDowNzoyOVrOF_kTRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5OTM2NA==", "bodyText": "\ud83d\ude3b", "url": "https://github.com/elastic/apm-agent-java/pull/1118#discussion_r402199364", "createdAt": "2020-04-02T10:07:29Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "diffHunk": "@@ -74,104 +97,237 @@ public void tearDown() {\n \n     @Test\n     void testStressSimulation() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // see that the tracer remains inactive for another couple of polls\n-        pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n     @Test\n     void testTwoMonitors() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n \n         TestStressMonitor secondMonitor = new TestStressMonitor(tracer);\n         circuitBreaker.registerStressMonitor(secondMonitor);\n \n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertRunning();\n+\n+        // adding stress from a single monitor should pause tracer\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // adding stress from a second monitor should not resume tracer\n+        secondMonitor.simulateStress();\n \n-        pollCount = secondMonitor.simulateStress();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n+\n+        simulateReliefAndWaitPoll(monitor);\n \n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode, until ALL monitors allow resuming\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n \n-        pollCount = secondMonitor.simulateStressRelieved();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        simulateReliefAndWaitPoll(secondMonitor);\n+\n+        assertRunning();\n \n         circuitBreaker.unregisterStressMonitor(secondMonitor);\n     }\n \n+    private static void simulateReliefAndWaitPoll(TestStressMonitor monitor){\n+        awaitHasBeenPolled(monitor, monitor.simulateStressRelieved());\n+    }\n+\n+    private static void awaitHasBeenPolled(TestStressMonitor monitor, final int pollCount) {\n+        awaitAssert(() -> assertThat(monitor.getPollCount()).isGreaterThan(pollCount + 1));\n+    }\n+\n+\n     @Test\n-    void testStressReliefThenReactivate() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+    void testPauseThroughConfigUnderStressThenResumeThroughConfig() throws IOException, InterruptedException {\n+        // stress pauses when recording enabled\n+        // timeline   1  2  3  4  5\n+        // stress     ---sssssss-----\n+        // recording  xxxxxx------xxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // 3 recording = false under stress should not change state\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        // should still be PAUSED as the state is inactive\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertState(this::assertPaused);\n+\n+        // 4 stress ends, should still be paused due to recording = false\n+        monitor.simulateStressRelieved();\n+        assertState(this::assertPaused);\n+\n+        // 5\n+        // configuration recording = true should make it run again\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        awaitRunning();\n     }\n \n     @Test\n-    void testReactivateThenStressRelief() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+    void testPauseThroughConfigThenResumeOnlyWhenStressRelieved() throws IOException, InterruptedException {\n+        // enable recording while under stress does not trigger runnable state\n+        // timeline   1  2  3  4  5\n+        // stress     ------ssssss----\n+        // recording  xxx------xxxxxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2 recording = false should pause\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        awaitPaused();\n+\n+        // 3 stress should keep it paused\n         monitor.simulateStress();\n+        assertState(this::assertPaused);\n+\n+        // 4 should not resume tracer as we are under stress\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        // check that reactivation now has no effect even after waiting for the next resume poll\n-        int pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // check that stress relief now reactivates\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertState(this::assertPaused);\n+\n+        // 5 stress relief now resumes tracer\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n+\n     @Test\n     void testCircuitBreakerDisabled() throws IOException, InterruptedException {\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertThat(circuitBreakerConfiguration.isCircuitBreakerEnabled()).isFalse();\n+\n+        assertRunning();\n+\n         monitor.simulateStress();\n-        Thread.sleep(50);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertState(this::assertRunning);\n+\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertRunning();\n     }\n \n     @Test\n-    void testResumeWhenDisabledUnderStress() throws InterruptedException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n+    void testResumeWhenDisabledUnderStress() {\n+\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(false);\n+        awaitRunning();\n+    }\n+\n+    private void awaitPaused() {\n+        awaitAssert(this::assertPaused);\n+    }\n+\n+    private void assertRunning() {\n         assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n+    }\n+\n+    private void awaitRunning() {\n+        awaitAssert(this::assertRunning);\n+    }\n+\n+    private void assertPaused() {\n         assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        doReturn(false).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        Thread.sleep(50);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+    }\n+\n+    private void assertState(Runnable assertion) throws InterruptedException {\n+        for (long i = 0; i < 10; i++) {\n+            assertion.run();\n+            Thread.sleep(1);\n+        }\n+        assertion.run();\n+    }\n+\n+    private static void awaitAssert(ThrowingRunnable assertion) {\n+        doAwait().untilAsserted(assertion);\n+    }\n+\n+    private static ConditionFactory doAwait() {\n+        return await()\n+            .pollInterval(1, TimeUnit.MILLISECONDS)\n+            .timeout(50, TimeUnit.MILLISECONDS);\n+\n+    }\n+\n+\n+    /**\n+     * We have to use a thread-safe wrapper because sharing mocked/stubbed classes\n+     */\n+    private static class ConfigThreadSafeWrapper extends CircuitBreakerConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f90d3369a358e2d6b71f192a5225f7ddfe1824b5"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDQ3MTUxOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDoyNzo0NFrOF_k-gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDoyNzo0NFrOF_k-gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxMDQzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    monitor.simulateStress();\n          \n          \n            \n                    monitor. simulateStressAndWaitPoll();", "url": "https://github.com/elastic/apm-agent-java/pull/1118#discussion_r402210433", "createdAt": "2020-04-02T10:27:44Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "diffHunk": "@@ -74,104 +97,237 @@ public void tearDown() {\n \n     @Test\n     void testStressSimulation() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // see that the tracer remains inactive for another couple of polls\n-        pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n     @Test\n     void testTwoMonitors() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n \n         TestStressMonitor secondMonitor = new TestStressMonitor(tracer);\n         circuitBreaker.registerStressMonitor(secondMonitor);\n \n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertRunning();\n+\n+        // adding stress from a single monitor should pause tracer\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // adding stress from a second monitor should not resume tracer\n+        secondMonitor.simulateStress();\n \n-        pollCount = secondMonitor.simulateStress();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n+\n+        simulateReliefAndWaitPoll(monitor);\n \n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode, until ALL monitors allow resuming\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n \n-        pollCount = secondMonitor.simulateStressRelieved();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        simulateReliefAndWaitPoll(secondMonitor);\n+\n+        assertRunning();\n \n         circuitBreaker.unregisterStressMonitor(secondMonitor);\n     }\n \n+    private static void simulateReliefAndWaitPoll(TestStressMonitor monitor){\n+        awaitHasBeenPolled(monitor, monitor.simulateStressRelieved());\n+    }\n+\n+    private static void awaitHasBeenPolled(TestStressMonitor monitor, final int pollCount) {\n+        awaitAssert(() -> assertThat(monitor.getPollCount()).isGreaterThan(pollCount + 1));\n+    }\n+\n+\n     @Test\n-    void testStressReliefThenReactivate() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+    void testPauseThroughConfigUnderStressThenResumeThroughConfig() throws IOException, InterruptedException {\n+        // stress pauses when recording enabled\n+        // timeline   1  2  3  4  5\n+        // stress     ---sssssss-----\n+        // recording  xxxxxx------xxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // 3 recording = false under stress should not change state\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        // should still be PAUSED as the state is inactive\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertState(this::assertPaused);\n+\n+        // 4 stress ends, should still be paused due to recording = false\n+        monitor.simulateStressRelieved();\n+        assertState(this::assertPaused);\n+\n+        // 5\n+        // configuration recording = true should make it run again\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        awaitRunning();\n     }\n \n     @Test\n-    void testReactivateThenStressRelief() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+    void testPauseThroughConfigThenResumeOnlyWhenStressRelieved() throws IOException, InterruptedException {\n+        // enable recording while under stress does not trigger runnable state\n+        // timeline   1  2  3  4  5\n+        // stress     ------ssssss----\n+        // recording  xxx------xxxxxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2 recording = false should pause\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        awaitPaused();\n+\n+        // 3 stress should keep it paused\n         monitor.simulateStress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f90d3369a358e2d6b71f192a5225f7ddfe1824b5"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDQ3Njg4OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDoyOToyMFrOF_lBzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDoyOToyMFrOF_lBzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxMTI3Nw==", "bodyText": "You need to awaitPoll somehow. It doesn't make sense to assert that the state remained the same without that.", "url": "https://github.com/elastic/apm-agent-java/pull/1118#discussion_r402211277", "createdAt": "2020-04-02T10:29:20Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "diffHunk": "@@ -74,104 +97,237 @@ public void tearDown() {\n \n     @Test\n     void testStressSimulation() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // see that the tracer remains inactive for another couple of polls\n-        pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n     @Test\n     void testTwoMonitors() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n \n         TestStressMonitor secondMonitor = new TestStressMonitor(tracer);\n         circuitBreaker.registerStressMonitor(secondMonitor);\n \n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertRunning();\n+\n+        // adding stress from a single monitor should pause tracer\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // adding stress from a second monitor should not resume tracer\n+        secondMonitor.simulateStress();\n \n-        pollCount = secondMonitor.simulateStress();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n+\n+        simulateReliefAndWaitPoll(monitor);\n \n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode, until ALL monitors allow resuming\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n \n-        pollCount = secondMonitor.simulateStressRelieved();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        simulateReliefAndWaitPoll(secondMonitor);\n+\n+        assertRunning();\n \n         circuitBreaker.unregisterStressMonitor(secondMonitor);\n     }\n \n+    private static void simulateReliefAndWaitPoll(TestStressMonitor monitor){\n+        awaitHasBeenPolled(monitor, monitor.simulateStressRelieved());\n+    }\n+\n+    private static void awaitHasBeenPolled(TestStressMonitor monitor, final int pollCount) {\n+        awaitAssert(() -> assertThat(monitor.getPollCount()).isGreaterThan(pollCount + 1));\n+    }\n+\n+\n     @Test\n-    void testStressReliefThenReactivate() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+    void testPauseThroughConfigUnderStressThenResumeThroughConfig() throws IOException, InterruptedException {\n+        // stress pauses when recording enabled\n+        // timeline   1  2  3  4  5\n+        // stress     ---sssssss-----\n+        // recording  xxxxxx------xxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // 3 recording = false under stress should not change state\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        // should still be PAUSED as the state is inactive\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertState(this::assertPaused);\n+\n+        // 4 stress ends, should still be paused due to recording = false\n+        monitor.simulateStressRelieved();\n+        assertState(this::assertPaused);\n+\n+        // 5\n+        // configuration recording = true should make it run again\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        awaitRunning();\n     }\n \n     @Test\n-    void testReactivateThenStressRelief() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+    void testPauseThroughConfigThenResumeOnlyWhenStressRelieved() throws IOException, InterruptedException {\n+        // enable recording while under stress does not trigger runnable state\n+        // timeline   1  2  3  4  5\n+        // stress     ------ssssss----\n+        // recording  xxx------xxxxxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2 recording = false should pause\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        awaitPaused();\n+\n+        // 3 stress should keep it paused\n         monitor.simulateStress();\n+        assertState(this::assertPaused);\n+\n+        // 4 should not resume tracer as we are under stress\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        // check that reactivation now has no effect even after waiting for the next resume poll\n-        int pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // check that stress relief now reactivates\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertState(this::assertPaused);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f90d3369a358e2d6b71f192a5225f7ddfe1824b5"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDQ3OTE4OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDozMDowMVrOF_lDRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDozMDowMVrOF_lDRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxMTY1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertState(this::assertRunning);\n          \n          \n            \n                    assertRunning();", "url": "https://github.com/elastic/apm-agent-java/pull/1118#discussion_r402211655", "createdAt": "2020-04-02T10:30:01Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "diffHunk": "@@ -74,104 +97,237 @@ public void tearDown() {\n \n     @Test\n     void testStressSimulation() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // see that the tracer remains inactive for another couple of polls\n-        pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n     @Test\n     void testTwoMonitors() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n \n         TestStressMonitor secondMonitor = new TestStressMonitor(tracer);\n         circuitBreaker.registerStressMonitor(secondMonitor);\n \n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertRunning();\n+\n+        // adding stress from a single monitor should pause tracer\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // adding stress from a second monitor should not resume tracer\n+        secondMonitor.simulateStress();\n \n-        pollCount = secondMonitor.simulateStress();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n+\n+        simulateReliefAndWaitPoll(monitor);\n \n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode, until ALL monitors allow resuming\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n \n-        pollCount = secondMonitor.simulateStressRelieved();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        simulateReliefAndWaitPoll(secondMonitor);\n+\n+        assertRunning();\n \n         circuitBreaker.unregisterStressMonitor(secondMonitor);\n     }\n \n+    private static void simulateReliefAndWaitPoll(TestStressMonitor monitor){\n+        awaitHasBeenPolled(monitor, monitor.simulateStressRelieved());\n+    }\n+\n+    private static void awaitHasBeenPolled(TestStressMonitor monitor, final int pollCount) {\n+        awaitAssert(() -> assertThat(monitor.getPollCount()).isGreaterThan(pollCount + 1));\n+    }\n+\n+\n     @Test\n-    void testStressReliefThenReactivate() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+    void testPauseThroughConfigUnderStressThenResumeThroughConfig() throws IOException, InterruptedException {\n+        // stress pauses when recording enabled\n+        // timeline   1  2  3  4  5\n+        // stress     ---sssssss-----\n+        // recording  xxxxxx------xxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // 3 recording = false under stress should not change state\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        // should still be PAUSED as the state is inactive\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertState(this::assertPaused);\n+\n+        // 4 stress ends, should still be paused due to recording = false\n+        monitor.simulateStressRelieved();\n+        assertState(this::assertPaused);\n+\n+        // 5\n+        // configuration recording = true should make it run again\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        awaitRunning();\n     }\n \n     @Test\n-    void testReactivateThenStressRelief() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+    void testPauseThroughConfigThenResumeOnlyWhenStressRelieved() throws IOException, InterruptedException {\n+        // enable recording while under stress does not trigger runnable state\n+        // timeline   1  2  3  4  5\n+        // stress     ------ssssss----\n+        // recording  xxx------xxxxxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2 recording = false should pause\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        awaitPaused();\n+\n+        // 3 stress should keep it paused\n         monitor.simulateStress();\n+        assertState(this::assertPaused);\n+\n+        // 4 should not resume tracer as we are under stress\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        // check that reactivation now has no effect even after waiting for the next resume poll\n-        int pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // check that stress relief now reactivates\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertState(this::assertPaused);\n+\n+        // 5 stress relief now resumes tracer\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n+\n     @Test\n     void testCircuitBreakerDisabled() throws IOException, InterruptedException {\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertThat(circuitBreakerConfiguration.isCircuitBreakerEnabled()).isFalse();\n+\n+        assertRunning();\n+\n         monitor.simulateStress();\n-        Thread.sleep(50);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertState(this::assertRunning);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f90d3369a358e2d6b71f192a5225f7ddfe1824b5"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDQ4MDE5OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDozMDoxOVrOF_lD9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDozMDoxOVrOF_lD9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxMTgyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    monitor.simulateStress();\n          \n          \n            \n                    monitor.simulateStressAndWaitPoll();", "url": "https://github.com/elastic/apm-agent-java/pull/1118#discussion_r402211829", "createdAt": "2020-04-02T10:30:19Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/circuitbreaker/CircuitBreakerTest.java", "diffHunk": "@@ -74,104 +97,237 @@ public void tearDown() {\n \n     @Test\n     void testStressSimulation() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // see that the tracer remains inactive for another couple of polls\n-        pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n     @Test\n     void testTwoMonitors() {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n \n         TestStressMonitor secondMonitor = new TestStressMonitor(tracer);\n         circuitBreaker.registerStressMonitor(secondMonitor);\n \n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertRunning();\n+\n+        // adding stress from a single monitor should pause tracer\n+\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // adding stress from a second monitor should not resume tracer\n+        secondMonitor.simulateStress();\n \n-        pollCount = secondMonitor.simulateStress();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n+\n+        simulateReliefAndWaitPoll(monitor);\n \n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n         // tracer should still be in PAUSED mode, until ALL monitors allow resuming\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertPaused();\n \n-        pollCount = secondMonitor.simulateStressRelieved();\n-        secondMonitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        simulateReliefAndWaitPoll(secondMonitor);\n+\n+        assertRunning();\n \n         circuitBreaker.unregisterStressMonitor(secondMonitor);\n     }\n \n+    private static void simulateReliefAndWaitPoll(TestStressMonitor monitor){\n+        awaitHasBeenPolled(monitor, monitor.simulateStressRelieved());\n+    }\n+\n+    private static void awaitHasBeenPolled(TestStressMonitor monitor, final int pollCount) {\n+        awaitAssert(() -> assertThat(monitor.getPollCount()).isGreaterThan(pollCount + 1));\n+    }\n+\n+\n     @Test\n-    void testStressReliefThenReactivate() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n-        int pollCount = monitor.simulateStress();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+    void testPauseThroughConfigUnderStressThenResumeThroughConfig() throws IOException, InterruptedException {\n+        // stress pauses when recording enabled\n+        // timeline   1  2  3  4  5\n+        // stress     ---sssssss-----\n+        // recording  xxxxxx------xxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2\n+        monitor.simulateStress();\n+        awaitPaused();\n+\n+        // 3 recording = false under stress should not change state\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        // should still be PAUSED as the state is inactive\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        assertState(this::assertPaused);\n+\n+        // 4 stress ends, should still be paused due to recording = false\n+        monitor.simulateStressRelieved();\n+        assertState(this::assertPaused);\n+\n+        // 5\n+        // configuration recording = true should make it run again\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        awaitRunning();\n     }\n \n     @Test\n-    void testReactivateThenStressRelief() throws IOException {\n-        doReturn(true).when(circuitBreakerConfiguration).isCircuitBreakerEnabled();\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+    void testPauseThroughConfigThenResumeOnlyWhenStressRelieved() throws IOException, InterruptedException {\n+        // enable recording while under stress does not trigger runnable state\n+        // timeline   1  2  3  4  5\n+        // stress     ------ssssss----\n+        // recording  xxx------xxxxxx\n+        // state      rrr---------rrr\n+\n+        // 1\n+        circuitBreakerConfiguration.circuitBreakerEnabled.set(true);\n+        assertRunning();\n+\n+        // 2 recording = false should pause\n         TracerInternalApiUtils.setRecordingConfig(config, false, TEST_CONFIG_SOURCE_NAME);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n+        awaitPaused();\n+\n+        // 3 stress should keep it paused\n         monitor.simulateStress();\n+        assertState(this::assertPaused);\n+\n+        // 4 should not resume tracer as we are under stress\n         TracerInternalApiUtils.setRecordingConfig(config, true, TEST_CONFIG_SOURCE_NAME);\n-        // check that reactivation now has no effect even after waiting for the next resume poll\n-        int pollCount = monitor.getPollCount();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(PAUSED);\n-        // check that stress relief now reactivates\n-        pollCount = monitor.simulateStressRelieved();\n-        monitor.waitUntilPollCounterIsGreaterThan(pollCount + 1);\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertState(this::assertPaused);\n+\n+        // 5 stress relief now resumes tracer\n+        monitor.simulateStressRelieved();\n+        awaitRunning();\n     }\n \n+\n     @Test\n     void testCircuitBreakerDisabled() throws IOException, InterruptedException {\n-        assertThat(tracer.getState()).isEqualTo(RUNNING);\n+        assertThat(circuitBreakerConfiguration.isCircuitBreakerEnabled()).isFalse();\n+\n+        assertRunning();\n+\n         monitor.simulateStress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f90d3369a358e2d6b71f192a5225f7ddfe1824b5"}, "originalPosition": 235}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 255, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}