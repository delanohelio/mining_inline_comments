{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NjMxNTY4", "number": 1048, "title": "Add Scala concurrent plugin", "bodyText": "What does this PR do?\nThis PR is a draft to add specific Scala support to the ElasticAPM agent.\nThe goal is to add basic support for Scala Futures.\nKnown issues\n\nTest multiple Scala version (2.12.x and 2.13.x) -> cross-compiling multiple Scala versions doesn't seem to work/be possible with the Maven plugin\nLinkageError when the agent has a specific Scala dependency\nNot all edge-cases are caught in the tests, some of them were only found when running a small test-setup\n\nChecklist\n\n My code follows the style guidelines of this project\n I have rebased my changes on top of the latest master branch\n I have made corresponding changes to the documentation\n I have added tests that prove my fix is effective or that my feature works\n New and existing unit tests pass locally with my changes\n I have updated CHANGELOG.asciidoc\n I have updated supported-technologies.asciidoc\n Added an API method or config option? Document in which version this will be introduced\n Added an instrumentation plugin? How did you make sure that old, non-supported versions are not instrumented by accident?\n\nRelated issues\nPart of #818", "createdAt": "2020-02-22T21:05:45Z", "url": "https://github.com/elastic/apm-agent-java/pull/1048", "merged": true, "mergeCommit": {"oid": "d9b25fcd0c4a9a2ecfe72b2f8571ca75926a2bbf"}, "closed": true, "closedAt": "2020-06-25T13:35:53Z", "author": {"login": "milanvdm"}, "timelineItems": {"totalCount": 61, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcE9Rd4AH2gAyMzc4NjMxNTY4OjQwNGY2ZmIzNjRlYWI4MWIwNjY0ODNhZjEwMmEyNjg1ZGEzZmM2YWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcurEPggH2gAyMzc4NjMxNTY4OmI2OGQzZDJmNGY4N2I4OTIxYTc5Y2IzYTU1ODBjMDZjM2VmOGJjOGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "404f6fb364eab81b066483af102a2685da3fc6ac", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/404f6fb364eab81b066483af102a2685da3fc6ac", "committedDate": "2020-02-16T18:45:04Z", "message": "WIP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b", "committedDate": "2020-02-22T12:17:07Z", "message": "Add initial scala instrumentation for Future"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDA5NTEx", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-363409511", "createdAt": "2020-02-24T14:03:38Z", "commit": {"oid": "9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNDowMzozOVrOFthp8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNDowMzozOVrOFthp8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MTY1MQ==", "bodyText": "agent plugins do not need to rely on apm-agent-api and should use internal API instead, dependency is provided implicitly by apm-agent-plugins parent module.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r383281651", "createdAt": "2020-02-24T14:03:39Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,42 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.13.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>${project.groupId}</groupId>\n+            <artifactId>apm-agent-api</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ce7f3fc27d83b0671b5f11fbafd08d2ec2f211b"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0a4335e8be3ee9afbdbcf8a3d69cbef82f1be6b", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/e0a4335e8be3ee9afbdbcf8a3d69cbef82f1be6b", "committedDate": "2020-02-24T15:14:44Z", "message": "Remove test-dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e57e2d8c03b2a972a805498b59d5467701c24dd1", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/e57e2d8c03b2a972a805498b59d5467701c24dd1", "committedDate": "2020-03-29T10:17:17Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/3ef57c0f45f274926c314413454cc35ed8e141ad", "committedDate": "2020-03-29T19:50:59Z", "message": "Add first test approach"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNjcwMjE4", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-390670218", "createdAt": "2020-04-09T10:22:15Z", "commit": {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMjoxNVrOGDSxPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDo1MjoyM1rOGDTshQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNjQyOA==", "bodyText": "The type matchers should not refer to classes as that would cause loading these classes. Instead, use the named matcher, like named(\"scala.util.Try\")", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406106428", "createdAt": "2020-04-09T10:22:15Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/scala/co/elastic/apm/agent/concurrent/FutureInstrumentation.scala", "diffHunk": "@@ -0,0 +1,41 @@\n+package co.elastic.apm.agent.concurrent\n+\n+import java.util\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation\n+import net.bytebuddy.asm.Advice\n+import net.bytebuddy.description.`type`.TypeDescription\n+import net.bytebuddy.description.method.MethodDescription\n+import net.bytebuddy.matcher.ElementMatcher\n+import net.bytebuddy.matcher.ElementMatchers._\n+\n+import scala.collection.JavaConverters._\n+import scala.util.Try\n+\n+class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+  override def getTypeMatcher: ElementMatcher[_ >: TypeDescription] =\n+    hasSuperType[TypeDescription](named(\"scala.concurrent.Future\"))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise\")))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\")))\n+      .or(hasSuperType(named(\"scala.concurrent.Future$\")))\n+\n+  override def getMethodMatcher: ElementMatcher[_ >: MethodDescription] =\n+    named[MethodDescription](\"onComplete\").and(returns(classOf[Unit])).and(takesArguments(classOf[Try[_] => _]))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExNjU2Mg==", "bodyText": "The executor service instrumentations can only be applied in the tests if you have a dependency on that module:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                <dependencies>\n          \n          \n            \n                    <dependency>\n          \n          \n            \n                        <groupId>${project.groupId}</groupId>\n          \n          \n            \n                        <artifactId>apm-java-concurrent-plugin</artifactId>\n          \n          \n            \n                        <version>${project.version}</version>\n          \n          \n            \n                        <scope>test</scope>\n          \n          \n            \n                    </dependency>\n          \n          \n            \n                    <dependency>\n          \n          \n            \n                        <groupId>${project.groupId}</groupId>\n          \n          \n            \n                        <artifactId>apm-java-concurrent-plugin</artifactId>\n          \n          \n            \n                        <version>${project.version}</version>\n          \n          \n            \n                        <type>test-jar</type>\n          \n          \n            \n                        <scope>test</scope>\n          \n          \n            \n                    </dependency>\n          \n          \n            \n                </dependencies>\n          \n      \n    \n    \n  \n\nAdd this snippet to the concurrent plugin in order to be able to access its test classes, in particular WrappedExecutorService (see also comment further below)>\n    <build>\n        <plugins>\n            <plugin>\n                <artifactId>maven-jar-plugin</artifactId>\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>test-jar</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406116562", "createdAt": "2020-04-09T10:42:05Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.15.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+    </properties>\n+\n+    <build>\n+        <sourceDirectory>src/main/scala</sourceDirectory>\n+        <testSourceDirectory>src/test/scala</testSourceDirectory>\n+        <plugins>\n+            <plugin>\n+                <groupId>net.alchim31.maven</groupId>\n+                <artifactId>scala-maven-plugin</artifactId>\n+                <version>4.3.0</version>\n+                <configuration>\n+                    <scalaVersion>2.12.10</scalaVersion>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExOTMxMg==", "bodyText": "Maybe here's something going wrong with the instrumentation. One limitation of the unit tests is that you can't test instrumenting classes from the bootstrap class loader. ThreadPoolExecutor, which is returned from Executors.newFixedThreadPool(1) is such a class.\nTo work around this, we use co.elastic.apm.agent.concurrent.ExecutorServiceWrapper in our tests. This is a class that the agent can instrument in tests that just delegates to the wrapped ExecutorService.\nFor the built-in executor service instrumentation to work, you also have to declare a test dependency to the java-concurrent-plugin (see comment on pom.xml).\nTo access the ExecutorServiceWrapper class, you either need to copy/paste it to your module or build a test jar from the java-concurrent-plugin and add it as a test dependency as well (see comment on pom.xml).", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406119312", "createdAt": "2020-04-09T10:47:38Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,64 @@\n+package co.elastic.apm.agent.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.AbstractInstrumentationTest\n+import org.assertj.core.api.Assertions.assertThat\n+import org.junit.jupiter.api.Test\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, Future}\n+\n+class FutureInstrumentationSpec extends AbstractInstrumentationTest {\n+\n+  @Test\n+  def testWithDefaultConfig(): Unit = {\n+    new TestFutureTraceMethods().invokeAsync()\n+    assertThat(AbstractInstrumentationTest.reporter.getTransactions().toArray).hasSize(1)\n+    assertThat(AbstractInstrumentationTest.reporter.getSpans().toArray).hasSize(4)\n+  }\n+\n+  private class TestFutureTraceMethods {\n+\n+    /**\n+     * Calling this method results in this method call tree:\n+     *\n+     *                      main thread                         |           worker thread\n+     * -------------------------------------------------------------------------------------------\n+     * invokeAsync                                              |\n+     *      |                                                   |\n+     *      --- blockingMethodOnMainThread                      |\n+     *                     |                                    |\n+     *                     --- nonBlockingMethodOnMainThread    |\n+     *                                      |                   |\n+     *                                      --------------------------> methodOnWorkerThread\n+     *                                                          |                |\n+     *                                                          |                --- longMethod\n+     *                                                          |\n+     */\n+    def invokeAsync(): Unit = blockingMethodOnMainThread()\n+\n+    private def blockingMethodOnMainThread(): Unit = {\n+      try {\n+        Await.result(nonBlockingMethodOnMainThread(), 10.seconds)\n+      } catch {\n+        case e: Exception => e.printStackTrace()\n+      }\n+    }\n+\n+    private def nonBlockingMethodOnMainThread(): Future[Unit] =\n+      Future(methodOnWorkerThread())(ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyMTYwNQ==", "bodyText": "What are you trying to achieve by instrumenting the onComplete method?\nIs the onComplete executed in the context of the Runnable from the Executor that is used within the ExecutionContext.fromExecutor?", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r406121605", "createdAt": "2020-04-09T10:52:23Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/scala/co/elastic/apm/agent/concurrent/FutureInstrumentation.scala", "diffHunk": "@@ -0,0 +1,41 @@\n+package co.elastic.apm.agent.concurrent\n+\n+import java.util\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation\n+import net.bytebuddy.asm.Advice\n+import net.bytebuddy.description.`type`.TypeDescription\n+import net.bytebuddy.description.method.MethodDescription\n+import net.bytebuddy.matcher.ElementMatcher\n+import net.bytebuddy.matcher.ElementMatchers._\n+\n+import scala.collection.JavaConverters._\n+import scala.util.Try\n+\n+class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+  override def getTypeMatcher: ElementMatcher[_ >: TypeDescription] =\n+    hasSuperType[TypeDescription](named(\"scala.concurrent.Future\"))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise\")))\n+      .or(hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\")))\n+      .or(hasSuperType(named(\"scala.concurrent.Future$\")))\n+\n+  override def getMethodMatcher: ElementMatcher[_ >: MethodDescription] =\n+    named[MethodDescription](\"onComplete\").and(returns(classOf[Unit])).and(takesArguments(classOf[Try[_] => _]))\n+//    .or(named[MethodDescription](\"transform\").and(returns(classOf[Future[_]])).and(takesArguments(classOf[Try[_] => Try[_]])))\n+//    .or(named[MethodDescription](\"transformWith\").and(returns(classOf[Future[_]])).and(takesArguments(classOf[Try[_] => Future[_]])))\n+    .and(not(isTypeInitializer[MethodDescription]()))\n+\n+  override def getInstrumentationGroupNames: util.Collection[String] = List(\"concurrent\", \"future\").asJavaCollection\n+\n+  @Advice.OnMethodEnter(suppress = classOf[Throwable])\n+  def onComplete(@Advice.Argument(value = 0, readOnly = true) callback: Try[_] => _): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ef57c0f45f274926c314413454cc35ed8e141ad"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dd336d4fad4ed76beacccad038b8bd7f864adc7", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/2dd336d4fad4ed76beacccad038b8bd7f864adc7", "committedDate": "2020-04-09T19:17:01Z", "message": "Use Java for method matching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "167ecde0806ada0f1454bc806e84a2499d700b25", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/167ecde0806ada0f1454bc806e84a2499d700b25", "committedDate": "2020-04-14T15:56:37Z", "message": "Add dummy test using Scala"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90d0b6f227399923a3a3ce2271dae8db32df44fe", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/90d0b6f227399923a3a3ce2271dae8db32df44fe", "committedDate": "2020-04-14T20:36:16Z", "message": "Add java-version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63", "committedDate": "2020-04-14T20:37:03Z", "message": "Add first matching instrumentation test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjc3ODk5", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-393277899", "createdAt": "2020-04-14T20:39:14Z", "commit": {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDozOToxNFrOGFgBqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDozOToxNFrOGFgBqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMDc3OQ==", "bodyText": "Currently, disabling this dependency since adding it not only brings in the Wrapper classes, but for some reason also pulls in the JavaInstrumentation and method-matchers from the java-concurrent-plugin.\nComments welcome on how to prevent that :)", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408420779", "createdAt": "2020-04-14T20:39:14Z", "author": {"login": "milanvdm"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,92 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.15.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+        <maven.compiler.target>9</maven.compiler.target>\n+        <maven.compiler.testTarget>9</maven.compiler.testTarget>\n+    </properties>\n+\n+    <dependencies>\n+<!--        <dependency>-->\n+<!--            <groupId>${project.groupId}</groupId>-->\n+<!--            <artifactId>apm-java-concurrent-plugin</artifactId>-->\n+<!--            <version>${project.version}</version>-->\n+<!--            <scope>test</scope>-->\n+<!--        </dependency>-->\n+<!--        <dependency>-->\n+<!--            <groupId>${project.groupId}</groupId>-->\n+<!--            <artifactId>apm-java-concurrent-plugin</artifactId>-->\n+<!--            <version>${project.version}</version>-->\n+<!--            <type>test-jar</type>-->\n+<!--            <scope>test</scope>-->\n+<!--        </dependency>-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjc5NDQw", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-393279440", "createdAt": "2020-04-14T20:41:34Z", "commit": {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0MTozNFrOGFgGrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0MTozNFrOGFgGrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMjA2MA==", "bodyText": "I'm unsure on how to start the initial transaction for every test. Since the FutureInstrumentation doesn't create any transactions, I expect that I manually need to activate it here.\nAlthough, I cannot find a similar thing in the AsyncTraceMethodInstrumentationTest of the java-concurrent plugin.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408422060", "createdAt": "2020-04-14T20:41:34Z", "author": {"login": "milanvdm"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,91 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.scalatest.BeforeAndAfterEach\n+import org.scalatest.flatspec.AnyFlatSpec\n+import org.scalatest.matchers.should.Matchers\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future}\n+\n+class FutureInstrumentationSpec extends AnyFlatSpec with Matchers with BeforeAndAfterEach {\n+\n+  implicit def executionContext: ExecutionContextExecutor =\n+    ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach: Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjgwNzMz", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-393280733", "createdAt": "2020-04-14T20:43:31Z", "commit": {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0MzozMVrOGFgK6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDo0MzozMVrOGFgK6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQyMzE0Nw==", "bodyText": "I see the FutureInstrumentation match correctly on this method-call which I find good progress :)\nIm confused on why the test is not passing due to not having any transactions in the reporter although I manually create that root-transaction.\nAny reason why it is not getting this root-transaction that gets created before every test?", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r408423147", "createdAt": "2020-04-14T20:43:31Z", "author": {"login": "milanvdm"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,91 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.scalatest.BeforeAndAfterEach\n+import org.scalatest.flatspec.AnyFlatSpec\n+import org.scalatest.matchers.should.Matchers\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future}\n+\n+class FutureInstrumentationSpec extends AnyFlatSpec with Matchers with BeforeAndAfterEach {\n+\n+  implicit def executionContext: ExecutionContextExecutor =\n+    ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach: Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()\n+  }\n+\n+  override def afterEach: Unit = {\n+    transaction.deactivate().end()\n+    ElasticApmAgent.reset()\n+  }\n+\n+  \"test\" should \"test\" in {\n+    new TestFutureTraceMethods().invokeAsync()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5b369d9ff7a343ee7e3faf7d6b4adf1c238b63"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/f20a929179a0b7ca8e64add118f8e86de6a4b3d6", "committedDate": "2020-04-18T08:54:40Z", "message": "WIP"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODk3MTM1", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-395897135", "createdAt": "2020-04-18T09:11:40Z", "commit": {"oid": "f20a929179a0b7ca8e64add118f8e86de6a4b3d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwOToxMTo0MFrOGHpeFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwOToxMTo0MFrOGHpeFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3MjY2Mw==", "bodyText": "Im currently trying out to create a first real test to see how everything works.\nIm currently stuck on why ByteBuddy is not executing this onEnter function even though I see method-matches on DEBUG level:\n[ScalaTest-main-running-FutureInstrumentationSpec] DEBUG co.elastic.apm.agent.bci.ElasticApmAgent - Method match for instrumentation FutureInstrumentation: ((((name(equals(onComplete)) and returns(erasure(is(void)))) or (name(equals(transform)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or (name(equals(transformWith)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or name(equals(result))) matches public final void scala.concurrent.impl.Promise$DefaultPromise.onComplete(scala.Function1,scala.concurrent.ExecutionContext)\n[ScalaTest-main-running-FutureInstrumentationSpec] DEBUG co.elastic.apm.agent.bci.ElasticApmAgent - Method match for instrumentation FutureInstrumentation: ((((name(equals(onComplete)) and returns(erasure(is(void)))) or (name(equals(transform)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or (name(equals(transformWith)) and returns(erasure(name(equals(scala.concurrent.Future)))))) or name(equals(result))) matches public final java.lang.Object scala.concurrent.impl.Promise$DefaultPromise.result(scala.concurrent.duration.Duration,scala.concurrent.CanAwait) throws java.lang.Exception\n\nI see that the log also mentions throws java.lang.Exception but it is unclear on how and when that Exception is thrown.\n@felixbarny Any idea on what I'm missing on why onEnter is not being called even though there is a method match?", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r410672663", "createdAt": "2020-04-18T09:11:40Z", "author": {"login": "milanvdm"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.Future\"))\n+            .or(hasSuperType(named(\"scala.concurrent.impl.Promise\")))\n+            .or(hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\")))\n+            .or(hasSuperType(named(\"scala.concurrent.Future$\")));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"onComplete\").and(returns(void.class))\n+            .or(named(\"transform\").and(returns(named(\"scala.concurrent.Future\"))))\n+            .or(named(\"transformWith\").and(returns(named(\"scala.concurrent.Future\"))))\n+            .or(named(\"result\"));\n+    }\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @VisibleForAdvice\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void onEnter() {\n+        System.out.println(\"DEBUG2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f20a929179a0b7ca8e64add118f8e86de6a4b3d6"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2d2bb72c3f2d0e200b81ab07e6c5ec47931b3ba", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/b2d2bb72c3f2d0e200b81ab07e6c5ec47931b3ba", "committedDate": "2020-04-20T21:09:56Z", "message": "Use MUnit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2feb98fdbd6dde9243158d7928fb5b954398d835", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/2feb98fdbd6dde9243158d7928fb5b954398d835", "committedDate": "2020-04-22T20:23:52Z", "message": "Cleanup pom"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0af62cef3da61e316f994f5fd7e1c7600a5d2d3e", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/0af62cef3da61e316f994f5fd7e1c7600a5d2d3e", "committedDate": "2020-04-22T20:24:05Z", "message": "Add Future instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f97b0b10f431f082307efcc3160e6d10146c862b", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/f97b0b10f431f082307efcc3160e6d10146c862b", "committedDate": "2020-04-22T20:24:15Z", "message": "Add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NTY0NDE2", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-398564416", "createdAt": "2020-04-22T20:33:47Z", "commit": {"oid": "f97b0b10f431f082307efcc3160e6d10146c862b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDozMzo0N1rOGKKbOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDozMzo0N1rOGKKbOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwOTc1Mw==", "bodyText": "Had to upgrade versions to be able to work with the Scala Munit test-framework.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r413309753", "createdAt": "2020-04-22T20:33:47Z", "author": {"login": "milanvdm"}, "path": "pom.xml", "diffHunk": "@@ -420,13 +420,8 @@\n                 </plugin>\n                 <plugin>\n                     <artifactId>maven-surefire-plugin</artifactId>\n-                    <version>2.19.1</version>\n+                    <version>2.22.2</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f97b0b10f431f082307efcc3160e6d10146c862b"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NTY0NzI3", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-398564727", "createdAt": "2020-04-22T20:34:11Z", "commit": {"oid": "f97b0b10f431f082307efcc3160e6d10146c862b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDozNDoxMVrOGKKcOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDozNDoxMVrOGKKcOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMxMDAxMA==", "bodyText": "Needed to match Scala *Spec.scala test files", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r413310010", "createdAt": "2020-04-22T20:34:11Z", "author": {"login": "milanvdm"}, "path": "pom.xml", "diffHunk": "@@ -438,6 +433,11 @@\n                             <version>${version.junit-jupiter}</version>\n                         </dependency>\n                     </dependencies>\n+                    <configuration>\n+                        <includes>\n+                            <include>**/*Spec.*</include>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f97b0b10f431f082307efcc3160e6d10146c862b"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "649207b84ef4a73c923569193fde0f94df62efbd", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/649207b84ef4a73c923569193fde0f94df62efbd", "committedDate": "2020-04-23T15:47:31Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/324ce67e0f9648e7f95fe86416ee6d0807be635b", "committedDate": "2020-04-23T20:47:44Z", "message": "Add plugin to release process"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NjY3ODMy", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-399667832", "createdAt": "2020-04-24T06:19:37Z", "commit": {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjoxOTozN1rOGLIRyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjoyNzowMlrOGLIeRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyMzE0NA==", "bodyText": "Don't forget to deactivate the context.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414323144", "createdAt": "2020-04-24T06:19:37Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            promisesToContext.remove(thiz);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNDU5NA==", "bodyText": "Catch thrown exceptions @Thrown @Nullable Throwable t and captureException(t)", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414324594", "createdAt": "2020-04-24T06:23:01Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng==", "bodyText": "Promises could be created outside a transaction but used in the context of a transaction at the point a promise is scheduled.\nIs there a canonical place where promises are scheduled? Maybe something equivalent to Executor#execute(Runnable)?", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414325356", "createdAt": "2020-04-24T06:24:54Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNjM0Mw==", "bodyText": "Why is Java 9 required here? The agent must still support Java 7.  Loading the plugin (instantiating FutureInstrumentation) on an earlier JVM would result in an error.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r414326343", "createdAt": "2020-04-24T06:27:02Z", "author": {"login": "felixbarny"}, "path": "apm-agent-core/pom.xml", "diffHunk": "@@ -165,6 +165,14 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <source>9</source>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451", "committedDate": "2020-04-24T18:06:59Z", "message": "Instrument ExecutionContext"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNDUxNjgx", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-402451681", "createdAt": "2020-04-29T08:16:55Z", "commit": {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoxNjo1NVrOGN0WkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoxOTo0OFrOGN0cfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw==", "bodyText": "To properly deactivate on exit with considering wrapped promises, add @Advice.Local(\"context\") TraceContextHolder<?> context to the parameters.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417142417", "createdAt": "2020-04-29T08:16:55Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjczMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public static void onExit(@Advice.This Promise<?> thiz) {\n          \n          \n            \n                    public static void onExit(@Advice.This Promise<?> thiz, @Nullable @Advice.Local(\"context\") TraceContextHolder<?> context) {", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417142733", "createdAt": "2020-04-29T08:17:34Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzMzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        promisesToContext.remove(thiz);\n          \n          \n            \n                        if (context != null) {\n          \n          \n            \n                            promisesToContext.remove(thiz);\n          \n          \n            \n                            tracer.deactivate(context);\n          \n          \n            \n                        }", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417143335", "createdAt": "2020-04-29T08:18:41Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> context = promisesToContext.getIfPresent(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);\n+            }\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            promisesToContext.remove(thiz);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzkzMg==", "bodyText": "Maybe the non-deactivated context has something to do with the MDC issue.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r417143932", "createdAt": "2020-04-29T08:19:48Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.ExecutionContext\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"execute\").and(returns(void.class)).and(takesArguments(Runnable.class));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class BatchedExecutionContextInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.BatchingExecutor\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher(){\n+            return named(\"submitForExecution\").and(returns(void.class)).and(takesArguments(Runnable.class))\n+                .or(named(\"submitAsyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)))\n+                .or(named(\"submitSyncBatched\").and(returns(void.class)).and(takesArguments(Runnable.class)));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onExecute(@Advice.Argument(value = 0, readOnly = false) @Nullable Runnable runnable) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null && runnable != null && tracer != null) {\n+                // Do no discard branches leading to async operations so not to break span references\n+                active.setDiscard(false);\n+                runnable = active.withActive(runnable);\n+            }\n+        }\n+\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final TraceContextHolder<?> active = getActive();\n+            if (active != null) {\n+                promisesToContext.put(thiz, active);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjQxNw=="}, "originalCommit": {"oid": "9d0eb3926e7a103d72c4757b7fc3a47ef6dc1451"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ab2834402574dd4baa0c04cf76bf562e9448943", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/7ab2834402574dd4baa0c04cf76bf562e9448943", "committedDate": "2020-05-08T07:39:26Z", "message": "Merge branch 'master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee6da7dacbcded6509264890011e547cffdb3974", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/ee6da7dacbcded6509264890011e547cffdb3974", "committedDate": "2020-05-08T10:15:57Z", "message": "Add onStream instrumentation on AsyncHandler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec2b7eb1da08e9d011da26da03d1ad99fdd6c4c2", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/ec2b7eb1da08e9d011da26da03d1ad99fdd6c4c2", "committedDate": "2020-05-08T11:02:49Z", "message": "Add StreamHandler tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9e0762aea300de8f45437353e384ec5739a7988", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/d9e0762aea300de8f45437353e384ec5739a7988", "committedDate": "2020-05-08T11:12:00Z", "message": "Merge branch 'keep-spans-active-on-stream-async-http' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84417b0c209008813b79228a342f5b67c5884c8a", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/84417b0c209008813b79228a342f5b67c5884c8a", "committedDate": "2020-05-13T07:18:21Z", "message": "Add Promise instrumentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "199e514be3fcb9baf8fb086eb74a6c3cd217fd9e", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/199e514be3fcb9baf8fb086eb74a6c3cd217fd9e", "committedDate": "2020-05-13T07:18:30Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad429931922d2f810fed7e4a323b922c89123e33", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/ad429931922d2f810fed7e4a323b922c89123e33", "committedDate": "2020-05-15T09:56:23Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49bca5fe02443656ffbef02cfcc74f9ee685caf3", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/49bca5fe02443656ffbef02cfcc74f9ee685caf3", "committedDate": "2020-05-15T10:22:08Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e41f63c2d07732c4886892f22a1551dcebeb9062", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/e41f63c2d07732c4886892f22a1551dcebeb9062", "committedDate": "2020-05-15T11:10:07Z", "message": "Fix versions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDc4MjYy", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-413078262", "createdAt": "2020-05-16T13:50:59Z", "commit": {"oid": "e41f63c2d07732c4886892f22a1551dcebeb9062"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxMzo1MDo1OVrOGWadiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQxMzo1OToyM1rOGWaf2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTQwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            promisesToContext.put(thiz, context);\n          \n          \n            \n                            promisesToContext.put(thiz, context);\n          \n          \n            \n                            // this span might be ended before the Promise$Transformation#run method starts\n          \n          \n            \n                            // we have to avoid that this span gets recycled, even in the above mentioned case\n          \n          \n            \n                            context.incrementReferences();", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155403", "createdAt": "2020-05-16T13:50:59Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final AbstractSpan<?> context = getActive();\n+            if (context != null) {\n+                promisesToContext.put(thiz, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e41f63c2d07732c4886892f22a1551dcebeb9062"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTgyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            tracer.activate(context);\n          \n          \n            \n                            tracer.activate(context);\n          \n          \n            \n                            // decrements the reference we incremented to avoid that the parent context gets recycled before the promise is run\n          \n          \n            \n                            // because we have activated it, we can be sure it doesn't get recycled until we deactivate in the OnMethodExit advice\n          \n          \n            \n                            context.decrementReferences();", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155822", "createdAt": "2020-05-16T13:57:02Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class)\n+        public static void onExit(@Advice.This Promise<?> thiz) {\n+            final AbstractSpan<?> context = getActive();\n+            if (context != null) {\n+                promisesToContext.put(thiz, context);\n+            }\n+        }\n+\n+    }\n+\n+    public static class RunInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+            return named(\"scala.concurrent.impl.Promise$Transformation\");\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"run\").and(returns(void.class));\n+        }\n+\n+        @VisibleForAdvice\n+        @Advice.OnMethodEnter(suppress = Throwable.class)\n+        public static void onEnter(@Advice.This Promise<?> thiz, @Nullable @Advice.Local(\"context\") AbstractSpan<?> context) {\n+            context = promisesToContext.remove(thiz);\n+            if (tracer != null && context != null) {\n+                tracer.activate(context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e41f63c2d07732c4886892f22a1551dcebeb9062"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1NTk5NQ==", "bodyText": "I've added suggestions that are likely to fix the cause of this.\n\nI don't see how the new Span can suddenly have any references right after being made and before the method actually returns the created Span.\n\nThat's because the span it gets out of the pool is still being referenced.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r426155995", "createdAt": "2020-05-16T13:59:23Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.TraceContextHolder;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.Promise;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Promise<?>, TraceContextHolder<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"scala.concurrent.impl.Promise$Transformation\"));\n+    }\n+\n+    public static class ConstructorInstrumentation extends FutureInstrumentation {\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return isConstructor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNTM1Ng=="}, "originalCommit": {"oid": "324ce67e0f9648e7f95fe86416ee6d0807be635b"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0375b74bf560d68cc4b0f9638d7e05213b81b5d", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/a0375b74bf560d68cc4b0f9638d7e05213b81b5d", "committedDate": "2020-05-16T14:44:58Z", "message": "Make sure spans are not recycled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "accd469299e47d98a9cd03f6597a25b7bac1b75d", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/accd469299e47d98a9cd03f6597a25b7bac1b75d", "committedDate": "2020-05-19T08:38:26Z", "message": "Cleanup Java 9 compilers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTQxMTQ1", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-414541145", "createdAt": "2020-05-19T15:03:05Z", "commit": {"oid": "accd469299e47d98a9cd03f6597a25b7bac1b75d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTowMzowNVrOGXk4dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNTowMzowNVrOGXk4dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3NDcwOQ==", "bodyText": "Marking as experimental disables this instrumentation by default.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Arrays.asList(\"concurrent\", \"future\");\n          \n          \n            \n                    return Arrays.asList(\"scala-future\", \"experimental\");", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r427374709", "createdAt": "2020-05-19T15:03:05Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/main/java/co/elastic/apm/agent/scala/concurrent/FutureInstrumentation.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.scala.concurrent;\n+\n+import co.elastic.apm.agent.bci.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.bci.VisibleForAdvice;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public abstract class FutureInstrumentation extends ElasticApmInstrumentation {\n+\n+    @VisibleForAdvice\n+    @SuppressWarnings(\"WeakerAccess\")\n+    public static final WeakConcurrentMap<Object, AbstractSpan<?>> promisesToContext =\n+        new WeakConcurrentMap.WithInlinedExpunction<>();\n+\n+    @Nonnull\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Arrays.asList(\"concurrent\", \"future\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "accd469299e47d98a9cd03f6597a25b7bac1b75d"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7843966cc39a26e402b10955c25ccab258e564d3", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/7843966cc39a26e402b10955c25ccab258e564d3", "committedDate": "2020-05-19T17:14:34Z", "message": "Add docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f7b25734c84ed509f5f50d42d8249795a8fb4b2", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/0f7b25734c84ed509f5f50d42d8249795a8fb4b2", "committedDate": "2020-05-19T17:15:10Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4", "committedDate": "2020-05-19T17:15:45Z", "message": "Fix merge"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5MzIwMjEy", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-419320212", "createdAt": "2020-05-27T15:08:28Z", "commit": {"oid": "f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTowODoyOFrOGbPTjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNTowODoyOFrOGbPTjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxNTUwMA==", "bodyText": "can this be removed?", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r431215500", "createdAt": "2020-05-27T15:08:28Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,53 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.16.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+        <maven.compiler.source>1.9</maven.compiler.source>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9b8e56f8ca5d8c4a5a3f96c120394dfab5cc8a4"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "063ed391f99b95686f6b2aec0cabe5a99dcf364d", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/063ed391f99b95686f6b2aec0cabe5a99dcf364d", "committedDate": "2020-05-27T18:35:14Z", "message": "Remove Java version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c638d9509fd5d44d1632d851f4d532089efb15c", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/6c638d9509fd5d44d1632d851f4d532089efb15c", "committedDate": "2020-05-27T18:35:22Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40033fa77968c637587e912fe77d418c7eea1b47", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/40033fa77968c637587e912fe77d418c7eea1b47", "committedDate": "2020-05-29T18:47:18Z", "message": "Improve testing for edge cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjA1MDI0", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-421205024", "createdAt": "2020-05-29T18:51:30Z", "commit": {"oid": "40033fa77968c637587e912fe77d418c7eea1b47"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxODo1MTozMFrOGcoWKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxODo1MTozMFrOGcoWKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NDM0Nw==", "bodyText": "@felixbarny I saw in your branch that you were using this approach.\nTechnically, this is not needed as the test framework will correctly await the Future for you.\nBut I can imagine that this makes it more explicit when you don't know the test-framework or Scala Futures.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r432674347", "createdAt": "2020-05-29T18:51:30Z", "author": {"login": "milanvdm"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,224 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import munit.FunSuite\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future, Promise}\n+import scala.util.{Failure, Success}\n+\n+class FutureInstrumentationSpec extends FunSuite {\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach(context: BeforeEach): Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()\n+  }\n+\n+  override def afterEach(context: AfterEach): Unit = ElasticApmAgent.reset()\n+\n+  test(\"Scala Future should propagate the tracing-context correctly across different threads\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    val future =  Future(\"Test\")\n+      .map(_.length)\n+      .flatMap(l => Future(l * 2))\n+      .map(_.toString)\n+      .flatMap(s => Future(s\"$s-$s\"))\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+\n+  }\n+\n+  test(\"Worker thread should correctly set context on the current transaction\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    new TestFutureTraceMethods().invokeAsync(tracer)\n+    transaction.deactivate().end()\n+    assertEquals(reporter.getTransactions.size(), 1)\n+    assertEquals(reporter.getSpans.size(), 0)\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+  }\n+\n+  test(\"Multiple async operations should be able to set context on the current transaction\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val future = Future\n+      .traverse(1 to 100) { _ =>\n+        Future.sequence(List(\n+          Future {\n+            Thread.sleep(25)\n+            tracer.currentTransaction().addCustomContext(\"future1\", true)\n+          },\n+          Future {\n+            Thread.sleep(50)\n+            tracer.currentTransaction().addCustomContext(\"future2\", true)\n+          },\n+          Future {\n+            Thread.sleep(10)\n+            tracer.currentTransaction().addCustomContext(\"future3\", true)\n+          }\n+        ))\n+      }\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future1\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future2\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future3\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a combination of Promises and Futures correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val promise = Promise[Int]()\n+\n+    Future {\n+      Thread.sleep(100)\n+      }\n+      .map(_ => 42)\n+      .onComplete {\n+        case Success(value) => promise.success(value)\n+        case Failure(exception) => promise.failure(exception)\n+      }\n+\n+    val future = promise\n+      .future\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a combination of Promises and complex Futures correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val promise = Promise[Int]()\n+\n+    Future\n+      .traverse(1 to 100) { _ =>\n+        Future.sequence(List(\n+          Future {\n+            Thread.sleep(25)\n+          },\n+          Future {\n+            Thread.sleep(50)\n+          },\n+          Future {\n+            Thread.sleep(10)\n+          }\n+        ))\n+      }\n+      .map(_ => 42)\n+      .onComplete {\n+        case Success(value) => promise.success(value)\n+        case Failure(exception) => promise.failure(exception)\n+      }\n+\n+    val future = promise\n+      .future\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40033fa77968c637587e912fe77d418c7eea1b47"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ee2b3b1cff2686e4511fd7651c70967154b2f9b", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/5ee2b3b1cff2686e4511fd7651c70967154b2f9b", "committedDate": "2020-05-29T19:02:32Z", "message": "Simplify failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1721794b2f3a6c83c4d398fa3b87208dab54cceb", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/1721794b2f3a6c83c4d398fa3b87208dab54cceb", "committedDate": "2020-05-29T19:36:53Z", "message": "Add extra failing test on Future.sequence"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjYyNjg3", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-421262687", "createdAt": "2020-05-29T20:20:28Z", "commit": {"oid": "1721794b2f3a6c83c4d398fa3b87208dab54cceb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDoyMDoyOFrOGcq6BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDoyMDoyOFrOGcq6BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxNjI5Mg==", "bodyText": "From what I tested with a Java Executor only:\n\nIf the Thread.sleep(x) with x = 1, the test does not always fail\nAdding a map with adding customContext on the Future inside of the Sequence, the context is correctly propagated\nSo only the map after the Sequence seems to lose context when only using the Java Executor\n\nSequence uses the parasitic Executor from Scala.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r432716292", "createdAt": "2020-05-29T20:20:28Z", "author": {"login": "milanvdm"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/src/test/scala/co/elastic/apm/agent/scala/concurrent/FutureInstrumentationSpec.scala", "diffHunk": "@@ -0,0 +1,237 @@\n+package co.elastic.apm.agent.scala.concurrent\n+\n+import java.util.concurrent.Executors\n+\n+import co.elastic.apm.agent.MockReporter\n+import co.elastic.apm.agent.bci.ElasticApmAgent\n+import co.elastic.apm.agent.configuration.{CoreConfiguration, SpyConfiguration}\n+import co.elastic.apm.agent.impl.transaction.Transaction\n+import co.elastic.apm.agent.impl.{ElasticApmTracer, ElasticApmTracerBuilder}\n+import munit.FunSuite\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import org.stagemonitor.configuration.ConfigurationRegistry\n+\n+import scala.concurrent.duration._\n+import scala.concurrent.{Await, ExecutionContext, ExecutionContextExecutor, Future, Promise}\n+import scala.util.{Failure, Success}\n+\n+class FutureInstrumentationSpec extends FunSuite {\n+\n+  private var reporter: MockReporter = _\n+  private var tracer: ElasticApmTracer = _\n+  private var coreConfiguration: CoreConfiguration = _\n+  private var transaction: Transaction = _\n+\n+  override def beforeEach(context: BeforeEach): Unit = {\n+    reporter = new MockReporter\n+    val config: ConfigurationRegistry = SpyConfiguration.createSpyConfig\n+    coreConfiguration = config.getConfig(classOf[CoreConfiguration])\n+    tracer = new ElasticApmTracerBuilder().configurationRegistry(config).reporter(reporter).build\n+    ElasticApmAgent.initInstrumentation(tracer, ByteBuddyAgent.install)\n+    transaction = tracer.startRootTransaction(null).withName(\"Transaction\").activate()\n+  }\n+\n+  override def afterEach(context: AfterEach): Unit = ElasticApmAgent.reset()\n+\n+  test(\"Scala Future should propagate the tracing-context correctly across different threads\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    val future =  Future(\"Test\")\n+      .map(_.length)\n+      .flatMap(l => Future(l * 2))\n+      .map(_.toString)\n+      .flatMap(s => Future(s\"$s-$s\"))\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+\n+  }\n+\n+  test(\"Worker thread should correctly set context on the current transaction\") {\n+    implicit val executionContext: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(1))\n+\n+    new TestFutureTraceMethods().invokeAsync(tracer)\n+    transaction.deactivate().end()\n+    assertEquals(reporter.getTransactions.size(), 1)\n+    assertEquals(reporter.getSpans.size(), 0)\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+  }\n+\n+  test(\"Multiple async operations should be able to set context on the current transaction\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val future = Future\n+      .traverse(1 to 100) { _ =>\n+        Future.sequence(List(\n+          Future {\n+            Thread.sleep(25)\n+            tracer.currentTransaction().addCustomContext(\"future1\", true)\n+          },\n+          Future {\n+            Thread.sleep(50)\n+            tracer.currentTransaction().addCustomContext(\"future2\", true)\n+          },\n+          Future {\n+            Thread.sleep(10)\n+            tracer.currentTransaction().addCustomContext(\"future3\", true)\n+          }\n+        ))\n+      }\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future1\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future2\").asInstanceOf[Boolean],\n+      true\n+    )\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future3\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a combination of Promises and Futures correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val promise = Promise[Int]()\n+\n+    Future { Thread.sleep(100) }\n+      .map(_ => 42)\n+      .onComplete {\n+        case Success(value) => promise.success(value)\n+        case Failure(exception) => promise.failure(exception)\n+      }\n+\n+    val future = promise\n+      .future\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))\n+\n+    Await.ready(future, 10.seconds)\n+    transaction.deactivate().end()\n+    assertEquals(\n+      reporter.getTransactions.get(0).getContext.getCustom(\"future\").asInstanceOf[Boolean],\n+      true\n+    )\n+\n+  }\n+\n+  test(\"Handle a Future.sequence correctly\") {\n+\n+    implicit val multiPoolEc: ExecutionContextExecutor =\n+      ExecutionContext.fromExecutor(Executors.newFixedThreadPool(3))\n+\n+    val future = Future\n+      .sequence(List(\n+        Future(Thread.sleep(25))\n+      ))\n+      .map(_ => tracer.currentTransaction().addCustomContext(\"future\", true))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1721794b2f3a6c83c4d398fa3b87208dab54cceb"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNzI4MTc4", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-430728178", "createdAt": "2020-06-15T14:59:26Z", "commit": {"oid": "1721794b2f3a6c83c4d398fa3b87208dab54cceb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6", "author": {"user": {"login": "felixbarny", "name": "Felix Barnsteiner"}}, "url": "https://github.com/elastic/apm-agent-java/commit/737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6", "committedDate": "2020-06-15T15:01:40Z", "message": "Merge branch 'master' into add-scala-executor-apm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNzM4NDMx", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-430738431", "createdAt": "2020-06-15T15:10:17Z", "commit": {"oid": "737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNToxMDoxOFrOGj2iiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNToxMDoxOFrOGj2iiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NjkyMQ==", "bodyText": "Maybe one thing to add is a test-dependency on the java-concurrent plugin to test the effects of having both means of context propagation on at the same time.", "url": "https://github.com/elastic/apm-agent-java/pull/1048#discussion_r440246921", "createdAt": "2020-06-15T15:10:18Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-scala-concurrent-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,50 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-agent-plugins</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.16.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-scala-concurrent-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <apm-agent-parent.base.dir>${project.basedir}/../..</apm-agent-parent.base.dir>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.scalameta</groupId>\n+            <artifactId>munit_2.13</artifactId>\n+            <version>0.7.2</version>\n+            <scope>test</scope>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "737bb0e01e1e4aff843a36778f03a3fe2ea4cbf6"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1885c8e64e22363b5ece20d07ddc24ce49496cb5", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/1885c8e64e22363b5ece20d07ddc24ce49496cb5", "committedDate": "2020-06-15T16:18:55Z", "message": "Add java apm dependency to test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTE1NzM5", "url": "https://github.com/elastic/apm-agent-java/pull/1048#pullrequestreview-432515739", "createdAt": "2020-06-17T15:22:12Z", "commit": {"oid": "1885c8e64e22363b5ece20d07ddc24ce49496cb5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c893ac024e0fdfa27a97c41708a64f8a72b78964", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/c893ac024e0fdfa27a97c41708a64f8a72b78964", "committedDate": "2020-06-17T15:47:04Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f844049da47c548259973da58d5623fa1bca12b7", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/f844049da47c548259973da58d5623fa1bca12b7", "committedDate": "2020-06-17T15:48:28Z", "message": "Bump to new snapshot version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f530a0684d941e3fd282157f0296ba4435409ac", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/0f530a0684d941e3fd282157f0296ba4435409ac", "committedDate": "2020-06-23T18:24:06Z", "message": "Start tracer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6a6581d6e431a1eb593c16fe6f48c805d1296b4", "author": {"user": {"login": "milanvdm", "name": "Milan van der Meer"}}, "url": "https://github.com/elastic/apm-agent-java/commit/c6a6581d6e431a1eb593c16fe6f48c805d1296b4", "committedDate": "2020-06-23T18:24:52Z", "message": "Merge remote-tracking branch 'upstream/master' into add-scala-executor-apm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b68d3d2f4f87b8921a79cb3a5580c06c3ef8bc8f", "author": {"user": {"login": "felixbarny", "name": "Felix Barnsteiner"}}, "url": "https://github.com/elastic/apm-agent-java/commit/b68d3d2f4f87b8921a79cb3a5580c06c3ef8bc8f", "committedDate": "2020-06-25T09:17:09Z", "message": "Merge branch 'master' into add-scala-executor-apm"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4097, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}