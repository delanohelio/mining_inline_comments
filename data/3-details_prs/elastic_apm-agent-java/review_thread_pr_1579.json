{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzMDk5NTMz", "number": 1579, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMzozNVrOFHtwGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOToxMjo0MVrOFHt6ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjMzOTQ3OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Request.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOTowMzozNVrOIJQ_rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQxMjoyOTowMlrOIJWqYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NjU0Mg==", "bodyText": "[question] What about returning a CharSequence for reading and an Appendable for writing instead of the CharBuffer itself ? Encapsulating the CharBuffer seems a good option here as it would prevent any call to .flip() when not expected.\nOne bonus here would be to not having to cast to Object in the test assertions.", "url": "https://github.com/elastic/apm-agent-java/pull/1579#discussion_r546586542", "createdAt": "2020-12-21T09:03:35Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Request.java", "diffHunk": "@@ -187,9 +191,17 @@ public CharBuffer getBodyBuffer() {\n         }\n     }\n \n+    /**\n+     * Returns the body buffer if it was written to and writing to it was finished through {@link Request#endOfBufferInput()}\n+     * @return body buffer if it was written to and writing was finished; returns {@code null} otherwise.\n+     */\n     @Nullable\n     public CharBuffer getBodyBufferForSerialization() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da1f82125e63eed5bb1dcd935e5c09840082ef58"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5Njc2OQ==", "bodyText": "\ud83d\udc4d  Great suggestion! Will do.", "url": "https://github.com/elastic/apm-agent-java/pull/1579#discussion_r546596769", "createdAt": "2020-12-21T09:25:12Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Request.java", "diffHunk": "@@ -187,9 +191,17 @@ public CharBuffer getBodyBuffer() {\n         }\n     }\n \n+    /**\n+     * Returns the body buffer if it was written to and writing to it was finished through {@link Request#endOfBufferInput()}\n+     * @return body buffer if it was written to and writing was finished; returns {@code null} otherwise.\n+     */\n     @Nullable\n     public CharBuffer getBodyBufferForSerialization() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NjU0Mg=="}, "originalCommit": {"oid": "da1f82125e63eed5bb1dcd935e5c09840082ef58"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1MjA1Ng==", "bodyText": "The change to Appendable turns out to be trickier as its writing users use it for decoding through IOUtils which relies on basic Java APIs that require CharBuffer, so I will only change getBodyBufferForSerialization for now.", "url": "https://github.com/elastic/apm-agent-java/pull/1579#discussion_r546652056", "createdAt": "2020-12-21T11:22:31Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Request.java", "diffHunk": "@@ -187,9 +191,17 @@ public CharBuffer getBodyBuffer() {\n         }\n     }\n \n+    /**\n+     * Returns the body buffer if it was written to and writing to it was finished through {@link Request#endOfBufferInput()}\n+     * @return body buffer if it was written to and writing was finished; returns {@code null} otherwise.\n+     */\n     @Nullable\n     public CharBuffer getBodyBufferForSerialization() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NjU0Mg=="}, "originalCommit": {"oid": "da1f82125e63eed5bb1dcd935e5c09840082ef58"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY3OTM5Mw==", "bodyText": "\ud83d\udc4d That was also something that made the rabbitmq body capture more complex than initially thought.", "url": "https://github.com/elastic/apm-agent-java/pull/1579#discussion_r546679393", "createdAt": "2020-12-21T12:29:02Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Request.java", "diffHunk": "@@ -187,9 +191,17 @@ public CharBuffer getBodyBuffer() {\n         }\n     }\n \n+    /**\n+     * Returns the body buffer if it was written to and writing to it was finished through {@link Request#endOfBufferInput()}\n+     * @return body buffer if it was written to and writing was finished; returns {@code null} otherwise.\n+     */\n     @Nullable\n     public CharBuffer getBodyBufferForSerialization() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU4NjU0Mg=="}, "originalCommit": {"oid": "da1f82125e63eed5bb1dcd935e5c09840082ef58"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNjM2NjY2OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/org/example/stacktrace/ErrorCaptureTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOToxMjo0MVrOIJRP4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwOToxMjo0MVrOIJRP4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU5MDY4OA==", "bodyText": "[minor] move comment to assertion description.", "url": "https://github.com/elastic/apm-agent-java/pull/1579#discussion_r546590688", "createdAt": "2020-12-21T09:12:41Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/test/java/org/example/stacktrace/ErrorCaptureTest.java", "diffHunk": "@@ -82,4 +84,34 @@ public NestedException(Throwable cause) {\n         }\n     }\n \n+    @Test\n+    void testTransactionContextTransfer() {\n+        final Transaction transaction = new Transaction(tracer);\n+        Request transactionRequest = transaction.getContext().getRequest()\n+            .withMethod(\"GET\")\n+            .addHeader(\"key\", \"value\");\n+        transactionRequest.withBodyBuffer().append(\"TEST\");\n+        transactionRequest.endOfBufferInput();\n+        final ErrorCapture errorCapture = new ErrorCapture(tracer).asChildOf(transaction);\n+        Request errorRequest = errorCapture.getContext().getRequest();\n+        assertThat(errorRequest.getMethod()).isEqualTo(\"GET\");\n+        assertThat(errorRequest.getHeaders().get(\"key\")).isEqualTo(\"value\");\n+        assertThat((Object)errorRequest.getBodyBufferForSerialization()).isNotNull();\n+        assertThat(errorRequest.getBodyBufferForSerialization().toString()).isEqualTo(\"TEST\");\n+    }\n+\n+    @Test\n+    void testTransactionContextTransferNonFinishedBody() {\n+        final Transaction transaction = new Transaction(tracer);\n+        Request transactionRequest = transaction.getContext().getRequest()\n+            .withMethod(\"GET\")\n+            .addHeader(\"key\", \"value\");\n+        transactionRequest.withBodyBuffer().append(\"TEST\");\n+        final ErrorCapture errorCapture = new ErrorCapture(tracer).asChildOf(transaction);\n+        Request errorRequest = errorCapture.getContext().getRequest();\n+        assertThat(errorRequest.getMethod()).isEqualTo(\"GET\");\n+        assertThat(errorRequest.getHeaders().get(\"key\")).isEqualTo(\"value\");\n+        // Since body capturing was not finished, we shouldn't copy it to the error capture", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da1f82125e63eed5bb1dcd935e5c09840082ef58"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 8, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}