{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MTUxOTkz", "number": 1212, "title": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR", "bodyText": "closes #557\nreopened from #557\ncloses #384\n\n changelog\n test\n integration-test\n capture exception from headers\n fixed logic with early span creation\n added to documentation (supported technologies page)", "createdAt": "2020-06-01T18:47:37Z", "url": "https://github.com/elastic/apm-agent-java/pull/1212", "merged": true, "mergeCommit": {"oid": "30ba723a3e9551ffee083acc44818c0017286ce6"}, "closed": true, "closedAt": "2020-08-21T15:49:09Z", "author": {"login": "kananindzya"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnF5xCgBqjMzOTQ2NzM4NDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBG1K8AFqTQ3MjYwMjAzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9dfa4cc4888141ac8d58a0930fd5be4e80864786", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/9dfa4cc4888141ac8d58a0930fd5be4e80864786", "committedDate": "2020-06-01T18:45:12Z", "message": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR"}, "afterCommit": {"oid": "e33b14d3c9653ded790ad9609470b83f792a204c", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/e33b14d3c9653ded790ad9609470b83f792a204c", "committedDate": "2020-06-01T20:01:28Z", "message": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa132ba39b2cab2a9740855f68f3b731ed6cba1e", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/fa132ba39b2cab2a9740855f68f3b731ed6cba1e", "committedDate": "2020-06-02T11:25:06Z", "message": "clear"}, "afterCommit": {"oid": "722d42a183c275c40baeeac707fcf1c121d790c5", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/722d42a183c275c40baeeac707fcf1c121d790c5", "committedDate": "2020-06-02T11:29:30Z", "message": "clear"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "722d42a183c275c40baeeac707fcf1c121d790c5", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/722d42a183c275c40baeeac707fcf1c121d790c5", "committedDate": "2020-06-02T11:29:30Z", "message": "clear"}, "afterCommit": {"oid": "99a0789c1ecd67af76eef0a2b199311605b892e8", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/99a0789c1ecd67af76eef0a2b199311605b892e8", "committedDate": "2020-06-02T11:35:36Z", "message": "clear"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "847a73da576062dcc4bb90a6b384383d3ad6c63c", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/847a73da576062dcc4bb90a6b384383d3ad6c63c", "committedDate": "2020-06-09T05:24:39Z", "message": "added path info for span name of FORWARD, INCLUDE dispatcher types."}, "afterCommit": {"oid": "6eef95e0b3154103e28940fe58474d994b65ab1e", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/6eef95e0b3154103e28940fe58474d994b65ab1e", "committedDate": "2020-06-09T05:26:35Z", "message": "added path info for span name of FORWARD, INCLUDE dispatcher types."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6eef95e0b3154103e28940fe58474d994b65ab1e", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/6eef95e0b3154103e28940fe58474d994b65ab1e", "committedDate": "2020-06-09T05:26:35Z", "message": "added path info for span name of FORWARD, INCLUDE dispatcher types."}, "afterCommit": {"oid": "db73c877c9ba112d75d5dd2bff71ecca2c509365", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/db73c877c9ba112d75d5dd2bff71ecca2c509365", "committedDate": "2020-06-09T18:52:46Z", "message": "delete testTransactionReportingWithErrorHandling test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0894c243e92c005a42304065eed7338013303f93", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/0894c243e92c005a42304065eed7338013303f93", "committedDate": "2020-06-09T19:54:27Z", "message": "run tests"}, "afterCommit": {"oid": "ede29338fb5a47532d42ec1b61a46634299cd594", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/ede29338fb5a47532d42ec1b61a46634299cd594", "committedDate": "2020-06-14T20:36:50Z", "message": "return setFramework"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzU4ODI0", "url": "https://github.com/elastic/apm-agent-java/pull/1212#pullrequestreview-433358824", "createdAt": "2020-06-18T14:45:38Z", "commit": {"oid": "96711728acd8fb3d4b652c676cf29ee656ecd085"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNDo0NTozOFrOGlyz4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNToyNToyMVrOGl0hxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI4Mjk3Nw==", "bodyText": "This is allocating four String objects every time. Please use the AbstractSpan#appendToName() API instead (create it before).\nSame for the other ones.", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442282977", "createdAt": "2020-06-18T14:45:38Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96711728acd8fb3d4b652c676cf29ee656ecd085"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5MTE2Ng==", "bodyText": "This else statement looks misplaced. Its content should go inside the if above and you can do else with the servletRequest.getDispatcherType() == DispatcherType.REQUEST check.", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442291166", "createdAt": "2020-06-18T14:56:27Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96711728acd8fb3d4b652c676cf29ee656ecd085"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5ODQzMw==", "bodyText": "Why using RequestDispatcher.FORWARD_SERVLET_PATH in this case? I think we want the error page path. The transaction will contain the original servlet path.", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442298433", "createdAt": "2020-06-18T15:06:55Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = FORWARD_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = INCLUDE_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.ERROR) {\n+                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96711728acd8fb3d4b652c676cf29ee656ecd085"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMwMDU3MQ==", "bodyText": "Please check if you already get the Exception object stored in the RequestDispatcher.ERROR_EXCEPTION attribute somewhere else. If not, let's create and send an error here with captureException through the parent span.", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442300571", "createdAt": "2020-06-18T15:10:09Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -143,6 +156,37 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n             servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n                 request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n                 request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+        } else if (transaction == null && servletRequest instanceof HttpServletRequest) {\n+            final AbstractSpan<?> parent = tracer.getActive();\n+            if (parent != null) {\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                DispatcherType dispatcherType = request.getDispatcherType();\n+                boolean isAllowedType = false;\n+                String spanAction = null, spanName = null;\n+                if (dispatcherType == DispatcherType.FORWARD) {\n+                    String pathInfo = request.getPathInfo();\n+                    spanName = FORWARD + SPACE + request.getServletPath() + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = FORWARD_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                    Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                    spanName = INCLUDE + SPACE + request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH) + (pathInfo != null ? pathInfo : EMPTY);\n+                    spanAction = INCLUDE_SPAN_ACTION;\n+                    isAllowedType = true;\n+                } else if (dispatcherType == DispatcherType.ERROR) {\n+                    spanName = ERROR + SPACE + request.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH);\n+                    spanAction = ERROR_SPAN_ACTION;\n+                    isAllowedType = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96711728acd8fb3d4b652c676cf29ee656ecd085"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMxMTExMA==", "bodyText": "You need to assert that exactly the expected spans are captured. Potentially, this can pass if two non-related spans are captured.\nYou can filter the span collection for each and assert you get exactly one that contains the required info.", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r442311110", "createdAt": "2020-06-18T15:25:21Z", "author": {"login": "eyalkoren"}, "path": "integration-tests/application-server-integration-tests/src/test/java/co/elastic/apm/servlet/tests/ServletApiTestApp.java", "diffHunk": "@@ -75,6 +78,58 @@ private void testCaptureBody(AbstractServletContainerIntegrationTest test) throw\n         }\n     }\n \n+    private void testTransactionReportingWithForward(AbstractServletContainerIntegrationTest test) throws Exception {\n+        String pathToTest = \"/simple-webapp\" + \"/forward\";\n+        boolean isExistForwardSpan = false;\n+        boolean isExistDbH2QuerySpan = false;\n+        test.clearMockServerLog();\n+\n+        test.executeAndValidateRequest(pathToTest, \"Hello World\", 200, null);\n+\n+        JsonNode transaction = test.assertTransactionReported(pathToTest, 200);\n+\n+        List<JsonNode> reportedSpans = test.getReportedSpans();\n+        assertThat(reportedSpans.size()).isEqualTo(2);\n+\n+        for (JsonNode span : test.getReportedSpans()) {\n+            String spanType = span.get(\"type\").textValue();\n+            if (\"servlet.request-dispatcher.forward\".equals(spanType)) {\n+                isExistForwardSpan = true;\n+                assertThat(span.get(\"name\").textValue()).isEqualTo(\"FORWARD /servlet\");\n+            } else if (\"db.h2.query\".equals(spanType)) {\n+                isExistDbH2QuerySpan = true;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96711728acd8fb3d4b652c676cf29ee656ecd085"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNzY3MDU3", "url": "https://github.com/elastic/apm-agent-java/pull/1212#pullrequestreview-442767057", "createdAt": "2020-07-06T04:27:39Z", "commit": {"oid": "4be406076c63ed4421d7b9e4fa1a9faec3914b18"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDoyNzozOVrOGtIcrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwNDo0ODo0MFrOGtItOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NzUxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String FORWARD = \"FORWARD\";\n          \n          \n            \n                private static final String INCLUDE = \"INCLUDE\";\n          \n          \n            \n                private static final String ERROR = \"ERROR\";\n          \n          \n            \n                private static final String SPACE = \" \";\n          \n          \n            \n                private static final String EMPTY = \"\";\n          \n          \n            \n                private static final String FORWARD = \"FORWARD \";\n          \n          \n            \n                private static final String INCLUDE = \"INCLUDE \";\n          \n          \n            \n                private static final String ERROR = \"ERROR \";", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977518", "createdAt": "2020-07-06T04:27:39Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -60,6 +63,16 @@\n public class ServletApiAdvice {\n \n     private static final String FRAMEWORK_NAME = \"Servlet API\";\n+    private static final String SPAN_TYPE = \"servlet\";\n+    private static final String SPAN_SUBTYPE = \"request-dispatcher\";\n+    private static final String FORWARD_SPAN_ACTION = \"forward\";\n+    private static final String INCLUDE_SPAN_ACTION = \"include\";\n+    private static final String ERROR_SPAN_ACTION = \"error\";\n+    private static final String FORWARD = \"FORWARD\";\n+    private static final String INCLUDE = \"INCLUDE\";\n+    private static final String ERROR = \"ERROR\";\n+    private static final String SPACE = \" \";\n+    private static final String EMPTY = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4be406076c63ed4421d7b9e4fa1a9faec3914b18"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzg2Mg==", "bodyText": "Why is the transaction == null required here? Seems it will always be null", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977862", "createdAt": "2020-07-06T04:29:14Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4be406076c63ed4421d7b9e4fa1a9faec3914b18"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3Nzk0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    span.withAction(FORWARD_SPAN_ACTION);\n          \n          \n            \n                                    span.withAction(INCLUDE_SPAN_ACTION);", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449977945", "createdAt": "2020-07-06T04:29:41Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);\n+\n+                    if (dispatcherType == DispatcherType.FORWARD) {\n+                        span.appendToName(FORWARD)\n+                            .appendToName(SPACE)\n+                            .appendToName(request.getServletPath());\n+                        if (request.getPathInfo() != null) {\n+                            span.appendToName(request.getPathInfo());\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n+                        span.appendToName(INCLUDE)\n+                            .appendToName(SPACE);\n+                        if (includeServletPath != null) {\n+                            span.appendToName((String) includeServletPath);\n+                        }\n+                        if (pathInfo != null) {\n+                            span.appendToName((String) pathInfo);\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4be406076c63ed4421d7b9e4fa1a9faec3914b18"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk4MDU0NA==", "bodyText": "Do not create a span unless you know we need one. Currently these spans can leak. You must always end a span you created, like you must always deactivate a span you activated (which you did).\nIn rare cases (this is not one), you may create a span and then requestDiscarding it, but you still must end it.", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449980544", "createdAt": "2020-07-06T04:42:06Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4be406076c63ed4421d7b9e4fa1a9faec3914b18"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk4MTc1Mg==", "bodyText": "getNameAsString is allocating a String objects (so two in this comparison).\nThere are better ways to avoid creation of same nested spans. For example, before creating a span, see if the parent span has the same type, subtype and action.\nWhat cases are you trying to prevent with this comparison?", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r449981752", "createdAt": "2020-07-06T04:48:40Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -100,49 +122,96 @@ public static void onEnterServletService(@Advice.Argument(0) ServletRequest serv\n         if (tracer.isRunning() &&\n             servletTransactionHelper != null &&\n             servletRequest instanceof HttpServletRequest &&\n-            servletRequest.getDispatcherType() == DispatcherType.REQUEST &&\n             !Boolean.TRUE.equals(excluded.get())) {\n+            if (servletRequest.getDispatcherType() == DispatcherType.REQUEST) {\n+                ServletContext servletContext = servletRequest.getServletContext();\n+                if (servletContext != null) {\n+                    // this makes sure service name discovery also works when attaching at runtime\n+                    determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n+                }\n \n-            ServletContext servletContext = servletRequest.getServletContext();\n-            if (servletContext != null) {\n-                // this makes sure service name discovery also works when attaching at runtime\n-                determineServiceName(servletContext.getServletContextName(), servletContext.getClassLoader(), servletContext.getContextPath());\n-            }\n-\n-            final HttpServletRequest request = (HttpServletRequest) servletRequest;\n-            if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n-                ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n-                    ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n-                if (helper != null) {\n-                    transaction = helper.createAndActivateTransaction(request);\n+                final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                if (ServletInstrumentation.servletTransactionCreationHelperManager != null) {\n+                    ServletInstrumentation.ServletTransactionCreationHelper<HttpServletRequest> helper =\n+                        ServletInstrumentation.servletTransactionCreationHelperManager.getForClassLoaderOfClass(HttpServletRequest.class);\n+                    if (helper != null) {\n+                        transaction = helper.createAndActivateTransaction(request);\n+                    }\n                 }\n-            }\n \n-            if (transaction == null) {\n-                // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n-                excluded.set(Boolean.TRUE);\n-                return;\n-            }\n-            final Request req = transaction.getContext().getRequest();\n-            if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n-                if (request.getCookies() != null) {\n-                    for (Cookie cookie : request.getCookies()) {\n-                        req.addCookie(cookie.getName(), cookie.getValue());\n+                if (transaction == null) {\n+                    // if the request is excluded, avoid matching all exclude patterns again on each filter invocation\n+                    excluded.set(Boolean.TRUE);\n+                    return;\n+                }\n+                final Request req = transaction.getContext().getRequest();\n+                if (transaction.isSampled() && tracer.getConfig(CoreConfiguration.class).isCaptureHeaders()) {\n+                    if (request.getCookies() != null) {\n+                        for (Cookie cookie : request.getCookies()) {\n+                            req.addCookie(cookie.getName(), cookie.getValue());\n+                        }\n+                    }\n+                    final Enumeration<String> headerNames = request.getHeaderNames();\n+                    if (headerNames != null) {\n+                        while (headerNames.hasMoreElements()) {\n+                            final String headerName = headerNames.nextElement();\n+                            req.addHeader(headerName, request.getHeaders(headerName));\n+                        }\n                     }\n                 }\n-                final Enumeration<String> headerNames = request.getHeaderNames();\n-                if (headerNames != null) {\n-                    while (headerNames.hasMoreElements()) {\n-                        final String headerName = headerNames.nextElement();\n-                        req.addHeader(headerName, request.getHeaders(headerName));\n+                transaction.setFrameworkName(FRAMEWORK_NAME);\n+\n+                servletTransactionHelper.fillRequestContext(transaction, request.getProtocol(), request.getMethod(), request.isSecure(),\n+                    request.getScheme(), request.getServerName(), request.getServerPort(), request.getRequestURI(), request.getQueryString(),\n+                    request.getRemoteAddr(), request.getHeader(\"Content-Type\"));\n+            } else if (transaction == null) {\n+                final AbstractSpan<?> parent = tracer.getActive();\n+                if (parent != null) {\n+                    final HttpServletRequest request = (HttpServletRequest) servletRequest;\n+                    DispatcherType dispatcherType = request.getDispatcherType();\n+                    boolean isSpannableDispatcherType = false;\n+                    span = parent.createSpan()\n+                        .withType(SPAN_TYPE)\n+                        .withSubtype(SPAN_SUBTYPE);\n+\n+                    if (dispatcherType == DispatcherType.FORWARD) {\n+                        span.appendToName(FORWARD)\n+                            .appendToName(SPACE)\n+                            .appendToName(request.getServletPath());\n+                        if (request.getPathInfo() != null) {\n+                            span.appendToName(request.getPathInfo());\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.INCLUDE) {\n+                        Object pathInfo = request.getAttribute(RequestDispatcher.INCLUDE_PATH_INFO);\n+                        Object includeServletPath = request.getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\n+                        span.appendToName(INCLUDE)\n+                            .appendToName(SPACE);\n+                        if (includeServletPath != null) {\n+                            span.appendToName((String) includeServletPath);\n+                        }\n+                        if (pathInfo != null) {\n+                            span.appendToName((String) pathInfo);\n+                        }\n+                        span.withAction(FORWARD_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    } else if (dispatcherType == DispatcherType.ERROR) {\n+                        Object servletPath = request.getServletPath();\n+                        span.appendToName(ERROR)\n+                            .appendToName(SPACE);\n+                        if (servletPath != null) {\n+                            span.appendToName((String) servletPath);\n+                        }\n+                        span.withAction(ERROR_SPAN_ACTION);\n+                        isSpannableDispatcherType = true;\n+                    }\n+                    if (isSpannableDispatcherType && !parent.getNameAsString().equals(span.getNameAsString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4be406076c63ed4421d7b9e4fa1a9faec3914b18"}, "originalPosition": 176}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db15630aa76758604b14c0b2365512207fd3a1ac", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/db15630aa76758604b14c0b2365512207fd3a1ac", "committedDate": "2020-08-05T16:21:11Z", "message": "issue-557 added automatically span creation for DispatcherTypes: FORWARD, INCLUDE, ERROR\nminor fixes with creating span that has same names\nadded path info for span name of FORWARD, INCLUDE dispatcher types.\ndelete testTransactionReportingWithErrorHandling test\nUpdate apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nCo-authored-by: eyalkoren <41850454+eyalkoren@users.noreply.github.com>\nUpdate apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\nCo-authored-by: eyalkoren <41850454+eyalkoren@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e77603e4d1477333942461bf64062d50fe2e104a", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/e77603e4d1477333942461bf64062d50fe2e104a", "committedDate": "2020-08-05T17:52:02Z", "message": "merged from master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b5267a3fa3b46b7102c95a04f71aba54be96a7cd", "author": {"user": {"login": "kananindzya", "name": "Nugusbayev Kanagat"}}, "url": "https://github.com/elastic/apm-agent-java/commit/b5267a3fa3b46b7102c95a04f71aba54be96a7cd", "committedDate": "2020-07-06T07:02:18Z", "message": "Update apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java\n\nCo-authored-by: eyalkoren <41850454+eyalkoren@users.noreply.github.com>"}, "afterCommit": {"oid": "e77603e4d1477333942461bf64062d50fe2e104a", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/e77603e4d1477333942461bf64062d50fe2e104a", "committedDate": "2020-08-05T17:52:02Z", "message": "merged from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52b87b92acaaaec5c596f67c873c3859705fa7d7", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/52b87b92acaaaec5c596f67c873c3859705fa7d7", "committedDate": "2020-08-06T21:48:30Z", "message": "fixed logic with excluded for psans"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0dee5794e079384260e3539dae85bde745f34d9", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/c0dee5794e079384260e3539dae85bde745f34d9", "committedDate": "2020-08-07T19:15:15Z", "message": "fixed logic with span creating, before we check that parent span is has same name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df6c456152ce9e9e57bbdf3a071c992c49369e64", "author": {"user": {"login": "eyalkoren", "name": null}}, "url": "https://github.com/elastic/apm-agent-java/commit/df6c456152ce9e9e57bbdf3a071c992c49369e64", "committedDate": "2020-08-11T13:02:43Z", "message": "Suggested changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzI0MzIy", "url": "https://github.com/elastic/apm-agent-java/pull/1212#pullrequestreview-464324322", "createdAt": "2020-08-10T15:16:55Z", "commit": {"oid": "c0dee5794e079384260e3539dae85bde745f34d9"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deed18c5c5d999c9c105c61164fd9a3a28394fdd", "author": {"user": {"login": "kananindzya", "name": "Nugusbayev Kanagat"}}, "url": "https://github.com/elastic/apm-agent-java/commit/deed18c5c5d999c9c105c61164fd9a3a28394fdd", "committedDate": "2020-08-11T16:39:51Z", "message": "Merge pull request #6 from eyalkoren/suggested-changes\n\nSuggested changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dc1a1f568d8be0fe364e63bff92b4834200b73c", "author": {"user": null}, "url": "https://github.com/elastic/apm-agent-java/commit/0dc1a1f568d8be0fe364e63bff92b4834200b73c", "committedDate": "2020-08-11T19:28:23Z", "message": "added RequestDispatcher.ERROR_EXCEPTION attribute exception handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "532276b369f6339d1ffaf0dd80848bfdb5d12715", "author": {"user": {"login": "eyalkoren", "name": null}}, "url": "https://github.com/elastic/apm-agent-java/commit/532276b369f6339d1ffaf0dd80848bfdb5d12715", "committedDate": "2020-08-12T06:44:39Z", "message": "Merge remote-tracking branch 'upstream/master' into issue-557-track-spans-request-dispatcher-forward-include"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02605be8d4fb2a99161c4a503a079c150764e1ad", "author": {"user": {"login": "eyalkoren", "name": null}}, "url": "https://github.com/elastic/apm-agent-java/commit/02605be8d4fb2a99161c4a503a079c150764e1ad", "committedDate": "2020-08-12T07:16:58Z", "message": "Error handling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NjI3NDc2", "url": "https://github.com/elastic/apm-agent-java/pull/1212#pullrequestreview-465627476", "createdAt": "2020-08-12T06:37:31Z", "commit": {"oid": "0dc1a1f568d8be0fe364e63bff92b4834200b73c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjozNzozMVrOG_TseA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjozNzozMVrOG_TseA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzNjE1Mg==", "bodyText": "No, we can't do that as we don't know if it's the same exception or not.", "url": "https://github.com/elastic/apm-agent-java/pull/1212#discussion_r469036152", "createdAt": "2020-08-12T06:37:31Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-servlet-plugin/src/main/java/co/elastic/apm/agent/servlet/ServletApiAdvice.java", "diffHunk": "@@ -253,8 +254,12 @@ public static void onExitServletService(@Advice.Argument(0) ServletRequest servl\n                         Object throwable = request.getAttribute(attributeName);\n                         if (throwable instanceof Throwable) {\n                             t2 = (Throwable) throwable;\n-                            if (!attributeName.equals(\"javax.servlet.error.exception\")) {\n+                            if (!attributeName.equals(RequestDispatcher.ERROR_EXCEPTION)) {\n                                 overrideStatusCodeOnThrowable = false;\n+                            } else {\n+                                if (Boolean.TRUE.equals(isExceptionAttributeCaptured.get())) {\n+                                    t2 = null;\n+                                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dc1a1f568d8be0fe364e63bff92b4834200b73c"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzE5ODgz", "url": "https://github.com/elastic/apm-agent-java/pull/1212#pullrequestreview-465719883", "createdAt": "2020-08-12T08:54:33Z", "commit": {"oid": "02605be8d4fb2a99161c4a503a079c150764e1ad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50290852236aeb820f6ea322844d71a2a94caf61", "author": {"user": {"login": "SylvainJuge", "name": null}}, "url": "https://github.com/elastic/apm-agent-java/commit/50290852236aeb820f6ea322844d71a2a94caf61", "committedDate": "2020-08-21T14:30:44Z", "message": "Merge branch 'master' into issue-557-track-spans-request-dispatcher-forward-include\n\nAlso apply few minor changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjAyMDM1", "url": "https://github.com/elastic/apm-agent-java/pull/1212#pullrequestreview-472602035", "createdAt": "2020-08-21T15:48:40Z", "commit": {"oid": "50290852236aeb820f6ea322844d71a2a94caf61"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4012, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}