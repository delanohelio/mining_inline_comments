{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NDY1MzY4", "number": 1384, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNToyOToxMlrOEl7XtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozNToyM1rOEqFaLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjA1NDkzOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/configuration/CoreConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNToyOToxMlrOHVqsTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNToyOToxMlrOHVqsTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4MTYxNA==", "bodyText": "The spec talks about precision of 4 decimal places.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r492481614", "createdAt": "2020-09-22T05:29:12Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/configuration/CoreConfiguration.java", "diffHunk": "@@ -162,14 +165,15 @@\n             \"You must use the query bar to filter for a specific environment in versions prior to 7.2.\")\n         .build();\n \n-    private final ConfigurationOption<Double> sampleRate = ConfigurationOption.doubleOption()\n+    private final ConfigurationOption<Double> sampleRate = RoundedDoubleConverter.withPrecision(3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c085e201287495467278c1ade3ba0704eb44d252"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjEzOTc1OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TextTracestateAppender.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjoxNDowN1rOHVrbsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNjoxNDowN1rOHVrbsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ5Mzc0NQ==", "bodyText": "The iteration through index is meant to avoid the allocation of iterator.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r492493745", "createdAt": "2020-09-22T06:14:07Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TextTracestateAppender.java", "diffHunk": "@@ -41,8 +41,10 @@ static TextTracestateAppender instance() {\n \n     public String join(List<String> tracestate, int tracestateSizeLimit) {\n         StringBuilder buffer = getTracestateBuffer();\n-        for (int i = 0, size = tracestate.size(); i < size; i++) {\n-            appendTracestateHeaderValue(tracestate.get(i), buffer, tracestateSizeLimit);\n+        for (String value : tracestate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c085e201287495467278c1ade3ba0704eb44d252"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjI3OTMzOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzowNTowN1rOHVsr_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzowNTowN1rOHVsr_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxNDMwMw==", "bodyText": "This involves a lot of parsing and objects allocation with all those splits and iterations.\nI wonder if we can avoid that by looking for indexof(\"es=\").\nSee details in general comment.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r492514303", "createdAt": "2020-09-22T07:05:07Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final String VENDOR_ENTRIES_SEPARATOR = \",\";\n+    private static final String ENTRY_SEPARATOR = \";\";\n+    private static final String KEY_VALUE_SEPARATOR = \":\";\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_KEY = \"s\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    @Nullable\n+    private Double sampleRate;\n+\n+    /**\n+     * Key/Value pairs for entries in the 'es' namespace\n+     */\n+    private final Map<String, String> entries;\n+\n+    /**\n+     * where elastic apm header is stored (if any) within {@link #tracestate} list.\n+     */\n+    private int index;\n+\n+    /**\n+     * {@literal true} when tracestate array needs an update at known index\n+     */\n+    private boolean needsUpdate;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = null;\n+        entries = new LinkedHashMap<>(1);\n+        index = -1;\n+        needsUpdate = false;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+        entries.clear();\n+        entries.putAll(other.entries);\n+        index = other.index;\n+        needsUpdate = other.needsUpdate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        for (String header : headerValue.split(VENDOR_ENTRIES_SEPARATOR)) {\n+            addSingleHeader(header);\n+        }\n+    }\n+\n+    private void addSingleHeader(String header) {\n+        if (header.startsWith(VENDOR_PREFIX)) {\n+            index = tracestate.size();\n+            for (String entry : header.substring(3).split(ENTRY_SEPARATOR)) {\n+                String[] entryParts = entry.split(KEY_VALUE_SEPARATOR);\n+                if (entryParts.length == 2) {\n+                    String key = entryParts[0];\n+                    String value = entryParts[1];\n+                    if (SAMPLE_RATE_KEY.equals(key)) {\n+                        try {\n+                            double doubleValue = Double.parseDouble(value);\n+                            if (0 <= doubleValue && doubleValue <= 1.0) {\n+                                // ensure proper rounding of sample rate to minimize storage\n+                                // even if configuration should not allow this, any upstream value might require rounding\n+                                double rounded = Math.round(doubleValue * 10000d) / 10000d;\n+\n+                                needsUpdate = doubleValue != rounded;\n+                                sampleRate = rounded;\n+\n+                                entries.put(SAMPLE_RATE_KEY, sampleRate.toString());\n+                            }\n+                        } catch (NumberFormatException e) {\n+                            // silently ignored\n+                        }\n+                    } else {\n+                        entries.put(key, value);\n+                    }\n+                }\n+            }\n+        }\n+        tracestate.add(header);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c085e201287495467278c1ade3ba0704eb44d252"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjI4NTUyOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzowNzoyMFrOHVsvzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzowNzoyMFrOHVsvzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxNTI3OA==", "bodyText": "It is a Recyclable type, why not reuse the same StringBuilder?", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r492515278", "createdAt": "2020-09-22T07:07:20Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final String VENDOR_ENTRIES_SEPARATOR = \",\";\n+    private static final String ENTRY_SEPARATOR = \";\";\n+    private static final String KEY_VALUE_SEPARATOR = \":\";\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_KEY = \"s\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    @Nullable\n+    private Double sampleRate;\n+\n+    /**\n+     * Key/Value pairs for entries in the 'es' namespace\n+     */\n+    private final Map<String, String> entries;\n+\n+    /**\n+     * where elastic apm header is stored (if any) within {@link #tracestate} list.\n+     */\n+    private int index;\n+\n+    /**\n+     * {@literal true} when tracestate array needs an update at known index\n+     */\n+    private boolean needsUpdate;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = null;\n+        entries = new LinkedHashMap<>(1);\n+        index = -1;\n+        needsUpdate = false;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+        entries.clear();\n+        entries.putAll(other.entries);\n+        index = other.index;\n+        needsUpdate = other.needsUpdate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        for (String header : headerValue.split(VENDOR_ENTRIES_SEPARATOR)) {\n+            addSingleHeader(header);\n+        }\n+    }\n+\n+    private void addSingleHeader(String header) {\n+        if (header.startsWith(VENDOR_PREFIX)) {\n+            index = tracestate.size();\n+            for (String entry : header.substring(3).split(ENTRY_SEPARATOR)) {\n+                String[] entryParts = entry.split(KEY_VALUE_SEPARATOR);\n+                if (entryParts.length == 2) {\n+                    String key = entryParts[0];\n+                    String value = entryParts[1];\n+                    if (SAMPLE_RATE_KEY.equals(key)) {\n+                        try {\n+                            double doubleValue = Double.parseDouble(value);\n+                            if (0 <= doubleValue && doubleValue <= 1.0) {\n+                                // ensure proper rounding of sample rate to minimize storage\n+                                // even if configuration should not allow this, any upstream value might require rounding\n+                                double rounded = Math.round(doubleValue * 10000d) / 10000d;\n+\n+                                needsUpdate = doubleValue != rounded;\n+                                sampleRate = rounded;\n+\n+                                entries.put(SAMPLE_RATE_KEY, sampleRate.toString());\n+                            }\n+                        } catch (NumberFormatException e) {\n+                            // silently ignored\n+                        }\n+                    } else {\n+                        entries.put(key, value);\n+                    }\n+                }\n+            }\n+        }\n+        tracestate.add(header);\n+    }\n+\n+    public void setSampleRate(@Nullable Double rate) {\n+        if (null == sampleRate && rate != null) {\n+            // set first sample rate, actual value will be lazily written\n+            tracestate.add(null);\n+            index = 0;\n+        }\n+        if (rate == null) {\n+            entries.remove(SAMPLE_RATE_KEY);\n+        }\n+        needsUpdate = true;\n+        sampleRate = rate;\n+    }\n+\n+    /**\n+     * @return sample rate set in tracestate header, {@literal null} if not set\n+     */\n+    @Nullable\n+    public Double getSampleRate() {\n+        return sampleRate;\n+    }\n+\n+    /**\n+     * Serializes tracestate to a string representation\n+     *\n+     * @return string representation of tracestate header\n+     */\n+    @Nullable\n+    public String toTextHeader(int sizeLimit) {\n+        if (tracestate.isEmpty()) {\n+            return null;\n+        }\n+        if (needsUpdate) {\n+            if (sampleRate != null) {\n+                entries.put(SAMPLE_RATE_KEY, sampleRate.toString());\n+            }\n+            tracestate.set(index, getHeaderValue(entries));\n+        }\n+\n+        String value;\n+        if (tracestate.size() == 1) {\n+            value = tracestate.get(0);\n+        } else {\n+            value = TextTracestateAppender.instance().join(tracestate, sizeLimit);\n+        }\n+        return value;\n+    }\n+\n+    @Nullable\n+    private static String getHeaderValue(Map<String, String> entries) {\n+        if (entries.isEmpty()) {\n+            return null;\n+        }\n+        StringBuilder sb = new StringBuilder(VENDOR_PREFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c085e201287495467278c1ade3ba0704eb44d252"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjM0MjAzOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzoyNTozM1rOHVtRng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzoyNTozM1rOHVtRng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUyMzkzNA==", "bodyText": "There is no caching for Double objects, use a constant instead of allocating every time (due to autoboxing).", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r492523934", "createdAt": "2020-09-22T07:25:33Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java", "diffHunk": "@@ -486,6 +494,20 @@ public boolean isSampled() {\n         return isRecorded();\n     }\n \n+    /**\n+     * Returns the sample rate used for this transaction/span between 0.0 and 1.0 or {@literal null} if sample rate is unknown\n+     *\n+     * @return sample rate\n+     */\n+    @Nullable\n+    public Double getSampleRate() {\n+        if (isRecorded()) {\n+            return traceState.getSampleRate();\n+        } else {\n+            return 0d;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c085e201287495467278c1ade3ba0704eb44d252"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTgxNDczOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/configuration/CoreConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDoyMTowNFrOHZvtlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDoyMTowNFrOHZvtlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc1ODE2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"Value will be rounded with 3 significant digits, as an example, value '0.5555' will be rounded to `0.556`\")\n          \n          \n            \n                        \"Value will be rounded with 4 significance digits, as an example, value '0.55555' will be rounded to `0.5556`\")", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r496758167", "createdAt": "2020-09-29T14:21:04Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/configuration/CoreConfiguration.java", "diffHunk": "@@ -162,14 +165,15 @@\n             \"You must use the query bar to filter for a specific environment in versions prior to 7.2.\")\n         .build();\n \n-    private final ConfigurationOption<Double> sampleRate = ConfigurationOption.doubleOption()\n+    private final ConfigurationOption<Double> sampleRate = RoundedDoubleConverter.withPrecision(4)\n         .key(SAMPLE_RATE)\n         .aliasKeys(\"sample_rate\")\n         .configurationCategory(CORE_CATEGORY)\n         .tags(\"performance\")\n         .description(\"By default, the agent will sample every transaction (e.g. request to your service). \" +\n             \"To reduce overhead and storage requirements, you can set the sample rate to a value between 0.0 and 1.0. \" +\n-            \"We still record overall time and the result for unsampled transactions, but no context information, labels, or spans.\")\n+            \"We still record overall time and the result for unsampled transactions, but no context information, labels, or spans.\\n\\n\" +\n+            \"Value will be rounded with 3 significant digits, as an example, value '0.5555' will be rounded to `0.556`\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTgyMzI5OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDoyMjo0M1rOHZvy_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDoyMjo0M1rOHZvy_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc1OTU1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // avoid", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r496759551", "createdAt": "2020-09-29T14:22:43Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceContext.java", "diffHunk": "@@ -101,6 +99,10 @@\n     private static final int BINARY_FORMAT_FLAGS_OFFSET = 27;\n     private static final byte BINARY_FORMAT_FLAGS_FIELD_ID = (byte) 0b0000_0010;\n     private static final Logger logger = LoggerFactory.getLogger(TraceContext.class);\n+\n+    // avoid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTg2NTQyOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDozMTowNFrOHZwNlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDozMTowNFrOHZwNlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2NjM1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    sampleRate = Double.MIN_VALUE;\n          \n          \n            \n                    sampleRate = Double.MIN_VALUE;\n          \n          \n            \n                    tempBuffer.setLength(0);\n          \n      \n    \n    \n  \n\nJust to make it explicit...", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r496766356", "createdAt": "2020-09-29T14:31:04Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }\n+                double value;\n+                try {\n+                    value = Double.parseDouble(headerValue.substring(valueStart, valueEnd));\n+                    if (0 <= value && value <= 1.0) {\n+                        // ensure proper rounding of sample rate to minimize storage\n+                        // even if configuration should not allow this, any upstream value might require rounding\n+                        double rounded = Math.round(value * 10000d) / 10000d;\n+\n+                        if (rounded != value) {\n+                            headerValue = rewriteHeaderSampleRate(headerValue, valueStart, valueEnd, rounded);\n+                        }\n+                        sampleRate = rounded;\n+                    }\n+                } catch (NumberFormatException e) {\n+                    // silently ignored\n+                }\n+            }\n+        }\n+        tracestate.add(headerValue);\n+    }\n+\n+    private String rewriteHeaderSampleRate(String originalHeader, int valueStart, int valueEnd, double sampleRate) {\n+        tempBuffer.setLength(0);\n+        tempBuffer.append(originalHeader, 0, valueStart);\n+        tempBuffer.append(sampleRate);\n+        tempBuffer.append(originalHeader, valueEnd, originalHeader.length());\n+        return tempBuffer.toString();\n+    }\n+\n+    private String writeHeader(double sampleRate) {\n+        if (sampleRate == lastWrittenRate && lastWrittenHeader != null) {\n+            return lastWrittenHeader;\n+        }\n+\n+        tempBuffer.setLength(0);\n+        tempBuffer.append(VENDOR_PREFIX);\n+        tempBuffer.append(SAMPLE_RATE_PREFIX).append(sampleRate);\n+        lastWrittenHeader = tempBuffer.toString();\n+        lastWrittenRate = sampleRate;\n+        return lastWrittenHeader;\n+    }\n+\n+    /**\n+     * Sets sample rate if it hasn't already been set\n+     *\n+     * @param rate sample rate\n+     * @throws IllegalStateException if sample rate has already been set\n+     */\n+    public void setSampleRate(double rate) {\n+        if (sampleRate != Double.MIN_VALUE) {\n+            // sample rate is set either explicitly from this method (for root transactions)\n+            // or through upstream header, thus there is no need to change after. This allows to only\n+            // write/rewrite headers once\n+            throw new IllegalStateException(\"sample rate has already been set from headers\");\n+        }\n+        tracestate.add(writeHeader(rate));\n+        sampleRate = rate;\n+    }\n+\n+    /**\n+     * @return sample rate set in tracestate header, {@literal null} if not set\n+     */\n+    @Nullable\n+    public Double getSampleRate() {\n+        return Double.MIN_VALUE == sampleRate ? null : sampleRate;\n+    }\n+\n+    /**\n+     * Serializes tracestate to a string representation\n+     *\n+     * @return string representation of tracestate header\n+     */\n+    @Nullable\n+    public String toTextHeader(int sizeLimit) {\n+        if (tracestate.isEmpty()) {\n+            return null;\n+        } else if (tracestate.size() == 1) {\n+            return tracestate.get(0);\n+        } else {\n+            return TextTracestateAppender.instance().join(tracestate, sizeLimit);\n+        }\n+    }\n+\n+    @Nullable\n+    String toTextHeader() {\n+        return toTextHeader(Integer.MAX_VALUE);\n+    }\n+\n+    @Override\n+    public void resetState() {\n+        tracestate.clear();\n+        sampleRate = Double.MIN_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTkyMzA5OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0MjozNFrOHZwx-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoxMTo0OFrOHafj9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NTY3Mw==", "bodyText": "These are not cleared in resetState(). Regardless, caching per TraceState instance seems not as useful.\nI think these state fields are only get set in setSampleRate(), which is only called in a single place (besides tests) with the value of the sampler.\nWhat do you say about removing these states from here and instead add a String representation for the sample rate into Sampler implementations that is being calculated in the constructor, and a matching interface method? Then get it from the sampler when appending to the outgoing header. Take a look at https://github.com/elastic/apm-agent-java/blob/master/apm-agent-core/src/main/java/co/elastic/apm/agent/impl/ElasticApmTracer.java#L142-L147 - when the sampling rate config changes, a new PorbabilitySampler will be created, setting the proper string representation as well.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r496775673", "createdAt": "2020-09-29T14:42:34Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU0MjEzNA==", "bodyText": "fixed in the last commit, we now have a static value stored in the sampler once for all.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497542134", "createdAt": "2020-09-30T14:11:48Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NTY3Mw=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTk0Mzg1OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0NjozNVrOHZw-9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0NjozNVrOHZw-9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3ODk5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n          \n          \n            \n                        int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX, index);\n          \n      \n    \n    \n  \n\ns: is not unlikely to be used by other vendors.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r496778997", "createdAt": "2020-09-29T14:46:35Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjg2NTU3OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNDozNTo0MlrOHaM_cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoxMjoxN1rOHaflNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIzNzg3NQ==", "bodyText": "Why do we need this autoboxing? So we can have null? Can we use -1 (or any negative value) to denote that the sample rate was not set instead?", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497237875", "createdAt": "2020-09-30T04:35:42Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }\n+                double value;\n+                try {\n+                    value = Double.parseDouble(headerValue.substring(valueStart, valueEnd));\n+                    if (0 <= value && value <= 1.0) {\n+                        // ensure proper rounding of sample rate to minimize storage\n+                        // even if configuration should not allow this, any upstream value might require rounding\n+                        double rounded = Math.round(value * 10000d) / 10000d;\n+\n+                        if (rounded != value) {\n+                            headerValue = rewriteHeaderSampleRate(headerValue, valueStart, valueEnd, rounded);\n+                        }\n+                        sampleRate = rounded;\n+                    }\n+                } catch (NumberFormatException e) {\n+                    // silently ignored\n+                }\n+            }\n+        }\n+        tracestate.add(headerValue);\n+    }\n+\n+    private String rewriteHeaderSampleRate(String originalHeader, int valueStart, int valueEnd, double sampleRate) {\n+        tempBuffer.setLength(0);\n+        tempBuffer.append(originalHeader, 0, valueStart);\n+        tempBuffer.append(sampleRate);\n+        tempBuffer.append(originalHeader, valueEnd, originalHeader.length());\n+        return tempBuffer.toString();\n+    }\n+\n+    private String writeHeader(double sampleRate) {\n+        if (sampleRate == lastWrittenRate && lastWrittenHeader != null) {\n+            return lastWrittenHeader;\n+        }\n+\n+        tempBuffer.setLength(0);\n+        tempBuffer.append(VENDOR_PREFIX);\n+        tempBuffer.append(SAMPLE_RATE_PREFIX).append(sampleRate);\n+        lastWrittenHeader = tempBuffer.toString();\n+        lastWrittenRate = sampleRate;\n+        return lastWrittenHeader;\n+    }\n+\n+    /**\n+     * Sets sample rate if it hasn't already been set\n+     *\n+     * @param rate sample rate\n+     * @throws IllegalStateException if sample rate has already been set\n+     */\n+    public void setSampleRate(double rate) {\n+        if (sampleRate != Double.MIN_VALUE) {\n+            // sample rate is set either explicitly from this method (for root transactions)\n+            // or through upstream header, thus there is no need to change after. This allows to only\n+            // write/rewrite headers once\n+            throw new IllegalStateException(\"sample rate has already been set from headers\");\n+        }\n+        tracestate.add(writeHeader(rate));\n+        sampleRate = rate;\n+    }\n+\n+    /**\n+     * @return sample rate set in tracestate header, {@literal null} if not set\n+     */\n+    @Nullable\n+    public Double getSampleRate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU0MjQ1NA==", "bodyText": "fixed in last commit, we now use Double.NaN as a way to express the lack of value.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497542454", "createdAt": "2020-09-30T14:12:17Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }\n+                double value;\n+                try {\n+                    value = Double.parseDouble(headerValue.substring(valueStart, valueEnd));\n+                    if (0 <= value && value <= 1.0) {\n+                        // ensure proper rounding of sample rate to minimize storage\n+                        // even if configuration should not allow this, any upstream value might require rounding\n+                        double rounded = Math.round(value * 10000d) / 10000d;\n+\n+                        if (rounded != value) {\n+                            headerValue = rewriteHeaderSampleRate(headerValue, valueStart, valueEnd, rounded);\n+                        }\n+                        sampleRate = rounded;\n+                    }\n+                } catch (NumberFormatException e) {\n+                    // silently ignored\n+                }\n+            }\n+        }\n+        tracestate.add(headerValue);\n+    }\n+\n+    private String rewriteHeaderSampleRate(String originalHeader, int valueStart, int valueEnd, double sampleRate) {\n+        tempBuffer.setLength(0);\n+        tempBuffer.append(originalHeader, 0, valueStart);\n+        tempBuffer.append(sampleRate);\n+        tempBuffer.append(originalHeader, valueEnd, originalHeader.length());\n+        return tempBuffer.toString();\n+    }\n+\n+    private String writeHeader(double sampleRate) {\n+        if (sampleRate == lastWrittenRate && lastWrittenHeader != null) {\n+            return lastWrittenHeader;\n+        }\n+\n+        tempBuffer.setLength(0);\n+        tempBuffer.append(VENDOR_PREFIX);\n+        tempBuffer.append(SAMPLE_RATE_PREFIX).append(sampleRate);\n+        lastWrittenHeader = tempBuffer.toString();\n+        lastWrittenRate = sampleRate;\n+        return lastWrittenHeader;\n+    }\n+\n+    /**\n+     * Sets sample rate if it hasn't already been set\n+     *\n+     * @param rate sample rate\n+     * @throws IllegalStateException if sample rate has already been set\n+     */\n+    public void setSampleRate(double rate) {\n+        if (sampleRate != Double.MIN_VALUE) {\n+            // sample rate is set either explicitly from this method (for root transactions)\n+            // or through upstream header, thus there is no need to change after. This allows to only\n+            // write/rewrite headers once\n+            throw new IllegalStateException(\"sample rate has already been set from headers\");\n+        }\n+        tracestate.add(writeHeader(rate));\n+        sampleRate = rate;\n+    }\n+\n+    /**\n+     * @return sample rate set in tracestate header, {@literal null} if not set\n+     */\n+    @Nullable\n+    public Double getSampleRate() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIzNzg3NQ=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjg3Mzg2OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/serialize/DslJsonSerializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNDo0MDo1NFrOHaNEFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNDo0MDo1NFrOHaNEFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIzOTA2Mg==", "bodyText": "I think we can avoid the autoboxing to Double - a check of >= 0 can do the trick.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497239062", "createdAt": "2020-09-30T04:40:54Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/report/serialize/DslJsonSerializer.java", "diffHunk": "@@ -498,15 +498,21 @@ private void serializeKubeNodeInfo(@Nullable SystemInfo.Kubernetes.Node node) {\n     }\n \n     private void serializeTransaction(final Transaction transaction) {\n+        TraceContext traceContext = transaction.getTraceContext();\n+\n         jw.writeByte(OBJECT_START);\n         writeTimestamp(transaction.getTimestamp());\n         writeField(\"name\", transaction.getNameForSerialization());\n-        serializeTraceContext(transaction.getTraceContext(), false);\n+        serializeTraceContext(traceContext, false);\n         writeField(\"type\", transaction.getType());\n         writeField(\"duration\", transaction.getDurationMs());\n         writeField(\"result\", transaction.getResult());\n-        serializeContext(transaction, transaction.getContext(), transaction.getTraceContext());\n+        serializeContext(transaction, transaction.getContext(), traceContext);\n         serializeSpanCount(transaction.getSpanCount());\n+        Double sampleRate = traceContext.getSampleRate();\n+        if (sampleRate != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjg4NDk1OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNDo0NzozMFrOHaNKXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNDo0NzozMFrOHaNKXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MDY2OA==", "bodyText": "[minor]\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int index = headerValue.indexOf(VENDOR_PREFIX);\n          \n          \n            \n                    int elasticEntryStartIndex = headerValue.indexOf(VENDOR_PREFIX);", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497240668", "createdAt": "2020-09-30T04:47:30Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjkwMTUxOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNDo1Nzo1NFrOHaNUAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzo1NDo1N1rOHa-rNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MzEzNg==", "bodyText": "We need to add handling to a situation where es= is found but it doesn't have the s: entry. In this case, we need to log a warning and decide on the sample rate. Maybe it should be 1.0?", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497243136", "createdAt": "2020-09-30T04:57:54Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxNjc2Mw==", "bodyText": "This case is covered by the spec and we should not have a sample rate set\n\nFor non-root transactions the agent must parse incoming tracestate headers to identify the es entry and extract the s attribute. The s attribute value should be used to populate the sample_rate field of transactions and spans. If there is no tracestate or no valid es entry with an s attribute, then the agent must omit sample_rate from non-root transactions and their spans.\n\nHowever I agree with you that we probably miss a corner test case on this one.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497516763", "createdAt": "2020-09-30T13:39:07Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MzEzNg=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyNTM2Mw==", "bodyText": "And we should forward downstream as is, without adding it?", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497525363", "createdAt": "2020-09-30T13:50:09Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MzEzNg=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5ODM0NA==", "bodyText": "That's how I understand the spec but that might not be consistent:\n\nwe currently fix rounding from upstream header if required\nvalues < 0.0 and > 1.0, invalid or missing are just ignored, but we propagate them as-is when we might be able to \"fix\" them by using value from sampler.\n\nMaybe just not propagating headers as-is when they aren't valid would make more sense.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497598344", "createdAt": "2020-09-30T15:23:03Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MzEzNg=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA1MTg5Mg==", "bodyText": "I remember that the logic to add it or not depends on if the transaction is a root transaction or not:\n\nif it's a root transaction: we add the sample_rate\nif it's a child transaction and there is no valid upstream sample_rate, we do not add it so apm-server will use 1 as total distributed transaction weight (this behavior is the one used by agents that don't implement sample_rate, thus we keep it as-is for compatibility).\nif it's a child transaction and there is a valid sample rate, we use and propagate it\n\nThus, to me the case where we have an invalid value (or no value) for sample rate is included in 2), but propagate as-is even if we know it's bogus is an open question.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r498051892", "createdAt": "2020-10-01T07:54:57Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TraceState implements Recyclable {\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+\n+    /**\n+     * List of tracestate header values\n+     */\n+    private final List<String> tracestate;\n+\n+    /**\n+     * sample rate, null if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    // temp buffer used for rewriting\n+    private final StringBuilder tempBuffer = new StringBuilder();\n+\n+    // cache to avoid rewriting same header many times when rate does not change\n+    private double lastWrittenRate = Double.NaN;\n+    @Nullable\n+    private String lastWrittenHeader = null;\n+\n+    public TraceState() {\n+        tracestate = new ArrayList<>(1);\n+        sampleRate = Double.MIN_VALUE;\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        tracestate.clear();\n+        tracestate.addAll(other.tracestate);\n+        sampleRate = other.sampleRate;\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int index = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (index >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MzEzNg=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjkyNzI1OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/transaction/TraceContextTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwNToxMzozMFrOHaNjpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwODoyOToxNFrOHa_5EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0NzE0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"es=s:0.42|0.42\",\n          \n          \n            \n                    \"es=s:0.42|0.42\",\n          \n          \n            \n                    \"es=d:0.42|(maybe 1.0?)\",", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497247143", "createdAt": "2020-09-30T05:13:30Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/transaction/TraceContextTest.java", "diffHunk": "@@ -473,11 +481,109 @@ void testRandomValue() {\n     void testSetSampled() {\n         final TraceContext traceContext = TraceContext.with64BitId(tracer);\n         traceContext.asRootSpan(ConstantSampler.of(false));\n+\n+        // not sampled means zero sample rate\n         assertThat(traceContext.isSampled()).isFalse();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0d);\n+\n+        // sampled without sample rate\n         traceContext.setRecorded(true);\n+\n         assertThat(traceContext.isSampled()).isTrue();\n+        assertThat(traceContext.getSampleRate()).isNull();\n+\n+        // sampled with sample rate\n+        traceContext.getTraceState().setSampleRate(0.5d);\n+\n+        assertThat(traceContext.isSampled()).isTrue();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0.5d);\n+\n+        // not sampled, sample rate should be unset\n         traceContext.setRecorded(false);\n         assertThat(traceContext.isSampled()).isFalse();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0.0d);\n+    }\n+\n+    @Test\n+    void testRootSpanShouldAddsSampleRateToTraceState() {\n+        final TraceContext traceContext = createRootSpan(0.42d);\n+        String traceState = traceContext.getTraceState().toTextHeader(Integer.MAX_VALUE);\n+        assertThat(traceState).isEqualTo(\"es=s:0.42\");\n+    }\n+\n+    private TraceContext createRootSpan(double sampleRate){\n+        final TraceContext traceContext = TraceContext.with64BitId(tracer);\n+\n+        Sampler sampler = mock(Sampler.class);\n+        when(sampler.isSampled(any(Id.class))).thenReturn(true);\n+        when(sampler.getSampleRate()).thenReturn(sampleRate);\n+\n+        traceContext.asRootSpan(sampler);\n+        return traceContext;\n+    }\n+\n+    @Test\n+    void testTracedChildSpanWithoutTraceState() {\n+        Map<String, String> headers = Map.of(\n+            TraceContext.W3C_TRACE_PARENT_TEXTUAL_HEADER_NAME, \"00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-01\"\n+        );\n+        TraceContext child = createChildSpanFromHeaders(headers);\n+\n+        assertThat(child.isSampled()).isTrue();\n+        assertThat(child.getSampleRate()).isNull();\n+    }\n+\n+    @Test\n+    void testNonTracedChildSpanWithoutTraceState() {\n+        Map<String, String> headers = Map.of(\n+            TraceContext.W3C_TRACE_PARENT_TEXTUAL_HEADER_NAME, \"00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-00\"\n+        );\n+        TraceContext child = createChildSpanFromHeaders(headers);\n+\n+        assertThat(child.isSampled()).isFalse();\n+        assertThat(child.getSampleRate()).isEqualTo(0.0d);\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(delimiter = '|', value = {\n+        // invalid tracestate values: just assume no sample rate is provided\n+        \"|null\",\n+        \"es=|null\",\n+        \"es=s|null\",\n+        \"es=s:|null\",\n+        \"es=s:a|null\",\n+        // valid tracestate values with sample rate\n+        \"es=s:1|1\",\n+        \"es=s:0.42|0.42\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYxOTEwOQ==", "bodyText": "I looked quickly at ruby (ref impl) and go agents, and both consider invalid values implies same behavior as if they were simply absent.", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r497619109", "createdAt": "2020-09-30T15:51:44Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/transaction/TraceContextTest.java", "diffHunk": "@@ -473,11 +481,109 @@ void testRandomValue() {\n     void testSetSampled() {\n         final TraceContext traceContext = TraceContext.with64BitId(tracer);\n         traceContext.asRootSpan(ConstantSampler.of(false));\n+\n+        // not sampled means zero sample rate\n         assertThat(traceContext.isSampled()).isFalse();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0d);\n+\n+        // sampled without sample rate\n         traceContext.setRecorded(true);\n+\n         assertThat(traceContext.isSampled()).isTrue();\n+        assertThat(traceContext.getSampleRate()).isNull();\n+\n+        // sampled with sample rate\n+        traceContext.getTraceState().setSampleRate(0.5d);\n+\n+        assertThat(traceContext.isSampled()).isTrue();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0.5d);\n+\n+        // not sampled, sample rate should be unset\n         traceContext.setRecorded(false);\n         assertThat(traceContext.isSampled()).isFalse();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0.0d);\n+    }\n+\n+    @Test\n+    void testRootSpanShouldAddsSampleRateToTraceState() {\n+        final TraceContext traceContext = createRootSpan(0.42d);\n+        String traceState = traceContext.getTraceState().toTextHeader(Integer.MAX_VALUE);\n+        assertThat(traceState).isEqualTo(\"es=s:0.42\");\n+    }\n+\n+    private TraceContext createRootSpan(double sampleRate){\n+        final TraceContext traceContext = TraceContext.with64BitId(tracer);\n+\n+        Sampler sampler = mock(Sampler.class);\n+        when(sampler.isSampled(any(Id.class))).thenReturn(true);\n+        when(sampler.getSampleRate()).thenReturn(sampleRate);\n+\n+        traceContext.asRootSpan(sampler);\n+        return traceContext;\n+    }\n+\n+    @Test\n+    void testTracedChildSpanWithoutTraceState() {\n+        Map<String, String> headers = Map.of(\n+            TraceContext.W3C_TRACE_PARENT_TEXTUAL_HEADER_NAME, \"00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-01\"\n+        );\n+        TraceContext child = createChildSpanFromHeaders(headers);\n+\n+        assertThat(child.isSampled()).isTrue();\n+        assertThat(child.getSampleRate()).isNull();\n+    }\n+\n+    @Test\n+    void testNonTracedChildSpanWithoutTraceState() {\n+        Map<String, String> headers = Map.of(\n+            TraceContext.W3C_TRACE_PARENT_TEXTUAL_HEADER_NAME, \"00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-00\"\n+        );\n+        TraceContext child = createChildSpanFromHeaders(headers);\n+\n+        assertThat(child.isSampled()).isFalse();\n+        assertThat(child.getSampleRate()).isEqualTo(0.0d);\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(delimiter = '|', value = {\n+        // invalid tracestate values: just assume no sample rate is provided\n+        \"|null\",\n+        \"es=|null\",\n+        \"es=s|null\",\n+        \"es=s:|null\",\n+        \"es=s:a|null\",\n+        // valid tracestate values with sample rate\n+        \"es=s:1|1\",\n+        \"es=s:0.42|0.42\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0NzE0Mw=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3MTgyNQ==", "bodyText": "OK, I guess other tests cover that", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r498071825", "createdAt": "2020-10-01T08:29:14Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/impl/transaction/TraceContextTest.java", "diffHunk": "@@ -473,11 +481,109 @@ void testRandomValue() {\n     void testSetSampled() {\n         final TraceContext traceContext = TraceContext.with64BitId(tracer);\n         traceContext.asRootSpan(ConstantSampler.of(false));\n+\n+        // not sampled means zero sample rate\n         assertThat(traceContext.isSampled()).isFalse();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0d);\n+\n+        // sampled without sample rate\n         traceContext.setRecorded(true);\n+\n         assertThat(traceContext.isSampled()).isTrue();\n+        assertThat(traceContext.getSampleRate()).isNull();\n+\n+        // sampled with sample rate\n+        traceContext.getTraceState().setSampleRate(0.5d);\n+\n+        assertThat(traceContext.isSampled()).isTrue();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0.5d);\n+\n+        // not sampled, sample rate should be unset\n         traceContext.setRecorded(false);\n         assertThat(traceContext.isSampled()).isFalse();\n+        assertThat(traceContext.getSampleRate()).isEqualTo(0.0d);\n+    }\n+\n+    @Test\n+    void testRootSpanShouldAddsSampleRateToTraceState() {\n+        final TraceContext traceContext = createRootSpan(0.42d);\n+        String traceState = traceContext.getTraceState().toTextHeader(Integer.MAX_VALUE);\n+        assertThat(traceState).isEqualTo(\"es=s:0.42\");\n+    }\n+\n+    private TraceContext createRootSpan(double sampleRate){\n+        final TraceContext traceContext = TraceContext.with64BitId(tracer);\n+\n+        Sampler sampler = mock(Sampler.class);\n+        when(sampler.isSampled(any(Id.class))).thenReturn(true);\n+        when(sampler.getSampleRate()).thenReturn(sampleRate);\n+\n+        traceContext.asRootSpan(sampler);\n+        return traceContext;\n+    }\n+\n+    @Test\n+    void testTracedChildSpanWithoutTraceState() {\n+        Map<String, String> headers = Map.of(\n+            TraceContext.W3C_TRACE_PARENT_TEXTUAL_HEADER_NAME, \"00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-01\"\n+        );\n+        TraceContext child = createChildSpanFromHeaders(headers);\n+\n+        assertThat(child.isSampled()).isTrue();\n+        assertThat(child.getSampleRate()).isNull();\n+    }\n+\n+    @Test\n+    void testNonTracedChildSpanWithoutTraceState() {\n+        Map<String, String> headers = Map.of(\n+            TraceContext.W3C_TRACE_PARENT_TEXTUAL_HEADER_NAME, \"00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-00\"\n+        );\n+        TraceContext child = createChildSpanFromHeaders(headers);\n+\n+        assertThat(child.isSampled()).isFalse();\n+        assertThat(child.getSampleRate()).isEqualTo(0.0d);\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(delimiter = '|', value = {\n+        // invalid tracestate values: just assume no sample rate is provided\n+        \"|null\",\n+        \"es=|null\",\n+        \"es=s|null\",\n+        \"es=s:|null\",\n+        \"es=s:a|null\",\n+        // valid tracestate values with sample rate\n+        \"es=s:1|1\",\n+        \"es=s:0.42|0.42\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0NzE0Mw=="}, "originalCommit": {"oid": "1a2ba9d98c1a26eead9abc2971fb9914162c3290"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExODE5ODQ4OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/sampling/ProbabilitySampler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwODo0MTozOVrOHbAWvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwODo0MTozOVrOHbAWvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTQyMQ==", "bodyText": "I don't think we need this dependency in TraceState - enough to be able to get sampleRateAsString here and use the the StringBuilder in TraceState to append to the header when required. This means both no allocation and no dependency.\nSorry for nagging, but conceptually - a sampler shouldn't be aware of tracestate", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r498079421", "createdAt": "2020-10-01T08:41:39Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/sampling/ProbabilitySampler.java", "diffHunk": "@@ -54,10 +55,14 @@\n     private final long higherBound;\n     private final double sampleRate;\n \n+    // Because header value only contains sampling rate, we can cache it here\n+    private final String traceStateHeader;\n+\n     private ProbabilitySampler(double samplingRate) {\n         higherBound = (long) (Long.MAX_VALUE * samplingRate);\n         lowerBound = -higherBound;\n         this.sampleRate = samplingRate;\n+        traceStateHeader = TraceState.buildHeaderString(samplingRate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d6278a359fc591a35105c90736ba85f941cb19"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTY0MjcwOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxMTozNToyM1rOHcG-2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoxMTozNFrOHce5ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjU3MA==", "bodyText": "[minor] The optimization we lost in TraceContext (just forwarding a header as it was received):\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public String join(List<? extends CharSequence> tracestate, int tracestateSizeLimit) {\n          \n          \n            \n                    public String join(List<? extends CharSequence> tracestate, int tracestateSizeLimit) {\n          \n          \n            \n                      if (tracestate.size() == 1 && tracestate.get(0) instanceof String) {\n          \n          \n            \n                        return (String) tracestate.get(0);\n          \n          \n            \n                      }", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r499236570", "createdAt": "2020-10-04T11:35:23Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TraceState implements Recyclable {\n+\n+    private static final int DEFAULT_SIZE_LIMIT = 4096;\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+    private static final String FULL_PREFIX = VENDOR_PREFIX + SAMPLE_RATE_PREFIX;\n+\n+    private int sizeLimit;\n+\n+    private final StringBuilder header;\n+\n+    private final StringBuilder rewriteBuffer;\n+\n+    private final List<CharSequence> tracestate;\n+\n+    /**\n+     * sample rate, {@link Double#NaN} if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    public TraceState() {\n+        sampleRate = Double.NaN;\n+        sizeLimit = DEFAULT_SIZE_LIMIT;\n+        tracestate = new ArrayList<>(1);\n+        rewriteBuffer = new StringBuilder();\n+        header = new StringBuilder(FULL_PREFIX.length());\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        sampleRate = other.sampleRate;\n+        sizeLimit = other.sizeLimit;\n+        tracestate.clear();\n+        // copy and make sure we have the immutable variant\n+        for (int i = 0; i < other.tracestate.size(); i++) {\n+            tracestate.add(other.tracestate.get(i).toString());\n+        }\n+        rewriteBuffer.setLength(0);\n+        header.setLength(0);\n+        header.append(other.header);\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int elasticEntryStartIndex = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (elasticEntryStartIndex >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX, elasticEntryStartIndex);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }\n+                double value;\n+                try {\n+                    value = Double.parseDouble(headerValue.substring(valueStart, valueEnd));\n+                    if (0 <= value && value <= 1.0) {\n+                        // ensure proper rounding of sample rate to minimize storage\n+                        // even if configuration should not allow this, any upstream value might require rounding\n+                        double rounded = Math.round(value * 10000d) / 10000d;\n+\n+                        if (rounded != value) {\n+\n+                            // value needs to be re-written first\n+                            rewriteBuffer.setLength(0);\n+                            rewriteBuffer.append(headerValue, 0, valueStart);\n+                            rewriteBuffer.append(rounded);\n+                            rewriteBuffer.append(headerValue, valueEnd, headerValue.length());\n+                            // we don't minimize allocation as re-writing should be an exception\n+                            headerValue = rewriteBuffer.toString();\n+                        }\n+                        sampleRate = rounded;\n+                    }\n+                } catch (NumberFormatException e) {\n+                    // silently ignored\n+                }\n+            }\n+        }\n+\n+        tracestate.add(headerValue);\n+    }\n+\n+    /**\n+     * Sets value for trace state. Provided rate and string value are assumed to be correct and consistent\n+     *\n+     * @param rate       sample rate\n+     * @param rateString rate written as a string, used to minimize allocation\n+     * @throws IllegalStateException    if sample rate has already been set\n+     * @throws IllegalArgumentException if rate has an invalid value\n+     */\n+    public void set(double rate, String rateString) {\n+        if (!Double.isNaN(sampleRate)) {\n+            // sample rate is set either explicitly from this method (for root transactions)\n+            // or through upstream header, thus there is no need to change after. This allows to only\n+            // write/rewrite headers once\n+            throw new IllegalStateException(\"sample rate has already been set from headers\");\n+        }\n+        sampleRate = rate;\n+        header.setLength(0);\n+        header.append(FULL_PREFIX);\n+        header.append(rateString);\n+        tracestate.add(header);\n+    }\n+\n+    /**\n+     * @return sample rate between 0.0 and 1.0, or {@link Double#NaN} if not set\n+     */\n+    public double getSampleRate() {\n+        return sampleRate;\n+    }\n+\n+    @Nullable\n+    public String toTextHeader() {\n+        if (tracestate.isEmpty()) {\n+            return null;\n+        } else {\n+            return TextTracestateAppender.INSTANCE.join(tracestate, sizeLimit);\n+        }\n+    }\n+\n+    @Override\n+    public void resetState() {\n+        sampleRate = Double.NaN;\n+        sizeLimit = DEFAULT_SIZE_LIMIT;\n+        rewriteBuffer.setLength(0);\n+        tracestate.clear();\n+    }\n+\n+    public void setSizeLimit(int limit) {\n+        if(!tracestate.isEmpty()) {\n+            throw new IllegalStateException(\"can't change size limit once headers have been added\");\n+        }\n+        this.sizeLimit = limit;\n+    }\n+\n+    /**\n+     * Internal appender uses a per-thread StringBuilder instance to concatenate the tracestate header.\n+     * This allows ot limit actual memory usage to be linear to the number of active threads which\n+     * is assumed to be far less than the number of active in-flight transactions.\n+     */\n+    private static class TextTracestateAppender {\n+\n+        private static final TextTracestateAppender INSTANCE = new TextTracestateAppender();\n+        private final ThreadLocal<StringBuilder> tracestateBuffer = new ThreadLocal<StringBuilder>();\n+\n+        private TextTracestateAppender() {\n+        }\n+\n+        @Nullable\n+        public String join(List<? extends CharSequence> tracestate, int tracestateSizeLimit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1be0e0d05638849e310de61dd50e26f7f3582f05"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyODM4OQ==", "bodyText": "Thanks for catching this, there was one corner case to apply here though when tracestate is transmitted as-is and larger that the size limit we have to truncate it :-)", "url": "https://github.com/elastic/apm-agent-java/pull/1384#discussion_r499628389", "createdAt": "2020-10-05T14:11:34Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/transaction/TraceState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.impl.transaction;\n+\n+import co.elastic.apm.agent.objectpool.Recyclable;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TraceState implements Recyclable {\n+\n+    private static final int DEFAULT_SIZE_LIMIT = 4096;\n+\n+    private static final char VENDOR_SEPARATOR = ',';\n+    private static final char ENTRY_SEPARATOR = ';';\n+    private static final String VENDOR_PREFIX = \"es=\";\n+    private static final String SAMPLE_RATE_PREFIX = \"s:\";\n+    private static final String FULL_PREFIX = VENDOR_PREFIX + SAMPLE_RATE_PREFIX;\n+\n+    private int sizeLimit;\n+\n+    private final StringBuilder header;\n+\n+    private final StringBuilder rewriteBuffer;\n+\n+    private final List<CharSequence> tracestate;\n+\n+    /**\n+     * sample rate, {@link Double#NaN} if unknown or not set\n+     */\n+    private double sampleRate;\n+\n+    public TraceState() {\n+        sampleRate = Double.NaN;\n+        sizeLimit = DEFAULT_SIZE_LIMIT;\n+        tracestate = new ArrayList<>(1);\n+        rewriteBuffer = new StringBuilder();\n+        header = new StringBuilder(FULL_PREFIX.length());\n+    }\n+\n+    public void copyFrom(TraceState other) {\n+        sampleRate = other.sampleRate;\n+        sizeLimit = other.sizeLimit;\n+        tracestate.clear();\n+        // copy and make sure we have the immutable variant\n+        for (int i = 0; i < other.tracestate.size(); i++) {\n+            tracestate.add(other.tracestate.get(i).toString());\n+        }\n+        rewriteBuffer.setLength(0);\n+        header.setLength(0);\n+        header.append(other.header);\n+    }\n+\n+    public void addTextHeader(String headerValue) {\n+        int elasticEntryStartIndex = headerValue.indexOf(VENDOR_PREFIX);\n+\n+        if (elasticEntryStartIndex >= 0) {\n+            // parsing (and maybe fixing) current tracestate required\n+            int entriesStart = headerValue.indexOf(SAMPLE_RATE_PREFIX, elasticEntryStartIndex);\n+            if (entriesStart >= 0) {\n+                int valueStart = entriesStart + 2;\n+                int valueEnd = valueStart;\n+                if (valueEnd < headerValue.length()) {\n+                    char c = headerValue.charAt(valueEnd);\n+                    while (valueEnd < headerValue.length() && c != VENDOR_SEPARATOR && c != ENTRY_SEPARATOR) {\n+                        c = headerValue.charAt(valueEnd++);\n+                    }\n+                    if (valueEnd < headerValue.length()) {\n+                        // end due to separator char that needs to be trimmed\n+                        valueEnd--;\n+                    }\n+                }\n+                double value;\n+                try {\n+                    value = Double.parseDouble(headerValue.substring(valueStart, valueEnd));\n+                    if (0 <= value && value <= 1.0) {\n+                        // ensure proper rounding of sample rate to minimize storage\n+                        // even if configuration should not allow this, any upstream value might require rounding\n+                        double rounded = Math.round(value * 10000d) / 10000d;\n+\n+                        if (rounded != value) {\n+\n+                            // value needs to be re-written first\n+                            rewriteBuffer.setLength(0);\n+                            rewriteBuffer.append(headerValue, 0, valueStart);\n+                            rewriteBuffer.append(rounded);\n+                            rewriteBuffer.append(headerValue, valueEnd, headerValue.length());\n+                            // we don't minimize allocation as re-writing should be an exception\n+                            headerValue = rewriteBuffer.toString();\n+                        }\n+                        sampleRate = rounded;\n+                    }\n+                } catch (NumberFormatException e) {\n+                    // silently ignored\n+                }\n+            }\n+        }\n+\n+        tracestate.add(headerValue);\n+    }\n+\n+    /**\n+     * Sets value for trace state. Provided rate and string value are assumed to be correct and consistent\n+     *\n+     * @param rate       sample rate\n+     * @param rateString rate written as a string, used to minimize allocation\n+     * @throws IllegalStateException    if sample rate has already been set\n+     * @throws IllegalArgumentException if rate has an invalid value\n+     */\n+    public void set(double rate, String rateString) {\n+        if (!Double.isNaN(sampleRate)) {\n+            // sample rate is set either explicitly from this method (for root transactions)\n+            // or through upstream header, thus there is no need to change after. This allows to only\n+            // write/rewrite headers once\n+            throw new IllegalStateException(\"sample rate has already been set from headers\");\n+        }\n+        sampleRate = rate;\n+        header.setLength(0);\n+        header.append(FULL_PREFIX);\n+        header.append(rateString);\n+        tracestate.add(header);\n+    }\n+\n+    /**\n+     * @return sample rate between 0.0 and 1.0, or {@link Double#NaN} if not set\n+     */\n+    public double getSampleRate() {\n+        return sampleRate;\n+    }\n+\n+    @Nullable\n+    public String toTextHeader() {\n+        if (tracestate.isEmpty()) {\n+            return null;\n+        } else {\n+            return TextTracestateAppender.INSTANCE.join(tracestate, sizeLimit);\n+        }\n+    }\n+\n+    @Override\n+    public void resetState() {\n+        sampleRate = Double.NaN;\n+        sizeLimit = DEFAULT_SIZE_LIMIT;\n+        rewriteBuffer.setLength(0);\n+        tracestate.clear();\n+    }\n+\n+    public void setSizeLimit(int limit) {\n+        if(!tracestate.isEmpty()) {\n+            throw new IllegalStateException(\"can't change size limit once headers have been added\");\n+        }\n+        this.sizeLimit = limit;\n+    }\n+\n+    /**\n+     * Internal appender uses a per-thread StringBuilder instance to concatenate the tracestate header.\n+     * This allows ot limit actual memory usage to be linear to the number of active threads which\n+     * is assumed to be far less than the number of active in-flight transactions.\n+     */\n+    private static class TextTracestateAppender {\n+\n+        private static final TextTracestateAppender INSTANCE = new TextTracestateAppender();\n+        private final ThreadLocal<StringBuilder> tracestateBuffer = new ThreadLocal<StringBuilder>();\n+\n+        private TextTracestateAppender() {\n+        }\n+\n+        @Nullable\n+        public String join(List<? extends CharSequence> tracestate, int tracestateSizeLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjU3MA=="}, "originalCommit": {"oid": "1be0e0d05638849e310de61dd50e26f7f3582f05"}, "originalPosition": 192}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 30, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}