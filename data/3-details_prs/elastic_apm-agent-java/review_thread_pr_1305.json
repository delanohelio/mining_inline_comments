{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MTg0MjM3", "number": 1305, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDoxOToxNlrOFtAo3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxNDoyNjo0MFrOF2iWOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyNzQwNzAyOnYy", "diffSide": "RIGHT", "path": "elastic-apm-agent/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDoxOToxNlrOJBfZSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDoxOToxNlrOJBfZSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTU0MjczMA==", "bodyText": "allows to skip git commit plugin execution and still get a valid property", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r605542730", "createdAt": "2021-04-01T10:19:16Z", "author": {"login": "SylvainJuge"}, "path": "elastic-apm-agent/pom.xml", "diffHunk": "@@ -14,6 +14,9 @@\n     <properties>\n         <elastic.apm.agent>co.elastic.apm.agent.premain.AgentMain</elastic.apm.agent>\n         <apm-agent-parent.base.dir>${project.basedir}/..</apm-agent-parent.base.dir>\n+\n+        <!-- default value that will be overloaded through commit-id plugin -->\n+        <git.commit.id.abbrev>UNKNOWN</git.commit.id.abbrev>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a4afa7718a3c50520841d7f8876269dfcc0093"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgyNzQxMTM1OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDoyMDoxOVrOJBfbxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wMVQxMDoyMDoxOVrOJBfbxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTU0MzM2NA==", "bodyText": "not sure if it's worth having such a global version as most plugins use their own. We could align it in another PR if it makes sense.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r605543364", "createdAt": "2021-04-01T10:20:19Z", "author": {"login": "SylvainJuge"}, "path": "pom.xml", "diffHunk": "@@ -107,6 +107,7 @@\n         <version.log4j>2.12.1</version.log4j>\n         <version.log4j2-ecs-layout>1.0.1</version.log4j2-ecs-layout>\n         <version.spring>5.0.15.RELEASE</version.spring>\n+        <version.spring-boot>2.2.2.RELEASE</version.spring-boot>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a4afa7718a3c50520841d7f8876269dfcc0093"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0ODc2MzUyOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzoxNjo1OVrOJEcqVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzoxNjo1OVrOJEcqVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY0MzY3MA==", "bodyText": "[minor] Not clear - framework types are not visible from the boot CL", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608643670", "createdAt": "2021-04-07T13:16:59Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -481,42 +481,65 @@ static void validateAdvice(Class<?> adviceClass) {\n \n         TypePool pool = new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.NoOp.INSTANCE, ClassFileLocator.ForClassLoader.of(classLoader), TypePool.Default.ReaderMode.FAST);\n         TypeDescription typeDescription = pool.describe(adviceClassName).resolve();\n+\n         for (MethodDescription.InDefinedShape enterAdvice : typeDescription.getDeclaredMethods().filter(isStatic().and(isAnnotatedWith(Advice.OnMethodEnter.class)))) {\n-            validateAdviceReturnAndParameterTypes(enterAdvice);\n+            validateAdviceReturnAndParameterTypes(enterAdvice, adviceClassName);\n \n             for (AnnotationDescription enter : enterAdvice.getDeclaredAnnotations().filter(ElementMatchers.annotationType(Advice.OnMethodEnter.class))) {\n-                if (enter.prepare(Advice.OnMethodEnter.class).load().inline()) {\n-                    throw new IllegalStateException(String.format(\"Indy-dispatched advice %s#%s has to be declared with inline=false\", adviceClassName, enterAdvice.getName()));\n-                }\n+                checkInline(enterAdvice, adviceClassName, enter.prepare(Advice.OnMethodEnter.class).load().inline());\n             }\n         }\n         for (MethodDescription.InDefinedShape exitAdvice : typeDescription.getDeclaredMethods().filter(isStatic().and(isAnnotatedWith(Advice.OnMethodExit.class)))) {\n-            validateAdviceReturnAndParameterTypes(exitAdvice);\n+            validateAdviceReturnAndParameterTypes(exitAdvice, adviceClassName);\n             if (exitAdvice.getReturnType().asRawType().getTypeName().startsWith(\"co.elastic.apm\")) {\n                 throw new IllegalStateException(\"Advice return type must be visible from the bootstrap class loader and must not be an agent type.\");\n             }\n             for (AnnotationDescription exit : exitAdvice.getDeclaredAnnotations().filter(ElementMatchers.annotationType(Advice.OnMethodExit.class))) {\n-                if (exit.prepare(Advice.OnMethodExit.class).load().inline()) {\n-                    throw new IllegalStateException(String.format(\"Indy-dispatched advice %s#%s has to be declared with inline=false\", adviceClassName, exitAdvice.getName()));\n-                }\n+                checkInline(exitAdvice, adviceClassName, exit.prepare(Advice.OnMethodExit.class).load().inline());\n             }\n         }\n         if (!(classLoader instanceof ExternalPluginClassLoader) && adviceClassName.startsWith(\"co.elastic.apm.agent.\") && adviceClassName.split(\"\\\\.\").length > 6) {\n             throw new IllegalStateException(String.format(\n                 \"Invalid Advice class - %s - Indy-dispatched advice class must be at the root of the instrumentation plugin.\",\n                 adviceClassName)\n             );\n+\n         }\n     }\n \n-    private static void validateAdviceReturnAndParameterTypes(MethodDescription.InDefinedShape advice) {\n-        if (advice.getReturnType().asRawType().getTypeName().startsWith(\"co.elastic.apm\")) {\n-            throw new IllegalStateException(\"Advice return type must not be an agent type: \" + advice.toGenericString());\n+    private static void checkInline(MethodDescription.InDefinedShape advice, String adviceClassName, boolean isInline){\n+        if (isInline) {\n+            throw new IllegalStateException(String.format(\"Indy-dispatched advice %s#%s has to be declared with inline=false\", adviceClassName, advice.getName()));\n+        } else if (!Modifier.isPublic(advice.getModifiers())) {\n+            throw new IllegalStateException(String.format(\"Indy-dispatched advice %s#%s has to be declared public\", adviceClassName, advice.getName()));\n         }\n-        for (ParameterDescription.InDefinedShape parameter : advice.getParameters()) {\n-            if (parameter.getType().asRawType().getTypeName().startsWith(\"co.elastic.apm\")) {\n-                throw new IllegalStateException(\"Advice parameters must not contain an agent type: \" + advice.toGenericString());\n+    }\n+\n+    private static void validateAdviceReturnAndParameterTypes(MethodDescription.InDefinedShape advice, String adviceClass) {\n+        String adviceMethod = advice.getInternalName();\n+        try {\n+            checkNotAgentType(advice.getReturnType(), \"return type\", adviceClass, adviceMethod);\n+\n+            for (ParameterDescription.InDefinedShape parameter : advice.getParameters()) {\n+                checkNotAgentType(parameter.getType(), \"parameter\", adviceClass, adviceMethod);\n+\n+                AnnotationDescription.Loadable<Advice.Return> returnAnnotation = parameter.getDeclaredAnnotations().ofType(Advice.Return.class);\n+                if (returnAnnotation != null && !returnAnnotation.load().readOnly()) {\n+                    throw new IllegalStateException(\"Advice parameter must not use '@Advice.Return(readOnly=false)', use @AssignTo.Return instead\");\n+                }\n             }\n+        } catch (Exception e) {\n+            // Because types are lazily resolved, unexpected things are expected\n+            throw new IllegalStateException(String.format(\"unable to validate advice defined in %s#%s\", adviceClass, adviceMethod), e);\n+        }\n+    }\n+\n+    private static void checkNotAgentType(TypeDescription.Generic type, String description, String adviceClass, String adviceMethod) {\n+        // we have to use 'raw' type to avoid trying to resolve classes that are not visible in bootstrap classloader\n+        // for example, a plugin may use framework types in advice signature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0ODgwMzM1OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Url.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzoyNDoyMVrOJEdC7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzoyNDozNFrOJEdDpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY0OTk2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Updates full URL from current state of {@literal this}.\n          \n          \n            \n                 * Updates full URL from current state of {@literal this}. Must be called after all other Url fields are set.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608649964", "createdAt": "2021-04-07T13:24:21Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Url.java", "diffHunk": "@@ -86,6 +86,36 @@ public StringBuilder getFull() {\n         return full;\n     }\n \n+    /**\n+     * Updates full URL from current state of {@literal this}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY1MDE0OQ==", "bodyText": "[minor]", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608650149", "createdAt": "2021-04-07T13:24:34Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Url.java", "diffHunk": "@@ -86,6 +86,36 @@ public StringBuilder getFull() {\n         return full;\n     }\n \n+    /**\n+     * Updates full URL from current state of {@literal this}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY0OTk2NA=="}, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0ODg1MTUyOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Url.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzozMzowOVrOJEdhAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQxNDoyMjo1MFrOJFgk4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY1NzY2Nw==", "bodyText": "What's the benefit? This adds allocation in serialization (Integer.toString).", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608657667", "createdAt": "2021-04-07T13:33:09Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Url.java", "diffHunk": "@@ -108,17 +138,17 @@ public Url withHostname(@Nullable String hostname) {\n     }\n \n     /**\n-     * The port of the request, e.g. '443'\n+     * The port of the request, e.g. 443\n      */\n-    public StringBuilder getPort() {\n+    public int getPort() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTc1NjM4Nw==", "bodyText": "As of 7.0.0 we can have url.port as a numeric field, making this an int allows to better fit the current schema. I've changed the behavior to only allocate when using a pre 7.0.0 server.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r609756387", "createdAt": "2021-04-08T14:22:50Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/impl/context/Url.java", "diffHunk": "@@ -108,17 +138,17 @@ public Url withHostname(@Nullable String hostname) {\n     }\n \n     /**\n-     * The port of the request, e.g. '443'\n+     * The port of the request, e.g. 443\n      */\n-    public StringBuilder getPort() {\n+    public int getPort() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY1NzY2Nw=="}, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0ODg4NzQ1OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/util/SpanConcurrentHashMapTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzozOToyMlrOJEd23g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzozOToyMlrOJEd23g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY2MzI2Mg==", "bodyText": "[minor] you can check ref count after each clear()", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608663262", "createdAt": "2021-04-07T13:39:22Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/util/SpanConcurrentHashMapTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.util;\n+\n+import co.elastic.apm.agent.MockTracer;\n+import co.elastic.apm.agent.impl.context.AbstractContext;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+class SpanConcurrentHashMapTest {\n+\n+    @Nullable\n+    private Object key;\n+\n+    @Test\n+    void putRemove() {\n+        TestSpan testSpan = new TestSpan();\n+        checkRefCount(testSpan, 0);\n+\n+        key = new Object();\n+        SpanConcurrentHashMap<Object, TestSpan> map = new SpanConcurrentHashMap<>();\n+        map.put(key, testSpan);\n+\n+        checkRefCount(testSpan, 1);\n+\n+        assertThat(map.remove(key)).isSameAs(testSpan);\n+        checkRefCount(testSpan, 0);\n+\n+        // remove when already removed should not decrement further\n+        assertThat(map.remove(key)).isNull();\n+        checkRefCount(testSpan, 0);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(PutOperation.class)\n+    void putTwice(PutOperation operation) {\n+        TestSpan testSpan = new TestSpan();\n+        key = new Object();\n+        SpanConcurrentHashMap<Object, TestSpan> map = new SpanConcurrentHashMap<>();\n+\n+        checkRefCount(testSpan, 0);\n+\n+        operation.execute(map, key, testSpan);\n+\n+        checkRefCount(testSpan, 1);\n+\n+        operation.execute(map, key, testSpan);\n+\n+        checkRefCount(testSpan, 1);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(PutOperation.class)\n+    void swapValues(PutOperation operation) {\n+        TestSpan ts1 = new TestSpan();\n+        TestSpan ts2 = new TestSpan();\n+\n+        key = new Object();\n+        SpanConcurrentHashMap<Object, TestSpan> map = new SpanConcurrentHashMap<>();\n+\n+        operation.execute(map, key, ts1);\n+        operation.execute(map, key, ts2);\n+\n+        assertThat(map).hasSize(1);\n+\n+        checkRefCount(ts1, 0);\n+        checkRefCount(ts2, 1);\n+    }\n+\n+    private enum PutOperation {\n+        put,\n+        putIfAbsent;\n+\n+        void execute(ConcurrentHashMap<Object, TestSpan> map, Object key, TestSpan value) {\n+            switch (this) {\n+                case put:\n+                    map.put(key, value);\n+                    break;\n+                case putIfAbsent:\n+                    map.putIfAbsent(key, value);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void clear() {\n+        SpanConcurrentHashMap<Object, TestSpan> map = new SpanConcurrentHashMap<>();\n+\n+        List<AbstractSpan<?>> list = new ArrayList<>();\n+        for (int i = 0; i < 5; i++) {\n+            TestSpan span = new TestSpan();\n+            list.add(span);\n+            map.put(i, span);\n+            checkRefCount(span, 1);\n+        }\n+\n+        // clear twice, should only decrement once\n+        map.clear();\n+        map.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0ODkwNjcxOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/util/SpanConcurrentHashMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxMzo0Mjo1NVrOJEeC_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQxNDoyNDo0NlrOJFgsvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY2NjM2Nw==", "bodyText": "Suggestion: move this factory method to WeakMapSupplier", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608666367", "createdAt": "2021-04-07T13:42:55Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/util/SpanConcurrentHashMap.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.util;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.sdk.weakmap.NullSafeWeakConcurrentMap;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.AbstractWeakConcurrentMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Hash map dedicated to storage of in-flight spans and transactions, reference count is being incremented/decremented\n+ * when entry is added/removed. Usage of this map is intended for providing GC-based storage of context associated\n+ * to a framework-level object key, when the latter is collected by GC it allows to decrement and then recycle the\n+ * span/transaction.\n+ *\n+ * @param <K> key type\n+ * @param <V> context type\n+ */\n+public class SpanConcurrentHashMap<K, V extends AbstractSpan<?>> extends ConcurrentHashMap<K, V> {\n+\n+    public static <K, V extends AbstractSpan<?>> WeakConcurrentMap<K, V> createWeakMap() {\n+        SpanConcurrentHashMap<AbstractWeakConcurrentMap.WeakKey<K>, V> map = new SpanConcurrentHashMap<>();\n+        WeakConcurrentMap<K, V> result = new NullSafeWeakConcurrentMap<>(false, map);\n+        WeakMapSupplier.registerMap(result);\n+        return result;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTc1ODM5OQ==", "bodyText": "We can't because WeakMapSupplier is part of the plugin-sdk module, which has no dependency on core module for AbstractSpan definition. I agree with you that this is definitely not super elegant to have it this way.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r609758399", "createdAt": "2021-04-08T14:24:46Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/util/SpanConcurrentHashMap.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.util;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.sdk.weakmap.NullSafeWeakConcurrentMap;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import com.blogspot.mydailyjava.weaklockfree.AbstractWeakConcurrentMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+\n+import javax.annotation.Nullable;\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Hash map dedicated to storage of in-flight spans and transactions, reference count is being incremented/decremented\n+ * when entry is added/removed. Usage of this map is intended for providing GC-based storage of context associated\n+ * to a framework-level object key, when the latter is collected by GC it allows to decrement and then recycle the\n+ * span/transaction.\n+ *\n+ * @param <K> key type\n+ * @param <V> context type\n+ */\n+public class SpanConcurrentHashMap<K, V extends AbstractSpan<?>> extends ConcurrentHashMap<K, V> {\n+\n+    public static <K, V extends AbstractSpan<?>> WeakConcurrentMap<K, V> createWeakMap() {\n+        SpanConcurrentHashMap<AbstractWeakConcurrentMap.WeakKey<K>, V> map = new SpanConcurrentHashMap<>();\n+        WeakConcurrentMap<K, V> result = new NullSafeWeakConcurrentMap<>(false, map);\n+        WeakMapSupplier.registerMap(result);\n+        return result;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY2NjM2Nw=="}, "originalCommit": {"oid": "56467fbf868b035479e555548657a61212bdb1d4"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0OTEzODk0OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/TracedSubscriber.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDoyMzo1MFrOJEgUcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDoyMzo1MFrOJEgUcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcwMzYwMA==", "bodyText": "On the one hand it uses GlobalVariables, but on the other hand it registers the instrumentation class, which is loaded (in this context) buy the plugin CL, so effectively you have an entry-per-plugin load. Is that what you wanted to achieve? If so, I think a simple AtomicBoolean will achieve the same, as there will be one TracedSubscriber class per indy plugin CL.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608703600", "createdAt": "2021-04-07T14:23:50Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/TracedSubscriber.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.reactor;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.sdk.state.GlobalVariables;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public class TracedSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TracedSubscriber.class);\n+\n+    private static final AtomicBoolean isRegistered = GlobalVariables.get(ReactorInstrumentation.class, \"reactor-hook-enabled\", new AtomicBoolean(false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0OTE4NTY2OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/TracedSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDozMTo1NFrOJEgx2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yMlQwOTozMTozMlrOJNmVMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcxMTEzMA==", "bodyText": "[reminder] it allocates three objects. If there is an easy way to pool some and only allocate through the lift operation, then that could be nice. I am not sure it worth terrible complication of the code and the effort though. Maybe see in benchmarks if it makes sense.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608711130", "createdAt": "2021-04-07T14:31:54Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/TracedSubscriber.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.reactor;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.sdk.state.GlobalVariables;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public class TracedSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TracedSubscriber.class);\n+\n+    private static final AtomicBoolean isRegistered = GlobalVariables.get(ReactorInstrumentation.class, \"reactor-hook-enabled\", new AtomicBoolean(false));\n+\n+    private static final WeakConcurrentMap<TracedSubscriber<?>, AbstractSpan<?>> contextMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private static final String HOOK_KEY = \"elastic-apm\";\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final Tracer tracer;\n+\n+    TracedSubscriber(CoreSubscriber<? super T> subscriber, Tracer tracer, AbstractSpan<?> context) {\n+        this.subscriber = subscriber;\n+        this.tracer = tracer;\n+        contextMap.put(this, context);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscriber scheduler\".\n+     *\n+     * @param s subscription\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onSubscribe\", context);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(hasActivated, \"onSubscribe\", context);\n+            discardIf(thrown != null);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\"\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onNext\", context);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(hasActivated, \"onNext\", context);\n+            discardIf(thrown != null);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\"\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onError\", context);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            doExit(hasActivated, \"onError\", context);\n+            discardIf(true);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\"\n+     */\n+    @Override\n+    public void onComplete() {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onComplete\", context);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            doExit(hasActivated, \"onComplete\", context);\n+            discardIf(true);\n+        }\n+    }\n+\n+    /**\n+     * Wrapped method entry\n+     *\n+     * @param method  method name (only for debugging)\n+     * @param context context\n+     * @return {@literal true} if context has been activated\n+     */\n+    private boolean doEnter(String method, @Nullable AbstractSpan<?> context) {\n+        debugTrace(true, method, context);\n+\n+        if (context == null || tracer.getActive() == context) {\n+            // already activated or discarded\n+            return false;\n+        }\n+\n+        context.activate();\n+        return true;\n+    }\n+\n+    /**\n+     * Wrapped method exit\n+     *\n+     * @param deactivate {@literal true} to de-activate due to a previous activation, no-op otherwise\n+     * @param method     method name (only for debugging)\n+     * @param context    context\n+     */\n+    private void doExit(boolean deactivate, String method, @Nullable AbstractSpan<?> context) {\n+        debugTrace(false, method, context);\n+\n+        if (context == null || !deactivate) {\n+            return;\n+        }\n+\n+        if (context != tracer.getActive()) {\n+            // don't attempt to deactivate if not the active one\n+            return;\n+        }\n+\n+        // the current context has been activated on enter thus must be the active one\n+        context.deactivate();\n+    }\n+\n+    private void discardIf(boolean condition) {\n+        if (!condition) {\n+            return;\n+        }\n+        contextMap.remove(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable AbstractSpan<?> context) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} reactor {} {}\", isEnter ? \">>\" : \"<<\", method, context);\n+    }\n+\n+    /**\n+     * @return context associated with {@literal this}.\n+     */\n+    @Nullable\n+    private AbstractSpan<?> getContext() {\n+        return contextMap.get(this);\n+    }\n+\n+    /**\n+     * Register active context propagation\n+     *\n+     * @param tracer tracer\n+     */\n+    static void registerHooks(Tracer tracer) {\n+        if (isRegistered.getAndSet(true)) {\n+            return;\n+        }\n+        Hooks.onEachOperator(HOOK_KEY, wrapOperators(tracer));\n+    }\n+\n+    /**\n+     * Unregister active context propagation. Should only be used for testing\n+     */\n+    static void unregisterHooks() {\n+        if (!isRegistered.getAndSet(false)) {\n+            return;\n+        }\n+        Hooks.resetOnEachOperator(HOOK_KEY);\n+    }\n+\n+    /**\n+     * @return true if hook is registered. Should only be used for testing\n+     */\n+    static boolean isHookRegistered() {\n+        return isRegistered.get();\n+    }\n+\n+    private static <X> Function<? super Publisher<X>, ? extends Publisher<X>> wrapOperators(final Tracer tracer) {\n+        //noinspection Convert2Lambda,rawtypes,Convert2Diamond\n+        return Operators.liftPublisher(new BiFunction<Publisher, CoreSubscriber<? super X>, CoreSubscriber<? super X>>() {\n+            @Override\n+            public CoreSubscriber<? super X> apply(Publisher publisher, CoreSubscriber<? super X> subscriber) {\n+                // don't wrap known #error #just #empty as they have instantaneous execution\n+                if (publisher instanceof Fuseable.ScalarCallable) {\n+                    log.trace(\"skip wrapping {}\", subscriber.toString());\n+                    return subscriber;\n+                }\n+\n+                AbstractSpan<?> active = tracer.getActive();\n+\n+                if (active == null) {\n+                    // no active context, we have nothing to wrap\n+                    return subscriber;\n+                }\n+\n+                log.trace(\"wrapping subscriber {} publisher {} with active span/transaction {}\", subscriber.toString(), publisher, active);\n+\n+                return new TracedSubscriber<>(subscriber, tracer, active);\n+            }\n+        });\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxODIzOTI4Mg==", "bodyText": "I don't think it's worth the effort now, while I don't have exact measurement of allocation, it's currently on the same level as what other agents do. That would however be easy to further optimize if that proves to be an issue later on.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r618239282", "createdAt": "2021-04-22T09:31:32Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/TracedSubscriber.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.reactor;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.sdk.state.GlobalVariables;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Fuseable;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Operators;\n+\n+import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+public class TracedSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TracedSubscriber.class);\n+\n+    private static final AtomicBoolean isRegistered = GlobalVariables.get(ReactorInstrumentation.class, \"reactor-hook-enabled\", new AtomicBoolean(false));\n+\n+    private static final WeakConcurrentMap<TracedSubscriber<?>, AbstractSpan<?>> contextMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private static final String HOOK_KEY = \"elastic-apm\";\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final Tracer tracer;\n+\n+    TracedSubscriber(CoreSubscriber<? super T> subscriber, Tracer tracer, AbstractSpan<?> context) {\n+        this.subscriber = subscriber;\n+        this.tracer = tracer;\n+        contextMap.put(this, context);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscriber scheduler\".\n+     *\n+     * @param s subscription\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onSubscribe\", context);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(hasActivated, \"onSubscribe\", context);\n+            discardIf(thrown != null);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\"\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onNext\", context);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(hasActivated, \"onNext\", context);\n+            discardIf(thrown != null);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\"\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onError\", context);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            doExit(hasActivated, \"onError\", context);\n+            discardIf(true);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\"\n+     */\n+    @Override\n+    public void onComplete() {\n+        AbstractSpan<?> context = getContext();\n+        boolean hasActivated = doEnter(\"onComplete\", context);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            doExit(hasActivated, \"onComplete\", context);\n+            discardIf(true);\n+        }\n+    }\n+\n+    /**\n+     * Wrapped method entry\n+     *\n+     * @param method  method name (only for debugging)\n+     * @param context context\n+     * @return {@literal true} if context has been activated\n+     */\n+    private boolean doEnter(String method, @Nullable AbstractSpan<?> context) {\n+        debugTrace(true, method, context);\n+\n+        if (context == null || tracer.getActive() == context) {\n+            // already activated or discarded\n+            return false;\n+        }\n+\n+        context.activate();\n+        return true;\n+    }\n+\n+    /**\n+     * Wrapped method exit\n+     *\n+     * @param deactivate {@literal true} to de-activate due to a previous activation, no-op otherwise\n+     * @param method     method name (only for debugging)\n+     * @param context    context\n+     */\n+    private void doExit(boolean deactivate, String method, @Nullable AbstractSpan<?> context) {\n+        debugTrace(false, method, context);\n+\n+        if (context == null || !deactivate) {\n+            return;\n+        }\n+\n+        if (context != tracer.getActive()) {\n+            // don't attempt to deactivate if not the active one\n+            return;\n+        }\n+\n+        // the current context has been activated on enter thus must be the active one\n+        context.deactivate();\n+    }\n+\n+    private void discardIf(boolean condition) {\n+        if (!condition) {\n+            return;\n+        }\n+        contextMap.remove(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable AbstractSpan<?> context) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} reactor {} {}\", isEnter ? \">>\" : \"<<\", method, context);\n+    }\n+\n+    /**\n+     * @return context associated with {@literal this}.\n+     */\n+    @Nullable\n+    private AbstractSpan<?> getContext() {\n+        return contextMap.get(this);\n+    }\n+\n+    /**\n+     * Register active context propagation\n+     *\n+     * @param tracer tracer\n+     */\n+    static void registerHooks(Tracer tracer) {\n+        if (isRegistered.getAndSet(true)) {\n+            return;\n+        }\n+        Hooks.onEachOperator(HOOK_KEY, wrapOperators(tracer));\n+    }\n+\n+    /**\n+     * Unregister active context propagation. Should only be used for testing\n+     */\n+    static void unregisterHooks() {\n+        if (!isRegistered.getAndSet(false)) {\n+            return;\n+        }\n+        Hooks.resetOnEachOperator(HOOK_KEY);\n+    }\n+\n+    /**\n+     * @return true if hook is registered. Should only be used for testing\n+     */\n+    static boolean isHookRegistered() {\n+        return isRegistered.get();\n+    }\n+\n+    private static <X> Function<? super Publisher<X>, ? extends Publisher<X>> wrapOperators(final Tracer tracer) {\n+        //noinspection Convert2Lambda,rawtypes,Convert2Diamond\n+        return Operators.liftPublisher(new BiFunction<Publisher, CoreSubscriber<? super X>, CoreSubscriber<? super X>>() {\n+            @Override\n+            public CoreSubscriber<? super X> apply(Publisher publisher, CoreSubscriber<? super X> subscriber) {\n+                // don't wrap known #error #just #empty as they have instantaneous execution\n+                if (publisher instanceof Fuseable.ScalarCallable) {\n+                    log.trace(\"skip wrapping {}\", subscriber.toString());\n+                    return subscriber;\n+                }\n+\n+                AbstractSpan<?> active = tracer.getActive();\n+\n+                if (active == null) {\n+                    // no active context, we have nothing to wrap\n+                    return subscriber;\n+                }\n+\n+                log.trace(\"wrapping subscriber {} publisher {} with active span/transaction {}\", subscriber.toString(), publisher, active);\n+\n+                return new TracedSubscriber<>(subscriber, tracer, active);\n+            }\n+        });\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcxMTEzMA=="}, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0OTIwMzkzOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/ReactorInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDozNToyM1rOJEg9mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQxNDozMjoxOFrOJFhNSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcxNDEzOA==", "bodyText": "It's a big one. Would you feel safer to start as experimental for a couple of releases?\nI was a bit sorry for not starting the log shading as such.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608714138", "createdAt": "2021-04-07T14:35:23Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/ReactorInstrumentation.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.reactor;\n+\n+import co.elastic.apm.agent.bci.TracerAwareInstrumentation;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+/**\n+ * Instruments Mono/Flux to automatically register context-propagation hook\n+ * <ul>\n+ *     <li>{@link reactor.core.publisher.Mono#onAssembly}</li>\n+ *     <li>{@link reactor.core.publisher.Flux#onAssembly}</li>\n+ * </ul>\n+ */\n+@SuppressWarnings(\"JavadocReference\")\n+public class ReactorInstrumentation extends TracerAwareInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return named(\"reactor.core.publisher.Mono\")\n+            .or(named(\"reactor.core.publisher.Flux\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return isStatic().and(named(\"onAssembly\"));\n+    }\n+\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Collections.singletonList(\"reactor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTc2NjcyOQ==", "bodyText": "That's definitely a very good idea, that would prevent missing expectations if things do not work 100% as expected on the 1st release.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r609766729", "createdAt": "2021-04-08T14:32:18Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/ReactorInstrumentation.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.reactor;\n+\n+import co.elastic.apm.agent.bci.TracerAwareInstrumentation;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+/**\n+ * Instruments Mono/Flux to automatically register context-propagation hook\n+ * <ul>\n+ *     <li>{@link reactor.core.publisher.Mono#onAssembly}</li>\n+ *     <li>{@link reactor.core.publisher.Flux#onAssembly}</li>\n+ * </ul>\n+ */\n+@SuppressWarnings(\"JavadocReference\")\n+public class ReactorInstrumentation extends TracerAwareInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return named(\"reactor.core.publisher.Mono\")\n+            .or(named(\"reactor.core.publisher.Flux\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return isStatic().and(named(\"onAssembly\"));\n+    }\n+\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Collections.singletonList(\"reactor\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcxNDEzOA=="}, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0OTIxMzUxOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/README.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDozNzowN1rOJEhDtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDozNzowN1rOJEhDtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcxNTcwMA==", "bodyText": "\u2764\ufe0f", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608715700", "createdAt": "2021-04-07T14:37:07Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/README.md", "diffHunk": "@@ -0,0 +1,52 @@\n+# Spring WebFlux plugin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0OTIzMzk5OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/ReactorInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDo0MDozNVrOJEhQXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDo0MDozNVrOJEhQXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcxODk0Mg==", "bodyText": "Extract to a separate advice class", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608718942", "createdAt": "2021-04-07T14:40:35Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-reactor-plugin/src/main/java/co/elastic/apm/agent/reactor/ReactorInstrumentation.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.reactor;\n+\n+import co.elastic.apm.agent.bci.TracerAwareInstrumentation;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.isStatic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+/**\n+ * Instruments Mono/Flux to automatically register context-propagation hook\n+ * <ul>\n+ *     <li>{@link reactor.core.publisher.Mono#onAssembly}</li>\n+ *     <li>{@link reactor.core.publisher.Flux#onAssembly}</li>\n+ * </ul>\n+ */\n+@SuppressWarnings(\"JavadocReference\")\n+public class ReactorInstrumentation extends TracerAwareInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return named(\"reactor.core.publisher.Mono\")\n+            .or(named(\"reactor.core.publisher.Flux\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return isStatic().and(named(\"onAssembly\"));\n+    }\n+\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Collections.singletonList(\"reactor\");\n+    }\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+    public static void onEnter() {\n+        TracedSubscriber.registerHooks(tracer);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg0OTI3MDI3OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/WebFluxInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDo0NzowM1rOJEhnJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wN1QxNDo0NzowM1rOJEhnJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODcyNDc3Mw==", "bodyText": "All these dependencies should not be in the instrumentation class, which is loaded early by the agent CL. Please extract to a helper class and make sure all instrumentations do not contain improper dependencies.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r608724773", "createdAt": "2021-04-07T14:47:03Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/WebFluxInstrumentation.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.bci.TracerAwareInstrumentation;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import org.reactivestreams.Publisher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.server.reactive.AbstractServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.web.server.ServerWebExchange;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.function.BiFunction;\n+\n+public abstract class WebFluxInstrumentation extends TracerAwareInstrumentation {\n+\n+    private static final Logger log = LoggerFactory.getLogger(WebFluxInstrumentation.class);\n+\n+    public static final String TRANSACTION_ATTRIBUTE = WebFluxInstrumentation.class.getName() + \".transaction\";\n+    public static final String ANNOTATED_BEAN_NAME_ATTRIBUTE = WebFluxInstrumentation.class.getName() + \".bean_name\";\n+    public static final String ANNOTATED_METHOD_NAME_ATTRIBUTE = WebFluxInstrumentation.class.getName() + \".method_name\";\n+    private static final String SERVLET_TRANSACTION = WebFluxInstrumentation.class.getName() + \".servlet_transaction\";\n+\n+    public static final String SSE_EVENT_CLASS = \"org.springframework.http.codec.ServerSentEvent\";\n+\n+    @Override\n+    public final Collection<String> getInstrumentationGroupNames() {\n+        return Collections.singletonList(\"spring-webflux\");\n+    }\n+\n+    @Nullable\n+    public static Transaction getOrCreateTransaction(Class<?> clazz, ServerWebExchange exchange) {\n+\n+        Transaction transaction = getServletTransaction(exchange);\n+        boolean fromServlet = transaction != null;\n+\n+        if (!fromServlet) {\n+            transaction = tracer.startRootTransaction(clazz.getClassLoader());\n+        }\n+\n+        if (transaction == null) {\n+            return null;\n+        }\n+\n+        transaction.withType(\"request\").activate();\n+\n+        // store transaction in exchange to make it easy to retrieve from other handlers\n+        exchange.getAttributes().put(TRANSACTION_ATTRIBUTE, transaction);\n+\n+        exchange.getAttributes().put(SERVLET_TRANSACTION, fromServlet);\n+\n+        return transaction;\n+    }\n+\n+    public static boolean isServletTransaction(ServerWebExchange exchange) {\n+        return Boolean.TRUE == exchange.getAttributes().get(SERVLET_TRANSACTION);\n+    }\n+\n+    @Nullable\n+    private static Transaction getServletTransaction(ServerWebExchange exchange) {\n+        // see ServletHttpHandlerAdapter and sub-classes for implementation details\n+\n+        // While the active transaction is the one created by Servlet, it would rely on the fact that we are on the\n+        // same thread as the one that created the transaction, which is an implementation detail. While not really\n+        // elegant, this solution seems the most reliable for now.\n+        Transaction transaction = null;\n+        try {\n+            ServerHttpRequest exchangeRequest = exchange.getRequest();\n+            if (exchangeRequest instanceof AbstractServerHttpRequest) {\n+                Object nativeRequest = ((AbstractServerHttpRequest) exchangeRequest).getNativeRequest();\n+                if (nativeRequest instanceof HttpServletRequest) {\n+                    transaction = (Transaction) ((HttpServletRequest) nativeRequest)\n+                        // adding a dependency to servlet instrumentation plugin is not worth for such a simple string\n+                        // but it's fine as long as we have tests for this\n+                        .getAttribute(\"co.elastic.apm.agent.servlet.ServletApiAdvice.transaction\");\n+                }\n+            }\n+        } catch (Throwable ignored) {\n+            return null;\n+        }\n+        return transaction;\n+    }\n+\n+    public static <T> Mono<T> wrapDispatcher(Mono<T> mono, Transaction transaction, ServerWebExchange exchange) {\n+        return doWrap(mono, transaction, exchange, \"webflux-dispatcher\");\n+    }\n+\n+    public static <T> Mono<T> wrapHandlerAdapter(Mono<T> mono, Transaction transaction, ServerWebExchange exchange) {\n+        return doWrap(mono, transaction, exchange, \"webflux-handler-adapter\");\n+    }\n+\n+    private static <T> Mono<T> doWrap(Mono<T> mono, final Transaction transaction, final ServerWebExchange exchange, final String description) {\n+        //noinspection Convert2Lambda,rawtypes,Convert2Diamond,ReactiveStreamsUnusedPublisher\n+        mono = mono.transform(Operators.liftPublisher(new BiFunction<Publisher, CoreSubscriber<? super T>, CoreSubscriber<? super T>>() {\n+            @Override // liftPublisher too (or whole transform param)\n+            public CoreSubscriber<? super T> apply(Publisher publisher, CoreSubscriber<? super T> subscriber) {\n+                log.trace(\"wrapping {} subscriber with transaction {}\", description, transaction);\n+\n+                // If there is already an active transaction, it's tempting to avoid wrapping as the context propagation\n+                // would be already provided through reactor instrumentation. However, we can't as the transaction\n+                // name would not be properly set to match Webflux annotated controllers/router definitions.\n+                return new TransactionAwareSubscriber<>(subscriber, tracer, transaction, exchange, description);\n+            }\n+        }));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg1NjUzOTk5OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-kafka-plugin/apm-kafka-headers-plugin/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQxNDo1NTozOFrOJFirJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0wOFQxNDo1NTozOFrOJFirJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTc5MDc1OA==", "bodyText": "We might find a better solution to avoid duplication of common plugin test dependencies, but it would be better handled in a separate cleanup PR.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r609790758", "createdAt": "2021-04-08T14:55:38Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-kafka-plugin/apm-kafka-headers-plugin/pom.xml", "diffHunk": "@@ -27,5 +27,10 @@\n             <artifactId>apm-kafka-base-plugin</artifactId>\n             <version>${project.version}</version>\n         </dependency>\n+        <dependency>\n+            <groupId>org.apache.ivy</groupId>\n+            <artifactId>ivy</artifactId>\n+            <scope>test</scope>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "012af603ce314abff0e04183cfaf61b537cf5495"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNjc2Njg5OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/WebfluxHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMjo1NTozM1rOJPiL1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMjo1NTozM1rOJPiL1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDI2ODUwMw==", "bodyText": "Is this safe to assume javax.servlet classes are available? While it is wrapped with try-catch, this may fail linkage if not occurring lazily enough.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620268503", "createdAt": "2021-04-26T12:55:33Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/WebfluxHelper.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import org.reactivestreams.Publisher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.server.reactive.AbstractServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.web.server.ServerWebExchange;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.function.BiFunction;\n+\n+public class WebfluxHelper {\n+\n+    private static final Logger log = LoggerFactory.getLogger(WebfluxHelper.class);\n+\n+    public static final String TRANSACTION_ATTRIBUTE = WebfluxHelper.class.getName() + \".transaction\";\n+    public static final String ANNOTATED_BEAN_NAME_ATTRIBUTE = WebfluxHelper.class.getName() + \".bean_name\";\n+    public static final String ANNOTATED_METHOD_NAME_ATTRIBUTE = WebfluxHelper.class.getName() + \".method_name\";\n+    private static final String SERVLET_TRANSACTION = WebfluxHelper.class.getName() + \".servlet_transaction\";\n+\n+    public static final String SSE_EVENT_CLASS = \"org.springframework.http.codec.ServerSentEvent\";\n+\n+    @Nullable\n+    public static Transaction getOrCreateTransaction(Tracer tracer, Class<?> clazz, ServerWebExchange exchange) {\n+\n+        Transaction transaction = getServletTransaction(exchange);\n+        boolean fromServlet = transaction != null;\n+\n+        if (!fromServlet) {\n+            transaction = tracer.startRootTransaction(clazz.getClassLoader());\n+        }\n+\n+        if (transaction == null) {\n+            return null;\n+        }\n+\n+        transaction.withType(\"request\").activate();\n+\n+        // store transaction in exchange to make it easy to retrieve from other handlers\n+        exchange.getAttributes().put(TRANSACTION_ATTRIBUTE, transaction);\n+\n+        exchange.getAttributes().put(SERVLET_TRANSACTION, fromServlet);\n+\n+        return transaction;\n+    }\n+\n+    public static boolean isServletTransaction(ServerWebExchange exchange) {\n+        return Boolean.TRUE == exchange.getAttributes().get(SERVLET_TRANSACTION);\n+    }\n+\n+    @Nullable\n+    private static Transaction getServletTransaction(ServerWebExchange exchange) {\n+        // see ServletHttpHandlerAdapter and sub-classes for implementation details\n+\n+        // While the active transaction is the one created by Servlet, it would rely on the fact that we are on the\n+        // same thread as the one that created the transaction, which is an implementation detail. While not really\n+        // elegant, this solution seems the most reliable for now.\n+        Transaction transaction = null;\n+        try {\n+            ServerHttpRequest exchangeRequest = exchange.getRequest();\n+            if (exchangeRequest instanceof AbstractServerHttpRequest) {\n+                Object nativeRequest = ((AbstractServerHttpRequest) exchangeRequest).getNativeRequest();\n+                if (nativeRequest instanceof HttpServletRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNjc5MTc0OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMjo1OTo0M1rOJPiZ0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMjo1OTo0M1rOJPiZ0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDI3MjA4MQ==", "bodyText": "Can we rely on this to be provided?", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620272081", "createdAt": "2021-04-26T12:59:43Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/pom.xml", "diffHunk": "@@ -0,0 +1,100 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>co.elastic.apm</groupId>\n+        <artifactId>apm-spring-webflux</artifactId>\n+        <version>1.22.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-spring-webflux-plugin</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <!-- for licence header plugin -->\n+        <apm-agent-parent.base.dir>${project.basedir}/../../..</apm-agent-parent.base.dir>\n+\n+        <animal.sniffer.skip>true</animal.sniffer.skip>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.springframework</groupId>\n+            <artifactId>spring-web</artifactId>\n+            <version>${version.spring}</version>\n+            <scope>provided</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.springframework</groupId>\n+            <artifactId>spring-webflux</artifactId>\n+            <version>${version.spring}</version>\n+            <scope>provided</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>javax.servlet</groupId>\n+            <artifactId>javax.servlet-api</artifactId>\n+            <version>3.1.0</version>\n+            <scope>provided</scope>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNjc5NDI3OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/WebfluxHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzowMDoxMVrOJPibWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzowMDoxMVrOJPibWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDI3MjQ3NQ==", "bodyText": "[minor] - not required", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620272475", "createdAt": "2021-04-26T13:00:11Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/WebfluxHelper.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2021 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import org.reactivestreams.Publisher;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.server.reactive.AbstractServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.web.server.ServerWebExchange;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.function.BiFunction;\n+\n+public class WebfluxHelper {\n+\n+    private static final Logger log = LoggerFactory.getLogger(WebfluxHelper.class);\n+\n+    public static final String TRANSACTION_ATTRIBUTE = WebfluxHelper.class.getName() + \".transaction\";\n+    public static final String ANNOTATED_BEAN_NAME_ATTRIBUTE = WebfluxHelper.class.getName() + \".bean_name\";\n+    public static final String ANNOTATED_METHOD_NAME_ATTRIBUTE = WebfluxHelper.class.getName() + \".method_name\";\n+    private static final String SERVLET_TRANSACTION = WebfluxHelper.class.getName() + \".servlet_transaction\";\n+\n+    public static final String SSE_EVENT_CLASS = \"org.springframework.http.codec.ServerSentEvent\";\n+\n+    @Nullable\n+    public static Transaction getOrCreateTransaction(Tracer tracer, Class<?> clazz, ServerWebExchange exchange) {\n+\n+        Transaction transaction = getServletTransaction(exchange);\n+        boolean fromServlet = transaction != null;\n+\n+        if (!fromServlet) {\n+            transaction = tracer.startRootTransaction(clazz.getClassLoader());\n+        }\n+\n+        if (transaction == null) {\n+            return null;\n+        }\n+\n+        transaction.withType(\"request\").activate();\n+\n+        // store transaction in exchange to make it easy to retrieve from other handlers\n+        exchange.getAttributes().put(TRANSACTION_ATTRIBUTE, transaction);\n+\n+        exchange.getAttributes().put(SERVLET_TRANSACTION, fromServlet);\n+\n+        return transaction;\n+    }\n+\n+    public static boolean isServletTransaction(ServerWebExchange exchange) {\n+        return Boolean.TRUE == exchange.getAttributes().get(SERVLET_TRANSACTION);\n+    }\n+\n+    @Nullable\n+    private static Transaction getServletTransaction(ServerWebExchange exchange) {\n+        // see ServletHttpHandlerAdapter and sub-classes for implementation details\n+\n+        // While the active transaction is the one created by Servlet, it would rely on the fact that we are on the\n+        // same thread as the one that created the transaction, which is an implementation detail. While not really\n+        // elegant, this solution seems the most reliable for now.\n+        Transaction transaction = null;\n+        try {\n+            ServerHttpRequest exchangeRequest = exchange.getRequest();\n+            if (exchangeRequest instanceof AbstractServerHttpRequest) {\n+                Object nativeRequest = ((AbstractServerHttpRequest) exchangeRequest).getNativeRequest();\n+                if (nativeRequest instanceof HttpServletRequest) {\n+                    transaction = (Transaction) ((HttpServletRequest) nativeRequest)\n+                        // adding a dependency to servlet instrumentation plugin is not worth for such a simple string\n+                        // but it's fine as long as we have tests for this\n+                        .getAttribute(\"co.elastic.apm.agent.servlet.ServletApiAdvice.transaction\");\n+                }\n+            }\n+        } catch (Throwable ignored) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNjgzOTg5OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzowODozNlrOJPi1aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzowODozNlrOJPi1aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDI3OTE0NQ==", "bodyText": "[minor] Would be a bit simpler to do this computation in HandlerAdapterInstrumentation and store only one attribute.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620279145", "createdAt": "2021-04-26T13:08:36Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.context.Request;\n+import co.elastic.apm.agent.impl.context.Response;\n+import co.elastic.apm.agent.impl.context.web.ResultUtil;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import co.elastic.apm.agent.util.PotentiallyMultiValuedMap;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpResponse;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.reactive.HandlerMapping;\n+import org.springframework.web.server.ServerWebExchange;\n+import org.springframework.web.util.pattern.PathPattern;\n+import reactor.core.CoreSubscriber;\n+\n+import javax.annotation.Nullable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.impl.transaction.AbstractSpan.PRIO_HIGH_LEVEL_FRAMEWORK;\n+import static org.springframework.web.reactive.function.server.RouterFunctions.MATCHING_PATTERN_ATTRIBUTE;\n+\n+/**\n+ * Transaction-aware subscriber that will (optionally) activate transaction and terminate it on error or completion.\n+ *\n+ * @param <T>\n+ */\n+class TransactionAwareSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TransactionAwareSubscriber.class);\n+\n+    private static final WeakConcurrentMap<HandlerMethod, Boolean> ignoredHandlerMethods = WeakMapSupplier.createMap();\n+\n+    private static final WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> transactionMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final ServerWebExchange exchange;\n+\n+    private final String description;\n+\n+    private final Tracer tracer;\n+\n+    /**\n+     * {@literal true} when transaction was activated on subscription\n+     */\n+    private boolean activatedOnSubscribe = false;\n+\n+    /**\n+     * @param subscriber  subscriber to wrap\n+     * @param transaction transaction\n+     * @param exchange    server web exchange\n+     * @param description human-readable description to make debugging easier\n+     */\n+    TransactionAwareSubscriber(CoreSubscriber<? super T> subscriber,\n+                               Tracer tracer,\n+                               Transaction transaction,\n+                               ServerWebExchange exchange,\n+                               String description) {\n+\n+        this.subscriber = subscriber;\n+        this.exchange = exchange;\n+        this.description = description;\n+        this.tracer = tracer;\n+\n+        transactionMap.put(this, transaction);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscribe scheduler\".\n+     * Might activate transaction if not already active. When activating the transaction is kept active after method execution.\n+     * Refer to {@link #doEnter} for details on activation.\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        Transaction transaction = getTransaction();\n+        doEnter(true, \"onSubscribe\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onSubscribe\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will discard transaction reference if any exception is thrown.\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onNext\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onNext\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onError\", transaction);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            endTransaction(t, transaction);\n+            doExit(true, \"onError\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     */\n+    @Override\n+    public void onComplete() {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onComplete\", transaction);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            endTransaction(null, transaction);\n+            doExit(true, \"onComplete\", transaction);\n+        }\n+    }\n+\n+    private void doEnter(boolean isSubscribe, String method, @Nullable Transaction transaction) {\n+        debugTrace(true, method, transaction);\n+\n+        if (!isSubscribe || transaction == null) {\n+            return;\n+        }\n+\n+        if (transaction == tracer.getActive()) {\n+            activatedOnSubscribe = false;\n+            return;\n+        }\n+\n+        transaction.activate();\n+        activatedOnSubscribe = true;\n+    }\n+\n+    private void doExit(boolean discard, String method, @Nullable Transaction transaction) {\n+        debugTrace(false, method, transaction);\n+\n+        if (transaction == null) {\n+            return;\n+        }\n+\n+        if (discard) {\n+            if (activatedOnSubscribe && tracer.getActive() == transaction) {\n+                transaction.deactivate();\n+            }\n+            transactionMap.remove(this);\n+        }\n+\n+    }\n+\n+    @Nullable\n+    private Transaction getTransaction() {\n+        return transactionMap.get(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable Transaction transaction) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} {} {} {}\", isEnter ? \">>>>\" : \"<<<<\", description, method, transaction);\n+    }\n+\n+    /**\n+     * Only for testing\n+     *\n+     * @return storage map for in-flight transactions\n+     */\n+    static WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> getTransactionMap() {\n+        return transactionMap;\n+    }\n+\n+    private void endTransaction(@Nullable Throwable thrown, @Nullable Transaction transaction) {\n+        if (transaction == null) {\n+            // already discarded\n+            return;\n+        }\n+\n+        Object attribute = exchange.getAttributes().remove(WebfluxHelper.TRANSACTION_ATTRIBUTE);\n+        if (attribute != transaction) {\n+            // transaction might be already terminated due to instrumentation of more than one\n+            // dispatcher/handler/invocation-handler class\n+            return;\n+        }\n+\n+        if (ignoreTransaction(exchange, transaction)) {\n+            transaction.ignoreTransaction();\n+            transaction.end();\n+            return;\n+        }\n+\n+        StringBuilder transactionName = transaction.getAndOverrideName(PRIO_HIGH_LEVEL_FRAMEWORK, true);\n+        if (transactionName != null) {\n+            String httpMethod = exchange.getRequest().getMethodValue();\n+\n+            // bean name & method should be set for annotated methods\n+            String beanName = exchange.getAttribute(WebfluxHelper.ANNOTATED_BEAN_NAME_ATTRIBUTE);\n+            String methodName = exchange.getAttribute(WebfluxHelper.ANNOTATED_METHOD_NAME_ATTRIBUTE);\n+\n+            PathPattern pattern = exchange.getAttribute(MATCHING_PATTERN_ATTRIBUTE);\n+\n+            if (beanName != null && methodName != null) {\n+                transactionName.append(beanName)\n+                    .append('#')\n+                    .append(methodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNjg3NDkxOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/HandlerAdapterInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzoxNDo0MVrOJPjJjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzoxNDo0MVrOJPjJjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDI4NDMwMg==", "bodyText": "[minor]\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Object attribute = exchange.getAttribute(WebfluxHelper.TRANSACTION_ATTRIBUTE);\n          \n          \n            \n                        Object transaction = exchange.getAttribute(WebfluxHelper.TRANSACTION_ATTRIBUTE);", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620284302", "createdAt": "2021-04-26T13:14:41Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/HandlerAdapterInstrumentation.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.reactive.HandlerResult;\n+import org.springframework.web.server.ServerWebExchange;\n+import reactor.core.publisher.Mono;\n+\n+import javax.annotation.Nullable;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+/**\n+ * Instruments known implementations of {@link org.springframework.web.reactive.HandlerAdapter#handle(ServerWebExchange, Object)}\n+ * that handle annotation based controllers execution and naming\n+ * <ul>\n+ *     <li>{@link org.springframework.web.reactive.function.server.support.HandlerFunctionAdapter}</li>\n+ *     <li>{@link org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter}</li>\n+ *     <li>{@link org.springframework.web.reactive.socket.server.support.WebSocketHandlerAdapter}</li>\n+ *     <li>{@link org.springframework.web.reactive.result.SimpleHandlerAdapter}</li>\n+ * </ul>\n+ */\n+public class HandlerAdapterInstrumentation extends WebFluxInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return named(\"org.springframework.web.reactive.function.server.support.HandlerFunctionAdapter\")\n+            .or(named(\"org.springframework.web.reactive.result.method.annotation.RequestMappingHandlerAdapter\"))\n+            .or(named(\"org.springframework.web.reactive.socket.server.support.WebSocketHandlerAdapter\"))\n+            .or(named(\"org.springframework.web.reactive.result.SimpleHandlerAdapter\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"handle\")\n+            .and(takesArgument(0, named(\"org.springframework.web.server.ServerWebExchange\")))\n+            .and(takesArgument(1, Object.class));\n+    }\n+\n+    @Override\n+    public String getAdviceClassName() {\n+        return \"co.elastic.apm.agent.springwebflux.HandlerAdapterInstrumentation$HandleAdvice\";\n+    }\n+\n+    public static class HandleAdvice {\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onEnter(@Advice.Argument(0) ServerWebExchange exchange,\n+                                     @Advice.Argument(1) Object handler) {\n+\n+            Object attribute = exchange.getAttribute(WebfluxHelper.TRANSACTION_ATTRIBUTE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNzA0NzU1OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzo0NDo0NFrOJPkwTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzo0NDo0NFrOJPkwTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDMxMDYwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static boolean ignoreTransaction(ServerWebExchange exchange, Transaction transaction) {\n          \n          \n            \n                private static boolean ignoreTransaction(ServerWebExchange exchange) {", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620310607", "createdAt": "2021-04-26T13:44:44Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.context.Request;\n+import co.elastic.apm.agent.impl.context.Response;\n+import co.elastic.apm.agent.impl.context.web.ResultUtil;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import co.elastic.apm.agent.util.PotentiallyMultiValuedMap;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpResponse;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.reactive.HandlerMapping;\n+import org.springframework.web.server.ServerWebExchange;\n+import org.springframework.web.util.pattern.PathPattern;\n+import reactor.core.CoreSubscriber;\n+\n+import javax.annotation.Nullable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.impl.transaction.AbstractSpan.PRIO_HIGH_LEVEL_FRAMEWORK;\n+import static org.springframework.web.reactive.function.server.RouterFunctions.MATCHING_PATTERN_ATTRIBUTE;\n+\n+/**\n+ * Transaction-aware subscriber that will (optionally) activate transaction and terminate it on error or completion.\n+ *\n+ * @param <T>\n+ */\n+class TransactionAwareSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TransactionAwareSubscriber.class);\n+\n+    private static final WeakConcurrentMap<HandlerMethod, Boolean> ignoredHandlerMethods = WeakMapSupplier.createMap();\n+\n+    private static final WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> transactionMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final ServerWebExchange exchange;\n+\n+    private final String description;\n+\n+    private final Tracer tracer;\n+\n+    /**\n+     * {@literal true} when transaction was activated on subscription\n+     */\n+    private boolean activatedOnSubscribe = false;\n+\n+    /**\n+     * @param subscriber  subscriber to wrap\n+     * @param transaction transaction\n+     * @param exchange    server web exchange\n+     * @param description human-readable description to make debugging easier\n+     */\n+    TransactionAwareSubscriber(CoreSubscriber<? super T> subscriber,\n+                               Tracer tracer,\n+                               Transaction transaction,\n+                               ServerWebExchange exchange,\n+                               String description) {\n+\n+        this.subscriber = subscriber;\n+        this.exchange = exchange;\n+        this.description = description;\n+        this.tracer = tracer;\n+\n+        transactionMap.put(this, transaction);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscribe scheduler\".\n+     * Might activate transaction if not already active. When activating the transaction is kept active after method execution.\n+     * Refer to {@link #doEnter} for details on activation.\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        Transaction transaction = getTransaction();\n+        doEnter(true, \"onSubscribe\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onSubscribe\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will discard transaction reference if any exception is thrown.\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onNext\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onNext\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onError\", transaction);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            endTransaction(t, transaction);\n+            doExit(true, \"onError\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     */\n+    @Override\n+    public void onComplete() {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onComplete\", transaction);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            endTransaction(null, transaction);\n+            doExit(true, \"onComplete\", transaction);\n+        }\n+    }\n+\n+    private void doEnter(boolean isSubscribe, String method, @Nullable Transaction transaction) {\n+        debugTrace(true, method, transaction);\n+\n+        if (!isSubscribe || transaction == null) {\n+            return;\n+        }\n+\n+        if (transaction == tracer.getActive()) {\n+            activatedOnSubscribe = false;\n+            return;\n+        }\n+\n+        transaction.activate();\n+        activatedOnSubscribe = true;\n+    }\n+\n+    private void doExit(boolean discard, String method, @Nullable Transaction transaction) {\n+        debugTrace(false, method, transaction);\n+\n+        if (transaction == null) {\n+            return;\n+        }\n+\n+        if (discard) {\n+            if (activatedOnSubscribe && tracer.getActive() == transaction) {\n+                transaction.deactivate();\n+            }\n+            transactionMap.remove(this);\n+        }\n+\n+    }\n+\n+    @Nullable\n+    private Transaction getTransaction() {\n+        return transactionMap.get(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable Transaction transaction) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} {} {} {}\", isEnter ? \">>>>\" : \"<<<<\", description, method, transaction);\n+    }\n+\n+    /**\n+     * Only for testing\n+     *\n+     * @return storage map for in-flight transactions\n+     */\n+    static WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> getTransactionMap() {\n+        return transactionMap;\n+    }\n+\n+    private void endTransaction(@Nullable Throwable thrown, @Nullable Transaction transaction) {\n+        if (transaction == null) {\n+            // already discarded\n+            return;\n+        }\n+\n+        Object attribute = exchange.getAttributes().remove(WebfluxHelper.TRANSACTION_ATTRIBUTE);\n+        if (attribute != transaction) {\n+            // transaction might be already terminated due to instrumentation of more than one\n+            // dispatcher/handler/invocation-handler class\n+            return;\n+        }\n+\n+        if (ignoreTransaction(exchange, transaction)) {\n+            transaction.ignoreTransaction();\n+            transaction.end();\n+            return;\n+        }\n+\n+        StringBuilder transactionName = transaction.getAndOverrideName(PRIO_HIGH_LEVEL_FRAMEWORK, true);\n+        if (transactionName != null) {\n+            String httpMethod = exchange.getRequest().getMethodValue();\n+\n+            // bean name & method should be set for annotated methods\n+            String beanName = exchange.getAttribute(WebfluxHelper.ANNOTATED_BEAN_NAME_ATTRIBUTE);\n+            String methodName = exchange.getAttribute(WebfluxHelper.ANNOTATED_METHOD_NAME_ATTRIBUTE);\n+\n+            PathPattern pattern = exchange.getAttribute(MATCHING_PATTERN_ATTRIBUTE);\n+\n+            if (beanName != null && methodName != null) {\n+                transactionName.append(beanName)\n+                    .append('#')\n+                    .append(methodName);\n+            } else {\n+                transactionName.append(httpMethod).append(' ');\n+                if (pattern != null) {\n+                    transactionName.append(pattern.getPatternString());\n+                } else {\n+                    transactionName.append(\"unknown route\");\n+                }\n+            }\n+        }\n+\n+        // Fill request/response details if they haven't been already by another HTTP plugin (servlet or other).\n+        if (!transaction.getContext().getRequest().hasContent()) {\n+            fillRequest(transaction, exchange);\n+            fillResponse(transaction, exchange);\n+        }\n+\n+        transaction.captureException(thrown);\n+\n+        // In case transaction has been created by Servlet, we should not terminate it as the Servlet instrumentation\n+        // will take care of this.\n+        if (!WebfluxHelper.isServletTransaction(exchange)) {\n+            transaction.end();\n+        }\n+\n+    }\n+\n+    private static boolean ignoreTransaction(ServerWebExchange exchange, Transaction transaction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNzExNzY1OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzo1NjozNVrOJPlaVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzo1NjozNVrOJPlaVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDMyMTM2NQ==", "bodyText": "Only if capture_headers config is enabled", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620321365", "createdAt": "2021-04-26T13:56:35Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.context.Request;\n+import co.elastic.apm.agent.impl.context.Response;\n+import co.elastic.apm.agent.impl.context.web.ResultUtil;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import co.elastic.apm.agent.util.PotentiallyMultiValuedMap;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpResponse;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.reactive.HandlerMapping;\n+import org.springframework.web.server.ServerWebExchange;\n+import org.springframework.web.util.pattern.PathPattern;\n+import reactor.core.CoreSubscriber;\n+\n+import javax.annotation.Nullable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.impl.transaction.AbstractSpan.PRIO_HIGH_LEVEL_FRAMEWORK;\n+import static org.springframework.web.reactive.function.server.RouterFunctions.MATCHING_PATTERN_ATTRIBUTE;\n+\n+/**\n+ * Transaction-aware subscriber that will (optionally) activate transaction and terminate it on error or completion.\n+ *\n+ * @param <T>\n+ */\n+class TransactionAwareSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TransactionAwareSubscriber.class);\n+\n+    private static final WeakConcurrentMap<HandlerMethod, Boolean> ignoredHandlerMethods = WeakMapSupplier.createMap();\n+\n+    private static final WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> transactionMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final ServerWebExchange exchange;\n+\n+    private final String description;\n+\n+    private final Tracer tracer;\n+\n+    /**\n+     * {@literal true} when transaction was activated on subscription\n+     */\n+    private boolean activatedOnSubscribe = false;\n+\n+    /**\n+     * @param subscriber  subscriber to wrap\n+     * @param transaction transaction\n+     * @param exchange    server web exchange\n+     * @param description human-readable description to make debugging easier\n+     */\n+    TransactionAwareSubscriber(CoreSubscriber<? super T> subscriber,\n+                               Tracer tracer,\n+                               Transaction transaction,\n+                               ServerWebExchange exchange,\n+                               String description) {\n+\n+        this.subscriber = subscriber;\n+        this.exchange = exchange;\n+        this.description = description;\n+        this.tracer = tracer;\n+\n+        transactionMap.put(this, transaction);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscribe scheduler\".\n+     * Might activate transaction if not already active. When activating the transaction is kept active after method execution.\n+     * Refer to {@link #doEnter} for details on activation.\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        Transaction transaction = getTransaction();\n+        doEnter(true, \"onSubscribe\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onSubscribe\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will discard transaction reference if any exception is thrown.\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onNext\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onNext\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onError\", transaction);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            endTransaction(t, transaction);\n+            doExit(true, \"onError\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     */\n+    @Override\n+    public void onComplete() {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onComplete\", transaction);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            endTransaction(null, transaction);\n+            doExit(true, \"onComplete\", transaction);\n+        }\n+    }\n+\n+    private void doEnter(boolean isSubscribe, String method, @Nullable Transaction transaction) {\n+        debugTrace(true, method, transaction);\n+\n+        if (!isSubscribe || transaction == null) {\n+            return;\n+        }\n+\n+        if (transaction == tracer.getActive()) {\n+            activatedOnSubscribe = false;\n+            return;\n+        }\n+\n+        transaction.activate();\n+        activatedOnSubscribe = true;\n+    }\n+\n+    private void doExit(boolean discard, String method, @Nullable Transaction transaction) {\n+        debugTrace(false, method, transaction);\n+\n+        if (transaction == null) {\n+            return;\n+        }\n+\n+        if (discard) {\n+            if (activatedOnSubscribe && tracer.getActive() == transaction) {\n+                transaction.deactivate();\n+            }\n+            transactionMap.remove(this);\n+        }\n+\n+    }\n+\n+    @Nullable\n+    private Transaction getTransaction() {\n+        return transactionMap.get(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable Transaction transaction) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} {} {} {}\", isEnter ? \">>>>\" : \"<<<<\", description, method, transaction);\n+    }\n+\n+    /**\n+     * Only for testing\n+     *\n+     * @return storage map for in-flight transactions\n+     */\n+    static WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> getTransactionMap() {\n+        return transactionMap;\n+    }\n+\n+    private void endTransaction(@Nullable Throwable thrown, @Nullable Transaction transaction) {\n+        if (transaction == null) {\n+            // already discarded\n+            return;\n+        }\n+\n+        Object attribute = exchange.getAttributes().remove(WebfluxHelper.TRANSACTION_ATTRIBUTE);\n+        if (attribute != transaction) {\n+            // transaction might be already terminated due to instrumentation of more than one\n+            // dispatcher/handler/invocation-handler class\n+            return;\n+        }\n+\n+        if (ignoreTransaction(exchange, transaction)) {\n+            transaction.ignoreTransaction();\n+            transaction.end();\n+            return;\n+        }\n+\n+        StringBuilder transactionName = transaction.getAndOverrideName(PRIO_HIGH_LEVEL_FRAMEWORK, true);\n+        if (transactionName != null) {\n+            String httpMethod = exchange.getRequest().getMethodValue();\n+\n+            // bean name & method should be set for annotated methods\n+            String beanName = exchange.getAttribute(WebfluxHelper.ANNOTATED_BEAN_NAME_ATTRIBUTE);\n+            String methodName = exchange.getAttribute(WebfluxHelper.ANNOTATED_METHOD_NAME_ATTRIBUTE);\n+\n+            PathPattern pattern = exchange.getAttribute(MATCHING_PATTERN_ATTRIBUTE);\n+\n+            if (beanName != null && methodName != null) {\n+                transactionName.append(beanName)\n+                    .append('#')\n+                    .append(methodName);\n+            } else {\n+                transactionName.append(httpMethod).append(' ');\n+                if (pattern != null) {\n+                    transactionName.append(pattern.getPatternString());\n+                } else {\n+                    transactionName.append(\"unknown route\");\n+                }\n+            }\n+        }\n+\n+        // Fill request/response details if they haven't been already by another HTTP plugin (servlet or other).\n+        if (!transaction.getContext().getRequest().hasContent()) {\n+            fillRequest(transaction, exchange);\n+            fillResponse(transaction, exchange);\n+        }\n+\n+        transaction.captureException(thrown);\n+\n+        // In case transaction has been created by Servlet, we should not terminate it as the Servlet instrumentation\n+        // will take care of this.\n+        if (!WebfluxHelper.isServletTransaction(exchange)) {\n+            transaction.end();\n+        }\n+\n+    }\n+\n+    private static boolean ignoreTransaction(ServerWebExchange exchange, Transaction transaction) {\n+        // Annotated controllers have the invoked handler method available in exchange\n+        // thus we can rely on this to ignore methods that return ServerSideEvents which should not report transactions\n+        Object attribute = exchange.getAttribute(HandlerMapping.BEST_MATCHING_HANDLER_ATTRIBUTE);\n+        if (!(attribute instanceof HandlerMethod)) {\n+            return false;\n+        }\n+\n+        HandlerMethod handlerMethod = (HandlerMethod) attribute;\n+        Boolean ignoredCache = ignoredHandlerMethods.get(handlerMethod);\n+        if (ignoredCache != null) {\n+            return ignoredCache;\n+        }\n+\n+        Type returnType = handlerMethod.getMethod().getGenericReturnType();\n+        if (!(returnType instanceof ParameterizedType)) {\n+            ignoredHandlerMethods.put(handlerMethod, false);\n+            return false;\n+        }\n+\n+        Type[] genReturnTypes = ((ParameterizedType) returnType).getActualTypeArguments();\n+        //noinspection ForLoopReplaceableByForEach\n+        for (int i = 0; i < genReturnTypes.length; i++) {\n+            if (genReturnTypes[i].getTypeName().startsWith(WebfluxHelper.SSE_EVENT_CLASS)) {\n+                ignoredHandlerMethods.put(handlerMethod, true);\n+                return true;\n+            }\n+        }\n+\n+        ignoredHandlerMethods.put(handlerMethod, false);\n+        return false;\n+    }\n+\n+    private static void fillRequest(Transaction transaction, ServerWebExchange exchange) {\n+        ServerHttpRequest serverRequest = exchange.getRequest();\n+        Request request = transaction.getContext().getRequest();\n+\n+        request.withMethod(serverRequest.getMethodValue());\n+\n+        InetSocketAddress remoteAddress = serverRequest.getRemoteAddress();\n+        request.getSocket()\n+            .withRemoteAddress(remoteAddress == null ? null : remoteAddress.getAddress().getHostAddress())\n+            .withEncrypted(serverRequest.getSslInfo() != null);\n+\n+        URI uri = serverRequest.getURI();\n+        request.getUrl()\n+            .withProtocol(uri.getScheme())\n+            .withHostname(uri.getHost())\n+            .withPort(uri.getPort())\n+            .withPathname(uri.getPath())\n+            .withSearch(uri.getQuery())\n+            .updateFull();\n+\n+        copyHeaders(serverRequest.getHeaders(), request.getHeaders());\n+\n+        for (Map.Entry<String, List<HttpCookie>> cookie : serverRequest.getCookies().entrySet()) {\n+            for (HttpCookie value : cookie.getValue()) {\n+                request.getCookies().add(cookie.getKey(), value.getValue());\n+            }\n+        }\n+\n+    }\n+\n+    private static void fillResponse(Transaction transaction, ServerWebExchange exchange) {\n+        ServerHttpResponse serverResponse = exchange.getResponse();\n+        HttpStatus statusCode = serverResponse.getStatusCode();\n+        int status = statusCode != null ? statusCode.value() : 200;\n+\n+        transaction.withResultIfUnset(ResultUtil.getResultByHttpStatus(status));\n+\n+        Response response = transaction.getContext().getResponse();\n+\n+        copyHeaders(serverResponse.getHeaders(), response.getHeaders());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNzEyMDMxOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzo1NzowMlrOJPlb8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxMzo1NzowMlrOJPlb8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDMyMTc3OA==", "bodyText": "Only if capture_headers config is enabled", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620321778", "createdAt": "2021-04-26T13:57:02Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.context.Request;\n+import co.elastic.apm.agent.impl.context.Response;\n+import co.elastic.apm.agent.impl.context.web.ResultUtil;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import co.elastic.apm.agent.util.PotentiallyMultiValuedMap;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpResponse;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.reactive.HandlerMapping;\n+import org.springframework.web.server.ServerWebExchange;\n+import org.springframework.web.util.pattern.PathPattern;\n+import reactor.core.CoreSubscriber;\n+\n+import javax.annotation.Nullable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.impl.transaction.AbstractSpan.PRIO_HIGH_LEVEL_FRAMEWORK;\n+import static org.springframework.web.reactive.function.server.RouterFunctions.MATCHING_PATTERN_ATTRIBUTE;\n+\n+/**\n+ * Transaction-aware subscriber that will (optionally) activate transaction and terminate it on error or completion.\n+ *\n+ * @param <T>\n+ */\n+class TransactionAwareSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TransactionAwareSubscriber.class);\n+\n+    private static final WeakConcurrentMap<HandlerMethod, Boolean> ignoredHandlerMethods = WeakMapSupplier.createMap();\n+\n+    private static final WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> transactionMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final ServerWebExchange exchange;\n+\n+    private final String description;\n+\n+    private final Tracer tracer;\n+\n+    /**\n+     * {@literal true} when transaction was activated on subscription\n+     */\n+    private boolean activatedOnSubscribe = false;\n+\n+    /**\n+     * @param subscriber  subscriber to wrap\n+     * @param transaction transaction\n+     * @param exchange    server web exchange\n+     * @param description human-readable description to make debugging easier\n+     */\n+    TransactionAwareSubscriber(CoreSubscriber<? super T> subscriber,\n+                               Tracer tracer,\n+                               Transaction transaction,\n+                               ServerWebExchange exchange,\n+                               String description) {\n+\n+        this.subscriber = subscriber;\n+        this.exchange = exchange;\n+        this.description = description;\n+        this.tracer = tracer;\n+\n+        transactionMap.put(this, transaction);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscribe scheduler\".\n+     * Might activate transaction if not already active. When activating the transaction is kept active after method execution.\n+     * Refer to {@link #doEnter} for details on activation.\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        Transaction transaction = getTransaction();\n+        doEnter(true, \"onSubscribe\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onSubscribe\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will discard transaction reference if any exception is thrown.\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onNext\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onNext\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onError\", transaction);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            endTransaction(t, transaction);\n+            doExit(true, \"onError\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     */\n+    @Override\n+    public void onComplete() {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onComplete\", transaction);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            endTransaction(null, transaction);\n+            doExit(true, \"onComplete\", transaction);\n+        }\n+    }\n+\n+    private void doEnter(boolean isSubscribe, String method, @Nullable Transaction transaction) {\n+        debugTrace(true, method, transaction);\n+\n+        if (!isSubscribe || transaction == null) {\n+            return;\n+        }\n+\n+        if (transaction == tracer.getActive()) {\n+            activatedOnSubscribe = false;\n+            return;\n+        }\n+\n+        transaction.activate();\n+        activatedOnSubscribe = true;\n+    }\n+\n+    private void doExit(boolean discard, String method, @Nullable Transaction transaction) {\n+        debugTrace(false, method, transaction);\n+\n+        if (transaction == null) {\n+            return;\n+        }\n+\n+        if (discard) {\n+            if (activatedOnSubscribe && tracer.getActive() == transaction) {\n+                transaction.deactivate();\n+            }\n+            transactionMap.remove(this);\n+        }\n+\n+    }\n+\n+    @Nullable\n+    private Transaction getTransaction() {\n+        return transactionMap.get(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable Transaction transaction) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} {} {} {}\", isEnter ? \">>>>\" : \"<<<<\", description, method, transaction);\n+    }\n+\n+    /**\n+     * Only for testing\n+     *\n+     * @return storage map for in-flight transactions\n+     */\n+    static WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> getTransactionMap() {\n+        return transactionMap;\n+    }\n+\n+    private void endTransaction(@Nullable Throwable thrown, @Nullable Transaction transaction) {\n+        if (transaction == null) {\n+            // already discarded\n+            return;\n+        }\n+\n+        Object attribute = exchange.getAttributes().remove(WebfluxHelper.TRANSACTION_ATTRIBUTE);\n+        if (attribute != transaction) {\n+            // transaction might be already terminated due to instrumentation of more than one\n+            // dispatcher/handler/invocation-handler class\n+            return;\n+        }\n+\n+        if (ignoreTransaction(exchange, transaction)) {\n+            transaction.ignoreTransaction();\n+            transaction.end();\n+            return;\n+        }\n+\n+        StringBuilder transactionName = transaction.getAndOverrideName(PRIO_HIGH_LEVEL_FRAMEWORK, true);\n+        if (transactionName != null) {\n+            String httpMethod = exchange.getRequest().getMethodValue();\n+\n+            // bean name & method should be set for annotated methods\n+            String beanName = exchange.getAttribute(WebfluxHelper.ANNOTATED_BEAN_NAME_ATTRIBUTE);\n+            String methodName = exchange.getAttribute(WebfluxHelper.ANNOTATED_METHOD_NAME_ATTRIBUTE);\n+\n+            PathPattern pattern = exchange.getAttribute(MATCHING_PATTERN_ATTRIBUTE);\n+\n+            if (beanName != null && methodName != null) {\n+                transactionName.append(beanName)\n+                    .append('#')\n+                    .append(methodName);\n+            } else {\n+                transactionName.append(httpMethod).append(' ');\n+                if (pattern != null) {\n+                    transactionName.append(pattern.getPatternString());\n+                } else {\n+                    transactionName.append(\"unknown route\");\n+                }\n+            }\n+        }\n+\n+        // Fill request/response details if they haven't been already by another HTTP plugin (servlet or other).\n+        if (!transaction.getContext().getRequest().hasContent()) {\n+            fillRequest(transaction, exchange);\n+            fillResponse(transaction, exchange);\n+        }\n+\n+        transaction.captureException(thrown);\n+\n+        // In case transaction has been created by Servlet, we should not terminate it as the Servlet instrumentation\n+        // will take care of this.\n+        if (!WebfluxHelper.isServletTransaction(exchange)) {\n+            transaction.end();\n+        }\n+\n+    }\n+\n+    private static boolean ignoreTransaction(ServerWebExchange exchange, Transaction transaction) {\n+        // Annotated controllers have the invoked handler method available in exchange\n+        // thus we can rely on this to ignore methods that return ServerSideEvents which should not report transactions\n+        Object attribute = exchange.getAttribute(HandlerMapping.BEST_MATCHING_HANDLER_ATTRIBUTE);\n+        if (!(attribute instanceof HandlerMethod)) {\n+            return false;\n+        }\n+\n+        HandlerMethod handlerMethod = (HandlerMethod) attribute;\n+        Boolean ignoredCache = ignoredHandlerMethods.get(handlerMethod);\n+        if (ignoredCache != null) {\n+            return ignoredCache;\n+        }\n+\n+        Type returnType = handlerMethod.getMethod().getGenericReturnType();\n+        if (!(returnType instanceof ParameterizedType)) {\n+            ignoredHandlerMethods.put(handlerMethod, false);\n+            return false;\n+        }\n+\n+        Type[] genReturnTypes = ((ParameterizedType) returnType).getActualTypeArguments();\n+        //noinspection ForLoopReplaceableByForEach\n+        for (int i = 0; i < genReturnTypes.length; i++) {\n+            if (genReturnTypes[i].getTypeName().startsWith(WebfluxHelper.SSE_EVENT_CLASS)) {\n+                ignoredHandlerMethods.put(handlerMethod, true);\n+                return true;\n+            }\n+        }\n+\n+        ignoredHandlerMethods.put(handlerMethod, false);\n+        return false;\n+    }\n+\n+    private static void fillRequest(Transaction transaction, ServerWebExchange exchange) {\n+        ServerHttpRequest serverRequest = exchange.getRequest();\n+        Request request = transaction.getContext().getRequest();\n+\n+        request.withMethod(serverRequest.getMethodValue());\n+\n+        InetSocketAddress remoteAddress = serverRequest.getRemoteAddress();\n+        request.getSocket()\n+            .withRemoteAddress(remoteAddress == null ? null : remoteAddress.getAddress().getHostAddress())\n+            .withEncrypted(serverRequest.getSslInfo() != null);\n+\n+        URI uri = serverRequest.getURI();\n+        request.getUrl()\n+            .withProtocol(uri.getScheme())\n+            .withHostname(uri.getHost())\n+            .withPort(uri.getPort())\n+            .withPathname(uri.getPath())\n+            .withSearch(uri.getQuery())\n+            .updateFull();\n+\n+        copyHeaders(serverRequest.getHeaders(), request.getHeaders());\n+\n+        for (Map.Entry<String, List<HttpCookie>> cookie : serverRequest.getCookies().entrySet()) {\n+            for (HttpCookie value : cookie.getValue()) {\n+                request.getCookies().add(cookie.getKey(), value.getValue());\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNzE4ODU5OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxNDowODoxOFrOJPmEVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yNVQxODo0ODoyMVrOJhfhAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDMzMjExOQ==", "bodyText": "How complicated would it be to use serverRequest.getBody() to capture the request body?", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620332119", "createdAt": "2021-04-26T14:08:18Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.context.Request;\n+import co.elastic.apm.agent.impl.context.Response;\n+import co.elastic.apm.agent.impl.context.web.ResultUtil;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import co.elastic.apm.agent.util.PotentiallyMultiValuedMap;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpResponse;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.reactive.HandlerMapping;\n+import org.springframework.web.server.ServerWebExchange;\n+import org.springframework.web.util.pattern.PathPattern;\n+import reactor.core.CoreSubscriber;\n+\n+import javax.annotation.Nullable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.impl.transaction.AbstractSpan.PRIO_HIGH_LEVEL_FRAMEWORK;\n+import static org.springframework.web.reactive.function.server.RouterFunctions.MATCHING_PATTERN_ATTRIBUTE;\n+\n+/**\n+ * Transaction-aware subscriber that will (optionally) activate transaction and terminate it on error or completion.\n+ *\n+ * @param <T>\n+ */\n+class TransactionAwareSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TransactionAwareSubscriber.class);\n+\n+    private static final WeakConcurrentMap<HandlerMethod, Boolean> ignoredHandlerMethods = WeakMapSupplier.createMap();\n+\n+    private static final WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> transactionMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final ServerWebExchange exchange;\n+\n+    private final String description;\n+\n+    private final Tracer tracer;\n+\n+    /**\n+     * {@literal true} when transaction was activated on subscription\n+     */\n+    private boolean activatedOnSubscribe = false;\n+\n+    /**\n+     * @param subscriber  subscriber to wrap\n+     * @param transaction transaction\n+     * @param exchange    server web exchange\n+     * @param description human-readable description to make debugging easier\n+     */\n+    TransactionAwareSubscriber(CoreSubscriber<? super T> subscriber,\n+                               Tracer tracer,\n+                               Transaction transaction,\n+                               ServerWebExchange exchange,\n+                               String description) {\n+\n+        this.subscriber = subscriber;\n+        this.exchange = exchange;\n+        this.description = description;\n+        this.tracer = tracer;\n+\n+        transactionMap.put(this, transaction);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscribe scheduler\".\n+     * Might activate transaction if not already active. When activating the transaction is kept active after method execution.\n+     * Refer to {@link #doEnter} for details on activation.\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        Transaction transaction = getTransaction();\n+        doEnter(true, \"onSubscribe\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onSubscribe\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will discard transaction reference if any exception is thrown.\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onNext\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onNext\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onError\", transaction);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            endTransaction(t, transaction);\n+            doExit(true, \"onError\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     */\n+    @Override\n+    public void onComplete() {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onComplete\", transaction);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            endTransaction(null, transaction);\n+            doExit(true, \"onComplete\", transaction);\n+        }\n+    }\n+\n+    private void doEnter(boolean isSubscribe, String method, @Nullable Transaction transaction) {\n+        debugTrace(true, method, transaction);\n+\n+        if (!isSubscribe || transaction == null) {\n+            return;\n+        }\n+\n+        if (transaction == tracer.getActive()) {\n+            activatedOnSubscribe = false;\n+            return;\n+        }\n+\n+        transaction.activate();\n+        activatedOnSubscribe = true;\n+    }\n+\n+    private void doExit(boolean discard, String method, @Nullable Transaction transaction) {\n+        debugTrace(false, method, transaction);\n+\n+        if (transaction == null) {\n+            return;\n+        }\n+\n+        if (discard) {\n+            if (activatedOnSubscribe && tracer.getActive() == transaction) {\n+                transaction.deactivate();\n+            }\n+            transactionMap.remove(this);\n+        }\n+\n+    }\n+\n+    @Nullable\n+    private Transaction getTransaction() {\n+        return transactionMap.get(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable Transaction transaction) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} {} {} {}\", isEnter ? \">>>>\" : \"<<<<\", description, method, transaction);\n+    }\n+\n+    /**\n+     * Only for testing\n+     *\n+     * @return storage map for in-flight transactions\n+     */\n+    static WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> getTransactionMap() {\n+        return transactionMap;\n+    }\n+\n+    private void endTransaction(@Nullable Throwable thrown, @Nullable Transaction transaction) {\n+        if (transaction == null) {\n+            // already discarded\n+            return;\n+        }\n+\n+        Object attribute = exchange.getAttributes().remove(WebfluxHelper.TRANSACTION_ATTRIBUTE);\n+        if (attribute != transaction) {\n+            // transaction might be already terminated due to instrumentation of more than one\n+            // dispatcher/handler/invocation-handler class\n+            return;\n+        }\n+\n+        if (ignoreTransaction(exchange, transaction)) {\n+            transaction.ignoreTransaction();\n+            transaction.end();\n+            return;\n+        }\n+\n+        StringBuilder transactionName = transaction.getAndOverrideName(PRIO_HIGH_LEVEL_FRAMEWORK, true);\n+        if (transactionName != null) {\n+            String httpMethod = exchange.getRequest().getMethodValue();\n+\n+            // bean name & method should be set for annotated methods\n+            String beanName = exchange.getAttribute(WebfluxHelper.ANNOTATED_BEAN_NAME_ATTRIBUTE);\n+            String methodName = exchange.getAttribute(WebfluxHelper.ANNOTATED_METHOD_NAME_ATTRIBUTE);\n+\n+            PathPattern pattern = exchange.getAttribute(MATCHING_PATTERN_ATTRIBUTE);\n+\n+            if (beanName != null && methodName != null) {\n+                transactionName.append(beanName)\n+                    .append('#')\n+                    .append(methodName);\n+            } else {\n+                transactionName.append(httpMethod).append(' ');\n+                if (pattern != null) {\n+                    transactionName.append(pattern.getPatternString());\n+                } else {\n+                    transactionName.append(\"unknown route\");\n+                }\n+            }\n+        }\n+\n+        // Fill request/response details if they haven't been already by another HTTP plugin (servlet or other).\n+        if (!transaction.getContext().getRequest().hasContent()) {\n+            fillRequest(transaction, exchange);\n+            fillResponse(transaction, exchange);\n+        }\n+\n+        transaction.captureException(thrown);\n+\n+        // In case transaction has been created by Servlet, we should not terminate it as the Servlet instrumentation\n+        // will take care of this.\n+        if (!WebfluxHelper.isServletTransaction(exchange)) {\n+            transaction.end();\n+        }\n+\n+    }\n+\n+    private static boolean ignoreTransaction(ServerWebExchange exchange, Transaction transaction) {\n+        // Annotated controllers have the invoked handler method available in exchange\n+        // thus we can rely on this to ignore methods that return ServerSideEvents which should not report transactions\n+        Object attribute = exchange.getAttribute(HandlerMapping.BEST_MATCHING_HANDLER_ATTRIBUTE);\n+        if (!(attribute instanceof HandlerMethod)) {\n+            return false;\n+        }\n+\n+        HandlerMethod handlerMethod = (HandlerMethod) attribute;\n+        Boolean ignoredCache = ignoredHandlerMethods.get(handlerMethod);\n+        if (ignoredCache != null) {\n+            return ignoredCache;\n+        }\n+\n+        Type returnType = handlerMethod.getMethod().getGenericReturnType();\n+        if (!(returnType instanceof ParameterizedType)) {\n+            ignoredHandlerMethods.put(handlerMethod, false);\n+            return false;\n+        }\n+\n+        Type[] genReturnTypes = ((ParameterizedType) returnType).getActualTypeArguments();\n+        //noinspection ForLoopReplaceableByForEach\n+        for (int i = 0; i < genReturnTypes.length; i++) {\n+            if (genReturnTypes[i].getTypeName().startsWith(WebfluxHelper.SSE_EVENT_CLASS)) {\n+                ignoredHandlerMethods.put(handlerMethod, true);\n+                return true;\n+            }\n+        }\n+\n+        ignoredHandlerMethods.put(handlerMethod, false);\n+        return false;\n+    }\n+\n+    private static void fillRequest(Transaction transaction, ServerWebExchange exchange) {\n+        ServerHttpRequest serverRequest = exchange.getRequest();\n+        Request request = transaction.getContext().getRequest();\n+\n+        request.withMethod(serverRequest.getMethodValue());\n+\n+        InetSocketAddress remoteAddress = serverRequest.getRemoteAddress();\n+        request.getSocket()\n+            .withRemoteAddress(remoteAddress == null ? null : remoteAddress.getAddress().getHostAddress())\n+            .withEncrypted(serverRequest.getSslInfo() != null);\n+\n+        URI uri = serverRequest.getURI();\n+        request.getUrl()\n+            .withProtocol(uri.getScheme())\n+            .withHostname(uri.getHost())\n+            .withPort(uri.getPort())\n+            .withPathname(uri.getPath())\n+            .withSearch(uri.getQuery())\n+            .updateFull();\n+\n+        copyHeaders(serverRequest.getHeaders(), request.getHeaders());\n+\n+        for (Map.Entry<String, List<HttpCookie>> cookie : serverRequest.getCookies().entrySet()) {\n+            for (HttpCookie value : cookie.getValue()) {\n+                request.getCookies().add(cookie.getKey(), value.getValue());\n+            }\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTA5OTEzNw==", "bodyText": "I don't think it would be easy to capture body using this, as we get a Flux and not a direct access to the request body byte buffer. Would better off keeping that for a follow-up PR.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r639099137", "createdAt": "2021-05-25T18:48:21Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-spring-webflux/apm-spring-webflux-plugin/src/main/java/co/elastic/apm/agent/springwebflux/TransactionAwareSubscriber.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.springwebflux;\n+\n+import co.elastic.apm.agent.impl.Tracer;\n+import co.elastic.apm.agent.impl.context.Request;\n+import co.elastic.apm.agent.impl.context.Response;\n+import co.elastic.apm.agent.impl.context.web.ResultUtil;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.sdk.weakmap.WeakMapSupplier;\n+import co.elastic.apm.agent.util.PotentiallyMultiValuedMap;\n+import co.elastic.apm.agent.util.SpanConcurrentHashMap;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.HttpCookie;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.server.reactive.ServerHttpRequest;\n+import org.springframework.http.server.reactive.ServerHttpResponse;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.reactive.HandlerMapping;\n+import org.springframework.web.server.ServerWebExchange;\n+import org.springframework.web.util.pattern.PathPattern;\n+import reactor.core.CoreSubscriber;\n+\n+import javax.annotation.Nullable;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.impl.transaction.AbstractSpan.PRIO_HIGH_LEVEL_FRAMEWORK;\n+import static org.springframework.web.reactive.function.server.RouterFunctions.MATCHING_PATTERN_ATTRIBUTE;\n+\n+/**\n+ * Transaction-aware subscriber that will (optionally) activate transaction and terminate it on error or completion.\n+ *\n+ * @param <T>\n+ */\n+class TransactionAwareSubscriber<T> implements CoreSubscriber<T> {\n+\n+    private static final Logger log = LoggerFactory.getLogger(TransactionAwareSubscriber.class);\n+\n+    private static final WeakConcurrentMap<HandlerMethod, Boolean> ignoredHandlerMethods = WeakMapSupplier.createMap();\n+\n+    private static final WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> transactionMap = SpanConcurrentHashMap.createWeakMap();\n+\n+    private final CoreSubscriber<? super T> subscriber;\n+\n+    private final ServerWebExchange exchange;\n+\n+    private final String description;\n+\n+    private final Tracer tracer;\n+\n+    /**\n+     * {@literal true} when transaction was activated on subscription\n+     */\n+    private boolean activatedOnSubscribe = false;\n+\n+    /**\n+     * @param subscriber  subscriber to wrap\n+     * @param transaction transaction\n+     * @param exchange    server web exchange\n+     * @param description human-readable description to make debugging easier\n+     */\n+    TransactionAwareSubscriber(CoreSubscriber<? super T> subscriber,\n+                               Tracer tracer,\n+                               Transaction transaction,\n+                               ServerWebExchange exchange,\n+                               String description) {\n+\n+        this.subscriber = subscriber;\n+        this.exchange = exchange;\n+        this.description = description;\n+        this.tracer = tracer;\n+\n+        transactionMap.put(this, transaction);\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onSubscribe(Subscription)} for context propagation, executed in \"subscribe scheduler\".\n+     * Might activate transaction if not already active. When activating the transaction is kept active after method execution.\n+     * Refer to {@link #doEnter} for details on activation.\n+     */\n+    @Override\n+    public void onSubscribe(Subscription s) {\n+        Transaction transaction = getTransaction();\n+        doEnter(true, \"onSubscribe\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onSubscribe(s);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onSubscribe\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onNext(Object)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will discard transaction reference if any exception is thrown.\n+     *\n+     * @param next next item\n+     */\n+    @Override\n+    public void onNext(T next) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onNext\", transaction);\n+        Throwable thrown = null;\n+        try {\n+            subscriber.onNext(next);\n+        } catch (Throwable e) {\n+            thrown = e;\n+            throw e;\n+        } finally {\n+            doExit(thrown != null, \"onNext\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onError(Throwable)} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     *\n+     * @param t error\n+     */\n+    @Override\n+    public void onError(Throwable t) {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onError\", transaction);\n+        try {\n+            subscriber.onError(t);\n+        } finally {\n+            endTransaction(t, transaction);\n+            doExit(true, \"onError\", transaction);\n+        }\n+    }\n+\n+    /**\n+     * Wraps {@link Subscriber#onComplete()} for context propagation, executed in \"publisher scheduler\".\n+     * Assumes the transaction is already active, will terminate transaction and optionally deactivate if it was\n+     * previously activated by {@link #onSubscribe(Subscription)}.\n+     */\n+    @Override\n+    public void onComplete() {\n+        Transaction transaction = getTransaction();\n+        doEnter(false, \"onComplete\", transaction);\n+        try {\n+            subscriber.onComplete();\n+        } finally {\n+            endTransaction(null, transaction);\n+            doExit(true, \"onComplete\", transaction);\n+        }\n+    }\n+\n+    private void doEnter(boolean isSubscribe, String method, @Nullable Transaction transaction) {\n+        debugTrace(true, method, transaction);\n+\n+        if (!isSubscribe || transaction == null) {\n+            return;\n+        }\n+\n+        if (transaction == tracer.getActive()) {\n+            activatedOnSubscribe = false;\n+            return;\n+        }\n+\n+        transaction.activate();\n+        activatedOnSubscribe = true;\n+    }\n+\n+    private void doExit(boolean discard, String method, @Nullable Transaction transaction) {\n+        debugTrace(false, method, transaction);\n+\n+        if (transaction == null) {\n+            return;\n+        }\n+\n+        if (discard) {\n+            if (activatedOnSubscribe && tracer.getActive() == transaction) {\n+                transaction.deactivate();\n+            }\n+            transactionMap.remove(this);\n+        }\n+\n+    }\n+\n+    @Nullable\n+    private Transaction getTransaction() {\n+        return transactionMap.get(this);\n+    }\n+\n+    private void debugTrace(boolean isEnter, String method, @Nullable Transaction transaction) {\n+        if (!log.isTraceEnabled()) {\n+            return;\n+        }\n+        log.trace(\"{} {} {} {}\", isEnter ? \">>>>\" : \"<<<<\", description, method, transaction);\n+    }\n+\n+    /**\n+     * Only for testing\n+     *\n+     * @return storage map for in-flight transactions\n+     */\n+    static WeakConcurrentMap<TransactionAwareSubscriber<?>, Transaction> getTransactionMap() {\n+        return transactionMap;\n+    }\n+\n+    private void endTransaction(@Nullable Throwable thrown, @Nullable Transaction transaction) {\n+        if (transaction == null) {\n+            // already discarded\n+            return;\n+        }\n+\n+        Object attribute = exchange.getAttributes().remove(WebfluxHelper.TRANSACTION_ATTRIBUTE);\n+        if (attribute != transaction) {\n+            // transaction might be already terminated due to instrumentation of more than one\n+            // dispatcher/handler/invocation-handler class\n+            return;\n+        }\n+\n+        if (ignoreTransaction(exchange, transaction)) {\n+            transaction.ignoreTransaction();\n+            transaction.end();\n+            return;\n+        }\n+\n+        StringBuilder transactionName = transaction.getAndOverrideName(PRIO_HIGH_LEVEL_FRAMEWORK, true);\n+        if (transactionName != null) {\n+            String httpMethod = exchange.getRequest().getMethodValue();\n+\n+            // bean name & method should be set for annotated methods\n+            String beanName = exchange.getAttribute(WebfluxHelper.ANNOTATED_BEAN_NAME_ATTRIBUTE);\n+            String methodName = exchange.getAttribute(WebfluxHelper.ANNOTATED_METHOD_NAME_ATTRIBUTE);\n+\n+            PathPattern pattern = exchange.getAttribute(MATCHING_PATTERN_ATTRIBUTE);\n+\n+            if (beanName != null && methodName != null) {\n+                transactionName.append(beanName)\n+                    .append('#')\n+                    .append(methodName);\n+            } else {\n+                transactionName.append(httpMethod).append(' ');\n+                if (pattern != null) {\n+                    transactionName.append(pattern.getPatternString());\n+                } else {\n+                    transactionName.append(\"unknown route\");\n+                }\n+            }\n+        }\n+\n+        // Fill request/response details if they haven't been already by another HTTP plugin (servlet or other).\n+        if (!transaction.getContext().getRequest().hasContent()) {\n+            fillRequest(transaction, exchange);\n+            fillResponse(transaction, exchange);\n+        }\n+\n+        transaction.captureException(thrown);\n+\n+        // In case transaction has been created by Servlet, we should not terminate it as the Servlet instrumentation\n+        // will take care of this.\n+        if (!WebfluxHelper.isServletTransaction(exchange)) {\n+            transaction.end();\n+        }\n+\n+    }\n+\n+    private static boolean ignoreTransaction(ServerWebExchange exchange, Transaction transaction) {\n+        // Annotated controllers have the invoked handler method available in exchange\n+        // thus we can rely on this to ignore methods that return ServerSideEvents which should not report transactions\n+        Object attribute = exchange.getAttribute(HandlerMapping.BEST_MATCHING_HANDLER_ATTRIBUTE);\n+        if (!(attribute instanceof HandlerMethod)) {\n+            return false;\n+        }\n+\n+        HandlerMethod handlerMethod = (HandlerMethod) attribute;\n+        Boolean ignoredCache = ignoredHandlerMethods.get(handlerMethod);\n+        if (ignoredCache != null) {\n+            return ignoredCache;\n+        }\n+\n+        Type returnType = handlerMethod.getMethod().getGenericReturnType();\n+        if (!(returnType instanceof ParameterizedType)) {\n+            ignoredHandlerMethods.put(handlerMethod, false);\n+            return false;\n+        }\n+\n+        Type[] genReturnTypes = ((ParameterizedType) returnType).getActualTypeArguments();\n+        //noinspection ForLoopReplaceableByForEach\n+        for (int i = 0; i < genReturnTypes.length; i++) {\n+            if (genReturnTypes[i].getTypeName().startsWith(WebfluxHelper.SSE_EVENT_CLASS)) {\n+                ignoredHandlerMethods.put(handlerMethod, true);\n+                return true;\n+            }\n+        }\n+\n+        ignoredHandlerMethods.put(handlerMethod, false);\n+        return false;\n+    }\n+\n+    private static void fillRequest(Transaction transaction, ServerWebExchange exchange) {\n+        ServerHttpRequest serverRequest = exchange.getRequest();\n+        Request request = transaction.getContext().getRequest();\n+\n+        request.withMethod(serverRequest.getMethodValue());\n+\n+        InetSocketAddress remoteAddress = serverRequest.getRemoteAddress();\n+        request.getSocket()\n+            .withRemoteAddress(remoteAddress == null ? null : remoteAddress.getAddress().getHostAddress())\n+            .withEncrypted(serverRequest.getSslInfo() != null);\n+\n+        URI uri = serverRequest.getURI();\n+        request.getUrl()\n+            .withProtocol(uri.getScheme())\n+            .withHostname(uri.getHost())\n+            .withPort(uri.getPort())\n+            .withPathname(uri.getPath())\n+            .withSearch(uri.getQuery())\n+            .updateFull();\n+\n+        copyHeaders(serverRequest.getHeaders(), request.getHeaders());\n+\n+        for (Map.Entry<String, List<HttpCookie>> cookie : serverRequest.getCookies().entrySet()) {\n+            for (HttpCookie value : cookie.getValue()) {\n+                request.getCookies().add(cookie.getKey(), value.getValue());\n+            }\n+        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDMzMjExOQ=="}, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzkyNzMwMTY4OnYy", "diffSide": "RIGHT", "path": "apm-agent-premain/src/main/java/co/elastic/apm/agent/premain/AgentMain.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yNlQxNDoyNjo0MFrOJPnHQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0yNVQxODo1NjoyNlrOJhf0tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDM0OTI0OA==", "bodyText": "The problem is that when we add something intentionally to the jar, we need to maintain both here and co.elastic.apm.servlet.AgentFileIT#testEverythingIsShaded. I don't see how something can be merged without making sure tests pass. So the latest we should stumble into this, is when running the integration tests, or running manual tests (which is normally done after integration tests pass).\nIf you feel this is important, at least add a reference from each of the location to the other, so that when one is updated, the other is updated as well.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r620349248", "createdAt": "2021-04-26T14:26:40Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-premain/src/main/java/co/elastic/apm/agent/premain/AgentMain.java", "diffHunk": "@@ -174,6 +177,43 @@ private static File getAgentJarFile() throws URISyntaxException {\n         if (!agentJar.getName().endsWith(\".jar\")) {\n             throw new IllegalStateException(\"Agent is not a jar file: \" + agentJar);\n         }\n-        return agentJar.getAbsoluteFile();\n+        // verify agent shading at runtime, because tests might not have been always executed (when creating plugin)\n+        // and failure to properly shade will create unexpected and complex behavior that is hard to diagnose and\n+        // debug, thus the cost of doing this at runtime is worth it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEwNDE4Mw==", "bodyText": "I agree, that completely duplicates that IT test, the issue I had with that was more related to the long feedback loop that it implies:\n\nintegration tests tend to take a while, thus I don't run them all the time\nthey are finally run in CI when PR/branch is pushed, thus we are sure that we won't merge with such test failing\nthe unexpected side effects of improper packaging (things not working as expected) can thus be silently ignored until IT are run\n\nWhen trying to have a short feedback loop and thus skipping long-running tests (which tends to be common, at least in my current plugin dev workflow), we might spend quite some time until figuring out that there is a packaging issue.\nGiven this issue might definitely go away once we have proper external plugin and do not require shading anymore, it's not worth keeping that here, I have removed it and kept only the testEverythingIsShaded variant.", "url": "https://github.com/elastic/apm-agent-java/pull/1305#discussion_r639104183", "createdAt": "2021-05-25T18:56:26Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-premain/src/main/java/co/elastic/apm/agent/premain/AgentMain.java", "diffHunk": "@@ -174,6 +177,43 @@ private static File getAgentJarFile() throws URISyntaxException {\n         if (!agentJar.getName().endsWith(\".jar\")) {\n             throw new IllegalStateException(\"Agent is not a jar file: \" + agentJar);\n         }\n-        return agentJar.getAbsoluteFile();\n+        // verify agent shading at runtime, because tests might not have been always executed (when creating plugin)\n+        // and failure to properly shade will create unexpected and complex behavior that is hard to diagnose and\n+        // debug, thus the cost of doing this at runtime is worth it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDM0OTI0OA=="}, "originalCommit": {"oid": "7af2fc1309f872895ada85e6b861fa7321b68c34"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 173, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}